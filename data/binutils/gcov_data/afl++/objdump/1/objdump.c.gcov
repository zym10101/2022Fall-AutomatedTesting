        -:    0:Source:objdump.c
        -:    0:Graph:objdump.gcno
        -:    0:Data:objdump.gcda
        -:    0:Runs:1
        -:    1:/* objdump.c -- dump information about an object file.
        -:    2:   Copyright (C) 1990-2022 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This file is part of GNU Binutils.
        -:    5:
        -:    6:   This program is free software; you can redistribute it and/or modify
        -:    7:   it under the terms of the GNU General Public License as published by
        -:    8:   the Free Software Foundation; either version 3, or (at your option)
        -:    9:   any later version.
        -:   10:
        -:   11:   This program is distributed in the hope that it will be useful,
        -:   12:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:   GNU General Public License for more details.
        -:   15:
        -:   16:   You should have received a copy of the GNU General Public License
        -:   17:   along with this program; if not, write to the Free Software
        -:   18:   Foundation, 51 Franklin Street - Fifth Floor, Boston,
        -:   19:   MA 02110-1301, USA.  */
        -:   20:
        -:   21:
        -:   22:/* Objdump overview.
        -:   23:
        -:   24:   Objdump displays information about one or more object files, either on
        -:   25:   their own, or inside libraries.  It is commonly used as a disassembler,
        -:   26:   but it can also display information about file headers, symbol tables,
        -:   27:   relocations, debugging directives and more.
        -:   28:
        -:   29:   The flow of execution is as follows:
        -:   30:
        -:   31:   1. Command line arguments are checked for control switches and the
        -:   32:      information to be displayed is selected.
        -:   33:
        -:   34:   2. Any remaining arguments are assumed to be object files, and they are
        -:   35:      processed in order by display_bfd().  If the file is an archive each
        -:   36:      of its elements is processed in turn.
        -:   37:
        -:   38:   3. The file's target architecture and binary file format are determined
        -:   39:      by bfd_check_format().  If they are recognised, then dump_bfd() is
        -:   40:      called.
        -:   41:
        -:   42:   4. dump_bfd() in turn calls separate functions to display the requested
        -:   43:      item(s) of information(s).  For example disassemble_data() is called if
        -:   44:      a disassembly has been requested.
        -:   45:
        -:   46:   When disassembling the code loops through blocks of instructions bounded
        -:   47:   by symbols, calling disassemble_bytes() on each block.  The actual
        -:   48:   disassembling is done by the libopcodes library, via a function pointer
        -:   49:   supplied by the disassembler() function.  */
        -:   50:
        -:   51:#include "sysdep.h"
        -:   52:#include "bfd.h"
        -:   53:#include "elf-bfd.h"
        -:   54:#include "coff-bfd.h"
        -:   55:#include "progress.h"
        -:   56:#include "bucomm.h"
        -:   57:#include "elfcomm.h"
        -:   58:#include "demanguse.h"
        -:   59:#include "dwarf.h"
        -:   60:#include "ctf-api.h"
        -:   61:#include "getopt.h"
        -:   62:#include "safe-ctype.h"
        -:   63:#include "dis-asm.h"
        -:   64:#include "libiberty.h"
        -:   65:#include "demangle.h"
        -:   66:#include "filenames.h"
        -:   67:#include "debug.h"
        -:   68:#include "budbg.h"
        -:   69:#include "objdump.h"
        -:   70:
        -:   71:#ifdef HAVE_MMAP
        -:   72:#include <sys/mman.h>
        -:   73:#endif
        -:   74:
        -:   75:/* Internal headers for the ELF .stab-dump code - sorry.  */
        -:   76:#define	BYTES_IN_WORD	32
        -:   77:#include "aout/aout64.h"
        -:   78:
        -:   79:/* Exit status.  */
        -:   80:static int exit_status = 0;
        -:   81:
        -:   82:static char *default_target = NULL;	/* Default at runtime.  */
        -:   83:
        -:   84:/* The following variables are set based on arguments passed on the
        -:   85:   command line.  */
        -:   86:static int show_version = 0;		/* Show the version number.  */
        -:   87:static int dump_section_contents;	/* -s */
        -:   88:static int dump_section_headers;	/* -h */
        -:   89:static bool dump_file_header;		/* -f */
        -:   90:static int dump_symtab;			/* -t */
        -:   91:static int dump_dynamic_symtab;		/* -T */
        -:   92:static int dump_reloc_info;		/* -r */
        -:   93:static int dump_dynamic_reloc_info;	/* -R */
        -:   94:static int dump_ar_hdrs;		/* -a */
        -:   95:static int dump_private_headers;	/* -p */
        -:   96:static char *dump_private_options;	/* -P */
        -:   97:static int no_addresses;		/* --no-addresses */
        -:   98:static int prefix_addresses;		/* --prefix-addresses */
        -:   99:static int with_line_numbers;		/* -l */
        -:  100:static bool with_source_code;		/* -S */
        -:  101:static int show_raw_insn;		/* --show-raw-insn */
        -:  102:static int dump_dwarf_section_info;	/* --dwarf */
        -:  103:static int dump_stab_section_info;	/* --stabs */
        -:  104:static int dump_ctf_section_info;       /* --ctf */
        -:  105:static char *dump_ctf_section_name;
        -:  106:static char *dump_ctf_parent_name;	/* --ctf-parent */
        -:  107:static int do_demangle;			/* -C, --demangle */
        -:  108:static bool disassemble;		/* -d */
        -:  109:static bool disassemble_all;		/* -D */
        -:  110:static int disassemble_zeroes;		/* --disassemble-zeroes */
        -:  111:static bool formats_info;		/* -i */
        -:  112:static int wide_output;			/* -w */
        -:  113:static int insn_width;			/* --insn-width */
        -:  114:static bfd_vma start_address = (bfd_vma) -1; /* --start-address */
        -:  115:static bfd_vma stop_address = (bfd_vma) -1;  /* --stop-address */
        -:  116:static int dump_debugging;		/* --debugging */
        -:  117:static int dump_debugging_tags;		/* --debugging-tags */
        -:  118:static int suppress_bfd_header;
        -:  119:static int dump_special_syms = 0;	/* --special-syms */
        -:  120:static bfd_vma adjust_section_vma = 0;	/* --adjust-vma */
        -:  121:static int file_start_context = 0;      /* --file-start-context */
        -:  122:static bool display_file_offsets;	/* -F */
        -:  123:static const char *prefix;		/* --prefix */
        -:  124:static int prefix_strip;		/* --prefix-strip */
        -:  125:static size_t prefix_length;
        -:  126:static bool unwind_inlines;		/* --inlines.  */
        -:  127:static const char * disasm_sym;		/* Disassembly start symbol.  */
        -:  128:static const char * source_comment;     /* --source_comment.  */
        -:  129:static bool visualize_jumps = false;	/* --visualize-jumps.  */
        -:  130:static bool color_output = false;	/* --visualize-jumps=color.  */
        -:  131:static bool extended_color_output = false; /* --visualize-jumps=extended-color.  */
        -:  132:static int process_links = false;       /* --process-links.  */
        -:  133:static bool disassembler_color = false; /* --disassembler-color=color.  */
        -:  134:static bool disassembler_extended_color = false; /* --disassembler-color=extended-color.  */
        -:  135:
        -:  136:static int dump_any_debugging;
        -:  137:static int demangle_flags = DMGL_ANSI | DMGL_PARAMS;
        -:  138:
        -:  139:/* This is reset to false each time we enter the disassembler, and set true
        -:  140:   when the disassembler emits something in the dis_style_comment_start
        -:  141:   style.  Once this is true, all further output on that line is done in
        -:  142:   the comment style.  This only has an effect when disassembler coloring
        -:  143:   is turned on.  */
        -:  144:static bool disassembler_in_comment = false;
        -:  145:
        -:  146:/* A structure to record the sections mentioned in -j switches.  */
        -:  147:struct only
        -:  148:{
        -:  149:  const char *name; /* The name of the section.  */
        -:  150:  bool seen; /* A flag to indicate that the section has been found in one or more input files.  */
        -:  151:  struct only *next; /* Pointer to the next structure in the list.  */
        -:  152:};
        -:  153:/* Pointer to an array of 'only' structures.
        -:  154:   This pointer is NULL if the -j switch has not been used.  */
        -:  155:static struct only * only_list = NULL;
        -:  156:
        -:  157:/* Variables for handling include file path table.  */
        -:  158:static const char **include_paths;
        -:  159:static int include_path_count;
        -:  160:
        -:  161:/* Extra info to pass to the section disassembler and address printing
        -:  162:   function.  */
        -:  163:struct objdump_disasm_info
        -:  164:{
        -:  165:  bfd *abfd;
        -:  166:  bool require_sec;
        -:  167:  disassembler_ftype disassemble_fn;
        -:  168:  arelent *reloc;
        -:  169:  const char *symbol;
        -:  170:};
        -:  171:
        -:  172:/* Architecture to disassemble for, or default if NULL.  */
        -:  173:static char *machine = NULL;
        -:  174:
        -:  175:/* Target specific options to the disassembler.  */
        -:  176:static char *disassembler_options = NULL;
        -:  177:
        -:  178:/* Endianness to disassemble for, or default if BFD_ENDIAN_UNKNOWN.  */
        -:  179:static enum bfd_endian endian = BFD_ENDIAN_UNKNOWN;
        -:  180:
        -:  181:/* The symbol table.  */
        -:  182:static asymbol **syms;
        -:  183:
        -:  184:/* Number of symbols in `syms'.  */
        -:  185:static long symcount = 0;
        -:  186:
        -:  187:/* The sorted symbol table.  */
        -:  188:static asymbol **sorted_syms;
        -:  189:
        -:  190:/* Number of symbols in `sorted_syms'.  */
        -:  191:static long sorted_symcount = 0;
        -:  192:
        -:  193:/* The dynamic symbol table.  */
        -:  194:static asymbol **dynsyms;
        -:  195:
        -:  196:/* The synthetic symbol table.  */
        -:  197:static asymbol *synthsyms;
        -:  198:static long synthcount = 0;
        -:  199:
        -:  200:/* Number of symbols in `dynsyms'.  */
        -:  201:static long dynsymcount = 0;
        -:  202:
        -:  203:static bfd_byte *stabs;
        -:  204:static bfd_size_type stab_size;
        -:  205:
        -:  206:static bfd_byte *strtab;
        -:  207:static bfd_size_type stabstr_size;
        -:  208:
        -:  209:/* Handlers for -P/--private.  */
        -:  210:static const struct objdump_private_desc * const objdump_private_vectors[] =
        -:  211:  {
        -:  212:    OBJDUMP_PRIVATE_VECTORS
        -:  213:    NULL
        -:  214:  };
        -:  215:
        -:  216:/* The list of detected jumps inside a function.  */
        -:  217:static struct jump_info *detected_jumps = NULL;
        -:  218:
        -:  219:typedef enum unicode_display_type
        -:  220:{
        -:  221:  unicode_default = 0,
        -:  222:  unicode_locale,
        -:  223:  unicode_escape,
        -:  224:  unicode_hex,
        -:  225:  unicode_highlight,
        -:  226:  unicode_invalid
        -:  227:} unicode_display_type;
        -:  228:
        -:  229:static unicode_display_type unicode_display = unicode_default;
        -:  230:
        -:  231:static void usage (FILE *, int) ATTRIBUTE_NORETURN;
        -:  232:static void
    #####:  233:usage (FILE *stream, int status)
        -:  234:{
    #####:  235:  fprintf (stream, _("Usage: %s <option(s)> <file(s)>\n"), program_name);
    #####:  236:  fprintf (stream, _(" Display information from object <file(s)>.\n"));
    #####:  237:  fprintf (stream, _(" At least one of the following switches must be given:\n"));
    #####:  238:  fprintf (stream, _("\
        -:  239:  -a, --archive-headers    Display archive header information\n"));
    #####:  240:  fprintf (stream, _("\
        -:  241:  -f, --file-headers       Display the contents of the overall file header\n"));
    #####:  242:  fprintf (stream, _("\
        -:  243:  -p, --private-headers    Display object format specific file header contents\n"));
    #####:  244:  fprintf (stream, _("\
        -:  245:  -P, --private=OPT,OPT... Display object format specific contents\n"));
    #####:  246:  fprintf (stream, _("\
        -:  247:  -h, --[section-]headers  Display the contents of the section headers\n"));
    #####:  248:  fprintf (stream, _("\
        -:  249:  -x, --all-headers        Display the contents of all headers\n"));
    #####:  250:  fprintf (stream, _("\
        -:  251:  -d, --disassemble        Display assembler contents of executable sections\n"));
    #####:  252:  fprintf (stream, _("\
        -:  253:  -D, --disassemble-all    Display assembler contents of all sections\n"));
    #####:  254:  fprintf (stream, _("\
        -:  255:      --disassemble=<sym>  Display assembler contents from <sym>\n"));
    #####:  256:  fprintf (stream, _("\
        -:  257:  -S, --source             Intermix source code with disassembly\n"));
    #####:  258:  fprintf (stream, _("\
        -:  259:      --source-comment[=<txt>] Prefix lines of source code with <txt>\n"));
    #####:  260:  fprintf (stream, _("\
        -:  261:  -s, --full-contents      Display the full contents of all sections requested\n"));
    #####:  262:  fprintf (stream, _("\
        -:  263:  -g, --debugging          Display debug information in object file\n"));
    #####:  264:  fprintf (stream, _("\
        -:  265:  -e, --debugging-tags     Display debug information using ctags style\n"));
    #####:  266:  fprintf (stream, _("\
        -:  267:  -G, --stabs              Display (in raw form) any STABS info in the file\n"));
    #####:  268:  fprintf (stream, _("\
        -:  269:  -W, --dwarf[a/=abbrev, A/=addr, r/=aranges, c/=cu_index, L/=decodedline,\n\
        -:  270:              f/=frames, F/=frames-interp, g/=gdb_index, i/=info, o/=loc,\n\
        -:  271:              m/=macro, p/=pubnames, t/=pubtypes, R/=Ranges, l/=rawline,\n\
        -:  272:              s/=str, O/=str-offsets, u/=trace_abbrev, T/=trace_aranges,\n\
        -:  273:              U/=trace_info]\n\
        -:  274:                           Display the contents of DWARF debug sections\n"));
    #####:  275:  fprintf (stream, _("\
        -:  276:  -Wk,--dwarf=links        Display the contents of sections that link to\n\
        -:  277:                            separate debuginfo files\n"));
        -:  278:#if DEFAULT_FOR_FOLLOW_LINKS
    #####:  279:  fprintf (stream, _("\
        -:  280:  -WK,--dwarf=follow-links\n\
        -:  281:                           Follow links to separate debug info files (default)\n"));
    #####:  282:  fprintf (stream, _("\
        -:  283:  -WN,--dwarf=no-follow-links\n\
        -:  284:                           Do not follow links to separate debug info files\n"));
        -:  285:#else
        -:  286:  fprintf (stream, _("\
        -:  287:  -WK,--dwarf=follow-links\n\
        -:  288:                           Follow links to separate debug info files\n"));
        -:  289:  fprintf (stream, _("\
        -:  290:  -WN,--dwarf=no-follow-links\n\
        -:  291:                           Do not follow links to separate debug info files\n\
        -:  292:                            (default)\n"));
        -:  293:#endif
        -:  294:#if HAVE_LIBDEBUGINFOD
        -:  295:  fprintf (stream, _("\
        -:  296:  -WD --dwarf=use-debuginfod\n\
        -:  297:                           When following links, also query debuginfod servers (default)\n"));
        -:  298:  fprintf (stream, _("\
        -:  299:  -WE --dwarf=do-not-use-debuginfod\n\
        -:  300:                           When following links, do not query debuginfod servers\n"));
        -:  301:#endif
    #####:  302:  fprintf (stream, _("\
        -:  303:  -L, --process-links      Display the contents of non-debug sections in\n\
        -:  304:                            separate debuginfo files.  (Implies -WK)\n"));
        -:  305:#ifdef ENABLE_LIBCTF
    #####:  306:  fprintf (stream, _("\
        -:  307:      --ctf[=SECTION]      Display CTF info from SECTION, (default `.ctf')\n"));
        -:  308:#endif
    #####:  309:  fprintf (stream, _("\
        -:  310:  -t, --syms               Display the contents of the symbol table(s)\n"));
    #####:  311:  fprintf (stream, _("\
        -:  312:  -T, --dynamic-syms       Display the contents of the dynamic symbol table\n"));
    #####:  313:  fprintf (stream, _("\
        -:  314:  -r, --reloc              Display the relocation entries in the file\n"));
    #####:  315:  fprintf (stream, _("\
        -:  316:  -R, --dynamic-reloc      Display the dynamic relocation entries in the file\n"));
    #####:  317:  fprintf (stream, _("\
        -:  318:  @<file>                  Read options from <file>\n"));
    #####:  319:  fprintf (stream, _("\
        -:  320:  -v, --version            Display this program's version number\n"));
    #####:  321:  fprintf (stream, _("\
        -:  322:  -i, --info               List object formats and architectures supported\n"));
    #####:  323:  fprintf (stream, _("\
        -:  324:  -H, --help               Display this information\n"));
        -:  325:
    #####:  326:  if (status != 2)
        -:  327:    {
        -:  328:      const struct objdump_private_desc * const *desc;
        -:  329:
    #####:  330:      fprintf (stream, _("\n The following switches are optional:\n"));
    #####:  331:      fprintf (stream, _("\
        -:  332:  -b, --target=BFDNAME           Specify the target object format as BFDNAME\n"));
    #####:  333:      fprintf (stream, _("\
        -:  334:  -m, --architecture=MACHINE     Specify the target architecture as MACHINE\n"));
    #####:  335:      fprintf (stream, _("\
        -:  336:  -j, --section=NAME             Only display information for section NAME\n"));
    #####:  337:      fprintf (stream, _("\
        -:  338:  -M, --disassembler-options=OPT Pass text OPT on to the disassembler\n"));
    #####:  339:      fprintf (stream, _("\
        -:  340:  -EB --endian=big               Assume big endian format when disassembling\n"));
    #####:  341:      fprintf (stream, _("\
        -:  342:  -EL --endian=little            Assume little endian format when disassembling\n"));
    #####:  343:      fprintf (stream, _("\
        -:  344:      --file-start-context       Include context from start of file (with -S)\n"));
    #####:  345:      fprintf (stream, _("\
        -:  346:  -I, --include=DIR              Add DIR to search list for source files\n"));
    #####:  347:      fprintf (stream, _("\
        -:  348:  -l, --line-numbers             Include line numbers and filenames in output\n"));
    #####:  349:      fprintf (stream, _("\
        -:  350:  -F, --file-offsets             Include file offsets when displaying information\n"));
    #####:  351:      fprintf (stream, _("\
        -:  352:  -C, --demangle[=STYLE]         Decode mangled/processed symbol names\n"));
    #####:  353:      display_demangler_styles (stream, _("\
        -:  354:                                   STYLE can be "));
    #####:  355:      fprintf (stream, _("\
        -:  356:      --recurse-limit            Enable a limit on recursion whilst demangling\n\
        -:  357:                                  (default)\n"));
    #####:  358:      fprintf (stream, _("\
        -:  359:      --no-recurse-limit         Disable a limit on recursion whilst demangling\n"));
    #####:  360:      fprintf (stream, _("\
        -:  361:  -w, --wide                     Format output for more than 80 columns\n"));
    #####:  362:      fprintf (stream, _("\
        -:  363:  -U[d|l|i|x|e|h]                Controls the display of UTF-8 unicode characters\n\
        -:  364:  --unicode=[default|locale|invalid|hex|escape|highlight]\n"));
    #####:  365:      fprintf (stream, _("\
        -:  366:  -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n"));
    #####:  367:      fprintf (stream, _("\
        -:  368:      --start-address=ADDR       Only process data whose address is >= ADDR\n"));
    #####:  369:      fprintf (stream, _("\
        -:  370:      --stop-address=ADDR        Only process data whose address is < ADDR\n"));
    #####:  371:      fprintf (stream, _("\
        -:  372:      --no-addresses             Do not print address alongside disassembly\n"));
    #####:  373:      fprintf (stream, _("\
        -:  374:      --prefix-addresses         Print complete address alongside disassembly\n"));
    #####:  375:      fprintf (stream, _("\
        -:  376:      --[no-]show-raw-insn       Display hex alongside symbolic disassembly\n"));
    #####:  377:      fprintf (stream, _("\
        -:  378:      --insn-width=WIDTH         Display WIDTH bytes on a single line for -d\n"));
    #####:  379:      fprintf (stream, _("\
        -:  380:      --adjust-vma=OFFSET        Add OFFSET to all displayed section addresses\n"));
    #####:  381:      fprintf (stream, _("\
        -:  382:      --special-syms             Include special symbols in symbol dumps\n"));
    #####:  383:      fprintf (stream, _("\
        -:  384:      --inlines                  Print all inlines for source line (with -l)\n"));
    #####:  385:      fprintf (stream, _("\
        -:  386:      --prefix=PREFIX            Add PREFIX to absolute paths for -S\n"));
    #####:  387:      fprintf (stream, _("\
        -:  388:      --prefix-strip=LEVEL       Strip initial directory names for -S\n"));
    #####:  389:      fprintf (stream, _("\
        -:  390:      --dwarf-depth=N            Do not display DIEs at depth N or greater\n"));
    #####:  391:      fprintf (stream, _("\
        -:  392:      --dwarf-start=N            Display DIEs starting at offset N\n"));
    #####:  393:      fprintf (stream, _("\
        -:  394:      --dwarf-check              Make additional dwarf consistency checks.\n"));
        -:  395:#ifdef ENABLE_LIBCTF
    #####:  396:      fprintf (stream, _("\
        -:  397:      --ctf-parent=NAME          Use CTF archive member NAME as the CTF parent\n"));
        -:  398:#endif
    #####:  399:      fprintf (stream, _("\
        -:  400:      --visualize-jumps          Visualize jumps by drawing ASCII art lines\n"));
    #####:  401:      fprintf (stream, _("\
        -:  402:      --visualize-jumps=color    Use colors in the ASCII art\n"));
    #####:  403:      fprintf (stream, _("\
        -:  404:      --visualize-jumps=extended-color\n\
        -:  405:                                 Use extended 8-bit color codes\n"));
    #####:  406:      fprintf (stream, _("\
        -:  407:      --visualize-jumps=off      Disable jump visualization\n\n"));
    #####:  408:      fprintf (stream, _("\
        -:  409:      --disassembler-color=off   Disable disassembler color output.\n\n"));
    #####:  410:      fprintf (stream, _("\
        -:  411:      --disassembler-color=color Use basic colors in disassembler output.\n\n"));
        -:  412:
    #####:  413:      list_supported_targets (program_name, stream);
    #####:  414:      list_supported_architectures (program_name, stream);
        -:  415:
    #####:  416:      disassembler_usage (stream);
        -:  417:
    #####:  418:      if (objdump_private_vectors[0] != NULL)
        -:  419:        {
    #####:  420:          fprintf (stream,
    #####:  421:                   _("\nOptions supported for -P/--private switch:\n"));
    #####:  422:          for (desc = objdump_private_vectors; *desc != NULL; desc++)
    #####:  423:            (*desc)->help (stream);
        -:  424:        }
        -:  425:    }
    #####:  426:  if (REPORT_BUGS_TO[0] && status == 0)
    #####:  427:    fprintf (stream, _("Report bugs to %s.\n"), REPORT_BUGS_TO);
    #####:  428:  exit (status);
        -:  429:}
        -:  430:
        -:  431:/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
        -:  432:enum option_values
        -:  433:  {
        -:  434:    OPTION_ENDIAN=150,
        -:  435:    OPTION_START_ADDRESS,
        -:  436:    OPTION_STOP_ADDRESS,
        -:  437:    OPTION_DWARF,
        -:  438:    OPTION_PREFIX,
        -:  439:    OPTION_PREFIX_STRIP,
        -:  440:    OPTION_INSN_WIDTH,
        -:  441:    OPTION_ADJUST_VMA,
        -:  442:    OPTION_DWARF_DEPTH,
        -:  443:    OPTION_DWARF_CHECK,
        -:  444:    OPTION_DWARF_START,
        -:  445:    OPTION_RECURSE_LIMIT,
        -:  446:    OPTION_NO_RECURSE_LIMIT,
        -:  447:    OPTION_INLINES,
        -:  448:    OPTION_SOURCE_COMMENT,
        -:  449:#ifdef ENABLE_LIBCTF
        -:  450:    OPTION_CTF,
        -:  451:    OPTION_CTF_PARENT,
        -:  452:#endif
        -:  453:    OPTION_VISUALIZE_JUMPS,
        -:  454:    OPTION_DISASSEMBLER_COLOR
        -:  455:  };
        -:  456:
        -:  457:static struct option long_options[]=
        -:  458:{
        -:  459:  {"adjust-vma", required_argument, NULL, OPTION_ADJUST_VMA},
        -:  460:  {"all-headers", no_argument, NULL, 'x'},
        -:  461:  {"architecture", required_argument, NULL, 'm'},
        -:  462:  {"archive-headers", no_argument, NULL, 'a'},
        -:  463:#ifdef ENABLE_LIBCTF
        -:  464:  {"ctf", optional_argument, NULL, OPTION_CTF},
        -:  465:  {"ctf-parent", required_argument, NULL, OPTION_CTF_PARENT},
        -:  466:#endif
        -:  467:  {"debugging", no_argument, NULL, 'g'},
        -:  468:  {"debugging-tags", no_argument, NULL, 'e'},
        -:  469:  {"demangle", optional_argument, NULL, 'C'},
        -:  470:  {"disassemble", optional_argument, NULL, 'd'},
        -:  471:  {"disassemble-all", no_argument, NULL, 'D'},
        -:  472:  {"disassemble-zeroes", no_argument, NULL, 'z'},
        -:  473:  {"disassembler-options", required_argument, NULL, 'M'},
        -:  474:  {"dwarf", optional_argument, NULL, OPTION_DWARF},
        -:  475:  {"dwarf-check", no_argument, 0, OPTION_DWARF_CHECK},
        -:  476:  {"dwarf-depth", required_argument, 0, OPTION_DWARF_DEPTH},
        -:  477:  {"dwarf-start", required_argument, 0, OPTION_DWARF_START},
        -:  478:  {"dynamic-reloc", no_argument, NULL, 'R'},
        -:  479:  {"dynamic-syms", no_argument, NULL, 'T'},
        -:  480:  {"endian", required_argument, NULL, OPTION_ENDIAN},
        -:  481:  {"file-headers", no_argument, NULL, 'f'},
        -:  482:  {"file-offsets", no_argument, NULL, 'F'},
        -:  483:  {"file-start-context", no_argument, &file_start_context, 1},
        -:  484:  {"full-contents", no_argument, NULL, 's'},
        -:  485:  {"headers", no_argument, NULL, 'h'},
        -:  486:  {"help", no_argument, NULL, 'H'},
        -:  487:  {"include", required_argument, NULL, 'I'},
        -:  488:  {"info", no_argument, NULL, 'i'},
        -:  489:  {"inlines", no_argument, 0, OPTION_INLINES},
        -:  490:  {"insn-width", required_argument, NULL, OPTION_INSN_WIDTH},
        -:  491:  {"line-numbers", no_argument, NULL, 'l'},
        -:  492:  {"no-addresses", no_argument, &no_addresses, 1},
        -:  493:  {"no-recurse-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
        -:  494:  {"no-recursion-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
        -:  495:  {"no-show-raw-insn", no_argument, &show_raw_insn, -1},
        -:  496:  {"prefix", required_argument, NULL, OPTION_PREFIX},
        -:  497:  {"prefix-addresses", no_argument, &prefix_addresses, 1},
        -:  498:  {"prefix-strip", required_argument, NULL, OPTION_PREFIX_STRIP},
        -:  499:  {"private", required_argument, NULL, 'P'},
        -:  500:  {"private-headers", no_argument, NULL, 'p'},
        -:  501:  {"process-links", no_argument, &process_links, true},
        -:  502:  {"recurse-limit", no_argument, NULL, OPTION_RECURSE_LIMIT},
        -:  503:  {"recursion-limit", no_argument, NULL, OPTION_RECURSE_LIMIT},
        -:  504:  {"reloc", no_argument, NULL, 'r'},
        -:  505:  {"section", required_argument, NULL, 'j'},
        -:  506:  {"section-headers", no_argument, NULL, 'h'},
        -:  507:  {"show-raw-insn", no_argument, &show_raw_insn, 1},
        -:  508:  {"source", no_argument, NULL, 'S'},
        -:  509:  {"source-comment", optional_argument, NULL, OPTION_SOURCE_COMMENT},
        -:  510:  {"special-syms", no_argument, &dump_special_syms, 1},
        -:  511:  {"stabs", no_argument, NULL, 'G'},
        -:  512:  {"start-address", required_argument, NULL, OPTION_START_ADDRESS},
        -:  513:  {"stop-address", required_argument, NULL, OPTION_STOP_ADDRESS},
        -:  514:  {"syms", no_argument, NULL, 't'},
        -:  515:  {"target", required_argument, NULL, 'b'},
        -:  516:  {"unicode", required_argument, NULL, 'U'},
        -:  517:  {"version", no_argument, NULL, 'V'},
        -:  518:  {"visualize-jumps", optional_argument, 0, OPTION_VISUALIZE_JUMPS},
        -:  519:  {"wide", no_argument, NULL, 'w'},
        -:  520:  {"disassembler-color", required_argument, NULL, OPTION_DISASSEMBLER_COLOR},
        -:  521:  {NULL, no_argument, NULL, 0}
        -:  522:};
        -:  523:
        -:  524:static void
      106:  525:nonfatal (const char *msg)
        -:  526:{
      106:  527:  bfd_nonfatal (msg);
      106:  528:  exit_status = 1;
      106:  529:}
        -:  530:
        -:  531:/* Convert a potential UTF-8 encoded sequence in IN into characters in OUT.
        -:  532:   The conversion format is controlled by the unicode_display variable.
        -:  533:   Returns the number of characters added to OUT.
        -:  534:   Returns the number of bytes consumed from IN in CONSUMED.
        -:  535:   Always consumes at least one byte and displays at least one character.  */
        -:  536:
        -:  537:static unsigned int
    #####:  538:display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)
        -:  539:{
    #####:  540:  char *        orig_out = out;
    #####:  541:  unsigned int  nchars = 0;
        -:  542:  unsigned int j;
        -:  543:
    #####:  544:  if (unicode_display == unicode_default)
    #####:  545:    goto invalid;
        -:  546:
    #####:  547:  if (in[0] < 0xc0)
    #####:  548:    goto invalid;
        -:  549:
    #####:  550:  if ((in[1] & 0xc0) != 0x80)
    #####:  551:    goto invalid;
        -:  552:
    #####:  553:  if ((in[0] & 0x20) == 0)
        -:  554:    {
    #####:  555:      nchars = 2;
    #####:  556:      goto valid;
        -:  557:    }
        -:  558:
    #####:  559:  if ((in[2] & 0xc0) != 0x80)
    #####:  560:    goto invalid;
        -:  561:
    #####:  562:  if ((in[0] & 0x10) == 0)
        -:  563:    {
    #####:  564:      nchars = 3;
    #####:  565:      goto valid;
        -:  566:    }
        -:  567:
    #####:  568:  if ((in[3] & 0xc0) != 0x80)
    #####:  569:    goto invalid;
        -:  570:
    #####:  571:  nchars = 4;
        -:  572:
    #####:  573: valid:
    #####:  574:  switch (unicode_display)
        -:  575:    {
    #####:  576:    case unicode_locale:
        -:  577:      /* Copy the bytes into the output buffer as is.  */
    #####:  578:      memcpy (out, in, nchars);
    #####:  579:      out += nchars;
    #####:  580:      break;
        -:  581:
    #####:  582:    case unicode_invalid:
        -:  583:    case unicode_hex:
    #####:  584:      out += sprintf (out, "%c", unicode_display == unicode_hex ? '<' : '{');
    #####:  585:      out += sprintf (out, "0x");
    #####:  586:      for (j = 0; j < nchars; j++)
    #####:  587:	out += sprintf (out, "%02x", in [j]);
    #####:  588:      out += sprintf (out, "%c", unicode_display == unicode_hex ? '>' : '}');
    #####:  589:      break;
        -:  590:
    #####:  591:    case unicode_highlight:
    #####:  592:      if (isatty (1))
    #####:  593:	out += sprintf (out, "\x1B[31;47m"); /* Red.  */
        -:  594:      /* Fall through.  */
        -:  595:    case unicode_escape:
        -:  596:      switch (nchars)
        -:  597:	{
    #####:  598:	case 2:
    #####:  599:	  out += sprintf (out, "\\u%02x%02x",
    #####:  600:		  ((in[0] & 0x1c) >> 2),
    #####:  601:		  ((in[0] & 0x03) << 6) | (in[1] & 0x3f));
    #####:  602:	  break;
        -:  603:
    #####:  604:	case 3:
    #####:  605:	  out += sprintf (out, "\\u%02x%02x",
    #####:  606:		  ((in[0] & 0x0f) << 4) | ((in[1] & 0x3c) >> 2),
    #####:  607:		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3f)));
    #####:  608:	  break;
        -:  609:
    #####:  610:	case 4:
    #####:  611:	  out += sprintf (out, "\\u%02x%02x%02x",
    #####:  612:		  ((in[0] & 0x07) << 6) | ((in[1] & 0x3c) >> 2),
    #####:  613:		  ((in[1] & 0x03) << 6) | ((in[2] & 0x3c) >> 2),
    #####:  614:		  ((in[2] & 0x03) << 6) | ((in[3] & 0x3f)));
    #####:  615:	  break;
    #####:  616:	default:
        -:  617:	  /* URG.  */
    #####:  618:	  break;
        -:  619:	}
        -:  620:
    #####:  621:      if (unicode_display == unicode_highlight && isatty (1))
    #####:  622:	out += sprintf (out, "\033[0m"); /* Default colour.  */
    #####:  623:      break;
        -:  624:
    #####:  625:    default:
        -:  626:      /* URG */
    #####:  627:      break;
        -:  628:    }
        -:  629:
    #####:  630:  * consumed = nchars;
    #####:  631:  return out - orig_out;
        -:  632:
    #####:  633: invalid:
        -:  634:  /* Not a valid UTF-8 sequence.  */
    #####:  635:  *out = *in;
    #####:  636:  * consumed = 1;
    #####:  637:  return 1;
        -:  638:}
        -:  639:
        -:  640:/* Returns a version of IN with any control characters
        -:  641:   replaced by escape sequences.  Uses a static buffer
        -:  642:   if necessary.
        -:  643:
        -:  644:   If unicode display is enabled, then also handles the
        -:  645:   conversion of unicode characters.  */
        -:  646:
        -:  647:static const char *
     1163:  648:sanitize_string (const char * in)
        -:  649:{
        -:  650:  static char *  buffer = NULL;
        -:  651:  static size_t  buffer_len = 0;
     1163:  652:  const char *   original = in;
        -:  653:  char *         out;
        -:  654:
        -:  655:  /* Paranoia.  */
     1163:  656:  if (in == NULL)
    #####:  657:    return "";
        -:  658:
        -:  659:  /* See if any conversion is necessary.  In the majority
        -:  660:     of cases it will not be needed.  */
        -:  661:  do
    31429:  662:    {
    32592:  663:      unsigned char c = *in++;
        -:  664:
    32592:  665:      if (c == 0)
     1133:  666:	return original;
        -:  667:
    31459:  668:      if (ISCNTRL (c))
       30:  669:	break;
        -:  670:
   31429*:  671:      if (unicode_display != unicode_default && c >= 0xc0)
    #####:  672:	break;
        -:  673:    }
        -:  674:  while (1);
        -:  675:
        -:  676:  /* Copy the input, translating as needed.  */
       30:  677:  in = original;
       30:  678:  if (buffer_len < (strlen (in) * 9))
        -:  679:    {
        2:  680:      free ((void *) buffer);
        2:  681:      buffer_len = strlen (in) * 9;
        2:  682:      buffer = xmalloc (buffer_len + 1);
        -:  683:    }
        -:  684:
       30:  685:  out = buffer;
        -:  686:  do
      138:  687:    {
      168:  688:      unsigned char c = *in++;
        -:  689:
      168:  690:      if (c == 0)
       30:  691:	break;
        -:  692:
      138:  693:      if (ISCNTRL (c))
        -:  694:	{
       50:  695:	  *out++ = '^';
       50:  696:	  *out++ = c + 0x40;
        -:  697:	}
      88*:  698:      else if (unicode_display != unicode_default && c >= 0xc0)
    #####:  699:	{
        -:  700:	  unsigned int num_consumed;
        -:  701:
    #####:  702:	  out += display_utf8 ((const unsigned char *)(in - 1), out, & num_consumed);
    #####:  703:	  in += num_consumed - 1;
        -:  704:	}
        -:  705:      else
       88:  706:	*out++ = c;
        -:  707:    }
        -:  708:  while (1);
        -:  709:
       30:  710:  *out = 0;
       30:  711:  return buffer;
        -:  712:}
        -:  713:
        -:  714:
        -:  715:/* Returns TRUE if the specified section should be dumped.  */
        -:  716:
        -:  717:static bool
      502:  718:process_section_p (asection * section)
        -:  719:{
        -:  720:  struct only * only;
        -:  721:
      502:  722:  if (only_list == NULL)
      502:  723:    return true;
        -:  724:
    #####:  725:  for (only = only_list; only; only = only->next)
    #####:  726:    if (strcmp (only->name, section->name) == 0)
        -:  727:      {
    #####:  728:	only->seen = true;
    #####:  729:	return true;
        -:  730:      }
        -:  731:
    #####:  732:  return false;
        -:  733:}
        -:  734:
        -:  735:/* Add an entry to the 'only' list.  */
        -:  736:
        -:  737:static void
    #####:  738:add_only (char * name)
        -:  739:{
        -:  740:  struct only * only;
        -:  741:
        -:  742:  /* First check to make sure that we do not
        -:  743:     already have an entry for this name.  */
    #####:  744:  for (only = only_list; only; only = only->next)
    #####:  745:    if (strcmp (only->name, name) == 0)
    #####:  746:      return;
        -:  747:
    #####:  748:  only = xmalloc (sizeof * only);
    #####:  749:  only->name = name;
    #####:  750:  only->seen = false;
    #####:  751:  only->next = only_list;
    #####:  752:  only_list = only;
        -:  753:}
        -:  754:
        -:  755:/* Release the memory used by the 'only' list.
        -:  756:   PR 11225: Issue a warning message for unseen sections.
        -:  757:   Only do this if none of the sections were seen.  This is mainly to support
        -:  758:   tools like the GAS testsuite where an object file is dumped with a list of
        -:  759:   generic section names known to be present in a range of different file
        -:  760:   formats.  */
        -:  761:
        -:  762:static void
        1:  763:free_only_list (void)
        -:  764:{
        1:  765:  bool at_least_one_seen = false;
        -:  766:  struct only * only;
        -:  767:  struct only * next;
        -:  768:
        1:  769:  if (only_list == NULL)
        1:  770:    return;
        -:  771:
    #####:  772:  for (only = only_list; only; only = only->next)
    #####:  773:    if (only->seen)
        -:  774:      {
    #####:  775:	at_least_one_seen = true;
    #####:  776:	break;
        -:  777:      }
        -:  778:
    #####:  779:  for (only = only_list; only; only = next)
        -:  780:    {
    #####:  781:      if (! at_least_one_seen)
        -:  782:	{
    #####:  783:	  non_fatal (_("section '%s' mentioned in a -j option, "
        -:  784:		       "but not found in any input file"),
        -:  785:		     only->name);
    #####:  786:	  exit_status = 1;
        -:  787:	}
    #####:  788:      next = only->next;
    #####:  789:      free (only);
        -:  790:    }
        -:  791:}
        -:  792:
        -:  793:
        -:  794:static void
    #####:  795:dump_section_header (bfd *abfd, asection *section, void *data)
        -:  796:{
    #####:  797:  char *comma = "";
    #####:  798:  unsigned int opb = bfd_octets_per_byte (abfd, section);
    #####:  799:  int longest_section_name = *((int *) data);
        -:  800:
        -:  801:  /* Ignore linker created section.  See elfNN_ia64_object_p in
        -:  802:     bfd/elfxx-ia64.c.  */
    #####:  803:  if (section->flags & SEC_LINKER_CREATED)
    #####:  804:    return;
        -:  805:
        -:  806:  /* PR 10413: Skip sections that we are ignoring.  */
    #####:  807:  if (! process_section_p (section))
    #####:  808:    return;
        -:  809:
    #####:  810:  printf ("%3d %-*s %08lx  ", section->index, longest_section_name,
        -:  811:	  sanitize_string (bfd_section_name (section)),
    #####:  812:	  (unsigned long) bfd_section_size (section) / opb);
    #####:  813:  bfd_printf_vma (abfd, bfd_section_vma (section));
    #####:  814:  printf ("  ");
    #####:  815:  bfd_printf_vma (abfd, section->lma);
    #####:  816:  printf ("  %08lx  2**%u", (unsigned long) section->filepos,
        -:  817:	  bfd_section_alignment (section));
    #####:  818:  if (! wide_output)
    #####:  819:    printf ("\n                ");
    #####:  820:  printf ("  ");
        -:  821:
        -:  822:#define PF(x, y) \
        -:  823:  if (section->flags & x) { printf ("%s%s", comma, y); comma = ", "; }
        -:  824:
    #####:  825:  PF (SEC_HAS_CONTENTS, "CONTENTS");
    #####:  826:  PF (SEC_ALLOC, "ALLOC");
    #####:  827:  PF (SEC_CONSTRUCTOR, "CONSTRUCTOR");
    #####:  828:  PF (SEC_LOAD, "LOAD");
    #####:  829:  PF (SEC_RELOC, "RELOC");
    #####:  830:  PF (SEC_READONLY, "READONLY");
    #####:  831:  PF (SEC_CODE, "CODE");
    #####:  832:  PF (SEC_DATA, "DATA");
    #####:  833:  PF (SEC_ROM, "ROM");
    #####:  834:  PF (SEC_DEBUGGING, "DEBUGGING");
    #####:  835:  PF (SEC_NEVER_LOAD, "NEVER_LOAD");
    #####:  836:  PF (SEC_EXCLUDE, "EXCLUDE");
    #####:  837:  PF (SEC_SORT_ENTRIES, "SORT_ENTRIES");
    #####:  838:  if (bfd_get_arch (abfd) == bfd_arch_tic54x)
        -:  839:    {
    #####:  840:      PF (SEC_TIC54X_BLOCK, "BLOCK");
    #####:  841:      PF (SEC_TIC54X_CLINK, "CLINK");
        -:  842:    }
    #####:  843:  PF (SEC_SMALL_DATA, "SMALL_DATA");
    #####:  844:  if (bfd_get_flavour (abfd) == bfd_target_coff_flavour)
        -:  845:    {
    #####:  846:      PF (SEC_COFF_SHARED, "SHARED");
    #####:  847:      PF (SEC_COFF_NOREAD, "NOREAD");
        -:  848:    }
    #####:  849:  else if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
        -:  850:    {
    #####:  851:      PF (SEC_ELF_OCTETS, "OCTETS");
    #####:  852:      PF (SEC_ELF_PURECODE, "PURECODE");
        -:  853:    }
    #####:  854:  PF (SEC_THREAD_LOCAL, "THREAD_LOCAL");
    #####:  855:  PF (SEC_GROUP, "GROUP");
    #####:  856:  if (bfd_get_arch (abfd) == bfd_arch_mep)
        -:  857:    {
    #####:  858:      PF (SEC_MEP_VLIW, "VLIW");
        -:  859:    }
        -:  860:
    #####:  861:  if ((section->flags & SEC_LINK_ONCE) != 0)
        -:  862:    {
        -:  863:      const char *ls;
        -:  864:      struct coff_comdat_info *comdat;
        -:  865:
    #####:  866:      switch (section->flags & SEC_LINK_DUPLICATES)
        -:  867:	{
    #####:  868:	default:
    #####:  869:	  abort ();
    #####:  870:	case SEC_LINK_DUPLICATES_DISCARD:
    #####:  871:	  ls = "LINK_ONCE_DISCARD";
    #####:  872:	  break;
    #####:  873:	case SEC_LINK_DUPLICATES_ONE_ONLY:
    #####:  874:	  ls = "LINK_ONCE_ONE_ONLY";
    #####:  875:	  break;
    #####:  876:	case SEC_LINK_DUPLICATES_SAME_SIZE:
    #####:  877:	  ls = "LINK_ONCE_SAME_SIZE";
    #####:  878:	  break;
    #####:  879:	case SEC_LINK_DUPLICATES_SAME_CONTENTS:
    #####:  880:	  ls = "LINK_ONCE_SAME_CONTENTS";
    #####:  881:	  break;
        -:  882:	}
    #####:  883:      printf ("%s%s", comma, ls);
        -:  884:
    #####:  885:      comdat = bfd_coff_get_comdat_section (abfd, section);
    #####:  886:      if (comdat != NULL)
    #####:  887:	printf (" (COMDAT %s %ld)", comdat->name, comdat->symbol);
        -:  888:
    #####:  889:      comma = ", ";
        -:  890:    }
        -:  891:
    #####:  892:  printf ("\n");
        -:  893:#undef PF
        -:  894:}
        -:  895:
        -:  896:/* Called on each SECTION in ABFD, update the int variable pointed to by
        -:  897:   DATA which contains the string length of the longest section name.  */
        -:  898:
        -:  899:static void
    #####:  900:find_longest_section_name (bfd *abfd ATTRIBUTE_UNUSED,
        -:  901:			   asection *section, void *data)
        -:  902:{
    #####:  903:  int *longest_so_far = (int *) data;
        -:  904:  const char *name;
        -:  905:  int len;
        -:  906:
        -:  907:  /* Ignore linker created section.  */
    #####:  908:  if (section->flags & SEC_LINKER_CREATED)
    #####:  909:    return;
        -:  910:
        -:  911:  /* Skip sections that we are ignoring.  */
    #####:  912:  if (! process_section_p (section))
    #####:  913:    return;
        -:  914:
    #####:  915:  name = bfd_section_name (section);
    #####:  916:  len = (int) strlen (name);
    #####:  917:  if (len > *longest_so_far)
    #####:  918:    *longest_so_far = len;
        -:  919:}
        -:  920:
        -:  921:static void
    #####:  922:dump_headers (bfd *abfd)
        -:  923:{
        -:  924:  /* The default width of 13 is just an arbitrary choice.  */
    #####:  925:  int max_section_name_length = 13;
        -:  926:  int bfd_vma_width;
        -:  927:
        -:  928:#ifndef BFD64
        -:  929:  bfd_vma_width = 10;
        -:  930:#else
        -:  931:  /* With BFD64, non-ELF returns -1 and wants always 64 bit addresses.  */
    #####:  932:  if (bfd_get_arch_size (abfd) == 32)
    #####:  933:    bfd_vma_width = 10;
        -:  934:  else
    #####:  935:    bfd_vma_width = 18;
        -:  936:#endif
        -:  937:
    #####:  938:  printf (_("Sections:\n"));
        -:  939:
    #####:  940:  if (wide_output)
    #####:  941:    bfd_map_over_sections (abfd, find_longest_section_name,
        -:  942:			   &max_section_name_length);
        -:  943:
    #####:  944:  printf (_("Idx %-*s Size      %-*s%-*sFile off  Algn"),
        -:  945:	  max_section_name_length, "Name",
        -:  946:	  bfd_vma_width, "VMA",
        -:  947:	  bfd_vma_width, "LMA");
        -:  948:
    #####:  949:  if (wide_output)
    #####:  950:    printf (_("  Flags"));
    #####:  951:  printf ("\n");
        -:  952:
    #####:  953:  bfd_map_over_sections (abfd, dump_section_header,
        -:  954:			 &max_section_name_length);
    #####:  955:}
        -:  956:
        -:  957:static asymbol **
      293:  958:slurp_symtab (bfd *abfd)
        -:  959:{
      293:  960:  asymbol **sy = NULL;
        -:  961:  long storage;
        -:  962:
      293:  963:  if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
        -:  964:    {
      293:  965:      symcount = 0;
      293:  966:      return NULL;
        -:  967:    }
        -:  968:
    #####:  969:  storage = bfd_get_symtab_upper_bound (abfd);
    #####:  970:  if (storage < 0)
        -:  971:    {
    #####:  972:      non_fatal (_("failed to read symbol table from: %s"), bfd_get_filename (abfd));
    #####:  973:      bfd_fatal (_("error message was"));
        -:  974:    }
        -:  975:
    #####:  976:  if (storage)
        -:  977:    {
    #####:  978:      off_t filesize = bfd_get_file_size (abfd);
        -:  979:
        -:  980:      /* qv PR 24707.  */
    #####:  981:      if (filesize > 0
    #####:  982:	  && filesize < storage
        -:  983:	  /* The MMO file format supports its own special compression
        -:  984:	     technique, so its sections can be larger than the file size.  */
    #####:  985:	  && bfd_get_flavour (abfd) != bfd_target_mmo_flavour)
        -:  986:	{
    #####:  987:	  bfd_nonfatal_message (bfd_get_filename (abfd), abfd, NULL,
    #####:  988:				_("error: symbol table size (%#lx) "
        -:  989:				  "is larger than filesize (%#lx)"),
        -:  990:				storage, (long) filesize);
    #####:  991:	  exit_status = 1;
    #####:  992:	  symcount = 0;
    #####:  993:	  return NULL;
        -:  994:	}
        -:  995:
    #####:  996:      sy = (asymbol **) xmalloc (storage);
        -:  997:    }
        -:  998:
    #####:  999:  symcount = bfd_canonicalize_symtab (abfd, sy);
    #####: 1000:  if (symcount < 0)
    #####: 1001:    bfd_fatal (bfd_get_filename (abfd));
    #####: 1002:  return sy;
        -: 1003:}
        -: 1004:
        -: 1005:/* Read in the dynamic symbols.  */
        -: 1006:
        -: 1007:static asymbol **
    #####: 1008:slurp_dynamic_symtab (bfd *abfd)
        -: 1009:{
    #####: 1010:  asymbol **sy = NULL;
        -: 1011:  long storage;
        -: 1012:
    #####: 1013:  storage = bfd_get_dynamic_symtab_upper_bound (abfd);
    #####: 1014:  if (storage < 0)
        -: 1015:    {
    #####: 1016:      if (!(bfd_get_file_flags (abfd) & DYNAMIC))
        -: 1017:	{
    #####: 1018:	  non_fatal (_("%s: not a dynamic object"), bfd_get_filename (abfd));
    #####: 1019:	  exit_status = 1;
    #####: 1020:	  dynsymcount = 0;
    #####: 1021:	  return NULL;
        -: 1022:	}
        -: 1023:
    #####: 1024:      bfd_fatal (bfd_get_filename (abfd));
        -: 1025:    }
        -: 1026:
    #####: 1027:  if (storage)
    #####: 1028:    sy = (asymbol **) xmalloc (storage);
        -: 1029:
    #####: 1030:  dynsymcount = bfd_canonicalize_dynamic_symtab (abfd, sy);
    #####: 1031:  if (dynsymcount < 0)
    #####: 1032:    bfd_fatal (bfd_get_filename (abfd));
    #####: 1033:  return sy;
        -: 1034:}
        -: 1035:
        -: 1036:/* Some symbol names are significant and should be kept in the
        -: 1037:   table of sorted symbol names, even if they are marked as
        -: 1038:   debugging/section symbols.  */
        -: 1039:
        -: 1040:static bool
    #####: 1041:is_significant_symbol_name (const char * name)
        -: 1042:{
    #####: 1043:  return startswith (name, ".plt") || startswith (name, ".got");
        -: 1044:}
        -: 1045:
        -: 1046:/* Filter out (in place) symbols that are useless for disassembly.
        -: 1047:   COUNT is the number of elements in SYMBOLS.
        -: 1048:   Return the number of useful symbols.  */
        -: 1049:
        -: 1050:static long
    #####: 1051:remove_useless_symbols (asymbol **symbols, long count)
        -: 1052:{
    #####: 1053:  asymbol **in_ptr = symbols, **out_ptr = symbols;
        -: 1054:
    #####: 1055:  while (--count >= 0)
        -: 1056:    {
    #####: 1057:      asymbol *sym = *in_ptr++;
        -: 1058:
    #####: 1059:      if (sym->name == NULL || sym->name[0] == '\0')
    #####: 1060:	continue;
    #####: 1061:      if ((sym->flags & (BSF_DEBUGGING | BSF_SECTION_SYM))
    #####: 1062:	  && ! is_significant_symbol_name (sym->name))
    #####: 1063:	continue;
    #####: 1064:      if (bfd_is_und_section (sym->section)
    #####: 1065:	  || bfd_is_com_section (sym->section))
    #####: 1066:	continue;
        -: 1067:
    #####: 1068:      *out_ptr++ = sym;
        -: 1069:    }
    #####: 1070:  return out_ptr - symbols;
        -: 1071:}
        -: 1072:
        -: 1073:static const asection *compare_section;
        -: 1074:
        -: 1075:/* Sort symbols into value order.  */
        -: 1076:
        -: 1077:static int
    #####: 1078:compare_symbols (const void *ap, const void *bp)
        -: 1079:{
    #####: 1080:  const asymbol *a = * (const asymbol **) ap;
    #####: 1081:  const asymbol *b = * (const asymbol **) bp;
        -: 1082:  const char *an;
        -: 1083:  const char *bn;
        -: 1084:  size_t anl;
        -: 1085:  size_t bnl;
        -: 1086:  bool as, af, bs, bf;
        -: 1087:  flagword aflags;
        -: 1088:  flagword bflags;
        -: 1089:
    #####: 1090:  if (bfd_asymbol_value (a) > bfd_asymbol_value (b))
    #####: 1091:    return 1;
    #####: 1092:  else if (bfd_asymbol_value (a) < bfd_asymbol_value (b))
    #####: 1093:    return -1;
        -: 1094:
        -: 1095:  /* Prefer symbols from the section currently being disassembled.
        -: 1096:     Don't sort symbols from other sections by section, since there
        -: 1097:     isn't much reason to prefer one section over another otherwise.
        -: 1098:     See sym_ok comment for why we compare by section name.  */
    #####: 1099:  as = strcmp (compare_section->name, a->section->name) == 0;
    #####: 1100:  bs = strcmp (compare_section->name, b->section->name) == 0;
    #####: 1101:  if (as && !bs)
    #####: 1102:    return -1;
    #####: 1103:  if (!as && bs)
    #####: 1104:    return 1;
        -: 1105:
    #####: 1106:  an = bfd_asymbol_name (a);
    #####: 1107:  bn = bfd_asymbol_name (b);
    #####: 1108:  anl = strlen (an);
    #####: 1109:  bnl = strlen (bn);
        -: 1110:
        -: 1111:  /* The symbols gnu_compiled and gcc2_compiled convey no real
        -: 1112:     information, so put them after other symbols with the same value.  */
    #####: 1113:  af = (strstr (an, "gnu_compiled") != NULL
    #####: 1114:	|| strstr (an, "gcc2_compiled") != NULL);
    #####: 1115:  bf = (strstr (bn, "gnu_compiled") != NULL
    #####: 1116:	|| strstr (bn, "gcc2_compiled") != NULL);
        -: 1117:
    #####: 1118:  if (af && ! bf)
    #####: 1119:    return 1;
    #####: 1120:  if (! af && bf)
    #####: 1121:    return -1;
        -: 1122:
        -: 1123:  /* We use a heuristic for the file name, to try to sort it after
        -: 1124:     more useful symbols.  It may not work on non Unix systems, but it
        -: 1125:     doesn't really matter; the only difference is precisely which
        -: 1126:     symbol names get printed.  */
        -: 1127:
        -: 1128:#define file_symbol(s, sn, snl)			\
        -: 1129:  (((s)->flags & BSF_FILE) != 0			\
        -: 1130:   || ((snl) > 2				\
        -: 1131:       && (sn)[(snl) - 2] == '.'		\
        -: 1132:       && ((sn)[(snl) - 1] == 'o'		\
        -: 1133:	   || (sn)[(snl) - 1] == 'a')))
        -: 1134:
    #####: 1135:  af = file_symbol (a, an, anl);
    #####: 1136:  bf = file_symbol (b, bn, bnl);
        -: 1137:
    #####: 1138:  if (af && ! bf)
    #####: 1139:    return 1;
    #####: 1140:  if (! af && bf)
    #####: 1141:    return -1;
        -: 1142:
        -: 1143:  /* Sort function and object symbols before global symbols before
        -: 1144:     local symbols before section symbols before debugging symbols.  */
        -: 1145:
    #####: 1146:  aflags = a->flags;
    #####: 1147:  bflags = b->flags;
        -: 1148:
    #####: 1149:  if ((aflags & BSF_DEBUGGING) != (bflags & BSF_DEBUGGING))
        -: 1150:    {
    #####: 1151:      if ((aflags & BSF_DEBUGGING) != 0)
    #####: 1152:	return 1;
        -: 1153:      else
    #####: 1154:	return -1;
        -: 1155:    }
    #####: 1156:  if ((aflags & BSF_SECTION_SYM) != (bflags & BSF_SECTION_SYM))
        -: 1157:    {
    #####: 1158:      if ((aflags & BSF_SECTION_SYM) != 0)
    #####: 1159:	return 1;
        -: 1160:      else
    #####: 1161:	return -1;
        -: 1162:    }
    #####: 1163:  if ((aflags & BSF_FUNCTION) != (bflags & BSF_FUNCTION))
        -: 1164:    {
    #####: 1165:      if ((aflags & BSF_FUNCTION) != 0)
    #####: 1166:	return -1;
        -: 1167:      else
    #####: 1168:	return 1;
        -: 1169:    }
    #####: 1170:  if ((aflags & BSF_OBJECT) != (bflags & BSF_OBJECT))
        -: 1171:    {
    #####: 1172:      if ((aflags & BSF_OBJECT) != 0)
    #####: 1173:	return -1;
        -: 1174:      else
    #####: 1175:	return 1;
        -: 1176:    }
    #####: 1177:  if ((aflags & BSF_LOCAL) != (bflags & BSF_LOCAL))
        -: 1178:    {
    #####: 1179:      if ((aflags & BSF_LOCAL) != 0)
    #####: 1180:	return 1;
        -: 1181:      else
    #####: 1182:	return -1;
        -: 1183:    }
    #####: 1184:  if ((aflags & BSF_GLOBAL) != (bflags & BSF_GLOBAL))
        -: 1185:    {
    #####: 1186:      if ((aflags & BSF_GLOBAL) != 0)
    #####: 1187:	return -1;
        -: 1188:      else
    #####: 1189:	return 1;
        -: 1190:    }
        -: 1191:
    #####: 1192:  if (bfd_get_flavour (bfd_asymbol_bfd (a)) == bfd_target_elf_flavour
    #####: 1193:      && bfd_get_flavour (bfd_asymbol_bfd (b)) == bfd_target_elf_flavour)
        -: 1194:    {
        -: 1195:      bfd_vma asz, bsz;
        -: 1196:
    #####: 1197:      asz = 0;
    #####: 1198:      if ((a->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) == 0)
    #####: 1199:	asz = ((elf_symbol_type *) a)->internal_elf_sym.st_size;
    #####: 1200:      bsz = 0;
    #####: 1201:      if ((b->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) == 0)
    #####: 1202:	bsz = ((elf_symbol_type *) b)->internal_elf_sym.st_size;
    #####: 1203:      if (asz != bsz)
    #####: 1204:	return asz > bsz ? -1 : 1;
        -: 1205:    }
        -: 1206:
        -: 1207:  /* Symbols that start with '.' might be section names, so sort them
        -: 1208:     after symbols that don't start with '.'.  */
    #####: 1209:  if (an[0] == '.' && bn[0] != '.')
    #####: 1210:    return 1;
    #####: 1211:  if (an[0] != '.' && bn[0] == '.')
    #####: 1212:    return -1;
        -: 1213:
        -: 1214:  /* Finally, if we can't distinguish them in any other way, try to
        -: 1215:     get consistent results by sorting the symbols by name.  */
    #####: 1216:  return strcmp (an, bn);
        -: 1217:}
        -: 1218:
        -: 1219:/* Sort relocs into address order.  */
        -: 1220:
        -: 1221:static int
    #####: 1222:compare_relocs (const void *ap, const void *bp)
        -: 1223:{
    #####: 1224:  const arelent *a = * (const arelent **) ap;
    #####: 1225:  const arelent *b = * (const arelent **) bp;
        -: 1226:
    #####: 1227:  if (a->address > b->address)
    #####: 1228:    return 1;
    #####: 1229:  else if (a->address < b->address)
    #####: 1230:    return -1;
        -: 1231:
        -: 1232:  /* So that associated relocations tied to the same address show up
        -: 1233:     in the correct order, we don't do any further sorting.  */
    #####: 1234:  if (a > b)
    #####: 1235:    return 1;
    #####: 1236:  else if (a < b)
    #####: 1237:    return -1;
        -: 1238:  else
    #####: 1239:    return 0;
        -: 1240:}
        -: 1241:
        -: 1242:/* Print an address (VMA) to the output stream in INFO.
        -: 1243:   If SKIP_ZEROES is TRUE, omit leading zeroes.  */
        -: 1244:
        -: 1245:static void
      734: 1246:objdump_print_value (bfd_vma vma, struct disassemble_info *inf,
        -: 1247:		     bool skip_zeroes)
        -: 1248:{
        -: 1249:  char buf[30];
        -: 1250:  char *p;
        -: 1251:  struct objdump_disasm_info *aux;
        -: 1252:
      734: 1253:  aux = (struct objdump_disasm_info *) inf->application_data;
      734: 1254:  bfd_sprintf_vma (aux->abfd, buf, vma);
      734: 1255:  if (! skip_zeroes)
      435: 1256:    p = buf;
        -: 1257:  else
        -: 1258:    {
      599: 1259:      for (p = buf; *p == '0'; ++p)
        -: 1260:	;
      299: 1261:      if (*p == '\0')
    #####: 1262:	--p;
        -: 1263:    }
      734: 1264:  (*inf->fprintf_styled_func) (inf->stream, dis_style_address, "%s", p);
      734: 1265:}
        -: 1266:
        -: 1267:/* Print the name of a symbol.  */
        -: 1268:
        -: 1269:static void
    #####: 1270:objdump_print_symname (bfd *abfd, struct disassemble_info *inf,
        -: 1271:		       asymbol *sym)
        -: 1272:{
        -: 1273:  char *alloc;
    #####: 1274:  const char *name, *version_string = NULL;
    #####: 1275:  bool hidden = false;
        -: 1276:
    #####: 1277:  alloc = NULL;
    #####: 1278:  name = bfd_asymbol_name (sym);
    #####: 1279:  if (do_demangle && name[0] != '\0')
        -: 1280:    {
        -: 1281:      /* Demangle the name.  */
    #####: 1282:      alloc = bfd_demangle (abfd, name, demangle_flags);
    #####: 1283:      if (alloc != NULL)
    #####: 1284:	name = alloc;
        -: 1285:    }
        -: 1286:
    #####: 1287:  if ((sym->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) == 0)
    #####: 1288:    version_string = bfd_get_symbol_version_string (abfd, sym, true,
        -: 1289:						    &hidden);
        -: 1290:
    #####: 1291:  if (bfd_is_und_section (bfd_asymbol_section (sym)))
    #####: 1292:    hidden = true;
        -: 1293:
    #####: 1294:  name = sanitize_string (name);
        -: 1295:
    #####: 1296:  if (inf != NULL)
        -: 1297:    {
    #####: 1298:      (*inf->fprintf_styled_func) (inf->stream, dis_style_symbol, "%s", name);
    #####: 1299:      if (version_string && *version_string != '\0')
    #####: 1300:	(*inf->fprintf_styled_func) (inf->stream, dis_style_symbol,
    #####: 1301:				     hidden ? "@%s" : "@@%s",
        -: 1302:				     version_string);
        -: 1303:    }
        -: 1304:  else
        -: 1305:    {
    #####: 1306:      printf ("%s", name);
    #####: 1307:      if (version_string && *version_string != '\0')
    #####: 1308:	printf (hidden ? "@%s" : "@@%s", version_string);
        -: 1309:    }
        -: 1310:
    #####: 1311:  if (alloc != NULL)
    #####: 1312:    free (alloc);
    #####: 1313:}
        -: 1314:
        -: 1315:static inline bool
    #####: 1316:sym_ok (bool want_section,
        -: 1317:	bfd *abfd ATTRIBUTE_UNUSED,
        -: 1318:	long place,
        -: 1319:	asection *sec,
        -: 1320:	struct disassemble_info *inf)
        -: 1321:{
    #####: 1322:  if (want_section)
        -: 1323:    {
        -: 1324:      /* NB: An object file can have different sections with the same
        -: 1325:	 section name.  Compare compare section pointers if they have
        -: 1326:	 the same owner.  */
    #####: 1327:      if (sorted_syms[place]->section->owner == sec->owner
    #####: 1328:	  && sorted_syms[place]->section != sec)
    #####: 1329:	return false;
        -: 1330:
        -: 1331:      /* Note - we cannot just compare section pointers because they could
        -: 1332:	 be different, but the same...  Ie the symbol that we are trying to
        -: 1333:	 find could have come from a separate debug info file.  Under such
        -: 1334:	 circumstances the symbol will be associated with a section in the
        -: 1335:	 debug info file, whilst the section we want is in a normal file.
        -: 1336:	 So the section pointers will be different, but the section names
        -: 1337:	 will be the same.  */
    #####: 1338:      if (strcmp (bfd_section_name (sorted_syms[place]->section),
        -: 1339:		  bfd_section_name (sec)) != 0)
    #####: 1340:	return false;
        -: 1341:    }
        -: 1342:
    #####: 1343:  return inf->symbol_is_valid (sorted_syms[place], inf);
        -: 1344:}
        -: 1345:
        -: 1346:/* Locate a symbol given a bfd and a section (from INFO->application_data),
        -: 1347:   and a VMA.  If INFO->application_data->require_sec is TRUE, then always
        -: 1348:   require the symbol to be in the section.  Returns NULL if there is no
        -: 1349:   suitable symbol.  If PLACE is not NULL, then *PLACE is set to the index
        -: 1350:   of the symbol in sorted_syms.  */
        -: 1351:
        -: 1352:static asymbol *
      435: 1353:find_symbol_for_address (bfd_vma vma,
        -: 1354:			 struct disassemble_info *inf,
        -: 1355:			 long *place)
        -: 1356:{
        -: 1357:  /* @@ Would it speed things up to cache the last two symbols returned,
        -: 1358:     and maybe their address ranges?  For many processors, only one memory
        -: 1359:     operand can be present at a time, so the 2-entry cache wouldn't be
        -: 1360:     constantly churned by code doing heavy memory accesses.  */
        -: 1361:
        -: 1362:  /* Indices in `sorted_syms'.  */
      435: 1363:  long min = 0;
      435: 1364:  long max_count = sorted_symcount;
        -: 1365:  long thisplace;
        -: 1366:  struct objdump_disasm_info *aux;
        -: 1367:  bfd *abfd;
        -: 1368:  asection *sec;
        -: 1369:  unsigned int opb;
        -: 1370:  bool want_section;
        -: 1371:  long rel_count;
        -: 1372:
      435: 1373:  if (sorted_symcount < 1)
      435: 1374:    return NULL;
        -: 1375:
    #####: 1376:  aux = (struct objdump_disasm_info *) inf->application_data;
    #####: 1377:  abfd = aux->abfd;
    #####: 1378:  sec = inf->section;
    #####: 1379:  opb = inf->octets_per_byte;
        -: 1380:
        -: 1381:  /* Perform a binary search looking for the closest symbol to the
        -: 1382:     required value.  We are searching the range (min, max_count].  */
    #####: 1383:  while (min + 1 < max_count)
        -: 1384:    {
        -: 1385:      asymbol *sym;
        -: 1386:
    #####: 1387:      thisplace = (max_count + min) / 2;
    #####: 1388:      sym = sorted_syms[thisplace];
        -: 1389:
    #####: 1390:      if (bfd_asymbol_value (sym) > vma)
    #####: 1391:	max_count = thisplace;
    #####: 1392:      else if (bfd_asymbol_value (sym) < vma)
    #####: 1393:	min = thisplace;
        -: 1394:      else
        -: 1395:	{
    #####: 1396:	  min = thisplace;
    #####: 1397:	  break;
        -: 1398:	}
        -: 1399:    }
        -: 1400:
        -: 1401:  /* The symbol we want is now in min, the low end of the range we
        -: 1402:     were searching.  If there are several symbols with the same
        -: 1403:     value, we want the first one.  */
    #####: 1404:  thisplace = min;
    #####: 1405:  while (thisplace > 0
    #####: 1406:	 && (bfd_asymbol_value (sorted_syms[thisplace])
    #####: 1407:	     == bfd_asymbol_value (sorted_syms[thisplace - 1])))
    #####: 1408:    --thisplace;
        -: 1409:
        -: 1410:  /* Prefer a symbol in the current section if we have multple symbols
        -: 1411:     with the same value, as can occur with overlays or zero size
        -: 1412:     sections.  */
    #####: 1413:  min = thisplace;
    #####: 1414:  while (min < max_count
    #####: 1415:	 && (bfd_asymbol_value (sorted_syms[min])
    #####: 1416:	     == bfd_asymbol_value (sorted_syms[thisplace])))
        -: 1417:    {
    #####: 1418:      if (sym_ok (true, abfd, min, sec, inf))
        -: 1419:	{
    #####: 1420:	  thisplace = min;
        -: 1421:
    #####: 1422:	  if (place != NULL)
    #####: 1423:	    *place = thisplace;
        -: 1424:
    #####: 1425:	  return sorted_syms[thisplace];
        -: 1426:	}
    #####: 1427:      ++min;
        -: 1428:    }
        -: 1429:
        -: 1430:  /* If the file is relocatable, and the symbol could be from this
        -: 1431:     section, prefer a symbol from this section over symbols from
        -: 1432:     others, even if the other symbol's value might be closer.
        -: 1433:
        -: 1434:     Note that this may be wrong for some symbol references if the
        -: 1435:     sections have overlapping memory ranges, but in that case there's
        -: 1436:     no way to tell what's desired without looking at the relocation
        -: 1437:     table.
        -: 1438:
        -: 1439:     Also give the target a chance to reject symbols.  */
    #####: 1440:  want_section = (aux->require_sec
    #####: 1441:		  || ((abfd->flags & HAS_RELOC) != 0
    #####: 1442:		      && vma >= bfd_section_vma (sec)
    #####: 1443:		      && vma < (bfd_section_vma (sec)
    #####: 1444:				+ bfd_section_size (sec) / opb)));
        -: 1445:
    #####: 1446:  if (! sym_ok (want_section, abfd, thisplace, sec, inf))
        -: 1447:    {
        -: 1448:      long i;
    #####: 1449:      long newplace = sorted_symcount;
        -: 1450:
    #####: 1451:      for (i = min - 1; i >= 0; i--)
        -: 1452:	{
    #####: 1453:	  if (sym_ok (want_section, abfd, i, sec, inf))
        -: 1454:	    {
    #####: 1455:	      if (newplace == sorted_symcount)
    #####: 1456:		newplace = i;
        -: 1457:
    #####: 1458:	      if (bfd_asymbol_value (sorted_syms[i])
    #####: 1459:		  != bfd_asymbol_value (sorted_syms[newplace]))
    #####: 1460:		break;
        -: 1461:
        -: 1462:	      /* Remember this symbol and keep searching until we reach
        -: 1463:		 an earlier address.  */
    #####: 1464:	      newplace = i;
        -: 1465:	    }
        -: 1466:	}
        -: 1467:
    #####: 1468:      if (newplace != sorted_symcount)
    #####: 1469:	thisplace = newplace;
        -: 1470:      else
        -: 1471:	{
        -: 1472:	  /* We didn't find a good symbol with a smaller value.
        -: 1473:	     Look for one with a larger value.  */
    #####: 1474:	  for (i = thisplace + 1; i < sorted_symcount; i++)
        -: 1475:	    {
    #####: 1476:	      if (sym_ok (want_section, abfd, i, sec, inf))
        -: 1477:		{
    #####: 1478:		  thisplace = i;
    #####: 1479:		  break;
        -: 1480:		}
        -: 1481:	    }
        -: 1482:	}
        -: 1483:
    #####: 1484:      if (! sym_ok (want_section, abfd, thisplace, sec, inf))
        -: 1485:	/* There is no suitable symbol.  */
    #####: 1486:	return NULL;
        -: 1487:    }
        -: 1488:
        -: 1489:  /* If we have not found an exact match for the specified address
        -: 1490:     and we have dynamic relocations available, then we can produce
        -: 1491:     a better result by matching a relocation to the address and
        -: 1492:     using the symbol associated with that relocation.  */
    #####: 1493:  rel_count = inf->dynrelcount;
    #####: 1494:  if (!want_section
    #####: 1495:      && sorted_syms[thisplace]->value != vma
    #####: 1496:      && rel_count > 0
    #####: 1497:      && inf->dynrelbuf != NULL
    #####: 1498:      && inf->dynrelbuf[0]->address <= vma
    #####: 1499:      && inf->dynrelbuf[rel_count - 1]->address >= vma
        -: 1500:      /* If we have matched a synthetic symbol, then stick with that.  */
    #####: 1501:      && (sorted_syms[thisplace]->flags & BSF_SYNTHETIC) == 0)
        -: 1502:    {
        -: 1503:      arelent **  rel_low;
        -: 1504:      arelent **  rel_high;
        -: 1505:
    #####: 1506:      rel_low = inf->dynrelbuf;
    #####: 1507:      rel_high = rel_low + rel_count - 1;
    #####: 1508:      while (rel_low <= rel_high)
        -: 1509:	{
    #####: 1510:	  arelent **rel_mid = &rel_low[(rel_high - rel_low) / 2];
    #####: 1511:	  arelent * rel = *rel_mid;
        -: 1512:
    #####: 1513:	  if (rel->address == vma)
        -: 1514:	    {
        -: 1515:	      /* Absolute relocations do not provide a more helpful
        -: 1516:		 symbolic address.  Find a non-absolute relocation
        -: 1517:		 with the same address.  */
    #####: 1518:	      arelent **rel_vma = rel_mid;
    #####: 1519:	      for (rel_mid--;
    #####: 1520:		   rel_mid >= rel_low && rel_mid[0]->address == vma;
    #####: 1521:		   rel_mid--)
    #####: 1522:		rel_vma = rel_mid;
        -: 1523:
    #####: 1524:	      for (; rel_vma <= rel_high && rel_vma[0]->address == vma;
    #####: 1525:		   rel_vma++)
        -: 1526:		{
    #####: 1527:		  rel = *rel_vma;
    #####: 1528:		  if (rel->sym_ptr_ptr != NULL
    #####: 1529:		      && ! bfd_is_abs_section ((* rel->sym_ptr_ptr)->section))
        -: 1530:		    {
    #####: 1531:		      if (place != NULL)
    #####: 1532:			* place = thisplace;
    #####: 1533:		      return * rel->sym_ptr_ptr;
        -: 1534:		    }
        -: 1535:		}
    #####: 1536:	      break;
        -: 1537:	    }
        -: 1538:
    #####: 1539:	  if (vma < rel->address)
    #####: 1540:	    rel_high = rel_mid;
    #####: 1541:	  else if (vma >= rel_mid[1]->address)
    #####: 1542:	    rel_low = rel_mid + 1;
        -: 1543:	  else
    #####: 1544:	    break;
        -: 1545:	}
        -: 1546:    }
        -: 1547:
    #####: 1548:  if (place != NULL)
    #####: 1549:    *place = thisplace;
        -: 1550:
    #####: 1551:  return sorted_syms[thisplace];
        -: 1552:}
        -: 1553:
        -: 1554:/* Print an address and the offset to the nearest symbol.  */
        -: 1555:
        -: 1556:static void
      435: 1557:objdump_print_addr_with_sym (bfd *abfd, asection *sec, asymbol *sym,
        -: 1558:			     bfd_vma vma, struct disassemble_info *inf,
        -: 1559:			     bool skip_zeroes)
        -: 1560:{
      435: 1561:  if (!no_addresses)
        -: 1562:    {
      435: 1563:      objdump_print_value (vma, inf, skip_zeroes);
      435: 1564:      (*inf->fprintf_styled_func) (inf->stream, dis_style_text, " ");
        -: 1565:    }
        -: 1566:
      435: 1567:  if (sym == NULL)
        -: 1568:    {
        -: 1569:      bfd_vma secaddr;
        -: 1570:
      435: 1571:      (*inf->fprintf_styled_func) (inf->stream, dis_style_text,"<");
      435: 1572:      (*inf->fprintf_styled_func) (inf->stream, dis_style_symbol, "%s",
        -: 1573:				   sanitize_string (bfd_section_name (sec)));
      435: 1574:      secaddr = bfd_section_vma (sec);
      435: 1575:      if (vma < secaddr)
        -: 1576:	{
    #####: 1577:	  (*inf->fprintf_styled_func) (inf->stream, dis_style_immediate,
        -: 1578:				       "-0x");
    #####: 1579:	  objdump_print_value (secaddr - vma, inf, true);
        -: 1580:	}
      435: 1581:      else if (vma > secaddr)
        -: 1582:	{
    #####: 1583:	  (*inf->fprintf_styled_func) (inf->stream, dis_style_immediate, "+0x");
    #####: 1584:	  objdump_print_value (vma - secaddr, inf, true);
        -: 1585:	}
      435: 1586:      (*inf->fprintf_styled_func) (inf->stream, dis_style_text, ">");
        -: 1587:    }
        -: 1588:  else
        -: 1589:    {
    #####: 1590:      (*inf->fprintf_styled_func) (inf->stream, dis_style_text, "<");
        -: 1591:
    #####: 1592:      objdump_print_symname (abfd, inf, sym);
        -: 1593:
    #####: 1594:      if (bfd_asymbol_value (sym) == vma)
        -: 1595:	;
        -: 1596:      /* Undefined symbols in an executables and dynamic objects do not have
        -: 1597:	 a value associated with them, so it does not make sense to display
        -: 1598:	 an offset relative to them.  Normally we would not be provided with
        -: 1599:	 this kind of symbol, but the target backend might choose to do so,
        -: 1600:	 and the code in find_symbol_for_address might return an as yet
        -: 1601:	 unresolved symbol associated with a dynamic reloc.  */
    #####: 1602:      else if ((bfd_get_file_flags (abfd) & (EXEC_P | DYNAMIC))
    #####: 1603:	       && bfd_is_und_section (sym->section))
        -: 1604:	;
    #####: 1605:      else if (bfd_asymbol_value (sym) > vma)
        -: 1606:	{
    #####: 1607:	  (*inf->fprintf_styled_func) (inf->stream, dis_style_immediate,"-0x");
    #####: 1608:	  objdump_print_value (bfd_asymbol_value (sym) - vma, inf, true);
        -: 1609:	}
    #####: 1610:      else if (vma > bfd_asymbol_value (sym))
        -: 1611:	{
    #####: 1612:	  (*inf->fprintf_styled_func) (inf->stream, dis_style_immediate, "+0x");
    #####: 1613:	  objdump_print_value (vma - bfd_asymbol_value (sym), inf, true);
        -: 1614:	}
        -: 1615:
    #####: 1616:      (*inf->fprintf_styled_func) (inf->stream, dis_style_text, ">");
        -: 1617:    }
        -: 1618:
      435: 1619:  if (display_file_offsets)
    #####: 1620:    inf->fprintf_styled_func (inf->stream, dis_style_text,
    #####: 1621:			      _(" (File Offset: 0x%lx)"),
    #####: 1622:			      (long int)(sec->filepos + (vma - sec->vma)));
      435: 1623:}
        -: 1624:
        -: 1625:/* Print an address (VMA), symbolically if possible.
        -: 1626:   If SKIP_ZEROES is TRUE, don't output leading zeroes.  */
        -: 1627:
        -: 1628:static void
      299: 1629:objdump_print_addr (bfd_vma vma,
        -: 1630:		    struct disassemble_info *inf,
        -: 1631:		    bool skip_zeroes)
        -: 1632:{
        -: 1633:  struct objdump_disasm_info *aux;
      299: 1634:  asymbol *sym = NULL;
      299: 1635:  bool skip_find = false;
        -: 1636:
      299: 1637:  aux = (struct objdump_disasm_info *) inf->application_data;
        -: 1638:
      299: 1639:  if (sorted_symcount < 1)
        -: 1640:    {
      299: 1641:      if (!no_addresses)
        -: 1642:	{
      299: 1643:	  (*inf->fprintf_styled_func) (inf->stream, dis_style_address, "0x");
      299: 1644:	  objdump_print_value (vma, inf, skip_zeroes);
        -: 1645:	}
        -: 1646:
      299: 1647:      if (display_file_offsets)
    #####: 1648:	inf->fprintf_styled_func (inf->stream, dis_style_text,
    #####: 1649:				  _(" (File Offset: 0x%lx)"),
    #####: 1650:				  (long int) (inf->section->filepos
    #####: 1651:					      + (vma - inf->section->vma)));
      299: 1652:      return;
        -: 1653:    }
        -: 1654:
    #####: 1655:  if (aux->reloc != NULL
    #####: 1656:      && aux->reloc->sym_ptr_ptr != NULL
    #####: 1657:      && * aux->reloc->sym_ptr_ptr != NULL)
        -: 1658:    {
    #####: 1659:      sym = * aux->reloc->sym_ptr_ptr;
        -: 1660:
        -: 1661:      /* Adjust the vma to the reloc.  */
    #####: 1662:      vma += bfd_asymbol_value (sym);
        -: 1663:
    #####: 1664:      if (bfd_is_und_section (bfd_asymbol_section (sym)))
    #####: 1665:	skip_find = true;
        -: 1666:    }
        -: 1667:
    #####: 1668:  if (!skip_find)
    #####: 1669:    sym = find_symbol_for_address (vma, inf, NULL);
        -: 1670:
    #####: 1671:  objdump_print_addr_with_sym (aux->abfd, inf->section, sym, vma, inf,
        -: 1672:			       skip_zeroes);
        -: 1673:}
        -: 1674:
        -: 1675:/* Print VMA to INFO.  This function is passed to the disassembler
        -: 1676:   routine.  */
        -: 1677:
        -: 1678:static void
      299: 1679:objdump_print_address (bfd_vma vma, struct disassemble_info *inf)
        -: 1680:{
      299: 1681:  objdump_print_addr (vma, inf, ! prefix_addresses);
      299: 1682:}
        -: 1683:
        -: 1684:/* Determine if the given address has a symbol associated with it.  */
        -: 1685:
        -: 1686:static asymbol *
    #####: 1687:objdump_symbol_at_address (bfd_vma vma, struct disassemble_info * inf)
        -: 1688:{
        -: 1689:  asymbol * sym;
        -: 1690:
    #####: 1691:  sym = find_symbol_for_address (vma, inf, NULL);
    #####: 1692:  if (sym != NULL && bfd_asymbol_value (sym) == vma)
    #####: 1693:    return sym;
        -: 1694:
    #####: 1695:  return NULL;
        -: 1696:}
        -: 1697:
        -: 1698:/* Hold the last function name and the last line number we displayed
        -: 1699:   in a disassembly.  */
        -: 1700:
        -: 1701:static char *prev_functionname;
        -: 1702:static unsigned int prev_line;
        -: 1703:static unsigned int prev_discriminator;
        -: 1704:
        -: 1705:/* We keep a list of all files that we have seen when doing a
        -: 1706:   disassembly with source, so that we know how much of the file to
        -: 1707:   display.  This can be important for inlined functions.  */
        -: 1708:
        -: 1709:struct print_file_list
        -: 1710:{
        -: 1711:  struct print_file_list *next;
        -: 1712:  const char *filename;
        -: 1713:  const char *modname;
        -: 1714:  const char *map;
        -: 1715:  size_t mapsize;
        -: 1716:  const char **linemap;
        -: 1717:  unsigned maxline;
        -: 1718:  unsigned last_line;
        -: 1719:  unsigned max_printed;
        -: 1720:  int first;
        -: 1721:};
        -: 1722:
        -: 1723:static struct print_file_list *print_files;
        -: 1724:
        -: 1725:/* The number of preceding context lines to show when we start
        -: 1726:   displaying a file for the first time.  */
        -: 1727:
        -: 1728:#define SHOW_PRECEDING_CONTEXT_LINES (5)
        -: 1729:
        -: 1730:/* Read a complete file into memory.  */
        -: 1731:
        -: 1732:static const char *
    #####: 1733:slurp_file (const char *fn, size_t *size, struct stat *fst)
        -: 1734:{
        -: 1735:#ifdef HAVE_MMAP
    #####: 1736:  int ps = getpagesize ();
        -: 1737:  size_t msize;
        -: 1738:#endif
        -: 1739:  const char *map;
    #####: 1740:  int fd = open (fn, O_RDONLY | O_BINARY);
        -: 1741:
    #####: 1742:  if (fd < 0)
    #####: 1743:    return NULL;
    #####: 1744:  if (fstat (fd, fst) < 0)
        -: 1745:    {
    #####: 1746:      close (fd);
    #####: 1747:      return NULL;
        -: 1748:    }
    #####: 1749:  *size = fst->st_size;
        -: 1750:#ifdef HAVE_MMAP
    #####: 1751:  msize = (*size + ps - 1) & ~(ps - 1);
    #####: 1752:  map = mmap (NULL, msize, PROT_READ, MAP_SHARED, fd, 0);
    #####: 1753:  if (map != (char *) -1L)
        -: 1754:    {
    #####: 1755:      close (fd);
    #####: 1756:      return map;
        -: 1757:    }
        -: 1758:#endif
    #####: 1759:  map = (const char *) malloc (*size);
    #####: 1760:  if (!map || (size_t) read (fd, (char *) map, *size) != *size)
        -: 1761:    {
    #####: 1762:      free ((void *) map);
    #####: 1763:      map = NULL;
        -: 1764:    }
    #####: 1765:  close (fd);
    #####: 1766:  return map;
        -: 1767:}
        -: 1768:
        -: 1769:#define line_map_decrease 5
        -: 1770:
        -: 1771:/* Precompute array of lines for a mapped file. */
        -: 1772:
        -: 1773:static const char **
    #####: 1774:index_file (const char *map, size_t size, unsigned int *maxline)
        -: 1775:{
        -: 1776:  const char *p, *lstart, *end;
    #####: 1777:  int chars_per_line = 45; /* First iteration will use 40.  */
        -: 1778:  unsigned int lineno;
    #####: 1779:  const char **linemap = NULL;
    #####: 1780:  unsigned long line_map_size = 0;
        -: 1781:
    #####: 1782:  lineno = 0;
    #####: 1783:  lstart = map;
    #####: 1784:  end = map + size;
        -: 1785:
    #####: 1786:  for (p = map; p < end; p++)
        -: 1787:    {
    #####: 1788:      if (*p == '\n')
        -: 1789:	{
    #####: 1790:	  if (p + 1 < end && p[1] == '\r')
    #####: 1791:	    p++;
        -: 1792:	}
    #####: 1793:      else if (*p == '\r')
        -: 1794:	{
    #####: 1795:	  if (p + 1 < end && p[1] == '\n')
    #####: 1796:	    p++;
        -: 1797:	}
        -: 1798:      else
    #####: 1799:	continue;
        -: 1800:
        -: 1801:      /* End of line found.  */
        -: 1802:
    #####: 1803:      if (linemap == NULL || line_map_size < lineno + 1)
        -: 1804:	{
        -: 1805:	  unsigned long newsize;
        -: 1806:
    #####: 1807:	  chars_per_line -= line_map_decrease;
    #####: 1808:	  if (chars_per_line <= 1)
    #####: 1809:	    chars_per_line = 1;
    #####: 1810:	  line_map_size = size / chars_per_line + 1;
    #####: 1811:	  if (line_map_size < lineno + 1)
    #####: 1812:	    line_map_size = lineno + 1;
    #####: 1813:	  newsize = line_map_size * sizeof (char *);
    #####: 1814:	  linemap = (const char **) xrealloc (linemap, newsize);
        -: 1815:	}
        -: 1816:
    #####: 1817:      linemap[lineno++] = lstart;
    #####: 1818:      lstart = p + 1;
        -: 1819:    }
        -: 1820:
    #####: 1821:  *maxline = lineno;
    #####: 1822:  return linemap;
        -: 1823:}
        -: 1824:
        -: 1825:/* Tries to open MODNAME, and if successful adds a node to print_files
        -: 1826:   linked list and returns that node.  Returns NULL on failure.  */
        -: 1827:
        -: 1828:static struct print_file_list *
    #####: 1829:try_print_file_open (const char *origname, const char *modname, struct stat *fst)
        -: 1830:{
        -: 1831:  struct print_file_list *p;
        -: 1832:
    #####: 1833:  p = (struct print_file_list *) xmalloc (sizeof (struct print_file_list));
        -: 1834:
    #####: 1835:  p->map = slurp_file (modname, &p->mapsize, fst);
    #####: 1836:  if (p->map == NULL)
        -: 1837:    {
    #####: 1838:      free (p);
    #####: 1839:      return NULL;
        -: 1840:    }
        -: 1841:
    #####: 1842:  p->linemap = index_file (p->map, p->mapsize, &p->maxline);
    #####: 1843:  p->last_line = 0;
    #####: 1844:  p->max_printed = 0;
    #####: 1845:  p->filename = origname;
    #####: 1846:  p->modname = modname;
    #####: 1847:  p->next = print_files;
    #####: 1848:  p->first = 1;
    #####: 1849:  print_files = p;
    #####: 1850:  return p;
        -: 1851:}
        -: 1852:
        -: 1853:/* If the source file, as described in the symtab, is not found
        -: 1854:   try to locate it in one of the paths specified with -I
        -: 1855:   If found, add location to print_files linked list.  */
        -: 1856:
        -: 1857:static struct print_file_list *
    #####: 1858:update_source_path (const char *filename, bfd *abfd)
        -: 1859:{
        -: 1860:  struct print_file_list *p;
        -: 1861:  const char *fname;
        -: 1862:  struct stat fst;
        -: 1863:  int i;
        -: 1864:
    #####: 1865:  p = try_print_file_open (filename, filename, &fst);
    #####: 1866:  if (p == NULL)
        -: 1867:    {
    #####: 1868:      if (include_path_count == 0)
    #####: 1869:	return NULL;
        -: 1870:
        -: 1871:      /* Get the name of the file.  */
    #####: 1872:      fname = lbasename (filename);
        -: 1873:
        -: 1874:      /* If file exists under a new path, we need to add it to the list
        -: 1875:	 so that show_line knows about it.  */
    #####: 1876:      for (i = 0; i < include_path_count; i++)
        -: 1877:	{
    #####: 1878:	  char *modname = concat (include_paths[i], "/", fname,
        -: 1879:				  (const char *) 0);
        -: 1880:
    #####: 1881:	  p = try_print_file_open (filename, modname, &fst);
    #####: 1882:	  if (p)
    #####: 1883:	    break;
        -: 1884:
    #####: 1885:	  free (modname);
        -: 1886:	}
        -: 1887:    }
        -: 1888:
    #####: 1889:  if (p != NULL)
        -: 1890:    {
    #####: 1891:      long mtime = bfd_get_mtime (abfd);
        -: 1892:
    #####: 1893:      if (fst.st_mtime > mtime)
    #####: 1894:	warn (_("source file %s is more recent than object file\n"),
        -: 1895:	      filename);
        -: 1896:    }
        -: 1897:
    #####: 1898:  return p;
        -: 1899:}
        -: 1900:
        -: 1901:/* Print a source file line.  */
        -: 1902:
        -: 1903:static void
    #####: 1904:print_line (struct print_file_list *p, unsigned int linenum)
        -: 1905:{
        -: 1906:  const char *l;
        -: 1907:  size_t len;
        -: 1908:
    #####: 1909:  --linenum;
    #####: 1910:  if (linenum >= p->maxline)
    #####: 1911:    return;
    #####: 1912:  l = p->linemap [linenum];
    #####: 1913:  if (source_comment != NULL && strlen (l) > 0)
    #####: 1914:    printf ("%s", source_comment);
    #####: 1915:  len = strcspn (l, "\n\r");
        -: 1916:  /* Test fwrite return value to quiet glibc warning.  */
    #####: 1917:  if (len == 0 || fwrite (l, len, 1, stdout) == 1)
    #####: 1918:    putchar ('\n');
        -: 1919:}
        -: 1920:
        -: 1921:/* Print a range of source code lines. */
        -: 1922:
        -: 1923:static void
    #####: 1924:dump_lines (struct print_file_list *p, unsigned int start, unsigned int end)
        -: 1925:{
    #####: 1926:  if (p->map == NULL)
    #####: 1927:    return;
    #####: 1928:  while (start <= end)
        -: 1929:    {
    #####: 1930:      print_line (p, start);
    #####: 1931:      start++;
        -: 1932:    }
        -: 1933:}
        -: 1934:
        -: 1935:/* Show the line number, or the source line, in a disassembly
        -: 1936:   listing.  */
        -: 1937:
        -: 1938:static void
     2555: 1939:show_line (bfd *abfd, asection *section, bfd_vma addr_offset)
        -: 1940:{
        -: 1941:  const char *filename;
        -: 1942:  const char *functionname;
        -: 1943:  unsigned int linenumber;
        -: 1944:  unsigned int discriminator;
        -: 1945:  bool reloc;
     2555: 1946:  char *path = NULL;
        -: 1947:
     2555: 1948:  if (! with_line_numbers && ! with_source_code)
    2555*: 1949:    return;
        -: 1950:
     2555: 1951:  if (! bfd_find_nearest_line_discriminator (abfd, section, syms, addr_offset,
        -: 1952:					     &filename, &functionname,
        -: 1953:					     &linenumber, &discriminator))
     2555: 1954:    return;
        -: 1955:
    #####: 1956:  if (filename != NULL && *filename == '\0')
    #####: 1957:    filename = NULL;
    #####: 1958:  if (functionname != NULL && *functionname == '\0')
    #####: 1959:    functionname = NULL;
        -: 1960:
    #####: 1961:  if (filename
    #####: 1962:      && IS_ABSOLUTE_PATH (filename)
    #####: 1963:      && prefix)
    #####: 1964:    {
        -: 1965:      char *path_up;
    #####: 1966:      const char *fname = filename;
        -: 1967:
    #####: 1968:      path = xmalloc (prefix_length + 1 + strlen (filename));
        -: 1969:
    #####: 1970:      if (prefix_length)
    #####: 1971:	memcpy (path, prefix, prefix_length);
    #####: 1972:      path_up = path + prefix_length;
        -: 1973:
        -: 1974:      /* Build relocated filename, stripping off leading directories
        -: 1975:	 from the initial filename if requested.  */
    #####: 1976:      if (prefix_strip > 0)
        -: 1977:	{
    #####: 1978:	  int level = 0;
        -: 1979:	  const char *s;
        -: 1980:
        -: 1981:	  /* Skip selected directory levels.  */
    #####: 1982:	  for (s = fname + 1; *s != '\0' && level < prefix_strip; s++)
    #####: 1983:	    if (IS_DIR_SEPARATOR (*s))
        -: 1984:	      {
    #####: 1985:		fname = s;
    #####: 1986:		level++;
        -: 1987:	      }
        -: 1988:	}
        -: 1989:
        -: 1990:      /* Update complete filename.  */
    #####: 1991:      strcpy (path_up, fname);
        -: 1992:
    #####: 1993:      filename = path;
    #####: 1994:      reloc = true;
        -: 1995:    }
        -: 1996:  else
    #####: 1997:    reloc = false;
        -: 1998:
    #####: 1999:  if (with_line_numbers)
        -: 2000:    {
    #####: 2001:      if (functionname != NULL
    #####: 2002:	  && (prev_functionname == NULL
    #####: 2003:	      || strcmp (functionname, prev_functionname) != 0))
        -: 2004:	{
    #####: 2005:	  char *demangle_alloc = NULL;
    #####: 2006:	  if (do_demangle && functionname[0] != '\0')
        -: 2007:	    {
        -: 2008:	      /* Demangle the name.  */
    #####: 2009:	      demangle_alloc = bfd_demangle (abfd, functionname,
        -: 2010:					     demangle_flags);
        -: 2011:	    }
        -: 2012:
        -: 2013:	  /* Demangling adds trailing parens, so don't print those.  */
    #####: 2014:	  if (demangle_alloc != NULL)
    #####: 2015:	    printf ("%s:\n", sanitize_string (demangle_alloc));
        -: 2016:	  else
    #####: 2017:	    printf ("%s():\n", sanitize_string (functionname));
        -: 2018:
    #####: 2019:	  prev_line = -1;
    #####: 2020:	  free (demangle_alloc);
        -: 2021:	}
    #####: 2022:      if (linenumber > 0
    #####: 2023:	  && (linenumber != prev_line
    #####: 2024:	      || discriminator != prev_discriminator))
        -: 2025:	{
    #####: 2026:	  if (discriminator > 0)
    #####: 2027:	    printf ("%s:%u (discriminator %u)\n",
    #####: 2028:		    filename == NULL ? "???" : sanitize_string (filename),
        -: 2029:		    linenumber, discriminator);
        -: 2030:	  else
    #####: 2031:	    printf ("%s:%u\n", filename == NULL
    #####: 2032:		    ? "???" : sanitize_string (filename),
        -: 2033:		    linenumber);
        -: 2034:	}
    #####: 2035:      if (unwind_inlines)
        -: 2036:	{
        -: 2037:	  const char *filename2;
        -: 2038:	  const char *functionname2;
        -: 2039:	  unsigned line2;
        -: 2040:
    #####: 2041:	  while (bfd_find_inliner_info (abfd, &filename2, &functionname2,
        -: 2042:					&line2))
        -: 2043:	    {
    #####: 2044:	      printf ("inlined by %s:%u",
        -: 2045:		      sanitize_string (filename2), line2);
    #####: 2046:	      printf (" (%s)\n", sanitize_string (functionname2));
        -: 2047:	    }
        -: 2048:	}
        -: 2049:    }
        -: 2050:
    #####: 2051:  if (with_source_code
    #####: 2052:      && filename != NULL
    #####: 2053:      && linenumber > 0)
        -: 2054:    {
        -: 2055:      struct print_file_list **pp, *p;
        -: 2056:      unsigned l;
        -: 2057:
    #####: 2058:      for (pp = &print_files; *pp != NULL; pp = &(*pp)->next)
    #####: 2059:	if (filename_cmp ((*pp)->filename, filename) == 0)
    #####: 2060:	  break;
    #####: 2061:      p = *pp;
        -: 2062:
    #####: 2063:      if (p == NULL)
        -: 2064:	{
    #####: 2065:	  if (reloc)
    #####: 2066:	    filename = xstrdup (filename);
    #####: 2067:	  p = update_source_path (filename, abfd);
        -: 2068:	}
        -: 2069:
    #####: 2070:      if (p != NULL && linenumber != p->last_line)
        -: 2071:	{
    #####: 2072:	  if (file_start_context && p->first)
    #####: 2073:	    l = 1;
        -: 2074:	  else
        -: 2075:	    {
    #####: 2076:	      l = linenumber - SHOW_PRECEDING_CONTEXT_LINES;
    #####: 2077:	      if (l >= linenumber)
    #####: 2078:		l = 1;
    #####: 2079:	      if (p->max_printed >= l)
        -: 2080:		{
    #####: 2081:		  if (p->max_printed < linenumber)
    #####: 2082:		    l = p->max_printed + 1;
        -: 2083:		  else
    #####: 2084:		    l = linenumber;
        -: 2085:		}
        -: 2086:	    }
    #####: 2087:	  dump_lines (p, l, linenumber);
    #####: 2088:	  if (p->max_printed < linenumber)
    #####: 2089:	    p->max_printed = linenumber;
    #####: 2090:	  p->last_line = linenumber;
    #####: 2091:	  p->first = 0;
        -: 2092:	}
        -: 2093:    }
        -: 2094:
    #####: 2095:  if (functionname != NULL
    #####: 2096:      && (prev_functionname == NULL
    #####: 2097:	  || strcmp (functionname, prev_functionname) != 0))
        -: 2098:    {
    #####: 2099:      if (prev_functionname != NULL)
    #####: 2100:	free (prev_functionname);
    #####: 2101:      prev_functionname = (char *) xmalloc (strlen (functionname) + 1);
    #####: 2102:      strcpy (prev_functionname, functionname);
        -: 2103:    }
        -: 2104:
    #####: 2105:  if (linenumber > 0 && linenumber != prev_line)
    #####: 2106:    prev_line = linenumber;
        -: 2107:
    #####: 2108:  if (discriminator != prev_discriminator)
    #####: 2109:    prev_discriminator = discriminator;
        -: 2110:
    #####: 2111:  if (path)
    #####: 2112:    free (path);
        -: 2113:}
        -: 2114:
        -: 2115:/* Pseudo FILE object for strings.  */
        -: 2116:typedef struct
        -: 2117:{
        -: 2118:  char *buffer;
        -: 2119:  size_t pos;
        -: 2120:  size_t alloc;
        -: 2121:} SFILE;
        -: 2122:
        -: 2123:/* sprintf to a "stream".  */
        -: 2124:
        -: 2125:static int ATTRIBUTE_PRINTF_2
    #####: 2126:objdump_sprintf (SFILE *f, const char *format, ...)
        -: 2127:{
        -: 2128:  size_t n;
        -: 2129:  va_list args;
        -: 2130:
        -: 2131:  while (1)
    #####: 2132:    {
    #####: 2133:      size_t space = f->alloc - f->pos;
        -: 2134:
    #####: 2135:      va_start (args, format);
    #####: 2136:      n = vsnprintf (f->buffer + f->pos, space, format, args);
    #####: 2137:      va_end (args);
        -: 2138:
    #####: 2139:      if (space > n)
    #####: 2140:	break;
        -: 2141:
    #####: 2142:      f->alloc = (f->alloc + n) * 2;
    #####: 2143:      f->buffer = (char *) xrealloc (f->buffer, f->alloc);
        -: 2144:    }
    #####: 2145:  f->pos += n;
        -: 2146:
    #####: 2147:  return n;
        -: 2148:}
        -: 2149:
        -: 2150:/* Return an integer greater than, or equal to zero, representing the color
        -: 2151:   for STYLE, or -1 if no color should be used.  */
        -: 2152:
        -: 2153:static int
    14842: 2154:objdump_color_for_disassembler_style (enum disassembler_style style)
        -: 2155:{
    14842: 2156:  int color = -1;
        -: 2157:
    14842: 2158:  if (style == dis_style_comment_start)
    #####: 2159:    disassembler_in_comment = true;
        -: 2160:
    14842: 2161:  if (disassembler_color)
        -: 2162:    {
    #####: 2163:      if (disassembler_in_comment)
    #####: 2164:	return color;
        -: 2165:
    #####: 2166:      switch (style)
        -: 2167:	{
    #####: 2168:	case dis_style_symbol: color = 32; break;
    #####: 2169:        case dis_style_assembler_directive:
    #####: 2170:	case dis_style_mnemonic: color = 33; break;
    #####: 2171:	case dis_style_register: color = 34; break;
    #####: 2172:	case dis_style_address:
        -: 2173:        case dis_style_address_offset:
    #####: 2174:	case dis_style_immediate: color = 35; break;
    #####: 2175:	default:
    #####: 2176:	case dis_style_text: color = -1; break;
        -: 2177:	}
        -: 2178:    }
    14842: 2179:  else if (disassembler_extended_color)
        -: 2180:    {
    #####: 2181:      if (disassembler_in_comment)
    #####: 2182:	return 250;
        -: 2183:
    #####: 2184:      switch (style)
        -: 2185:	{
    #####: 2186:	case dis_style_symbol: color = 40; break;
    #####: 2187:        case dis_style_assembler_directive:
    #####: 2188:	case dis_style_mnemonic: color = 142; break;
    #####: 2189:	case dis_style_register: color = 27; break;
    #####: 2190:	case dis_style_address:
        -: 2191:        case dis_style_address_offset:
    #####: 2192:	case dis_style_immediate: color = 134; break;
    #####: 2193:	default:
    #####: 2194:	case dis_style_text: color = -1; break;
        -: 2195:	}
    14842: 2196:    }
        -: 2197:
    14842: 2198:  return color;
        -: 2199:}
        -: 2200:
        -: 2201:/* Like objdump_sprintf, but add in escape sequences to highlight the
        -: 2202:   content according to STYLE.  */
        -: 2203:
        -: 2204:static int ATTRIBUTE_PRINTF_3
    14842: 2205:objdump_styled_sprintf (SFILE *f, enum disassembler_style style,
        -: 2206:			const char *format, ...)
        -: 2207:{
        -: 2208:  size_t n;
        -: 2209:  va_list args;
    14842: 2210:  int color = objdump_color_for_disassembler_style (style);
        -: 2211:
    14842: 2212:  if (color >= 0)
        -: 2213:    {
        -: 2214:      while (1)
    #####: 2215:	{
    #####: 2216:	  size_t space = f->alloc - f->pos;
        -: 2217:
    #####: 2218:	  if (disassembler_color)
    #####: 2219:	    n = snprintf (f->buffer + f->pos, space, "\033[%dm", color);
        -: 2220:	  else
    #####: 2221:	    n = snprintf (f->buffer + f->pos, space, "\033[38;5;%dm", color);
    #####: 2222:	  if (space > n)
    #####: 2223:	    break;
        -: 2224:
    #####: 2225:	  f->alloc = (f->alloc + n) * 2;
    #####: 2226:	  f->buffer = (char *) xrealloc (f->buffer, f->alloc);
        -: 2227:	}
    #####: 2228:      f->pos += n;
        -: 2229:    }
        -: 2230:
        -: 2231:  while (1)
    #####: 2232:    {
    14842: 2233:      size_t space = f->alloc - f->pos;
        -: 2234:
    14842: 2235:      va_start (args, format);
    14842: 2236:      n = vsnprintf (f->buffer + f->pos, space, format, args);
    14842: 2237:      va_end (args);
        -: 2238:
    14842: 2239:      if (space > n)
    14842: 2240:	break;
        -: 2241:
    #####: 2242:      f->alloc = (f->alloc + n) * 2;
    #####: 2243:      f->buffer = (char *) xrealloc (f->buffer, f->alloc);
        -: 2244:    }
    14842: 2245:  f->pos += n;
        -: 2246:
    14842: 2247:  if (color >= 0)
        -: 2248:    {
        -: 2249:      while (1)
    #####: 2250:	{
    #####: 2251:	  size_t space = f->alloc - f->pos;
        -: 2252:
    #####: 2253:	  n = snprintf (f->buffer + f->pos, space, "\033[0m");
        -: 2254:
    #####: 2255:	  if (space > n)
    #####: 2256:	    break;
        -: 2257:
    #####: 2258:	  f->alloc = (f->alloc + n) * 2;
    #####: 2259:	  f->buffer = (char *) xrealloc (f->buffer, f->alloc);
        -: 2260:	}
    #####: 2261:      f->pos += n;
        -: 2262:    }
        -: 2263:
    14842: 2264:  return n;
        -: 2265:}
        -: 2266:
        -: 2267:/* We discard the styling information here.  This function is only used
        -: 2268:   when objdump is printing auxiliary information, the symbol headers, and
        -: 2269:   disassembly address, or the bytes of the disassembled instruction.  We
        -: 2270:   don't (currently) apply styling to any of this stuff, so, for now, just
        -: 2271:   print the content with no additional style added.  */
        -: 2272:
        -: 2273:static int ATTRIBUTE_PRINTF_3
     2175: 2274:fprintf_styled (FILE *f, enum disassembler_style style ATTRIBUTE_UNUSED,
        -: 2275:		const char *fmt, ...)
        -: 2276:{
        -: 2277:  int res;
        -: 2278:  va_list ap;
        -: 2279:
     2175: 2280:  va_start (ap, fmt);
     2175: 2281:  res = vfprintf (f, fmt, ap);
     2175: 2282:  va_end (ap);
        -: 2283:
     2175: 2284:  return res;
        -: 2285:}
        -: 2286:
        -: 2287:/* Code for generating (colored) diagrams of control flow start and end
        -: 2288:   points.  */
        -: 2289:
        -: 2290:/* Structure used to store the properties of a jump.  */
        -: 2291:
        -: 2292:struct jump_info
        -: 2293:{
        -: 2294:  /* The next jump, or NULL if this is the last object.  */
        -: 2295:  struct jump_info *next;
        -: 2296:  /* The previous jump, or NULL if this is the first object.  */
        -: 2297:  struct jump_info *prev;
        -: 2298:  /* The start addresses of the jump.  */
        -: 2299:  struct
        -: 2300:    {
        -: 2301:      /* The list of start addresses.  */
        -: 2302:      bfd_vma *addresses;
        -: 2303:      /* The number of elements.  */
        -: 2304:      size_t count;
        -: 2305:      /* The maximum number of elements that fit into the array.  */
        -: 2306:      size_t max_count;
        -: 2307:    } start;
        -: 2308:  /* The end address of the jump.  */
        -: 2309:  bfd_vma end;
        -: 2310:  /* The drawing level of the jump.  */
        -: 2311:  int level;
        -: 2312:};
        -: 2313:
        -: 2314:/* Construct a jump object for a jump from start
        -: 2315:   to end with the corresponding level.  */
        -: 2316:
        -: 2317:static struct jump_info *
    #####: 2318:jump_info_new (bfd_vma start, bfd_vma end, int level)
        -: 2319:{
    #####: 2320:  struct jump_info *result = xmalloc (sizeof (struct jump_info));
        -: 2321:
    #####: 2322:  result->next = NULL;
    #####: 2323:  result->prev = NULL;
    #####: 2324:  result->start.addresses = xmalloc (sizeof (bfd_vma *) * 2);
    #####: 2325:  result->start.addresses[0] = start;
    #####: 2326:  result->start.count = 1;
    #####: 2327:  result->start.max_count = 2;
    #####: 2328:  result->end = end;
    #####: 2329:  result->level = level;
        -: 2330:
    #####: 2331:  return result;
        -: 2332:}
        -: 2333:
        -: 2334:/* Free a jump object and return the next object
        -: 2335:   or NULL if this was the last one.  */
        -: 2336:
        -: 2337:static struct jump_info *
    #####: 2338:jump_info_free (struct jump_info *ji)
        -: 2339:{
    #####: 2340:  struct jump_info *result = NULL;
        -: 2341:
    #####: 2342:  if (ji)
        -: 2343:    {
    #####: 2344:      result = ji->next;
    #####: 2345:      if (ji->start.addresses)
    #####: 2346:	free (ji->start.addresses);
    #####: 2347:      free (ji);
        -: 2348:    }
        -: 2349:
    #####: 2350:  return result;
        -: 2351:}
        -: 2352:
        -: 2353:/* Get the smallest value of all start and end addresses.  */
        -: 2354:
        -: 2355:static bfd_vma
    #####: 2356:jump_info_min_address (const struct jump_info *ji)
        -: 2357:{
    #####: 2358:  bfd_vma min_address = ji->end;
        -: 2359:  size_t i;
        -: 2360:
    #####: 2361:  for (i = ji->start.count; i-- > 0;)
    #####: 2362:    if (ji->start.addresses[i] < min_address)
    #####: 2363:      min_address = ji->start.addresses[i];
    #####: 2364:  return min_address;
        -: 2365:}
        -: 2366:
        -: 2367:/* Get the largest value of all start and end addresses.  */
        -: 2368:
        -: 2369:static bfd_vma
    #####: 2370:jump_info_max_address (const struct jump_info *ji)
        -: 2371:{
    #####: 2372:  bfd_vma max_address = ji->end;
        -: 2373:  size_t i;
        -: 2374:
    #####: 2375:  for (i = ji->start.count; i-- > 0;)
    #####: 2376:    if (ji->start.addresses[i] > max_address)
    #####: 2377:      max_address = ji->start.addresses[i];
    #####: 2378:  return max_address;
        -: 2379:}
        -: 2380:
        -: 2381:/* Get the target address of a jump.  */
        -: 2382:
        -: 2383:static bfd_vma
    #####: 2384:jump_info_end_address (const struct jump_info *ji)
        -: 2385:{
    #####: 2386:  return ji->end;
        -: 2387:}
        -: 2388:
        -: 2389:/* Test if an address is one of the start addresses of a jump.  */
        -: 2390:
        -: 2391:static bool
    #####: 2392:jump_info_is_start_address (const struct jump_info *ji, bfd_vma address)
        -: 2393:{
    #####: 2394:  bool result = false;
        -: 2395:  size_t i;
        -: 2396:
    #####: 2397:  for (i = ji->start.count; i-- > 0;)
    #####: 2398:    if (address == ji->start.addresses[i])
        -: 2399:      {
    #####: 2400:	result = true;
    #####: 2401:	break;
        -: 2402:      }
        -: 2403:
    #####: 2404:  return result;
        -: 2405:}
        -: 2406:
        -: 2407:/* Test if an address is the target address of a jump.  */
        -: 2408:
        -: 2409:static bool
    #####: 2410:jump_info_is_end_address (const struct jump_info *ji, bfd_vma address)
        -: 2411:{
    #####: 2412:  return (address == ji->end);
        -: 2413:}
        -: 2414:
        -: 2415:/* Get the difference between the smallest and largest address of a jump.  */
        -: 2416:
        -: 2417:static bfd_vma
    #####: 2418:jump_info_size (const struct jump_info *ji)
        -: 2419:{
    #####: 2420:  return jump_info_max_address (ji) - jump_info_min_address (ji);
        -: 2421:}
        -: 2422:
        -: 2423:/* Unlink a jump object from a list.  */
        -: 2424:
        -: 2425:static void
    #####: 2426:jump_info_unlink (struct jump_info *node,
        -: 2427:		  struct jump_info **base)
        -: 2428:{
    #####: 2429:  if (node->next)
    #####: 2430:    node->next->prev = node->prev;
    #####: 2431:  if (node->prev)
    #####: 2432:    node->prev->next = node->next;
        -: 2433:  else
    #####: 2434:    *base = node->next;
    #####: 2435:  node->next = NULL;
    #####: 2436:  node->prev = NULL;
    #####: 2437:}
        -: 2438:
        -: 2439:/* Insert unlinked jump info node into a list.  */
        -: 2440:
        -: 2441:static void
    #####: 2442:jump_info_insert (struct jump_info *node,
        -: 2443:		  struct jump_info *target,
        -: 2444:		  struct jump_info **base)
        -: 2445:{
    #####: 2446:  node->next = target;
    #####: 2447:  node->prev = target->prev;
    #####: 2448:  target->prev = node;
    #####: 2449:  if (node->prev)
    #####: 2450:    node->prev->next = node;
        -: 2451:  else
    #####: 2452:    *base = node;
    #####: 2453:}
        -: 2454:
        -: 2455:/* Add unlinked node to the front of a list.  */
        -: 2456:
        -: 2457:static void
    #####: 2458:jump_info_add_front (struct jump_info *node,
        -: 2459:		     struct jump_info **base)
        -: 2460:{
    #####: 2461:  node->next = *base;
    #####: 2462:  if (node->next)
    #####: 2463:    node->next->prev = node;
    #####: 2464:  node->prev = NULL;
    #####: 2465:  *base = node;
    #####: 2466:}
        -: 2467:
        -: 2468:/* Move linked node to target position.  */
        -: 2469:
        -: 2470:static void
    #####: 2471:jump_info_move_linked (struct jump_info *node,
        -: 2472:		       struct jump_info *target,
        -: 2473:		       struct jump_info **base)
        -: 2474:{
        -: 2475:  /* Unlink node.  */
    #####: 2476:  jump_info_unlink (node, base);
        -: 2477:  /* Insert node at target position.  */
    #####: 2478:  jump_info_insert (node, target, base);
    #####: 2479:}
        -: 2480:
        -: 2481:/* Test if two jumps intersect.  */
        -: 2482:
        -: 2483:static bool
    #####: 2484:jump_info_intersect (const struct jump_info *a,
        -: 2485:		     const struct jump_info *b)
        -: 2486:{
    #####: 2487:  return ((jump_info_max_address (a) >= jump_info_min_address (b))
    #####: 2488:	  && (jump_info_min_address (a) <= jump_info_max_address (b)));
        -: 2489:}
        -: 2490:
        -: 2491:/* Merge two compatible jump info objects.  */
        -: 2492:
        -: 2493:static void
    #####: 2494:jump_info_merge (struct jump_info **base)
        -: 2495:{
        -: 2496:  struct jump_info *a;
        -: 2497:
    #####: 2498:  for (a = *base; a; a = a->next)
        -: 2499:    {
        -: 2500:      struct jump_info *b;
        -: 2501:
    #####: 2502:      for (b = a->next; b; b = b->next)
        -: 2503:	{
        -: 2504:	  /* Merge both jumps into one.  */
    #####: 2505:	  if (a->end == b->end)
        -: 2506:	    {
        -: 2507:	      /* Reallocate addresses.  */
    #####: 2508:	      size_t needed_size = a->start.count + b->start.count;
        -: 2509:	      size_t i;
        -: 2510:
    #####: 2511:	      if (needed_size > a->start.max_count)
        -: 2512:		{
    #####: 2513:		  a->start.max_count += b->start.max_count;
    #####: 2514:		  a->start.addresses =
    #####: 2515:		    xrealloc (a->start.addresses,
    #####: 2516:			      a->start.max_count * sizeof (bfd_vma *));
        -: 2517:		}
        -: 2518:
        -: 2519:	      /* Append start addresses.  */
    #####: 2520:	      for (i = 0; i < b->start.count; ++i)
    #####: 2521:		a->start.addresses[a->start.count++] =
    #####: 2522:		  b->start.addresses[i];
        -: 2523:
        -: 2524:	      /* Remove and delete jump.  */
    #####: 2525:	      struct jump_info *tmp = b->prev;
    #####: 2526:	      jump_info_unlink (b, base);
    #####: 2527:	      jump_info_free (b);
    #####: 2528:	      b = tmp;
        -: 2529:	    }
        -: 2530:	}
        -: 2531:    }
    #####: 2532:}
        -: 2533:
        -: 2534:/* Sort jumps by their size and starting point using a stable
        -: 2535:   minsort. This could be improved if sorting performance is
        -: 2536:   an issue, for example by using mergesort.  */
        -: 2537:
        -: 2538:static void
    #####: 2539:jump_info_sort (struct jump_info **base)
        -: 2540:{
    #####: 2541:  struct jump_info *current_element = *base;
        -: 2542:
    #####: 2543:  while (current_element)
        -: 2544:    {
    #####: 2545:      struct jump_info *best_match = current_element;
    #####: 2546:      struct jump_info *runner = current_element->next;
    #####: 2547:      bfd_vma best_size = jump_info_size (best_match);
        -: 2548:
    #####: 2549:      while (runner)
        -: 2550:	{
    #####: 2551:	  bfd_vma runner_size = jump_info_size (runner);
        -: 2552:
    #####: 2553:	  if ((runner_size < best_size)
    #####: 2554:	      || ((runner_size == best_size)
    #####: 2555:		  && (jump_info_min_address (runner)
    #####: 2556:		      < jump_info_min_address (best_match))))
        -: 2557:	    {
    #####: 2558:	      best_match = runner;
    #####: 2559:	      best_size = runner_size;
        -: 2560:	    }
        -: 2561:
    #####: 2562:	  runner = runner->next;
        -: 2563:	}
        -: 2564:
    #####: 2565:      if (best_match == current_element)
    #####: 2566:	current_element = current_element->next;
        -: 2567:      else
    #####: 2568:	jump_info_move_linked (best_match, current_element, base);
        -: 2569:    }
    #####: 2570:}
        -: 2571:
        -: 2572:/* Visualize all jumps at a given address.  */
        -: 2573:
        -: 2574:static void
    #####: 2575:jump_info_visualize_address (bfd_vma address,
        -: 2576:			     int max_level,
        -: 2577:			     char *line_buffer,
        -: 2578:			     uint8_t *color_buffer)
        -: 2579:{
    #####: 2580:  struct jump_info *ji = detected_jumps;
    #####: 2581:  size_t len = (max_level + 1) * 3;
        -: 2582:
        -: 2583:  /* Clear line buffer.  */
    #####: 2584:  memset (line_buffer, ' ', len);
    #####: 2585:  memset (color_buffer, 0, len);
        -: 2586:
        -: 2587:  /* Iterate over jumps and add their ASCII art.  */
    #####: 2588:  while (ji)
        -: 2589:    {
        -: 2590:      /* Discard jumps that are never needed again.  */
    #####: 2591:      if (jump_info_max_address (ji) < address)
        -: 2592:	{
    #####: 2593:	  struct jump_info *tmp = ji;
        -: 2594:
    #####: 2595:	  ji = ji->next;
    #####: 2596:	  jump_info_unlink (tmp, &detected_jumps);
    #####: 2597:	  jump_info_free (tmp);
    #####: 2598:	  continue;
        -: 2599:	}
        -: 2600:
        -: 2601:      /* This jump intersects with the current address.  */
    #####: 2602:      if (jump_info_min_address (ji) <= address)
        -: 2603:	{
        -: 2604:	  /* Hash target address to get an even
        -: 2605:	     distribution between all values.  */
    #####: 2606:	  bfd_vma hash_address = jump_info_end_address (ji);
    #####: 2607:	  uint8_t color = iterative_hash_object (hash_address, 0);
        -: 2608:	  /* Fetch line offset.  */
    #####: 2609:	  int offset = (max_level - ji->level) * 3;
        -: 2610:
        -: 2611:	  /* Draw start line.  */
    #####: 2612:	  if (jump_info_is_start_address (ji, address))
        -: 2613:	    {
    #####: 2614:	      size_t i = offset + 1;
        -: 2615:
    #####: 2616:	      for (; i < len - 1; ++i)
    #####: 2617:		if (line_buffer[i] == ' ')
        -: 2618:		  {
    #####: 2619:		    line_buffer[i] = '-';
    #####: 2620:		    color_buffer[i] = color;
        -: 2621:		  }
        -: 2622:
    #####: 2623:	      if (line_buffer[i] == ' ')
        -: 2624:		{
    #####: 2625:		  line_buffer[i] = '-';
    #####: 2626:		  color_buffer[i] = color;
        -: 2627:		}
    #####: 2628:	      else if (line_buffer[i] == '>')
        -: 2629:		{
    #####: 2630:		  line_buffer[i] = 'X';
    #####: 2631:		  color_buffer[i] = color;
        -: 2632:		}
        -: 2633:
    #####: 2634:	      if (line_buffer[offset] == ' ')
        -: 2635:		{
    #####: 2636:		  if (address <= ji->end)
    #####: 2637:		    line_buffer[offset] =
    #####: 2638:		      (jump_info_min_address (ji) == address) ? '/': '+';
        -: 2639:		  else
    #####: 2640:		    line_buffer[offset] =
    #####: 2641:		      (jump_info_max_address (ji) == address) ? '\\': '+';
    #####: 2642:		  color_buffer[offset] = color;
        -: 2643:		}
        -: 2644:	    }
        -: 2645:	  /* Draw jump target.  */
    #####: 2646:	  else if (jump_info_is_end_address (ji, address))
        -: 2647:	    {
    #####: 2648:	      size_t i = offset + 1;
        -: 2649:
    #####: 2650:	      for (; i < len - 1; ++i)
    #####: 2651:		if (line_buffer[i] == ' ')
        -: 2652:		  {
    #####: 2653:		    line_buffer[i] = '-';
    #####: 2654:		    color_buffer[i] = color;
        -: 2655:		  }
        -: 2656:
    #####: 2657:	      if (line_buffer[i] == ' ')
        -: 2658:		{
    #####: 2659:		  line_buffer[i] = '>';
    #####: 2660:		  color_buffer[i] = color;
        -: 2661:		}
    #####: 2662:	      else if (line_buffer[i] == '-')
        -: 2663:		{
    #####: 2664:		  line_buffer[i] = 'X';
    #####: 2665:		  color_buffer[i] = color;
        -: 2666:		}
        -: 2667:
    #####: 2668:	      if (line_buffer[offset] == ' ')
        -: 2669:		{
    #####: 2670:		  if (jump_info_min_address (ji) < address)
    #####: 2671:		    line_buffer[offset] =
    #####: 2672:		      (jump_info_max_address (ji) > address) ? '>' : '\\';
        -: 2673:		  else
    #####: 2674:		    line_buffer[offset] = '/';
    #####: 2675:		  color_buffer[offset] = color;
        -: 2676:		}
        -: 2677:	    }
        -: 2678:	  /* Draw intermediate line segment.  */
    #####: 2679:	  else if (line_buffer[offset] == ' ')
        -: 2680:	    {
    #####: 2681:	      line_buffer[offset] = '|';
    #####: 2682:	      color_buffer[offset] = color;
        -: 2683:	    }
        -: 2684:	}
        -: 2685:
    #####: 2686:      ji = ji->next;
        -: 2687:    }
    #####: 2688:}
        -: 2689:
        -: 2690:/* Clone of disassemble_bytes to detect jumps inside a function.  */
        -: 2691:/* FIXME: is this correct? Can we strip it down even further?  */
        -: 2692:
        -: 2693:static struct jump_info *
    #####: 2694:disassemble_jumps (struct disassemble_info * inf,
        -: 2695:		   disassembler_ftype        disassemble_fn,
        -: 2696:		   bfd_vma                   start_offset,
        -: 2697:		   bfd_vma                   stop_offset,
        -: 2698:		   bfd_vma		     rel_offset,
        -: 2699:		   arelent ***               relppp,
        -: 2700:		   arelent **                relppend)
        -: 2701:{
        -: 2702:  struct objdump_disasm_info *aux;
    #####: 2703:  struct jump_info *jumps = NULL;
        -: 2704:  asection *section;
        -: 2705:  bfd_vma addr_offset;
    #####: 2706:  unsigned int opb = inf->octets_per_byte;
    #####: 2707:  int octets = opb;
        -: 2708:  SFILE sfile;
        -: 2709:
    #####: 2710:  aux = (struct objdump_disasm_info *) inf->application_data;
    #####: 2711:  section = inf->section;
        -: 2712:
    #####: 2713:  sfile.alloc = 120;
    #####: 2714:  sfile.buffer = (char *) xmalloc (sfile.alloc);
    #####: 2715:  sfile.pos = 0;
        -: 2716:
    #####: 2717:  inf->insn_info_valid = 0;
    #####: 2718:  disassemble_set_printf (inf, &sfile, (fprintf_ftype) objdump_sprintf,
        -: 2719:			  (fprintf_styled_ftype) objdump_styled_sprintf);
        -: 2720:
    #####: 2721:  addr_offset = start_offset;
    #####: 2722:  while (addr_offset < stop_offset)
        -: 2723:    {
        -: 2724:      int previous_octets;
        -: 2725:
        -: 2726:      /* Remember the length of the previous instruction.  */
    #####: 2727:      previous_octets = octets;
    #####: 2728:      octets = 0;
        -: 2729:
    #####: 2730:      sfile.pos = 0;
    #####: 2731:      inf->bytes_per_line = 0;
    #####: 2732:      inf->bytes_per_chunk = 0;
    #####: 2733:      inf->flags = ((disassemble_all ? DISASSEMBLE_DATA : 0)
    #####: 2734:		    | (wide_output ? WIDE_OUTPUT : 0));
    #####: 2735:      if (machine)
    #####: 2736:	inf->flags |= USER_SPECIFIED_MACHINE_TYPE;
        -: 2737:
    #####: 2738:      if (inf->disassembler_needs_relocs
    #####: 2739:	  && (bfd_get_file_flags (aux->abfd) & EXEC_P) == 0
    #####: 2740:	  && (bfd_get_file_flags (aux->abfd) & DYNAMIC) == 0
    #####: 2741:	  && *relppp < relppend)
        -: 2742:	{
        -: 2743:	  bfd_signed_vma distance_to_rel;
        -: 2744:
    #####: 2745:	  distance_to_rel = (**relppp)->address - (rel_offset + addr_offset);
        -: 2746:
        -: 2747:	  /* Check to see if the current reloc is associated with
        -: 2748:	     the instruction that we are about to disassemble.  */
    #####: 2749:	  if (distance_to_rel == 0
        -: 2750:	      /* FIXME: This is wrong.  We are trying to catch
        -: 2751:		 relocs that are addressed part way through the
        -: 2752:		 current instruction, as might happen with a packed
        -: 2753:		 VLIW instruction.  Unfortunately we do not know the
        -: 2754:		 length of the current instruction since we have not
        -: 2755:		 disassembled it yet.  Instead we take a guess based
        -: 2756:		 upon the length of the previous instruction.  The
        -: 2757:		 proper solution is to have a new target-specific
        -: 2758:		 disassembler function which just returns the length
        -: 2759:		 of an instruction at a given address without trying
        -: 2760:		 to display its disassembly. */
    #####: 2761:	      || (distance_to_rel > 0
    #####: 2762:		&& distance_to_rel < (bfd_signed_vma) (previous_octets/ opb)))
        -: 2763:	    {
    #####: 2764:	      inf->flags |= INSN_HAS_RELOC;
        -: 2765:	    }
        -: 2766:	}
        -: 2767:
    #####: 2768:      if (! disassemble_all
    #####: 2769:	  && (section->flags & (SEC_CODE | SEC_HAS_CONTENTS))
        -: 2770:	  == (SEC_CODE | SEC_HAS_CONTENTS))
        -: 2771:	/* Set a stop_vma so that the disassembler will not read
        -: 2772:	   beyond the next symbol.  We assume that symbols appear on
        -: 2773:	   the boundaries between instructions.  We only do this when
        -: 2774:	   disassembling code of course, and when -D is in effect.  */
    #####: 2775:	inf->stop_vma = section->vma + stop_offset;
        -: 2776:
    #####: 2777:      inf->stop_offset = stop_offset;
        -: 2778:
        -: 2779:      /* Extract jump information.  */
    #####: 2780:      inf->insn_info_valid = 0;
    #####: 2781:      disassembler_in_comment = false;
    #####: 2782:      octets = (*disassemble_fn) (section->vma + addr_offset, inf);
        -: 2783:      /* Test if a jump was detected.  */
    #####: 2784:      if (inf->insn_info_valid
    #####: 2785:	  && ((inf->insn_type == dis_branch)
    #####: 2786:	      || (inf->insn_type == dis_condbranch)
    #####: 2787:	      || (inf->insn_type == dis_jsr)
    #####: 2788:	      || (inf->insn_type == dis_condjsr))
    #####: 2789:	  && (inf->target >= section->vma + start_offset)
    #####: 2790:	  && (inf->target < section->vma + stop_offset))
        -: 2791:	{
        -: 2792:	  struct jump_info *ji =
    #####: 2793:	    jump_info_new (section->vma + addr_offset, inf->target, -1);
    #####: 2794:	  jump_info_add_front (ji, &jumps);
        -: 2795:	}
        -: 2796:
    #####: 2797:      inf->stop_vma = 0;
        -: 2798:
    #####: 2799:      addr_offset += octets / opb;
        -: 2800:    }
        -: 2801:
    #####: 2802:  disassemble_set_printf (inf, (void *) stdout, (fprintf_ftype) fprintf,
        -: 2803:			  (fprintf_styled_ftype) fprintf_styled);
    #####: 2804:  free (sfile.buffer);
        -: 2805:
        -: 2806:  /* Merge jumps.  */
    #####: 2807:  jump_info_merge (&jumps);
        -: 2808:  /* Process jumps.  */
    #####: 2809:  jump_info_sort (&jumps);
        -: 2810:
        -: 2811:  /* Group jumps by level.  */
    #####: 2812:  struct jump_info *last_jump = jumps;
    #####: 2813:  int max_level = -1;
        -: 2814:
    #####: 2815:  while (last_jump)
        -: 2816:    {
        -: 2817:      /* The last jump is part of the next group.  */
    #####: 2818:      struct jump_info *base = last_jump;
        -: 2819:      /* Increment level.  */
    #####: 2820:      base->level = ++max_level;
        -: 2821:
        -: 2822:      /* Find jumps that can be combined on the same
        -: 2823:	 level, with the largest jumps tested first.
        -: 2824:	 This has the advantage that large jumps are on
        -: 2825:	 lower levels and do not intersect with small
        -: 2826:	 jumps that get grouped on higher levels.  */
    #####: 2827:      struct jump_info *exchange_item = last_jump->next;
    #####: 2828:      struct jump_info *it = exchange_item;
        -: 2829:
    #####: 2830:      for (; it; it = it->next)
        -: 2831:	{
        -: 2832:	  /* Test if the jump intersects with any
        -: 2833:	     jump from current group.  */
    #####: 2834:	  bool ok = true;
        -: 2835:	  struct jump_info *it_collision;
        -: 2836:
    #####: 2837:	  for (it_collision = base;
        -: 2838:	       it_collision != exchange_item;
    #####: 2839:	       it_collision = it_collision->next)
        -: 2840:	    {
        -: 2841:	      /* This jump intersects so we leave it out.  */
    #####: 2842:	      if (jump_info_intersect (it_collision, it))
        -: 2843:		{
    #####: 2844:		  ok = false;
    #####: 2845:		  break;
        -: 2846:		}
        -: 2847:	    }
        -: 2848:
        -: 2849:	  /* Add jump to group.  */
    #####: 2850:	  if (ok)
        -: 2851:	    {
        -: 2852:	      /* Move current element to the front.  */
    #####: 2853:	      if (it != exchange_item)
        -: 2854:		{
    #####: 2855:		  struct jump_info *save = it->prev;
    #####: 2856:		  jump_info_move_linked (it, exchange_item, &jumps);
    #####: 2857:		  last_jump = it;
    #####: 2858:		  it = save;
        -: 2859:		}
        -: 2860:	      else
        -: 2861:		{
    #####: 2862:		  last_jump = exchange_item;
    #####: 2863:		  exchange_item = exchange_item->next;
        -: 2864:		}
    #####: 2865:	      last_jump->level = max_level;
        -: 2866:	    }
        -: 2867:	}
        -: 2868:
        -: 2869:      /* Move to next group.  */
    #####: 2870:      last_jump = exchange_item;
        -: 2871:    }
        -: 2872:
    #####: 2873:  return jumps;
        -: 2874:}
        -: 2875:
        -: 2876:/* The number of zeroes we want to see before we start skipping them.
        -: 2877:   The number is arbitrarily chosen.  */
        -: 2878:
        -: 2879:#define DEFAULT_SKIP_ZEROES 8
        -: 2880:
        -: 2881:/* The number of zeroes to skip at the end of a section.  If the
        -: 2882:   number of zeroes at the end is between SKIP_ZEROES_AT_END and
        -: 2883:   SKIP_ZEROES, they will be disassembled.  If there are fewer than
        -: 2884:   SKIP_ZEROES_AT_END, they will be skipped.  This is a heuristic
        -: 2885:   attempt to avoid disassembling zeroes inserted by section
        -: 2886:   alignment.  */
        -: 2887:
        -: 2888:#define DEFAULT_SKIP_ZEROES_AT_END 3
        -: 2889:
        -: 2890:static int
    #####: 2891:null_print (const void * stream ATTRIBUTE_UNUSED, const char * format ATTRIBUTE_UNUSED, ...)
        -: 2892:{
    #####: 2893:  return 1;
        -: 2894:}
        -: 2895:
        -: 2896:/* Like null_print, but takes the extra STYLE argument.  As this is not
        -: 2897:   going to print anything, the extra argument is just ignored.  */
        -: 2898:
        -: 2899:static int
    #####: 2900:null_styled_print (const void * stream ATTRIBUTE_UNUSED,
        -: 2901:		   enum disassembler_style style ATTRIBUTE_UNUSED,
        -: 2902:		   const char * format ATTRIBUTE_UNUSED, ...)
        -: 2903:{
    #####: 2904:  return 1;
        -: 2905:}
        -: 2906:
        -: 2907:/* Print out jump visualization.  */
        -: 2908:
        -: 2909:static void
     2557: 2910:print_jump_visualisation (bfd_vma addr, int max_level, char *line_buffer,
        -: 2911:			  uint8_t *color_buffer)
        -: 2912:{
     2557: 2913:  if (!line_buffer)
     2557: 2914:    return;
        -: 2915:
    #####: 2916:  jump_info_visualize_address (addr, max_level, line_buffer, color_buffer);
        -: 2917:
    #####: 2918:  size_t line_buffer_size = strlen (line_buffer);
    #####: 2919:  char last_color = 0;
        -: 2920:  size_t i;
        -: 2921:
    #####: 2922:  for (i = 0; i <= line_buffer_size; ++i)
        -: 2923:    {
    #####: 2924:      if (color_output)
        -: 2925:	{
    #####: 2926:	  uint8_t color = (i < line_buffer_size) ? color_buffer[i]: 0;
        -: 2927:
    #####: 2928:	  if (color != last_color)
        -: 2929:	    {
    #####: 2930:	      if (color)
    #####: 2931:		if (extended_color_output)
        -: 2932:		  /* Use extended 8bit color, but
        -: 2933:		     do not choose dark colors.  */
    #####: 2934:		  printf ("\033[38;5;%dm", 124 + (color % 108));
        -: 2935:		else
        -: 2936:		  /* Use simple terminal colors.  */
    #####: 2937:		  printf ("\033[%dm", 31 + (color % 7));
        -: 2938:	      else
        -: 2939:		/* Clear color.  */
    #####: 2940:		printf ("\033[0m");
    #####: 2941:	      last_color = color;
        -: 2942:	    }
        -: 2943:	}
    #####: 2944:      putchar ((i < line_buffer_size) ? line_buffer[i]: ' ');
        -: 2945:    }
        -: 2946:}
        -: 2947:
        -: 2948:/* Disassemble some data in memory between given values.  */
        -: 2949:
        -: 2950:static void
      435: 2951:disassemble_bytes (struct disassemble_info *inf,
        -: 2952:		   disassembler_ftype disassemble_fn,
        -: 2953:		   bool insns,
        -: 2954:		   bfd_byte *data,
        -: 2955:		   bfd_vma start_offset,
        -: 2956:		   bfd_vma stop_offset,
        -: 2957:		   bfd_vma rel_offset,
        -: 2958:		   arelent ***relppp,
        -: 2959:		   arelent **relppend)
        -: 2960:{
        -: 2961:  struct objdump_disasm_info *aux;
        -: 2962:  asection *section;
        -: 2963:  unsigned int octets_per_line;
        -: 2964:  unsigned int skip_addr_chars;
        -: 2965:  bfd_vma addr_offset;
      435: 2966:  unsigned int opb = inf->octets_per_byte;
      435: 2967:  unsigned int skip_zeroes = inf->skip_zeroes;
      435: 2968:  unsigned int skip_zeroes_at_end = inf->skip_zeroes_at_end;
        -: 2969:  size_t octets;
        -: 2970:  SFILE sfile;
        -: 2971:
      435: 2972:  aux = (struct objdump_disasm_info *) inf->application_data;
      435: 2973:  section = inf->section;
        -: 2974:
      435: 2975:  sfile.alloc = 120;
      435: 2976:  sfile.buffer = (char *) xmalloc (sfile.alloc);
      435: 2977:  sfile.pos = 0;
        -: 2978:
      435: 2979:  if (insn_width)
    #####: 2980:    octets_per_line = insn_width;
      435: 2981:  else if (insns)
      435: 2982:    octets_per_line = 4;
        -: 2983:  else
    #####: 2984:    octets_per_line = 16;
        -: 2985:
        -: 2986:  /* Figure out how many characters to skip at the start of an
        -: 2987:     address, to make the disassembly look nicer.  We discard leading
        -: 2988:     zeroes in chunks of 4, ensuring that there is always a leading
        -: 2989:     zero remaining.  */
      435: 2990:  skip_addr_chars = 0;
      435: 2991:  if (!no_addresses && !prefix_addresses)
        -: 2992:    {
        -: 2993:      char buf[30];
        -: 2994:
      435: 2995:      bfd_sprintf_vma (aux->abfd, buf, section->vma + section->size / opb);
        -: 2996:
      886: 2997:      while (buf[skip_addr_chars] == '0')
      451: 2998:	++skip_addr_chars;
        -: 2999:
        -: 3000:      /* Don't discard zeros on overflow.  */
     435*: 3001:      if (buf[skip_addr_chars] == '\0' && section->vma != 0)
    #####: 3002:	skip_addr_chars = 0;
        -: 3003:
      435: 3004:      if (skip_addr_chars != 0)
      430: 3005:	skip_addr_chars = (skip_addr_chars - 1) & -4;
        -: 3006:    }
        -: 3007:
      435: 3008:  inf->insn_info_valid = 0;
        -: 3009:
        -: 3010:  /* Determine maximum level. */
      435: 3011:  uint8_t *color_buffer = NULL;
      435: 3012:  char *line_buffer = NULL;
      435: 3013:  int max_level = -1;
        -: 3014:
        -: 3015:  /* Some jumps were detected.  */
      435: 3016:  if (detected_jumps)
        -: 3017:    {
        -: 3018:      struct jump_info *ji;
        -: 3019:
        -: 3020:      /* Find maximum jump level.  */
    #####: 3021:      for (ji = detected_jumps; ji; ji = ji->next)
        -: 3022:	{
    #####: 3023:	  if (ji->level > max_level)
    #####: 3024:	    max_level = ji->level;
        -: 3025:	}
        -: 3026:
        -: 3027:      /* Allocate buffers.  */
    #####: 3028:      size_t len = (max_level + 1) * 3 + 1;
    #####: 3029:      line_buffer = xmalloc (len);
    #####: 3030:      line_buffer[len - 1] = 0;
    #####: 3031:      color_buffer = xmalloc (len);
    #####: 3032:      color_buffer[len - 1] = 0;
        -: 3033:    }
        -: 3034:
      435: 3035:  addr_offset = start_offset;
     3216: 3036:  while (addr_offset < stop_offset)
        -: 3037:    {
     2781: 3038:      bool need_nl = false;
        -: 3039:
     2781: 3040:      octets = 0;
        -: 3041:
        -: 3042:      /* Make sure we don't use relocs from previous instructions.  */
     2781: 3043:      aux->reloc = NULL;
        -: 3044:
        -: 3045:      /* If we see more than SKIP_ZEROES octets of zeroes, we just
        -: 3046:	 print `...'.  */
     2781: 3047:      if (! disassemble_zeroes)
1275073555: 3048:	for (; addr_offset * opb + octets < stop_offset * opb; octets++)
1275073337: 3049:	  if (data[addr_offset * opb + octets] != 0)
     2563: 3050:	    break;
     2781: 3051:      if (! disassemble_zeroes
     2781: 3052:	  && (inf->insn_info_valid == 0
      443: 3053:	      || inf->branch_delay_insns == 0)
     2781: 3054:	  && (octets >= skip_zeroes
     2733: 3055:	      || (addr_offset * opb + octets == stop_offset * opb
      201: 3056:		  && octets < skip_zeroes_at_end)))
        -: 3057:	{
        -: 3058:	  /* If there are more nonzero octets to follow, we only skip
        -: 3059:	     zeroes in multiples of 4, to try to avoid running over
        -: 3060:	     the start of an instruction which happens to start with
        -: 3061:	     zero.  */
      226: 3062:	  if (addr_offset * opb + octets != stop_offset * opb)
       31: 3063:	    octets &= ~3;
        -: 3064:
        -: 3065:	  /* If we are going to display more data, and we are displaying
        -: 3066:	     file offsets, then tell the user how many zeroes we skip
        -: 3067:	     and the file offset from where we resume dumping.  */
      226: 3068:	  if (display_file_offsets
    #####: 3069:	      && addr_offset + octets / opb < stop_offset)
    #####: 3070:	    printf (_("\t... (skipping %lu zeroes, "
        -: 3071:		      "resuming at file offset: 0x%lx)\n"),
    #####: 3072:		    (unsigned long) (octets / opb),
    #####: 3073:		    (unsigned long) (section->filepos
    #####: 3074:				     + addr_offset + octets / opb));
        -: 3075:	  else
      226: 3076:	    printf ("\t...\n");
        -: 3077:	}
        -: 3078:      else
        -: 3079:	{
        -: 3080:	  char buf[50];
     2555: 3081:	  unsigned int bpc = 0;
     2555: 3082:	  unsigned int pb = 0;
        -: 3083:
     2555: 3084:	  if (with_line_numbers || with_source_code)
     2555: 3085:	    show_line (aux->abfd, section, addr_offset);
        -: 3086:
     2555: 3087:	  if (no_addresses)
    #####: 3088:	    printf ("\t");
     2555: 3089:	  else if (!prefix_addresses)
        -: 3090:	    {
        -: 3091:	      char *s;
        -: 3092:
     2555: 3093:	      bfd_sprintf_vma (aux->abfd, buf, section->vma + addr_offset);
     5137: 3094:	      for (s = buf + skip_addr_chars; *s == '0'; s++)
     2582: 3095:		*s = ' ';
     2555: 3096:	      if (*s == '\0')
        1: 3097:		*--s = '0';
     2555: 3098:	      printf ("%s:\t", buf + skip_addr_chars);
        -: 3099:	    }
        -: 3100:	  else
        -: 3101:	    {
    #####: 3102:	      aux->require_sec = true;
    #####: 3103:	      objdump_print_address (section->vma + addr_offset, inf);
    #####: 3104:	      aux->require_sec = false;
    #####: 3105:	      putchar (' ');
        -: 3106:	    }
        -: 3107:
     2555: 3108:	  print_jump_visualisation (section->vma + addr_offset,
        -: 3109:				    max_level, line_buffer,
        -: 3110:				    color_buffer);
        -: 3111:
     2555: 3112:	  if (insns)
        -: 3113:	    {
        -: 3114:	      int insn_size;
        -: 3115:
     2555: 3116:	      sfile.pos = 0;
     2555: 3117:	      disassemble_set_printf
        -: 3118:		(inf, &sfile, (fprintf_ftype) objdump_sprintf,
        -: 3119:		 (fprintf_styled_ftype) objdump_styled_sprintf);
     2555: 3120:	      inf->bytes_per_line = 0;
     2555: 3121:	      inf->bytes_per_chunk = 0;
    2555*: 3122:	      inf->flags = ((disassemble_all ? DISASSEMBLE_DATA : 0)
    2555*: 3123:			    | (wide_output ? WIDE_OUTPUT : 0));
     2555: 3124:	      if (machine)
    #####: 3125:		inf->flags |= USER_SPECIFIED_MACHINE_TYPE;
        -: 3126:
     2555: 3127:	      if (inf->disassembler_needs_relocs
    #####: 3128:		  && (bfd_get_file_flags (aux->abfd) & EXEC_P) == 0
    #####: 3129:		  && (bfd_get_file_flags (aux->abfd) & DYNAMIC) == 0
    #####: 3130:		  && *relppp < relppend)
        -: 3131:		{
        -: 3132:		  bfd_signed_vma distance_to_rel;
    #####: 3133:		  int max_reloc_offset
    #####: 3134:		    = aux->abfd->arch_info->max_reloc_offset_into_insn;
        -: 3135:
    #####: 3136:		  distance_to_rel = ((**relppp)->address - rel_offset
    #####: 3137:				     - addr_offset);
        -: 3138:
    #####: 3139:		  insn_size = 0;
    #####: 3140:		  if (distance_to_rel > 0
    #####: 3141:		      && (max_reloc_offset < 0
    #####: 3142:			  || distance_to_rel <= max_reloc_offset))
        -: 3143:		    {
        -: 3144:		      /* This reloc *might* apply to the current insn,
        -: 3145:			 starting somewhere inside it.  Discover the length
        -: 3146:			 of the current insn so that the check below will
        -: 3147:			 work.  */
    #####: 3148:		      if (insn_width)
    #####: 3149:			insn_size = insn_width;
        -: 3150:		      else
        -: 3151:			{
        -: 3152:			  /* We find the length by calling the dissassembler
        -: 3153:			     function with a dummy print handler.  This should
        -: 3154:			     work unless the disassembler is not expecting to
        -: 3155:			     be called multiple times for the same address.
        -: 3156:
        -: 3157:			     This does mean disassembling the instruction
        -: 3158:			     twice, but we only do this when there is a high
        -: 3159:			     probability that there is a reloc that will
        -: 3160:			     affect the instruction.  */
    #####: 3161:			  disassemble_set_printf
        -: 3162:			    (inf, inf->stream, (fprintf_ftype) null_print,
        -: 3163:			     (fprintf_styled_ftype) null_styled_print);
    #####: 3164:			  insn_size = disassemble_fn (section->vma
        -: 3165:						      + addr_offset, inf);
    #####: 3166:			  disassemble_set_printf
        -: 3167:			    (inf, inf->stream,
        -: 3168:			     (fprintf_ftype) objdump_sprintf,
        -: 3169:			     (fprintf_styled_ftype) objdump_styled_sprintf);
        -: 3170:			}
        -: 3171:		    }
        -: 3172:
        -: 3173:		  /* Check to see if the current reloc is associated with
        -: 3174:		     the instruction that we are about to disassemble.  */
    #####: 3175:		  if (distance_to_rel == 0
    #####: 3176:		      || (distance_to_rel > 0
    #####: 3177:			  && distance_to_rel < insn_size / (int) opb))
        -: 3178:		    {
    #####: 3179:		      inf->flags |= INSN_HAS_RELOC;
    #####: 3180:		      aux->reloc = **relppp;
        -: 3181:		    }
        -: 3182:		}
        -: 3183:
     2555: 3184:	      if (! disassemble_all
    #####: 3185:		  && ((section->flags & (SEC_CODE | SEC_HAS_CONTENTS))
        -: 3186:		      == (SEC_CODE | SEC_HAS_CONTENTS)))
        -: 3187:		/* Set a stop_vma so that the disassembler will not read
        -: 3188:		   beyond the next symbol.  We assume that symbols appear on
        -: 3189:		   the boundaries between instructions.  We only do this when
        -: 3190:		   disassembling code of course, and when -D is in effect.  */
    #####: 3191:		inf->stop_vma = section->vma + stop_offset;
        -: 3192:
     2555: 3193:	      inf->stop_offset = stop_offset;
     2555: 3194:	      disassembler_in_comment = false;
     2555: 3195:	      insn_size = (*disassemble_fn) (section->vma + addr_offset, inf);
     2555: 3196:	      octets = insn_size;
        -: 3197:
     2555: 3198:	      inf->stop_vma = 0;
     2555: 3199:	      disassemble_set_printf (inf, stdout, (fprintf_ftype) fprintf,
        -: 3200:				      (fprintf_styled_ftype) fprintf_styled);
     2555: 3201:	      if (insn_width == 0 && inf->bytes_per_line != 0)
     2555: 3202:		octets_per_line = inf->bytes_per_line;
     2555: 3203:	      if (insn_size < (int) opb)
        -: 3204:		{
    #####: 3205:		  if (sfile.pos)
    #####: 3206:		    printf ("%s\n", sfile.buffer);
    #####: 3207:		  if (insn_size >= 0)
        -: 3208:		    {
    #####: 3209:		      non_fatal (_("disassemble_fn returned length %d"),
        -: 3210:				 insn_size);
    #####: 3211:		      exit_status = 1;
        -: 3212:		    }
    #####: 3213:		  break;
        -: 3214:		}
        -: 3215:	    }
        -: 3216:	  else
        -: 3217:	    {
        -: 3218:	      bfd_vma j;
        -: 3219:
    #####: 3220:	      octets = octets_per_line;
    #####: 3221:	      if (addr_offset + octets / opb > stop_offset)
    #####: 3222:		octets = (stop_offset - addr_offset) * opb;
        -: 3223:
    #####: 3224:	      for (j = addr_offset * opb; j < addr_offset * opb + octets; ++j)
        -: 3225:		{
    #####: 3226:		  if (ISPRINT (data[j]))
    #####: 3227:		    buf[j - addr_offset * opb] = data[j];
        -: 3228:		  else
    #####: 3229:		    buf[j - addr_offset * opb] = '.';
        -: 3230:		}
    #####: 3231:	      buf[j - addr_offset * opb] = '\0';
        -: 3232:	    }
        -: 3233:
    2555*: 3234:	  if (prefix_addresses
     2555: 3235:	      ? show_raw_insn > 0
        -: 3236:	      : show_raw_insn >= 0)
        -: 3237:	    {
        -: 3238:	      bfd_vma j;
        -: 3239:
        -: 3240:	      /* If ! prefix_addresses and ! wide_output, we print
        -: 3241:		 octets_per_line octets per line.  */
     2555: 3242:	      pb = octets;
     2555: 3243:	      if (pb > octets_per_line && ! prefix_addresses && ! wide_output)
        2: 3244:		pb = octets_per_line;
        -: 3245:
     2555: 3246:	      if (inf->bytes_per_chunk)
    #####: 3247:		bpc = inf->bytes_per_chunk;
        -: 3248:	      else
     2555: 3249:		bpc = 1;
        -: 3250:
     9119: 3251:	      for (j = addr_offset * opb; j < addr_offset * opb + pb; j += bpc)
        -: 3252:		{
        -: 3253:		  /* PR 21580: Check for a buffer ending early.  */
     6564: 3254:		  if (j + bpc <= stop_offset * opb)
        -: 3255:		    {
        -: 3256:		      unsigned int k;
        -: 3257:
     6564: 3258:		      if (inf->display_endian == BFD_ENDIAN_LITTLE)
        -: 3259:			{
    13128: 3260:			  for (k = bpc; k-- != 0; )
     6564: 3261:			    printf ("%02x", (unsigned) data[j + k]);
        -: 3262:			}
        -: 3263:		      else
        -: 3264:			{
    #####: 3265:			  for (k = 0; k < bpc; k++)
    #####: 3266:			    printf ("%02x", (unsigned) data[j + k]);
        -: 3267:			}
        -: 3268:		    }
     6564: 3269:		  putchar (' ');
        -: 3270:		}
        -: 3271:
    13876: 3272:	      for (; pb < octets_per_line; pb += bpc)
        -: 3273:		{
        -: 3274:		  unsigned int k;
        -: 3275:
    22642: 3276:		  for (k = 0; k < bpc; k++)
    11321: 3277:		    printf ("  ");
    11321: 3278:		  putchar (' ');
        -: 3279:		}
        -: 3280:
        -: 3281:	      /* Separate raw data from instruction by extra space.  */
     2555: 3282:	      if (insns)
     2555: 3283:		putchar ('\t');
        -: 3284:	      else
    #####: 3285:		printf ("    ");
        -: 3286:	    }
        -: 3287:
     2555: 3288:	  if (! insns)
    #####: 3289:	    printf ("%s", buf);
     2555: 3290:	  else if (sfile.pos)
     2555: 3291:	    printf ("%s", sfile.buffer);
        -: 3292:
    2555*: 3293:	  if (prefix_addresses
     2555: 3294:	      ? show_raw_insn > 0
        -: 3295:	      : show_raw_insn >= 0)
        -: 3296:	    {
     2557: 3297:	      while (pb < octets)
        -: 3298:		{
        -: 3299:		  bfd_vma j;
        -: 3300:		  char *s;
        -: 3301:
        2: 3302:		  putchar ('\n');
        2: 3303:		  j = addr_offset * opb + pb;
        -: 3304:
        2: 3305:		  if (no_addresses)
    #####: 3306:		    printf ("\t");
        -: 3307:		  else
        -: 3308:		    {
        2: 3309:		      bfd_sprintf_vma (aux->abfd, buf, section->vma + j / opb);
        4: 3310:		      for (s = buf + skip_addr_chars; *s == '0'; s++)
        2: 3311:			*s = ' ';
        2: 3312:		      if (*s == '\0')
    #####: 3313:			*--s = '0';
        2: 3314:		      printf ("%s:\t", buf + skip_addr_chars);
        -: 3315:		    }
        -: 3316:
        2: 3317:		  print_jump_visualisation (section->vma + j / opb,
        -: 3318:					    max_level, line_buffer,
        -: 3319:					    color_buffer);
        -: 3320:
        2: 3321:		  pb += octets_per_line;
        2: 3322:		  if (pb > octets)
        2: 3323:		    pb = octets;
        8: 3324:		  for (; j < addr_offset * opb + pb; j += bpc)
        -: 3325:		    {
        -: 3326:		      /* PR 21619: Check for a buffer ending early.  */
        6: 3327:		      if (j + bpc <= stop_offset * opb)
        -: 3328:			{
        -: 3329:			  unsigned int k;
        -: 3330:
        6: 3331:			  if (inf->display_endian == BFD_ENDIAN_LITTLE)
        -: 3332:			    {
       12: 3333:			      for (k = bpc; k-- != 0; )
        6: 3334:				printf ("%02x", (unsigned) data[j + k]);
        -: 3335:			    }
        -: 3336:			  else
        -: 3337:			    {
    #####: 3338:			      for (k = 0; k < bpc; k++)
    #####: 3339:				printf ("%02x", (unsigned) data[j + k]);
        -: 3340:			    }
        -: 3341:			}
        6: 3342:		      putchar (' ');
        -: 3343:		    }
        -: 3344:		}
        -: 3345:	    }
        -: 3346:
     2555: 3347:	  if (!wide_output)
     2555: 3348:	    putchar ('\n');
        -: 3349:	  else
    #####: 3350:	    need_nl = true;
        -: 3351:	}
        -: 3352:
     2781: 3353:      while ((*relppp) < relppend
    #####: 3354:	     && (**relppp)->address < rel_offset + addr_offset + octets / opb)
        -: 3355:	{
    #####: 3356:	  if (dump_reloc_info || dump_dynamic_reloc_info)
        -: 3357:	    {
        -: 3358:	      arelent *q;
        -: 3359:
    #####: 3360:	      q = **relppp;
        -: 3361:
    #####: 3362:	      if (wide_output)
    #####: 3363:		putchar ('\t');
        -: 3364:	      else
    #####: 3365:		printf ("\t\t\t");
        -: 3366:
    #####: 3367:	      if (!no_addresses)
        -: 3368:		{
    #####: 3369:		  objdump_print_value (section->vma - rel_offset + q->address,
        -: 3370:				       inf, true);
    #####: 3371:		  printf (": ");
        -: 3372:		}
        -: 3373:
    #####: 3374:	      if (q->howto == NULL)
    #####: 3375:		printf ("*unknown*\t");
    #####: 3376:	      else if (q->howto->name)
    #####: 3377:		printf ("%s\t", q->howto->name);
        -: 3378:	      else
    #####: 3379:		printf ("%d\t", q->howto->type);
        -: 3380:
    #####: 3381:	      if (q->sym_ptr_ptr == NULL || *q->sym_ptr_ptr == NULL)
    #####: 3382:		printf ("*unknown*");
        -: 3383:	      else
        -: 3384:		{
        -: 3385:		  const char *sym_name;
        -: 3386:
    #####: 3387:		  sym_name = bfd_asymbol_name (*q->sym_ptr_ptr);
    #####: 3388:		  if (sym_name != NULL && *sym_name != '\0')
    #####: 3389:		    objdump_print_symname (aux->abfd, inf, *q->sym_ptr_ptr);
        -: 3390:		  else
        -: 3391:		    {
        -: 3392:		      asection *sym_sec;
        -: 3393:
    #####: 3394:		      sym_sec = bfd_asymbol_section (*q->sym_ptr_ptr);
    #####: 3395:		      sym_name = bfd_section_name (sym_sec);
    #####: 3396:		      if (sym_name == NULL || *sym_name == '\0')
    #####: 3397:			sym_name = "*unknown*";
    #####: 3398:		      printf ("%s", sanitize_string (sym_name));
        -: 3399:		    }
        -: 3400:		}
        -: 3401:
    #####: 3402:	      if (q->addend)
        -: 3403:		{
    #####: 3404:		  bfd_vma addend = q->addend;
    #####: 3405:		  if ((bfd_signed_vma) addend < 0)
        -: 3406:		    {
    #####: 3407:		      printf ("-0x");
    #####: 3408:		      addend = -addend;
        -: 3409:		    }
        -: 3410:		  else
    #####: 3411:		    printf ("+0x");
    #####: 3412:		  objdump_print_value (addend, inf, true);
        -: 3413:		}
        -: 3414:
    #####: 3415:	      printf ("\n");
    #####: 3416:	      need_nl = false;
        -: 3417:	    }
    #####: 3418:	  ++(*relppp);
        -: 3419:	}
        -: 3420:
     2781: 3421:      if (need_nl)
    #####: 3422:	printf ("\n");
        -: 3423:
     2781: 3424:      addr_offset += octets / opb;
        -: 3425:    }
        -: 3426:
      435: 3427:  free (sfile.buffer);
      435: 3428:  free (line_buffer);
      435: 3429:  free (color_buffer);
      435: 3430:}
        -: 3431:
        -: 3432:static void
      502: 3433:disassemble_section (bfd *abfd, asection *section, void *inf)
        -: 3434:{
        -: 3435:  const struct elf_backend_data *bed;
      502: 3436:  bfd_vma sign_adjust = 0;
      502: 3437:  struct disassemble_info *pinfo = (struct disassemble_info *) inf;
        -: 3438:  struct objdump_disasm_info *paux;
      502: 3439:  unsigned int opb = pinfo->octets_per_byte;
      502: 3440:  bfd_byte *data = NULL;
      502: 3441:  bfd_size_type datasize = 0;
      502: 3442:  arelent **rel_pp = NULL;
      502: 3443:  arelent **rel_ppstart = NULL;
        -: 3444:  arelent **rel_ppend;
        -: 3445:  bfd_vma stop_offset;
      502: 3446:  asymbol *sym = NULL;
      502: 3447:  long place = 0;
        -: 3448:  long rel_count;
        -: 3449:  bfd_vma rel_offset;
        -: 3450:  unsigned long addr_offset;
        -: 3451:  bool do_print;
        -: 3452:  enum loop_control
        -: 3453:  {
        -: 3454:   stop_offset_reached,
        -: 3455:   function_sym,
        -: 3456:   next_sym
        -: 3457:  } loop_until;
        -: 3458:
        -: 3459:  /* Sections that do not contain machine
        -: 3460:     code are not normally disassembled.  */
      502: 3461:  if (! disassemble_all
    #####: 3462:      && only_list == NULL
    #####: 3463:      && ((section->flags & (SEC_CODE | SEC_HAS_CONTENTS))
        -: 3464:	  != (SEC_CODE | SEC_HAS_CONTENTS)))
      67*: 3465:    return;
        -: 3466:
      502: 3467:  if (! process_section_p (section))
    #####: 3468:    return;
        -: 3469:
      502: 3470:  datasize = bfd_section_size (section);
      502: 3471:  if (datasize == 0)
        4: 3472:    return;
        -: 3473:
      498: 3474:  if (start_address == (bfd_vma) -1
    #####: 3475:      || start_address < section->vma)
      498: 3476:    addr_offset = 0;
        -: 3477:  else
    #####: 3478:    addr_offset = start_address - section->vma;
        -: 3479:
      498: 3480:  if (stop_address == (bfd_vma) -1)
      498: 3481:    stop_offset = datasize / opb;
        -: 3482:  else
        -: 3483:    {
    #####: 3484:      if (stop_address < section->vma)
    #####: 3485:	stop_offset = 0;
        -: 3486:      else
    #####: 3487:	stop_offset = stop_address - section->vma;
    #####: 3488:      if (stop_offset > datasize / opb)
    #####: 3489:	stop_offset = datasize / opb;
        -: 3490:    }
        -: 3491:
      498: 3492:  if (addr_offset >= stop_offset)
    #####: 3493:    return;
        -: 3494:
        -: 3495:  /* Decide which set of relocs to use.  Load them if necessary.  */
      498: 3496:  paux = (struct objdump_disasm_info *) pinfo->application_data;
     498*: 3497:  if (pinfo->dynrelbuf && dump_dynamic_reloc_info)
        -: 3498:    {
    #####: 3499:      rel_pp = pinfo->dynrelbuf;
    #####: 3500:      rel_count = pinfo->dynrelcount;
        -: 3501:      /* Dynamic reloc addresses are absolute, non-dynamic are section
        -: 3502:	 relative.  REL_OFFSET specifies the reloc address corresponding
        -: 3503:	 to the start of this section.  */
    #####: 3504:      rel_offset = section->vma;
        -: 3505:    }
        -: 3506:  else
        -: 3507:    {
      498: 3508:      rel_count = 0;
      498: 3509:      rel_pp = NULL;
      498: 3510:      rel_offset = 0;
        -: 3511:
      498: 3512:      if ((section->flags & SEC_RELOC) != 0
    #####: 3513:	  && (dump_reloc_info || pinfo->disassembler_needs_relocs))
        -: 3514:	{
        -: 3515:	  long relsize;
        -: 3516:
    #####: 3517:	  relsize = bfd_get_reloc_upper_bound (abfd, section);
    #####: 3518:	  if (relsize < 0)
    #####: 3519:	    bfd_fatal (bfd_get_filename (abfd));
        -: 3520:
    #####: 3521:	  if (relsize > 0)
        -: 3522:	    {
    #####: 3523:	      rel_ppstart = rel_pp = (arelent **) xmalloc (relsize);
    #####: 3524:	      rel_count = bfd_canonicalize_reloc (abfd, section, rel_pp, syms);
    #####: 3525:	      if (rel_count < 0)
    #####: 3526:		bfd_fatal (bfd_get_filename (abfd));
        -: 3527:
        -: 3528:	      /* Sort the relocs by address.  */
    #####: 3529:	      qsort (rel_pp, rel_count, sizeof (arelent *), compare_relocs);
        -: 3530:	    }
        -: 3531:	}
        -: 3532:    }
     498*: 3533:  rel_ppend = PTR_ADD (rel_pp, rel_count);
        -: 3534:
      498: 3535:  if (!bfd_malloc_and_get_section (abfd, section, &data))
        -: 3536:    {
       63: 3537:      non_fatal (_("Reading section %s failed because: %s"),
        -: 3538:		 section->name, bfd_errmsg (bfd_get_error ()));
       63: 3539:      return;
        -: 3540:    }
        -: 3541:
      435: 3542:  pinfo->buffer = data;
      435: 3543:  pinfo->buffer_vma = section->vma;
      435: 3544:  pinfo->buffer_length = datasize;
      435: 3545:  pinfo->section = section;
        -: 3546:
        -: 3547:  /* Sort the symbols into value and section order.  */
      435: 3548:  compare_section = section;
      435: 3549:  if (sorted_symcount > 1)
    #####: 3550:    qsort (sorted_syms, sorted_symcount, sizeof (asymbol *), compare_symbols);
        -: 3551:
        -: 3552:  /* Skip over the relocs belonging to addresses below the
        -: 3553:     start address.  */
      435: 3554:  while (rel_pp < rel_ppend
    #####: 3555:	 && (*rel_pp)->address < rel_offset + addr_offset)
    #####: 3556:    ++rel_pp;
        -: 3557:
      435: 3558:  printf (_("\nDisassembly of section %s:\n"), sanitize_string (section->name));
        -: 3559:
        -: 3560:  /* Find the nearest symbol forwards from our current position.  */
      435: 3561:  paux->require_sec = true;
      435: 3562:  sym = (asymbol *) find_symbol_for_address (section->vma + addr_offset,
        -: 3563:					     (struct disassemble_info *) inf,
        -: 3564:					     &place);
      435: 3565:  paux->require_sec = false;
        -: 3566:
        -: 3567:  /* PR 9774: If the target used signed addresses then we must make
        -: 3568:     sure that we sign extend the value that we calculate for 'addr'
        -: 3569:     in the loop below.  */
      435: 3570:  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      435: 3571:      && (bed = get_elf_backend_data (abfd)) != NULL
      435: 3572:      && bed->sign_extend_vma)
    #####: 3573:    sign_adjust = (bfd_vma) 1 << (bed->s->arch_size - 1);
        -: 3574:
        -: 3575:  /* Disassemble a block of instructions up to the address associated with
        -: 3576:     the symbol we have just found.  Then print the symbol and find the
        -: 3577:     next symbol on.  Repeat until we have disassembled the entire section
        -: 3578:     or we have reached the end of the address range we are interested in.  */
      435: 3579:  do_print = paux->symbol == NULL;
      435: 3580:  loop_until = stop_offset_reached;
        -: 3581:
      870: 3582:  while (addr_offset < stop_offset)
        -: 3583:    {
        -: 3584:      bfd_vma addr;
        -: 3585:      asymbol *nextsym;
        -: 3586:      bfd_vma nextstop_offset;
        -: 3587:      bool insns;
        -: 3588:
      435: 3589:      addr = section->vma + addr_offset;
      435: 3590:      addr = ((addr & ((sign_adjust << 1) - 1)) ^ sign_adjust) - sign_adjust;
        -: 3591:
     435*: 3592:      if (sym != NULL && bfd_asymbol_value (sym) <= addr)
    #####: 3593:	{
        -: 3594:	  int x;
        -: 3595:
    #####: 3596:	  for (x = place;
    #####: 3597:	       (x < sorted_symcount
    #####: 3598:		&& (bfd_asymbol_value (sorted_syms[x]) <= addr));
    #####: 3599:	       ++x)
    #####: 3600:	    continue;
        -: 3601:
    #####: 3602:	  pinfo->symbols = sorted_syms + place;
    #####: 3603:	  pinfo->num_symbols = x - place;
    #####: 3604:	  pinfo->symtab_pos = place;
        -: 3605:	}
        -: 3606:      else
        -: 3607:	{
      435: 3608:	  pinfo->symbols = NULL;
      435: 3609:	  pinfo->num_symbols = 0;
      435: 3610:	  pinfo->symtab_pos = -1;
        -: 3611:	}
        -: 3612:
        -: 3613:      /* If we are only disassembling from a specific symbol,
        -: 3614:	 check to see if we should start or stop displaying.  */
     435*: 3615:      if (sym && paux->symbol)
        -: 3616:	{
    #####: 3617:	  if (do_print)
        -: 3618:	    {
        -: 3619:	      /* See if we should stop printing.  */
    #####: 3620:	      switch (loop_until)
        -: 3621:		{
    #####: 3622:		case function_sym:
    #####: 3623:		  if (sym->flags & BSF_FUNCTION)
    #####: 3624:		    do_print = false;
    #####: 3625:		  break;
        -: 3626:
    #####: 3627:		case stop_offset_reached:
        -: 3628:		  /* Handled by the while loop.  */
    #####: 3629:		  break;
        -: 3630:
    #####: 3631:		case next_sym:
        -: 3632:		  /* FIXME: There is an implicit assumption here
        -: 3633:		     that the name of sym is different from
        -: 3634:		     paux->symbol.  */
    #####: 3635:		  if (! bfd_is_local_label (abfd, sym))
    #####: 3636:		    do_print = false;
    #####: 3637:		  break;
        -: 3638:		}
    #####: 3639:	    }
        -: 3640:	  else
        -: 3641:	    {
    #####: 3642:	      const char * name = bfd_asymbol_name (sym);
    #####: 3643:	      char * alloc = NULL;
        -: 3644:
    #####: 3645:	      if (do_demangle && name[0] != '\0')
        -: 3646:		{
        -: 3647:		  /* Demangle the name.  */
    #####: 3648:		  alloc = bfd_demangle (abfd, name, demangle_flags);
    #####: 3649:		  if (alloc != NULL)
    #####: 3650:		    name = alloc;
        -: 3651:		}
        -: 3652:
        -: 3653:	      /* We are not currently printing.  Check to see
        -: 3654:		 if the current symbol matches the requested symbol.  */
    #####: 3655:	      if (streq (name, paux->symbol))
        -: 3656:		{
    #####: 3657:		  do_print = true;
        -: 3658:
    #####: 3659:		  if (sym->flags & BSF_FUNCTION)
        -: 3660:		    {
    #####: 3661:		      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
    #####: 3662:			  && ((elf_symbol_type *) sym)->internal_elf_sym.st_size > 0)
        -: 3663:			{
        -: 3664:			  /* Sym is a function symbol with a size associated
        -: 3665:			     with it.  Turn on automatic disassembly for the
        -: 3666:			     next VALUE bytes.  */
    #####: 3667:			  stop_offset = addr_offset
    #####: 3668:			    + ((elf_symbol_type *) sym)->internal_elf_sym.st_size;
    #####: 3669:			  loop_until = stop_offset_reached;
        -: 3670:			}
        -: 3671:		      else
        -: 3672:			{
        -: 3673:			  /* Otherwise we need to tell the loop heuristic to
        -: 3674:			     loop until the next function symbol is encountered.  */
    #####: 3675:			  loop_until = function_sym;
        -: 3676:			}
        -: 3677:		    }
        -: 3678:		  else
        -: 3679:		    {
        -: 3680:		      /* Otherwise loop until the next symbol is encountered.  */
    #####: 3681:		      loop_until = next_sym;
        -: 3682:		    }
        -: 3683:		}
        -: 3684:
    #####: 3685:	      free (alloc);
        -: 3686:	    }
        -: 3687:	}
        -: 3688:
      435: 3689:      if (! prefix_addresses && do_print)
        -: 3690:	{
      435: 3691:	  pinfo->fprintf_func (pinfo->stream, "\n");
      435: 3692:	  objdump_print_addr_with_sym (abfd, section, sym, addr,
        -: 3693:				       pinfo, false);
      435: 3694:	  pinfo->fprintf_func (pinfo->stream, ":\n");
        -: 3695:	}
        -: 3696:
     435*: 3697:      if (sym != NULL && bfd_asymbol_value (sym) > addr)
    #####: 3698:	nextsym = sym;
      435: 3699:      else if (sym == NULL)
      435: 3700:	nextsym = NULL;
        -: 3701:      else
        -: 3702:	{
        -: 3703:#define is_valid_next_sym(SYM) \
        -: 3704:  (strcmp (bfd_section_name ((SYM)->section), bfd_section_name (section)) == 0 \
        -: 3705:   && (bfd_asymbol_value (SYM) > bfd_asymbol_value (sym)) \
        -: 3706:   && pinfo->symbol_is_valid (SYM, pinfo))
        -: 3707:
        -: 3708:	  /* Search forward for the next appropriate symbol in
        -: 3709:	     SECTION.  Note that all the symbols are sorted
        -: 3710:	     together into one big array, and that some sections
        -: 3711:	     may have overlapping addresses.  */
    #####: 3712:	  while (place < sorted_symcount
    #####: 3713:		 && ! is_valid_next_sym (sorted_syms [place]))
    #####: 3714:	    ++place;
        -: 3715:
    #####: 3716:	  if (place >= sorted_symcount)
    #####: 3717:	    nextsym = NULL;
        -: 3718:	  else
    #####: 3719:	    nextsym = sorted_syms[place];
        -: 3720:	}
        -: 3721:
     435*: 3722:      if (sym != NULL && bfd_asymbol_value (sym) > addr)
    #####: 3723:	nextstop_offset = bfd_asymbol_value (sym) - section->vma;
      435: 3724:      else if (nextsym == NULL)
      435: 3725:	nextstop_offset = stop_offset;
        -: 3726:      else
    #####: 3727:	nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;
        -: 3728:
      435: 3729:      if (nextstop_offset > stop_offset
      435: 3730:	  || nextstop_offset <= addr_offset)
    #####: 3731:	nextstop_offset = stop_offset;
        -: 3732:
        -: 3733:      /* If a symbol is explicitly marked as being an object
        -: 3734:	 rather than a function, just dump the bytes without
        -: 3735:	 disassembling them.  */
      435: 3736:      if (disassemble_all
    #####: 3737:	  || sym == NULL
    #####: 3738:	  || sym->section != section
    #####: 3739:	  || bfd_asymbol_value (sym) > addr
    #####: 3740:	  || ((sym->flags & BSF_OBJECT) == 0
    #####: 3741:	      && (strstr (bfd_asymbol_name (sym), "gnu_compiled")
        -: 3742:		  == NULL)
    #####: 3743:	      && (strstr (bfd_asymbol_name (sym), "gcc2_compiled")
        -: 3744:		  == NULL))
    #####: 3745:	  || (sym->flags & BSF_FUNCTION) != 0)
      435: 3746:	insns = true;
        -: 3747:      else
    #####: 3748:	insns = false;
        -: 3749:
      435: 3750:      if (do_print)
        -: 3751:	{
        -: 3752:	  /* Resolve symbol name.  */
     435*: 3753:	  if (visualize_jumps && abfd && sym && sym->name)
        -: 3754:	    {
        -: 3755:	      struct disassemble_info di;
        -: 3756:	      SFILE sf;
        -: 3757:
    #####: 3758:	      sf.alloc = strlen (sym->name) + 40;
    #####: 3759:	      sf.buffer = (char*) xmalloc (sf.alloc);
    #####: 3760:	      sf.pos = 0;
    #####: 3761:	      disassemble_set_printf
        -: 3762:		(&di, &sf, (fprintf_ftype) objdump_sprintf,
        -: 3763:		 (fprintf_styled_ftype) objdump_styled_sprintf);
        -: 3764:
    #####: 3765:	      objdump_print_symname (abfd, &di, sym);
        -: 3766:
        -: 3767:	      /* Fetch jump information.  */
    #####: 3768:	      detected_jumps = disassemble_jumps
        -: 3769:		(pinfo, paux->disassemble_fn,
        -: 3770:		 addr_offset, nextstop_offset,
        -: 3771:		 rel_offset, &rel_pp, rel_ppend);
        -: 3772:
        -: 3773:	      /* Free symbol name.  */
    #####: 3774:	      free (sf.buffer);
        -: 3775:	    }
        -: 3776:
        -: 3777:	  /* Add jumps to output.  */
      435: 3778:	  disassemble_bytes (pinfo, paux->disassemble_fn, insns, data,
        -: 3779:			     addr_offset, nextstop_offset,
        -: 3780:			     rel_offset, &rel_pp, rel_ppend);
        -: 3781:
        -: 3782:	  /* Free jumps.  */
      435: 3783:	  while (detected_jumps)
        -: 3784:	    {
    #####: 3785:	      detected_jumps = jump_info_free (detected_jumps);
        -: 3786:	    }
        -: 3787:	}
        -: 3788:
      435: 3789:      addr_offset = nextstop_offset;
      435: 3790:      sym = nextsym;
        -: 3791:    }
        -: 3792:
      435: 3793:  free (data);
        -: 3794:
      435: 3795:  if (rel_ppstart != NULL)
    #####: 3796:    free (rel_ppstart);
        -: 3797:}
        -: 3798:
        -: 3799:/* Disassemble the contents of an object file.  */
        -: 3800:
        -: 3801:static void
      293: 3802:disassemble_data (bfd *abfd)
        -: 3803:{
        -: 3804:  struct disassemble_info disasm_info;
        -: 3805:  struct objdump_disasm_info aux;
        -: 3806:  long i;
        -: 3807:
      293: 3808:  print_files = NULL;
      293: 3809:  prev_functionname = NULL;
      293: 3810:  prev_line = -1;
      293: 3811:  prev_discriminator = 0;
        -: 3812:
        -: 3813:  /* We make a copy of syms to sort.  We don't want to sort syms
        -: 3814:     because that will screw up the relocs.  */
     293*: 3815:  sorted_symcount = symcount ? symcount : dynsymcount;
      293: 3816:  sorted_syms = (asymbol **) xmalloc ((sorted_symcount + synthcount)
        -: 3817:				      * sizeof (asymbol *));
      293: 3818:  if (sorted_symcount != 0)
        -: 3819:    {
    #####: 3820:      memcpy (sorted_syms, symcount ? syms : dynsyms,
        -: 3821:	      sorted_symcount * sizeof (asymbol *));
        -: 3822:
    #####: 3823:      sorted_symcount = remove_useless_symbols (sorted_syms, sorted_symcount);
        -: 3824:    }
        -: 3825:
     293*: 3826:  for (i = 0; i < synthcount; ++i)
        -: 3827:    {
    #####: 3828:      sorted_syms[sorted_symcount] = synthsyms + i;
    #####: 3829:      ++sorted_symcount;
        -: 3830:    }
        -: 3831:
      293: 3832:  init_disassemble_info (&disasm_info, stdout, (fprintf_ftype) fprintf,
        -: 3833:			 (fprintf_styled_ftype) fprintf_styled);
      293: 3834:  disasm_info.application_data = (void *) &aux;
      293: 3835:  aux.abfd = abfd;
      293: 3836:  aux.require_sec = false;
      293: 3837:  disasm_info.dynrelbuf = NULL;
      293: 3838:  disasm_info.dynrelcount = 0;
      293: 3839:  aux.reloc = NULL;
      293: 3840:  aux.symbol = disasm_sym;
        -: 3841:
      293: 3842:  disasm_info.print_address_func = objdump_print_address;
      293: 3843:  disasm_info.symbol_at_address_func = objdump_symbol_at_address;
        -: 3844:
      293: 3845:  if (machine != NULL)
        -: 3846:    {
    #####: 3847:      const bfd_arch_info_type *inf = bfd_scan_arch (machine);
        -: 3848:
    #####: 3849:      if (inf == NULL)
    #####: 3850:	fatal (_("can't use supplied machine %s"), machine);
        -: 3851:
    #####: 3852:      abfd->arch_info = inf;
        -: 3853:    }
        -: 3854:
      293: 3855:  if (endian != BFD_ENDIAN_UNKNOWN)
        -: 3856:    {
        -: 3857:      struct bfd_target *xvec;
        -: 3858:
    #####: 3859:      xvec = (struct bfd_target *) xmalloc (sizeof (struct bfd_target));
    #####: 3860:      memcpy (xvec, abfd->xvec, sizeof (struct bfd_target));
    #####: 3861:      xvec->byteorder = endian;
    #####: 3862:      abfd->xvec = xvec;
        -: 3863:    }
        -: 3864:
        -: 3865:  /* Use libopcodes to locate a suitable disassembler.  */
      586: 3866:  aux.disassemble_fn = disassembler (bfd_get_arch (abfd),
      293: 3867:				     bfd_big_endian (abfd),
        -: 3868:				     bfd_get_mach (abfd), abfd);
      293: 3869:  if (!aux.disassemble_fn)
        -: 3870:    {
       30: 3871:      non_fatal (_("can't disassemble for architecture %s\n"),
        -: 3872:		 bfd_printable_arch_mach (bfd_get_arch (abfd), 0));
       30: 3873:      exit_status = 1;
       30: 3874:      return;
        -: 3875:    }
        -: 3876:
      263: 3877:  disasm_info.flavour = bfd_get_flavour (abfd);
      263: 3878:  disasm_info.arch = bfd_get_arch (abfd);
      263: 3879:  disasm_info.mach = bfd_get_mach (abfd);
      263: 3880:  disasm_info.disassembler_options = disassembler_options;
      263: 3881:  disasm_info.octets_per_byte = bfd_octets_per_byte (abfd, NULL);
      263: 3882:  disasm_info.skip_zeroes = DEFAULT_SKIP_ZEROES;
      263: 3883:  disasm_info.skip_zeroes_at_end = DEFAULT_SKIP_ZEROES_AT_END;
      263: 3884:  disasm_info.disassembler_needs_relocs = false;
        -: 3885:
      263: 3886:  if (bfd_big_endian (abfd))
    #####: 3887:    disasm_info.display_endian = disasm_info.endian = BFD_ENDIAN_BIG;
      263: 3888:  else if (bfd_little_endian (abfd))
      263: 3889:    disasm_info.display_endian = disasm_info.endian = BFD_ENDIAN_LITTLE;
        -: 3890:  else
        -: 3891:    /* ??? Aborting here seems too drastic.  We could default to big or little
        -: 3892:       instead.  */
    #####: 3893:    disasm_info.endian = BFD_ENDIAN_UNKNOWN;
        -: 3894:
      263: 3895:  disasm_info.endian_code = disasm_info.endian;
        -: 3896:
        -: 3897:  /* Allow the target to customize the info structure.  */
      263: 3898:  disassemble_init_for_target (& disasm_info);
        -: 3899:
        -: 3900:  /* Pre-load the dynamic relocs as we may need them during the disassembly.  */
      263: 3901:  long relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
        -: 3902:
      263: 3903:  if (relsize < 0 && dump_dynamic_reloc_info)
    #####: 3904:    bfd_fatal (bfd_get_filename (abfd));
        -: 3905:
      263: 3906:  if (relsize > 0)
        -: 3907:    {
    #####: 3908:      disasm_info.dynrelbuf = (arelent **) xmalloc (relsize);
        -: 3909:      disasm_info.dynrelcount
    #####: 3910:	= bfd_canonicalize_dynamic_reloc (abfd, disasm_info.dynrelbuf, dynsyms);
    #####: 3911:      if (disasm_info.dynrelcount < 0)
    #####: 3912:	bfd_fatal (bfd_get_filename (abfd));
        -: 3913:
        -: 3914:      /* Sort the relocs by address.  */
    #####: 3915:      qsort (disasm_info.dynrelbuf, disasm_info.dynrelcount, sizeof (arelent *),
        -: 3916:	     compare_relocs);
        -: 3917:    }
        -: 3918:
      263: 3919:  disasm_info.symtab = sorted_syms;
      263: 3920:  disasm_info.symtab_size = sorted_symcount;
        -: 3921:
      263: 3922:  bfd_map_over_sections (abfd, disassemble_section, & disasm_info);
        -: 3923:
      263: 3924:  free (disasm_info.dynrelbuf);
      263: 3925:  disasm_info.dynrelbuf = NULL;
      263: 3926:  free (sorted_syms);
      263: 3927:  disassemble_free_target (&disasm_info);
        -: 3928:}
        -: 3929:
        -: 3930:static bool
    #####: 3931:load_specific_debug_section (enum dwarf_section_display_enum debug,
        -: 3932:			     asection *sec, void *file)
        -: 3933:{
    #####: 3934:  struct dwarf_section *section = &debug_displays [debug].section;
    #####: 3935:  bfd *abfd = (bfd *) file;
        -: 3936:  bfd_byte *contents;
        -: 3937:  bfd_size_type amt;
        -: 3938:  size_t alloced;
        -: 3939:  bool ret;
        -: 3940:
    #####: 3941:  if (section->start != NULL)
        -: 3942:    {
        -: 3943:      /* If it is already loaded, do nothing.  */
    #####: 3944:      if (streq (section->filename, bfd_get_filename (abfd)))
    #####: 3945:	return true;
    #####: 3946:      free (section->start);
        -: 3947:    }
        -: 3948:
    #####: 3949:  section->filename = bfd_get_filename (abfd);
    #####: 3950:  section->reloc_info = NULL;
    #####: 3951:  section->num_relocs = 0;
    #####: 3952:  section->address = bfd_section_vma (sec);
    #####: 3953:  section->size = bfd_section_size (sec);
        -: 3954:  /* PR 24360: On 32-bit hosts sizeof (size_t) < sizeof (bfd_size_type). */
    #####: 3955:  alloced = amt = section->size + 1;
    #####: 3956:  if (alloced != amt || alloced == 0)
        -: 3957:    {
    #####: 3958:      section->start = NULL;
    #####: 3959:      free_debug_section (debug);
    #####: 3960:      printf (_("\nSection '%s' has an invalid size: %#llx.\n"),
        -: 3961:	      sanitize_string (section->name),
    #####: 3962:	      (unsigned long long) section->size);
    #####: 3963:      return false;
        -: 3964:    }
        -: 3965:
    #####: 3966:  section->start = contents = xmalloc (alloced);
        -: 3967:  /* Ensure any string section has a terminating NUL.  */
    #####: 3968:  section->start[section->size] = 0;
        -: 3969:
    #####: 3970:  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0
    #####: 3971:      && debug_displays [debug].relocate)
        -: 3972:    {
    #####: 3973:      ret = bfd_simple_get_relocated_section_contents (abfd,
        -: 3974:						       sec,
    #####: 3975:						       section->start,
        -: 3976:						       syms) != NULL;
    #####: 3977:      if (ret)
        -: 3978:	{
    #####: 3979:	  long reloc_size = bfd_get_reloc_upper_bound (abfd, sec);
        -: 3980:
    #####: 3981:	  if (reloc_size > 0)
        -: 3982:	    {
        -: 3983:	      unsigned long reloc_count;
        -: 3984:	      arelent **relocs;
        -: 3985:
    #####: 3986:	      relocs = (arelent **) xmalloc (reloc_size);
        -: 3987:
    #####: 3988:	      reloc_count = bfd_canonicalize_reloc (abfd, sec, relocs, NULL);
    #####: 3989:	      if (reloc_count == 0)
    #####: 3990:		free (relocs);
        -: 3991:	      else
        -: 3992:		{
    #####: 3993:		  section->reloc_info = relocs;
    #####: 3994:		  section->num_relocs = reloc_count;
        -: 3995:		}
        -: 3996:	    }
        -: 3997:	}
        -: 3998:    }
        -: 3999:  else
    #####: 4000:    ret = bfd_get_full_section_contents (abfd, sec, &contents);
        -: 4001:
    #####: 4002:  if (!ret)
        -: 4003:    {
    #####: 4004:      free_debug_section (debug);
    #####: 4005:      printf (_("\nCan't get contents for section '%s'.\n"),
        -: 4006:	      sanitize_string (section->name));
    #####: 4007:      return false;
        -: 4008:    }
        -: 4009:
    #####: 4010:  return true;
        -: 4011:}
        -: 4012:
        -: 4013:bool
    #####: 4014:reloc_at (struct dwarf_section * dsec, dwarf_vma offset)
        -: 4015:{
        -: 4016:  arelent ** relocs;
        -: 4017:  arelent * rp;
        -: 4018:
    #####: 4019:  if (dsec == NULL || dsec->reloc_info == NULL)
    #####: 4020:    return false;
        -: 4021:
    #####: 4022:  relocs = (arelent **) dsec->reloc_info;
        -: 4023:
    #####: 4024:  for (; (rp = * relocs) != NULL; ++ relocs)
    #####: 4025:    if (rp->address == offset)
    #####: 4026:      return true;
        -: 4027:
    #####: 4028:  return false;
        -: 4029:}
        -: 4030:
        -: 4031:bool
    #####: 4032:load_debug_section (enum dwarf_section_display_enum debug, void *file)
        -: 4033:{
    #####: 4034:  struct dwarf_section *section = &debug_displays [debug].section;
    #####: 4035:  bfd *abfd = (bfd *) file;
        -: 4036:  asection *sec;
        -: 4037:  const char *name;
        -: 4038:
    #####: 4039:  if (!dump_any_debugging)
    #####: 4040:    return false;
        -: 4041:
        -: 4042:  /* If it is already loaded, do nothing.  */
    #####: 4043:  if (section->start != NULL)
        -: 4044:    {
    #####: 4045:      if (streq (section->filename, bfd_get_filename (abfd)))
    #####: 4046:	return true;
        -: 4047:    }
        -: 4048:  /* Locate the debug section.  */
    #####: 4049:  name = section->uncompressed_name;
    #####: 4050:  sec = bfd_get_section_by_name (abfd, name);
    #####: 4051:  if (sec == NULL)
        -: 4052:    {
    #####: 4053:      name = section->compressed_name;
    #####: 4054:      if (*name)
    #####: 4055:	sec = bfd_get_section_by_name (abfd, name);
        -: 4056:    }
    #####: 4057:  if (sec == NULL)
        -: 4058:    {
    #####: 4059:      name = section->xcoff_name;
    #####: 4060:      if (*name)
    #####: 4061:	sec = bfd_get_section_by_name (abfd, name);
        -: 4062:    }
    #####: 4063:  if (sec == NULL)
    #####: 4064:    return false;
        -: 4065:
    #####: 4066:  section->name = name;
    #####: 4067:  return load_specific_debug_section (debug, sec, file);
        -: 4068:}
        -: 4069:
        -: 4070:void
    13771: 4071:free_debug_section (enum dwarf_section_display_enum debug)
        -: 4072:{
    13771: 4073:  struct dwarf_section *section = &debug_displays [debug].section;
        -: 4074:
    13771: 4075:  free ((char *) section->start);
    13771: 4076:  section->start = NULL;
    13771: 4077:  section->address = 0;
    13771: 4078:  section->size = 0;
    13771: 4079:}
        -: 4080:
        -: 4081:void
    #####: 4082:close_debug_file (void * file)
        -: 4083:{
    #####: 4084:  bfd * abfd = (bfd *) file;
        -: 4085:
    #####: 4086:  bfd_close (abfd);
    #####: 4087:}
        -: 4088:
        -: 4089:void *
    #####: 4090:open_debug_file (const char * pathname)
        -: 4091:{
        -: 4092:  bfd * data;
        -: 4093:
    #####: 4094:  data = bfd_openr (pathname, NULL);
    #####: 4095:  if (data == NULL)
    #####: 4096:    return NULL;
        -: 4097:
    #####: 4098:  if (! bfd_check_format (data, bfd_object))
    #####: 4099:    return NULL;
        -: 4100:
    #####: 4101:  return data;
        -: 4102:}
        -: 4103:
        -: 4104:#if HAVE_LIBDEBUGINFOD
        -: 4105:/* Return a hex string represention of the build-id.  */
        -: 4106:
        -: 4107:unsigned char *
        -: 4108:get_build_id (void * data)
        -: 4109:{
        -: 4110:  unsigned i;
        -: 4111:  char * build_id_str;
        -: 4112:  bfd * abfd = (bfd *) data;
        -: 4113:  const struct bfd_build_id * build_id;
        -: 4114:
        -: 4115:  build_id = abfd->build_id;
        -: 4116:  if (build_id == NULL)
        -: 4117:    return NULL;
        -: 4118:
        -: 4119:  build_id_str = malloc (build_id->size * 2 + 1);
        -: 4120:  if (build_id_str == NULL)
        -: 4121:    return NULL;
        -: 4122:
        -: 4123:  for (i = 0; i < build_id->size; i++)
        -: 4124:    sprintf (build_id_str + (i * 2), "%02x", build_id->data[i]);
        -: 4125:  build_id_str[build_id->size * 2] = '\0';
        -: 4126:
        -: 4127:  return (unsigned char *)build_id_str;
        -: 4128:}
        -: 4129:#endif /* HAVE_LIBDEBUGINFOD */
        -: 4130:
        -: 4131:static void
    #####: 4132:dump_dwarf_section (bfd *abfd, asection *section,
        -: 4133:		    void *arg)
        -: 4134:{
    #####: 4135:  const char *name = bfd_section_name (section);
        -: 4136:  const char *match;
        -: 4137:  int i;
    #####: 4138:  bool is_mainfile = *(bool *) arg;
        -: 4139:
    #####: 4140:  if (*name == 0)
    #####: 4141:    return;
        -: 4142:
    #####: 4143:  if (!is_mainfile && !process_links
    #####: 4144:      && (section->flags & SEC_DEBUGGING) == 0)
    #####: 4145:    return;
        -: 4146:
    #####: 4147:  if (startswith (name, ".gnu.linkonce.wi."))
    #####: 4148:    match = ".debug_info";
        -: 4149:  else
    #####: 4150:    match = name;
        -: 4151:
    #####: 4152:  for (i = 0; i < max; i++)
    #####: 4153:    if ((strcmp (debug_displays [i].section.uncompressed_name, match) == 0
    #####: 4154:	 || strcmp (debug_displays [i].section.compressed_name, match) == 0
    #####: 4155:	 || strcmp (debug_displays [i].section.xcoff_name, match) == 0)
    #####: 4156:	&& debug_displays [i].enabled != NULL
    #####: 4157:	&& *debug_displays [i].enabled)
        -: 4158:      {
    #####: 4159:	struct dwarf_section *sec = &debug_displays [i].section;
        -: 4160:
    #####: 4161:	if (strcmp (sec->uncompressed_name, match) == 0)
    #####: 4162:	  sec->name = sec->uncompressed_name;
    #####: 4163:	else if (strcmp (sec->compressed_name, match) == 0)
    #####: 4164:	  sec->name = sec->compressed_name;
        -: 4165:	else
    #####: 4166:	  sec->name = sec->xcoff_name;
    #####: 4167:	if (load_specific_debug_section ((enum dwarf_section_display_enum) i,
        -: 4168:					 section, abfd))
        -: 4169:	  {
    #####: 4170:	    debug_displays [i].display (sec, abfd);
        -: 4171:
    #####: 4172:	    if (i != info && i != abbrev)
    #####: 4173:	      free_debug_section ((enum dwarf_section_display_enum) i);
        -: 4174:	  }
    #####: 4175:	break;
        -: 4176:      }
        -: 4177:}
        -: 4178:
        -: 4179:/* Dump the dwarf debugging information.  */
        -: 4180:
        -: 4181:static void
    #####: 4182:dump_dwarf (bfd *abfd, bool is_mainfile)
        -: 4183:{
        -: 4184:  /* The byte_get pointer should have been set at the start of dump_bfd().  */
    #####: 4185:  if (byte_get == NULL)
        -: 4186:    {
    #####: 4187:      warn (_("File %s does not contain any dwarf debug information\n"),
        -: 4188:	    bfd_get_filename (abfd));
    #####: 4189:      return;
        -: 4190:    }
        -: 4191:
    #####: 4192:  switch (bfd_get_arch (abfd))
        -: 4193:    {
    #####: 4194:    case bfd_arch_s12z:
        -: 4195:      /* S12Z has a 24 bit address space.  But the only known
        -: 4196:	 producer of dwarf_info encodes addresses into 32 bits.  */
    #####: 4197:      eh_addr_size = 4;
    #####: 4198:      break;
        -: 4199:
    #####: 4200:    default:
    #####: 4201:      eh_addr_size = bfd_arch_bits_per_address (abfd) / 8;
    #####: 4202:      break;
        -: 4203:    }
        -: 4204:
    #####: 4205:  init_dwarf_regnames_by_bfd_arch_and_mach (bfd_get_arch (abfd),
        -: 4206:					    bfd_get_mach (abfd));
        -: 4207:
    #####: 4208:  bfd_map_over_sections (abfd, dump_dwarf_section, (void *) &is_mainfile);
        -: 4209:}
        -: 4210:
        -: 4211:/* Read ABFD's stabs section STABSECT_NAME, and return a pointer to
        -: 4212:   it.  Return NULL on failure.   */
        -: 4213:
        -: 4214:static bfd_byte *
    #####: 4215:read_section_stabs (bfd *abfd, const char *sect_name, bfd_size_type *size_ptr,
        -: 4216:		    bfd_size_type *entsize_ptr)
        -: 4217:{
        -: 4218:  asection *stabsect;
        -: 4219:  bfd_byte *contents;
        -: 4220:
    #####: 4221:  stabsect = bfd_get_section_by_name (abfd, sect_name);
    #####: 4222:  if (stabsect == NULL)
        -: 4223:    {
    #####: 4224:      printf (_("No %s section present\n\n"),
        -: 4225:	      sanitize_string (sect_name));
    #####: 4226:      return false;
        -: 4227:    }
        -: 4228:
    #####: 4229:  if (!bfd_malloc_and_get_section (abfd, stabsect, &contents))
        -: 4230:    {
    #####: 4231:      non_fatal (_("reading %s section of %s failed: %s"),
        -: 4232:		 sect_name, bfd_get_filename (abfd),
        -: 4233:		 bfd_errmsg (bfd_get_error ()));
    #####: 4234:      exit_status = 1;
    #####: 4235:      free (contents);
    #####: 4236:      return NULL;
        -: 4237:    }
        -: 4238:
    #####: 4239:  *size_ptr = bfd_section_size (stabsect);
    #####: 4240:  if (entsize_ptr)
    #####: 4241:    *entsize_ptr = stabsect->entsize;
        -: 4242:
    #####: 4243:  return contents;
        -: 4244:}
        -: 4245:
        -: 4246:/* Stabs entries use a 12 byte format:
        -: 4247:     4 byte string table index
        -: 4248:     1 byte stab type
        -: 4249:     1 byte stab other field
        -: 4250:     2 byte stab desc field
        -: 4251:     4 byte stab value
        -: 4252:   FIXME: This will have to change for a 64 bit object format.  */
        -: 4253:
        -: 4254:#define STRDXOFF  (0)
        -: 4255:#define TYPEOFF   (4)
        -: 4256:#define OTHEROFF  (5)
        -: 4257:#define DESCOFF   (6)
        -: 4258:#define VALOFF    (8)
        -: 4259:#define STABSIZE (12)
        -: 4260:
        -: 4261:/* Print ABFD's stabs section STABSECT_NAME (in `stabs'),
        -: 4262:   using string table section STRSECT_NAME (in `strtab').  */
        -: 4263:
        -: 4264:static void
    #####: 4265:print_section_stabs (bfd *abfd,
        -: 4266:		     const char *stabsect_name,
        -: 4267:		     unsigned *string_offset_ptr)
        -: 4268:{
        -: 4269:  int i;
    #####: 4270:  unsigned file_string_table_offset = 0;
    #####: 4271:  unsigned next_file_string_table_offset = *string_offset_ptr;
        -: 4272:  bfd_byte *stabp, *stabs_end;
        -: 4273:
    #####: 4274:  stabp = stabs;
    #####: 4275:  stabs_end = stabp + stab_size;
        -: 4276:
    #####: 4277:  printf (_("Contents of %s section:\n\n"), sanitize_string (stabsect_name));
    #####: 4278:  printf ("Symnum n_type n_othr n_desc n_value  n_strx String\n");
        -: 4279:
        -: 4280:  /* Loop through all symbols and print them.
        -: 4281:
        -: 4282:     We start the index at -1 because there is a dummy symbol on
        -: 4283:     the front of stabs-in-{coff,elf} sections that supplies sizes.  */
    #####: 4284:  for (i = -1; stabp <= stabs_end - STABSIZE; stabp += STABSIZE, i++)
        -: 4285:    {
        -: 4286:      const char *name;
        -: 4287:      unsigned long strx;
        -: 4288:      unsigned char type, other;
        -: 4289:      unsigned short desc;
        -: 4290:      bfd_vma value;
        -: 4291:
    #####: 4292:      strx = bfd_h_get_32 (abfd, stabp + STRDXOFF);
    #####: 4293:      type = bfd_h_get_8 (abfd, stabp + TYPEOFF);
    #####: 4294:      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
    #####: 4295:      desc = bfd_h_get_16 (abfd, stabp + DESCOFF);
    #####: 4296:      value = bfd_h_get_32 (abfd, stabp + VALOFF);
        -: 4297:
    #####: 4298:      printf ("\n%-6d ", i);
        -: 4299:      /* Either print the stab name, or, if unnamed, print its number
        -: 4300:	 again (makes consistent formatting for tools like awk).  */
    #####: 4301:      name = bfd_get_stab_name (type);
    #####: 4302:      if (name != NULL)
    #####: 4303:	printf ("%-6s", sanitize_string (name));
    #####: 4304:      else if (type == N_UNDF)
    #####: 4305:	printf ("HdrSym");
        -: 4306:      else
    #####: 4307:	printf ("%-6d", type);
    #####: 4308:      printf (" %-6d %-6d ", other, desc);
    #####: 4309:      bfd_printf_vma (abfd, value);
    #####: 4310:      printf (" %-6lu", strx);
        -: 4311:
        -: 4312:      /* Symbols with type == 0 (N_UNDF) specify the length of the
        -: 4313:	 string table associated with this file.  We use that info
        -: 4314:	 to know how to relocate the *next* file's string table indices.  */
    #####: 4315:      if (type == N_UNDF)
        -: 4316:	{
    #####: 4317:	  file_string_table_offset = next_file_string_table_offset;
    #####: 4318:	  next_file_string_table_offset += value;
        -: 4319:	}
        -: 4320:      else
        -: 4321:	{
    #####: 4322:	  bfd_size_type amt = strx + file_string_table_offset;
        -: 4323:
        -: 4324:	  /* Using the (possibly updated) string table offset, print the
        -: 4325:	     string (if any) associated with this symbol.  */
    #####: 4326:	  if (amt < stabstr_size)
        -: 4327:	    /* PR 17512: file: 079-79389-0.001:0.1.
        -: 4328:	       FIXME: May need to sanitize this string before displaying.  */
    #####: 4329:	    printf (" %.*s", (int)(stabstr_size - amt), strtab + amt);
        -: 4330:	  else
    #####: 4331:	    printf (" *");
        -: 4332:	}
        -: 4333:    }
    #####: 4334:  printf ("\n\n");
    #####: 4335:  *string_offset_ptr = next_file_string_table_offset;
    #####: 4336:}
        -: 4337:
        -: 4338:typedef struct
        -: 4339:{
        -: 4340:  const char * section_name;
        -: 4341:  const char * string_section_name;
        -: 4342:  unsigned string_offset;
        -: 4343:}
        -: 4344:stab_section_names;
        -: 4345:
        -: 4346:static void
    #####: 4347:find_stabs_section (bfd *abfd, asection *section, void *names)
        -: 4348:{
        -: 4349:  int len;
    #####: 4350:  stab_section_names * sought = (stab_section_names *) names;
        -: 4351:
        -: 4352:  /* Check for section names for which stabsect_name is a prefix, to
        -: 4353:     handle .stab.N, etc.  */
    #####: 4354:  len = strlen (sought->section_name);
        -: 4355:
        -: 4356:  /* If the prefix matches, and the files section name ends with a
        -: 4357:     nul or a digit, then we match.  I.e., we want either an exact
        -: 4358:     match or a section followed by a number.  */
    #####: 4359:  if (strncmp (sought->section_name, section->name, len) == 0
    #####: 4360:      && (section->name[len] == 0
    #####: 4361:	  || (section->name[len] == '.' && ISDIGIT (section->name[len + 1]))))
        -: 4362:    {
    #####: 4363:      if (strtab == NULL)
    #####: 4364:	strtab = read_section_stabs (abfd, sought->string_section_name,
        -: 4365:				     &stabstr_size, NULL);
        -: 4366:
    #####: 4367:      if (strtab)
        -: 4368:	{
    #####: 4369:	  stabs = read_section_stabs (abfd, section->name, &stab_size, NULL);
    #####: 4370:	  if (stabs)
    #####: 4371:	    print_section_stabs (abfd, section->name, &sought->string_offset);
        -: 4372:	}
        -: 4373:    }
    #####: 4374:}
        -: 4375:
        -: 4376:static void
    #####: 4377:dump_stabs_section (bfd *abfd, char *stabsect_name, char *strsect_name)
        -: 4378:{
        -: 4379:  stab_section_names s;
        -: 4380:
    #####: 4381:  s.section_name = stabsect_name;
    #####: 4382:  s.string_section_name = strsect_name;
    #####: 4383:  s.string_offset = 0;
        -: 4384:
    #####: 4385:  bfd_map_over_sections (abfd, find_stabs_section, & s);
        -: 4386:
    #####: 4387:  free (strtab);
    #####: 4388:  strtab = NULL;
    #####: 4389:}
        -: 4390:
        -: 4391:/* Dump the any sections containing stabs debugging information.  */
        -: 4392:
        -: 4393:static void
    #####: 4394:dump_stabs (bfd *abfd)
        -: 4395:{
    #####: 4396:  dump_stabs_section (abfd, ".stab", ".stabstr");
    #####: 4397:  dump_stabs_section (abfd, ".stab.excl", ".stab.exclstr");
    #####: 4398:  dump_stabs_section (abfd, ".stab.index", ".stab.indexstr");
        -: 4399:
        -: 4400:  /* For Darwin.  */
    #####: 4401:  dump_stabs_section (abfd, "LC_SYMTAB.stabs", "LC_SYMTAB.stabstr");
        -: 4402:
    #####: 4403:  dump_stabs_section (abfd, "$GDB_SYMBOLS$", "$GDB_STRINGS$");
    #####: 4404:}
        -: 4405:
        -: 4406:static void
    #####: 4407:dump_bfd_header (bfd *abfd)
        -: 4408:{
    #####: 4409:  char *comma = "";
        -: 4410:
    #####: 4411:  printf (_("architecture: %s, "),
        -: 4412:	  bfd_printable_arch_mach (bfd_get_arch (abfd),
        -: 4413:				   bfd_get_mach (abfd)));
    #####: 4414:  printf (_("flags 0x%08x:\n"), abfd->flags & ~BFD_FLAGS_FOR_BFD_USE_MASK);
        -: 4415:
        -: 4416:#define PF(x, y)    if (abfd->flags & x) {printf ("%s%s", comma, y); comma=", ";}
    #####: 4417:  PF (HAS_RELOC, "HAS_RELOC");
    #####: 4418:  PF (EXEC_P, "EXEC_P");
    #####: 4419:  PF (HAS_LINENO, "HAS_LINENO");
    #####: 4420:  PF (HAS_DEBUG, "HAS_DEBUG");
    #####: 4421:  PF (HAS_SYMS, "HAS_SYMS");
    #####: 4422:  PF (HAS_LOCALS, "HAS_LOCALS");
    #####: 4423:  PF (DYNAMIC, "DYNAMIC");
    #####: 4424:  PF (WP_TEXT, "WP_TEXT");
    #####: 4425:  PF (D_PAGED, "D_PAGED");
    #####: 4426:  PF (BFD_IS_RELAXABLE, "BFD_IS_RELAXABLE");
    #####: 4427:  printf (_("\nstart address 0x"));
    #####: 4428:  bfd_printf_vma (abfd, abfd->start_address);
    #####: 4429:  printf ("\n");
    #####: 4430:}
        -: 4431:
        -: 4432:
        -: 4433:#ifdef ENABLE_LIBCTF
        -: 4434:/* Formatting callback function passed to ctf_dump.  Returns either the pointer
        -: 4435:   it is passed, or a pointer to newly-allocated storage, in which case
        -: 4436:   dump_ctf() will free it when it no longer needs it.  */
        -: 4437:
        -: 4438:static char *
    #####: 4439:dump_ctf_indent_lines (ctf_sect_names_t sect ATTRIBUTE_UNUSED,
        -: 4440:		       char *s, void *arg)
        -: 4441:{
    #####: 4442:  const char *blanks = arg;
        -: 4443:  char *new_s;
        -: 4444:
    #####: 4445:  if (asprintf (&new_s, "%s%s", blanks, s) < 0)
    #####: 4446:    return s;
    #####: 4447:  return new_s;
        -: 4448:}
        -: 4449:
        -: 4450:/* Make a ctfsect suitable for ctf_bfdopen_ctfsect().  */
        -: 4451:static ctf_sect_t
    #####: 4452:make_ctfsect (const char *name, bfd_byte *data,
        -: 4453:	      bfd_size_type size)
        -: 4454:{
        -: 4455:  ctf_sect_t ctfsect;
        -: 4456:
    #####: 4457:  ctfsect.cts_name = name;
    #####: 4458:  ctfsect.cts_entsize = 1;
    #####: 4459:  ctfsect.cts_size = size;
    #####: 4460:  ctfsect.cts_data = data;
        -: 4461:
    #####: 4462:  return ctfsect;
        -: 4463:}
        -: 4464:
        -: 4465:/* Dump CTF errors/warnings.  */
        -: 4466:static void
    #####: 4467:dump_ctf_errs (ctf_dict_t *fp)
        -: 4468:{
    #####: 4469:  ctf_next_t *it = NULL;
        -: 4470:  char *errtext;
        -: 4471:  int is_warning;
        -: 4472:  int err;
        -: 4473:
        -: 4474:  /* Dump accumulated errors and warnings.  */
    #####: 4475:  while ((errtext = ctf_errwarning_next (fp, &it, &is_warning, &err)) != NULL)
        -: 4476:    {
    #####: 4477:      non_fatal (_("%s: %s"), is_warning ? _("warning"): _("error"),
        -: 4478:		 errtext);
    #####: 4479:      free (errtext);
        -: 4480:    }
    #####: 4481:  if (err != ECTF_NEXT_END)
        -: 4482:    {
    #####: 4483:      non_fatal (_("CTF error: cannot get CTF errors: `%s'"),
        -: 4484:		 ctf_errmsg (err));
        -: 4485:    }
    #####: 4486:}
        -: 4487:
        -: 4488:/* Dump one CTF archive member.  */
        -: 4489:
        -: 4490:static void
    #####: 4491:dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, ctf_dict_t *parent,
        -: 4492:			 size_t member)
        -: 4493:{
    #####: 4494:  const char *things[] = {"Header", "Labels", "Data objects",
        -: 4495:			  "Function objects", "Variables", "Types", "Strings",
        -: 4496:			  ""};
        -: 4497:  const char **thing;
        -: 4498:  size_t i;
        -: 4499:
        -: 4500:  /* Don't print out the name of the default-named archive member if it appears
        -: 4501:     first in the list.  The name .ctf appears everywhere, even for things that
        -: 4502:     aren't really archives, so printing it out is liable to be confusing; also,
        -: 4503:     the common case by far is for only one archive member to exist, and hiding
        -: 4504:     it in that case seems worthwhile.  */
        -: 4505:
    #####: 4506:  if (strcmp (name, ".ctf") != 0 || member != 0)
    #####: 4507:    printf (_("\nCTF archive member: %s:\n"), sanitize_string (name));
        -: 4508:
    #####: 4509:  if (ctf_parent_name (ctf) != NULL)
    #####: 4510:    ctf_import (ctf, parent);
        -: 4511:
    #####: 4512:  for (i = 0, thing = things; *thing[0]; thing++, i++)
        -: 4513:    {
    #####: 4514:      ctf_dump_state_t *s = NULL;
        -: 4515:      char *item;
        -: 4516:
    #####: 4517:      printf ("\n  %s:\n", *thing);
    #####: 4518:      while ((item = ctf_dump (ctf, &s, i, dump_ctf_indent_lines,
        -: 4519:			       (void *) "    ")) != NULL)
        -: 4520:	{
    #####: 4521:	  printf ("%s\n", item);
    #####: 4522:	  free (item);
        -: 4523:	}
        -: 4524:
    #####: 4525:      if (ctf_errno (ctf))
        -: 4526:	{
    #####: 4527:	  non_fatal (_("Iteration failed: %s, %s"), *thing,
        -: 4528:		   ctf_errmsg (ctf_errno (ctf)));
    #####: 4529:	  break;
        -: 4530:	}
        -: 4531:    }
        -: 4532:
    #####: 4533:  dump_ctf_errs (ctf);
    #####: 4534:}
        -: 4535:
        -: 4536:/* Dump the CTF debugging information.  */
        -: 4537:
        -: 4538:static void
    #####: 4539:dump_ctf (bfd *abfd, const char *sect_name, const char *parent_name)
        -: 4540:{
    #####: 4541:  ctf_archive_t *ctfa = NULL;
    #####: 4542:  bfd_byte *ctfdata = NULL;
        -: 4543:  bfd_size_type ctfsize;
        -: 4544:  ctf_sect_t ctfsect;
        -: 4545:  ctf_dict_t *parent;
        -: 4546:  ctf_dict_t *fp;
    #####: 4547:  ctf_next_t *i = NULL;
        -: 4548:  const char *name;
    #####: 4549:  size_t member = 0;
        -: 4550:  int err;
        -: 4551:
    #####: 4552:  if (sect_name == NULL)
    #####: 4553:    sect_name = ".ctf";
        -: 4554:
    #####: 4555:  if ((ctfdata = read_section_stabs (abfd, sect_name, &ctfsize, NULL)) == NULL)
    #####: 4556:      bfd_fatal (bfd_get_filename (abfd));
        -: 4557:
        -: 4558:  /* Load the CTF file and dump it.  Preload the parent dict, since it will
        -: 4559:     need to be imported into every child in turn. */
        -: 4560:
    #####: 4561:  ctfsect = make_ctfsect (sect_name, ctfdata, ctfsize);
    #####: 4562:  if ((ctfa = ctf_bfdopen_ctfsect (abfd, &ctfsect, &err)) == NULL)
        -: 4563:    {
    #####: 4564:      dump_ctf_errs (NULL);
    #####: 4565:      non_fatal (_("CTF open failure: %s"), ctf_errmsg (err));
    #####: 4566:      bfd_fatal (bfd_get_filename (abfd));
        -: 4567:    }
        -: 4568:
    #####: 4569:  if ((parent = ctf_dict_open (ctfa, parent_name, &err)) == NULL)
        -: 4570:    {
    #####: 4571:      dump_ctf_errs (NULL);
    #####: 4572:      non_fatal (_("CTF open failure: %s"), ctf_errmsg (err));
    #####: 4573:      bfd_fatal (bfd_get_filename (abfd));
        -: 4574:    }
        -: 4575:
    #####: 4576:  printf (_("Contents of CTF section %s:\n"), sanitize_string (sect_name));
        -: 4577:
    #####: 4578:  while ((fp = ctf_archive_next (ctfa, &i, &name, 0, &err)) != NULL)
    #####: 4579:    dump_ctf_archive_member (fp, name, parent, member++);
    #####: 4580:  if (err != ECTF_NEXT_END)
        -: 4581:    {
    #####: 4582:      dump_ctf_errs (NULL);
    #####: 4583:      non_fatal (_("CTF archive member open failure: %s"), ctf_errmsg (err));
    #####: 4584:      bfd_fatal (bfd_get_filename (abfd));
        -: 4585:    }
    #####: 4586:  ctf_dict_close (parent);
    #####: 4587:  ctf_close (ctfa);
    #####: 4588:  free (ctfdata);
    #####: 4589:}
        -: 4590:#else
        -: 4591:static void
        -: 4592:dump_ctf (bfd *abfd ATTRIBUTE_UNUSED, const char *sect_name ATTRIBUTE_UNUSED,
        -: 4593:	  const char *parent_name ATTRIBUTE_UNUSED) {}
        -: 4594:#endif
        -: 4595:
        -: 4596:
        -: 4597:static void
    #####: 4598:dump_bfd_private_header (bfd *abfd)
        -: 4599:{
    #####: 4600:  if (!bfd_print_private_bfd_data (abfd, stdout))
    #####: 4601:    non_fatal (_("warning: private headers incomplete: %s"),
        -: 4602:	       bfd_errmsg (bfd_get_error ()));
    #####: 4603:}
        -: 4604:
        -: 4605:static void
    #####: 4606:dump_target_specific (bfd *abfd)
        -: 4607:{
        -: 4608:  const struct objdump_private_desc * const *desc;
        -: 4609:  struct objdump_private_option *opt;
        -: 4610:  char *e, *b;
        -: 4611:
        -: 4612:  /* Find the desc.  */
    #####: 4613:  for (desc = objdump_private_vectors; *desc != NULL; desc++)
    #####: 4614:    if ((*desc)->filter (abfd))
    #####: 4615:      break;
        -: 4616:
    #####: 4617:  if (*desc == NULL)
        -: 4618:    {
    #####: 4619:      non_fatal (_("option -P/--private not supported by this file"));
    #####: 4620:      return;
        -: 4621:    }
        -: 4622:
        -: 4623:  /* Clear all options.  */
    #####: 4624:  for (opt = (*desc)->options; opt->name; opt++)
    #####: 4625:    opt->selected = false;
        -: 4626:
        -: 4627:  /* Decode options.  */
    #####: 4628:  b = dump_private_options;
        -: 4629:  do
        -: 4630:    {
    #####: 4631:      e = strchr (b, ',');
        -: 4632:
    #####: 4633:      if (e)
    #####: 4634:	*e = 0;
        -: 4635:
    #####: 4636:      for (opt = (*desc)->options; opt->name; opt++)
    #####: 4637:	if (strcmp (opt->name, b) == 0)
        -: 4638:	  {
    #####: 4639:	    opt->selected = true;
    #####: 4640:	    break;
        -: 4641:	  }
    #####: 4642:      if (opt->name == NULL)
    #####: 4643:	non_fatal (_("target specific dump '%s' not supported"), b);
        -: 4644:
    #####: 4645:      if (e)
        -: 4646:	{
    #####: 4647:	  *e = ',';
    #####: 4648:	  b = e + 1;
        -: 4649:	}
        -: 4650:    }
    #####: 4651:  while (e != NULL);
        -: 4652:
        -: 4653:  /* Dump.  */
    #####: 4654:  (*desc)->dump (abfd);
        -: 4655:}
        -: 4656:
        -: 4657:/* Display a section in hexadecimal format with associated characters.
        -: 4658:   Each line prefixed by the zero padded address.  */
        -: 4659:
        -: 4660:static void
    #####: 4661:dump_section (bfd *abfd, asection *section, void *dummy ATTRIBUTE_UNUSED)
        -: 4662:{
    #####: 4663:  bfd_byte *data = NULL;
        -: 4664:  bfd_size_type datasize;
        -: 4665:  bfd_vma addr_offset;
        -: 4666:  bfd_vma start_offset;
        -: 4667:  bfd_vma stop_offset;
    #####: 4668:  unsigned int opb = bfd_octets_per_byte (abfd, section);
        -: 4669:  /* Bytes per line.  */
    #####: 4670:  const int onaline = 16;
        -: 4671:  char buf[64];
        -: 4672:  int count;
        -: 4673:  int width;
        -: 4674:
    #####: 4675:  if (! process_section_p (section))
    #####: 4676:    return;
        -: 4677:
    #####: 4678:  if ((section->flags & SEC_HAS_CONTENTS) == 0)
    #####: 4679:    return;
        -: 4680:
    #####: 4681:  if ((datasize = bfd_section_size (section)) == 0)
    #####: 4682:    return;
        -: 4683:
        -: 4684:  /* Compute the address range to display.  */
    #####: 4685:  if (start_address == (bfd_vma) -1
    #####: 4686:      || start_address < section->vma)
    #####: 4687:    start_offset = 0;
        -: 4688:  else
    #####: 4689:    start_offset = start_address - section->vma;
        -: 4690:
    #####: 4691:  if (stop_address == (bfd_vma) -1)
    #####: 4692:    stop_offset = datasize / opb;
        -: 4693:  else
        -: 4694:    {
    #####: 4695:      if (stop_address < section->vma)
    #####: 4696:	stop_offset = 0;
        -: 4697:      else
    #####: 4698:	stop_offset = stop_address - section->vma;
        -: 4699:
    #####: 4700:      if (stop_offset > datasize / opb)
    #####: 4701:	stop_offset = datasize / opb;
        -: 4702:    }
        -: 4703:
    #####: 4704:  if (start_offset >= stop_offset)
    #####: 4705:    return;
        -: 4706:
    #####: 4707:  printf (_("Contents of section %s:"), sanitize_string (section->name));
    #####: 4708:  if (display_file_offsets)
    #####: 4709:    printf (_("  (Starting at file offset: 0x%lx)"),
    #####: 4710:	    (unsigned long) (section->filepos + start_offset));
    #####: 4711:  printf ("\n");
        -: 4712:
    #####: 4713:  if (!bfd_get_full_section_contents (abfd, section, &data))
        -: 4714:    {
    #####: 4715:      non_fatal (_("Reading section %s failed because: %s"),
        -: 4716:		 section->name, bfd_errmsg (bfd_get_error ()));
    #####: 4717:      return;
        -: 4718:    }
        -: 4719:
    #####: 4720:  width = 4;
        -: 4721:
    #####: 4722:  bfd_sprintf_vma (abfd, buf, start_offset + section->vma);
    #####: 4723:  if (strlen (buf) >= sizeof (buf))
    #####: 4724:    abort ();
        -: 4725:
    #####: 4726:  count = 0;
    #####: 4727:  while (buf[count] == '0' && buf[count+1] != '\0')
    #####: 4728:    count++;
    #####: 4729:  count = strlen (buf) - count;
    #####: 4730:  if (count > width)
    #####: 4731:    width = count;
        -: 4732:
    #####: 4733:  bfd_sprintf_vma (abfd, buf, stop_offset + section->vma - 1);
    #####: 4734:  if (strlen (buf) >= sizeof (buf))
    #####: 4735:    abort ();
        -: 4736:
    #####: 4737:  count = 0;
    #####: 4738:  while (buf[count] == '0' && buf[count+1] != '\0')
    #####: 4739:    count++;
    #####: 4740:  count = strlen (buf) - count;
    #####: 4741:  if (count > width)
    #####: 4742:    width = count;
        -: 4743:
    #####: 4744:  for (addr_offset = start_offset;
    #####: 4745:       addr_offset < stop_offset; addr_offset += onaline / opb)
        -: 4746:    {
        -: 4747:      bfd_size_type j;
        -: 4748:
    #####: 4749:      bfd_sprintf_vma (abfd, buf, (addr_offset + section->vma));
    #####: 4750:      count = strlen (buf);
    #####: 4751:      if ((size_t) count >= sizeof (buf))
    #####: 4752:	abort ();
        -: 4753:
    #####: 4754:      putchar (' ');
    #####: 4755:      while (count < width)
        -: 4756:	{
    #####: 4757:	  putchar ('0');
    #####: 4758:	  count++;
        -: 4759:	}
    #####: 4760:      fputs (buf + count - width, stdout);
    #####: 4761:      putchar (' ');
        -: 4762:
    #####: 4763:      for (j = addr_offset * opb;
    #####: 4764:	   j < addr_offset * opb + onaline; j++)
        -: 4765:	{
    #####: 4766:	  if (j < stop_offset * opb)
    #####: 4767:	    printf ("%02x", (unsigned) (data[j]));
        -: 4768:	  else
    #####: 4769:	    printf ("  ");
    #####: 4770:	  if ((j & 3) == 3)
    #####: 4771:	    printf (" ");
        -: 4772:	}
        -: 4773:
    #####: 4774:      printf (" ");
    #####: 4775:      for (j = addr_offset * opb;
    #####: 4776:	   j < addr_offset * opb + onaline; j++)
        -: 4777:	{
    #####: 4778:	  if (j >= stop_offset * opb)
    #####: 4779:	    printf (" ");
        -: 4780:	  else
    #####: 4781:	    printf ("%c", ISPRINT (data[j]) ? data[j] : '.');
        -: 4782:	}
    #####: 4783:      putchar ('\n');
        -: 4784:    }
    #####: 4785:  free (data);
        -: 4786:}
        -: 4787:
        -: 4788:/* Actually display the various requested regions.  */
        -: 4789:
        -: 4790:static void
    #####: 4791:dump_data (bfd *abfd)
        -: 4792:{
    #####: 4793:  bfd_map_over_sections (abfd, dump_section, NULL);
    #####: 4794:}
        -: 4795:
        -: 4796:/* Should perhaps share code and display with nm?  */
        -: 4797:
        -: 4798:static void
    #####: 4799:dump_symbols (bfd *abfd ATTRIBUTE_UNUSED, bool dynamic)
        -: 4800:{
        -: 4801:  asymbol **current;
        -: 4802:  long max_count;
        -: 4803:  long count;
        -: 4804:
    #####: 4805:  if (dynamic)
        -: 4806:    {
    #####: 4807:      current = dynsyms;
    #####: 4808:      max_count = dynsymcount;
    #####: 4809:      printf ("DYNAMIC SYMBOL TABLE:\n");
        -: 4810:    }
        -: 4811:  else
        -: 4812:    {
    #####: 4813:      current = syms;
    #####: 4814:      max_count = symcount;
    #####: 4815:      printf ("SYMBOL TABLE:\n");
        -: 4816:    }
        -: 4817:
    #####: 4818:  if (max_count == 0)
    #####: 4819:    printf (_("no symbols\n"));
        -: 4820:
    #####: 4821:  for (count = 0; count < max_count; count++)
        -: 4822:    {
        -: 4823:      bfd *cur_bfd;
        -: 4824:
    #####: 4825:      if (*current == NULL)
    #####: 4826:	printf (_("no information for symbol number %ld\n"), count);
        -: 4827:
    #####: 4828:      else if ((cur_bfd = bfd_asymbol_bfd (*current)) == NULL)
    #####: 4829:	printf (_("could not determine the type of symbol number %ld\n"),
        -: 4830:		count);
        -: 4831:
    #####: 4832:      else if (process_section_p ((* current)->section)
    #####: 4833:	       && (dump_special_syms
    #####: 4834:		   || !bfd_is_target_special_symbol (cur_bfd, *current)))
        -: 4835:	{
    #####: 4836:	  const char *name = (*current)->name;
        -: 4837:
    #####: 4838:	  if (do_demangle && name != NULL && *name != '\0')
    #####: 4839:	    {
        -: 4840:	      char *alloc;
        -: 4841:
        -: 4842:	      /* If we want to demangle the name, we demangle it
        -: 4843:		 here, and temporarily clobber it while calling
        -: 4844:		 bfd_print_symbol.  FIXME: This is a gross hack.  */
    #####: 4845:	      alloc = bfd_demangle (cur_bfd, name, demangle_flags);
    #####: 4846:	      if (alloc != NULL)
    #####: 4847:		(*current)->name = alloc;
    #####: 4848:	      bfd_print_symbol (cur_bfd, stdout, *current,
        -: 4849:				bfd_print_symbol_all);
    #####: 4850:	      if (alloc != NULL)
        -: 4851:		{
    #####: 4852:		  (*current)->name = name;
    #####: 4853:		  free (alloc);
        -: 4854:		}
        -: 4855:	    }
    #####: 4856:	  else if (unicode_display != unicode_default
    #####: 4857:		   && name != NULL && *name != '\0')
    #####: 4858:	    {
        -: 4859:	      const char * sanitized_name;
        -: 4860:
        -: 4861:	      /* If we want to sanitize the name, we do it here, and
        -: 4862:		 temporarily clobber it while calling bfd_print_symbol.
        -: 4863:		 FIXME: This is a gross hack.  */
    #####: 4864:	      sanitized_name = sanitize_string (name);
    #####: 4865:	      if (sanitized_name != name)
    #####: 4866:		(*current)->name = sanitized_name;
        -: 4867:	      else
    #####: 4868:		sanitized_name = NULL;
    #####: 4869:	      bfd_print_symbol (cur_bfd, stdout, *current,
        -: 4870:				bfd_print_symbol_all);
    #####: 4871:	      if (sanitized_name != NULL)
    #####: 4872:		(*current)->name = name;
        -: 4873:	    }
        -: 4874:	  else
    #####: 4875:	    bfd_print_symbol (cur_bfd, stdout, *current,
        -: 4876:			      bfd_print_symbol_all);
    #####: 4877:	  printf ("\n");
        -: 4878:	}
        -: 4879:
    #####: 4880:      current++;
        -: 4881:    }
    #####: 4882:  printf ("\n\n");
    #####: 4883:}
        -: 4884:
        -: 4885:static void
    #####: 4886:dump_reloc_set (bfd *abfd, asection *sec, arelent **relpp, long relcount)
        -: 4887:{
        -: 4888:  arelent **p;
        -: 4889:  char *last_filename, *last_functionname;
        -: 4890:  unsigned int last_line;
        -: 4891:  unsigned int last_discriminator;
        -: 4892:
        -: 4893:  /* Get column headers lined up reasonably.  */
        -: 4894:  {
        -: 4895:    static int width;
        -: 4896:
    #####: 4897:    if (width == 0)
        -: 4898:      {
        -: 4899:	char buf[30];
        -: 4900:
    #####: 4901:	bfd_sprintf_vma (abfd, buf, (bfd_vma) -1);
    #####: 4902:	width = strlen (buf) - 7;
        -: 4903:      }
    #####: 4904:    printf ("OFFSET %*s TYPE %*s VALUE\n", width, "", 12, "");
        -: 4905:  }
        -: 4906:
    #####: 4907:  last_filename = NULL;
    #####: 4908:  last_functionname = NULL;
    #####: 4909:  last_line = 0;
    #####: 4910:  last_discriminator = 0;
        -: 4911:
    #####: 4912:  for (p = relpp; relcount && *p != NULL; p++, relcount--)
        -: 4913:    {
    #####: 4914:      arelent *q = *p;
        -: 4915:      const char *filename, *functionname;
        -: 4916:      unsigned int linenumber;
        -: 4917:      unsigned int discriminator;
        -: 4918:      const char *sym_name;
        -: 4919:      const char *section_name;
    #####: 4920:      bfd_vma addend2 = 0;
        -: 4921:
    #####: 4922:      if (start_address != (bfd_vma) -1
    #####: 4923:	  && q->address < start_address)
    #####: 4924:	continue;
    #####: 4925:      if (stop_address != (bfd_vma) -1
    #####: 4926:	  && q->address > stop_address)
    #####: 4927:	continue;
        -: 4928:
    #####: 4929:      if (with_line_numbers
    #####: 4930:	  && sec != NULL
    #####: 4931:	  && bfd_find_nearest_line_discriminator (abfd, sec, syms, q->address,
        -: 4932:						  &filename, &functionname,
        -: 4933:						  &linenumber, &discriminator))
        -: 4934:	{
    #####: 4935:	  if (functionname != NULL
    #####: 4936:	      && (last_functionname == NULL
    #####: 4937:		  || strcmp (functionname, last_functionname) != 0))
        -: 4938:	    {
    #####: 4939:	      printf ("%s():\n", sanitize_string (functionname));
    #####: 4940:	      if (last_functionname != NULL)
    #####: 4941:		free (last_functionname);
    #####: 4942:	      last_functionname = xstrdup (functionname);
        -: 4943:	    }
        -: 4944:
    #####: 4945:	  if (linenumber > 0
    #####: 4946:	      && (linenumber != last_line
    #####: 4947:		  || (filename != NULL
    #####: 4948:		      && last_filename != NULL
    #####: 4949:		      && filename_cmp (filename, last_filename) != 0)
    #####: 4950:		  || (discriminator != last_discriminator)))
        -: 4951:	    {
    #####: 4952:	      if (discriminator > 0)
    #####: 4953:		printf ("%s:%u\n", filename == NULL ? "???" :
    #####: 4954:			sanitize_string (filename), linenumber);
        -: 4955:	      else
    #####: 4956:		printf ("%s:%u (discriminator %u)\n",
    #####: 4957:			filename == NULL ? "???" : sanitize_string (filename),
        -: 4958:			linenumber, discriminator);
    #####: 4959:	      last_line = linenumber;
    #####: 4960:	      last_discriminator = discriminator;
    #####: 4961:	      if (last_filename != NULL)
    #####: 4962:		free (last_filename);
    #####: 4963:	      if (filename == NULL)
    #####: 4964:		last_filename = NULL;
        -: 4965:	      else
    #####: 4966:		last_filename = xstrdup (filename);
        -: 4967:	    }
        -: 4968:	}
        -: 4969:
    #####: 4970:      if (q->sym_ptr_ptr && *q->sym_ptr_ptr)
        -: 4971:	{
    #####: 4972:	  sym_name = (*(q->sym_ptr_ptr))->name;
    #####: 4973:	  section_name = (*(q->sym_ptr_ptr))->section->name;
        -: 4974:	}
        -: 4975:      else
        -: 4976:	{
    #####: 4977:	  sym_name = NULL;
    #####: 4978:	  section_name = NULL;
        -: 4979:	}
        -: 4980:
    #####: 4981:      bfd_printf_vma (abfd, q->address);
    #####: 4982:      if (q->howto == NULL)
    #####: 4983:	printf (" *unknown*         ");
    #####: 4984:      else if (q->howto->name)
        -: 4985:	{
    #####: 4986:	  const char *name = q->howto->name;
        -: 4987:
        -: 4988:	  /* R_SPARC_OLO10 relocations contain two addends.
        -: 4989:	     But because 'arelent' lacks enough storage to
        -: 4990:	     store them both, the 64-bit ELF Sparc backend
        -: 4991:	     records this as two relocations.  One R_SPARC_LO10
        -: 4992:	     and one R_SPARC_13, both pointing to the same
        -: 4993:	     address.  This is merely so that we have some
        -: 4994:	     place to store both addend fields.
        -: 4995:
        -: 4996:	     Undo this transformation, otherwise the output
        -: 4997:	     will be confusing.  */
    #####: 4998:	  if (abfd->xvec->flavour == bfd_target_elf_flavour
    #####: 4999:	      && elf_tdata (abfd)->elf_header->e_machine == EM_SPARCV9
    #####: 5000:	      && relcount > 1
    #####: 5001:	      && !strcmp (q->howto->name, "R_SPARC_LO10"))
        -: 5002:	    {
    #####: 5003:	      arelent *q2 = *(p + 1);
    #####: 5004:	      if (q2 != NULL
    #####: 5005:		  && q2->howto
    #####: 5006:		  && q->address == q2->address
    #####: 5007:		  && !strcmp (q2->howto->name, "R_SPARC_13"))
        -: 5008:		{
    #####: 5009:		  name = "R_SPARC_OLO10";
    #####: 5010:		  addend2 = q2->addend;
    #####: 5011:		  p++;
        -: 5012:		}
        -: 5013:	    }
    #####: 5014:	  printf (" %-16s  ", name);
        -: 5015:	}
        -: 5016:      else
    #####: 5017:	printf (" %-16d  ", q->howto->type);
        -: 5018:
    #####: 5019:      if (sym_name)
        -: 5020:	{
    #####: 5021:	  objdump_print_symname (abfd, NULL, *q->sym_ptr_ptr);
        -: 5022:	}
        -: 5023:      else
        -: 5024:	{
    #####: 5025:	  if (section_name == NULL)
    #####: 5026:	    section_name = "*unknown*";
    #####: 5027:	  printf ("[%s]", sanitize_string (section_name));
        -: 5028:	}
        -: 5029:
    #####: 5030:      if (q->addend)
        -: 5031:	{
    #####: 5032:	  bfd_signed_vma addend = q->addend;
    #####: 5033:	  if (addend < 0)
        -: 5034:	    {
    #####: 5035:	      printf ("-0x");
    #####: 5036:	      addend = -addend;
        -: 5037:	    }
        -: 5038:	  else
    #####: 5039:	    printf ("+0x");
    #####: 5040:	  bfd_printf_vma (abfd, addend);
        -: 5041:	}
    #####: 5042:      if (addend2)
        -: 5043:	{
    #####: 5044:	  printf ("+0x");
    #####: 5045:	  bfd_printf_vma (abfd, addend2);
        -: 5046:	}
        -: 5047:
    #####: 5048:      printf ("\n");
        -: 5049:    }
        -: 5050:
    #####: 5051:  if (last_filename != NULL)
    #####: 5052:    free (last_filename);
    #####: 5053:  if (last_functionname != NULL)
    #####: 5054:    free (last_functionname);
    #####: 5055:}
        -: 5056:
        -: 5057:static void
    #####: 5058:dump_relocs_in_section (bfd *abfd,
        -: 5059:			asection *section,
        -: 5060:			void *dummy ATTRIBUTE_UNUSED)
        -: 5061:{
    #####: 5062:  arelent **relpp = NULL;
        -: 5063:  long relcount;
        -: 5064:  long relsize;
        -: 5065:
    #####: 5066:  if (   bfd_is_abs_section (section)
    #####: 5067:      || bfd_is_und_section (section)
    #####: 5068:      || bfd_is_com_section (section)
    #####: 5069:      || (! process_section_p (section))
    #####: 5070:      || ((section->flags & SEC_RELOC) == 0))
    #####: 5071:    return;
        -: 5072:
    #####: 5073:  printf ("RELOCATION RECORDS FOR [%s]:", sanitize_string (section->name));
        -: 5074:
    #####: 5075:  relsize = bfd_get_reloc_upper_bound (abfd, section);
    #####: 5076:  if (relsize == 0)
        -: 5077:    {
    #####: 5078:      printf (" (none)\n\n");
    #####: 5079:      return;
        -: 5080:    }
        -: 5081:
    #####: 5082:  if (relsize < 0)
    #####: 5083:    relcount = relsize;
        -: 5084:  else
        -: 5085:    {
    #####: 5086:      relpp = (arelent **) xmalloc (relsize);
    #####: 5087:      relcount = bfd_canonicalize_reloc (abfd, section, relpp, syms);
        -: 5088:    }
        -: 5089:
    #####: 5090:  if (relcount < 0)
        -: 5091:    {
    #####: 5092:      printf ("\n");
    #####: 5093:      non_fatal (_("failed to read relocs in: %s"),
        -: 5094:		 sanitize_string (bfd_get_filename (abfd)));
    #####: 5095:      bfd_fatal (_("error message was"));
        -: 5096:    }
    #####: 5097:  else if (relcount == 0)
    #####: 5098:    printf (" (none)\n\n");
        -: 5099:  else
        -: 5100:    {
    #####: 5101:      printf ("\n");
    #####: 5102:      dump_reloc_set (abfd, section, relpp, relcount);
    #####: 5103:      printf ("\n\n");
        -: 5104:    }
    #####: 5105:  free (relpp);
        -: 5106:}
        -: 5107:
        -: 5108:static void
    #####: 5109:dump_relocs (bfd *abfd)
        -: 5110:{
    #####: 5111:  bfd_map_over_sections (abfd, dump_relocs_in_section, NULL);
    #####: 5112:}
        -: 5113:
        -: 5114:static void
    #####: 5115:dump_dynamic_relocs (bfd *abfd)
        -: 5116:{
        -: 5117:  long relsize;
        -: 5118:  arelent **relpp;
        -: 5119:  long relcount;
        -: 5120:
    #####: 5121:  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
    #####: 5122:  if (relsize < 0)
    #####: 5123:    bfd_fatal (bfd_get_filename (abfd));
        -: 5124:
    #####: 5125:  printf ("DYNAMIC RELOCATION RECORDS");
        -: 5126:
    #####: 5127:  if (relsize == 0)
    #####: 5128:    printf (" (none)\n\n");
        -: 5129:  else
        -: 5130:    {
    #####: 5131:      relpp = (arelent **) xmalloc (relsize);
    #####: 5132:      relcount = bfd_canonicalize_dynamic_reloc (abfd, relpp, dynsyms);
        -: 5133:
    #####: 5134:      if (relcount < 0)
    #####: 5135:	bfd_fatal (bfd_get_filename (abfd));
    #####: 5136:      else if (relcount == 0)
    #####: 5137:	printf (" (none)\n\n");
        -: 5138:      else
        -: 5139:	{
    #####: 5140:	  printf ("\n");
    #####: 5141:	  dump_reloc_set (abfd, NULL, relpp, relcount);
    #####: 5142:	  printf ("\n\n");
        -: 5143:	}
    #####: 5144:      free (relpp);
        -: 5145:    }
    #####: 5146:}
        -: 5147:
        -: 5148:/* Creates a table of paths, to search for source files.  */
        -: 5149:
        -: 5150:static void
    #####: 5151:add_include_path (const char *path)
        -: 5152:{
    #####: 5153:  if (path[0] == 0)
    #####: 5154:    return;
    #####: 5155:  include_path_count++;
    #####: 5156:  include_paths = (const char **)
    #####: 5157:      xrealloc (include_paths, include_path_count * sizeof (*include_paths));
        -: 5158:#ifdef HAVE_DOS_BASED_FILE_SYSTEM
        -: 5159:  if (path[1] == ':' && path[2] == 0)
        -: 5160:    path = concat (path, ".", (const char *) 0);
        -: 5161:#endif
    #####: 5162:  include_paths[include_path_count - 1] = path;
        -: 5163:}
        -: 5164:
        -: 5165:static void
    #####: 5166:adjust_addresses (bfd *abfd ATTRIBUTE_UNUSED,
        -: 5167:		  asection *section,
        -: 5168:		  void *arg)
        -: 5169:{
    #####: 5170:  if ((section->flags & SEC_DEBUGGING) == 0)
        -: 5171:    {
    #####: 5172:      bool *has_reloc_p = (bool *) arg;
    #####: 5173:      section->vma += adjust_section_vma;
    #####: 5174:      if (*has_reloc_p)
    #####: 5175:	section->lma += adjust_section_vma;
        -: 5176:    }
    #####: 5177:}
        -: 5178:
        -: 5179:/* Return the sign-extended form of an ARCH_SIZE sized VMA.  */
        -: 5180:
        -: 5181:static bfd_vma
    #####: 5182:sign_extend_address (bfd *abfd ATTRIBUTE_UNUSED,
        -: 5183:		     bfd_vma vma,
        -: 5184:		     unsigned arch_size)
        -: 5185:{
        -: 5186:  bfd_vma mask;
    #####: 5187:  mask = (bfd_vma) 1 << (arch_size - 1);
    #####: 5188:  return (((vma & ((mask << 1) - 1)) ^ mask) - mask);
        -: 5189:}
        -: 5190:
        -: 5191:static bool
      293: 5192:might_need_separate_debug_info (bool is_mainfile)
        -: 5193:{
        -: 5194:  /* We do not follow links from debug info files.  */
      293: 5195:  if (! is_mainfile)
    #####: 5196:    return false;
        -: 5197:
        -: 5198:  /* Since do_follow_links might be enabled by default, only treat it as an
        -: 5199:     indication that separate files should be loaded if setting it was a
        -: 5200:     deliberate user action.  */
        -: 5201:  if (DEFAULT_FOR_FOLLOW_LINKS == 0 && do_follow_links)
        -: 5202:    return true;
        -: 5203:  
      293: 5204:  if (process_links || dump_symtab || dump_debugging
      293: 5205:      || dump_dwarf_section_info)
    #####: 5206:    return true;
        -: 5207:
      293: 5208:  return false;  
        -: 5209:}
        -: 5210:
        -: 5211:/* Dump selected contents of ABFD.  */
        -: 5212:
        -: 5213:static void
      293: 5214:dump_bfd (bfd *abfd, bool is_mainfile)
        -: 5215:{
        -: 5216:  const struct elf_backend_data * bed;
        -: 5217:
      293: 5218:  if (bfd_big_endian (abfd))
    #####: 5219:    byte_get = byte_get_big_endian;
      293: 5220:  else if (bfd_little_endian (abfd))
      293: 5221:    byte_get = byte_get_little_endian;
        -: 5222:  else
    #####: 5223:    byte_get = NULL;
        -: 5224:
        -: 5225:  /* Load any separate debug information files.  */
      293: 5226:  if (byte_get != NULL && might_need_separate_debug_info (is_mainfile))
        -: 5227:    {
    #####: 5228:      load_separate_debug_files (abfd, bfd_get_filename (abfd));
        -: 5229:
        -: 5230:      /* If asked to do so, recursively dump the separate files.  */
    #####: 5231:      if (do_follow_links)
        -: 5232:	{
        -: 5233:	  separate_info * i;
        -: 5234:
    #####: 5235:	  for (i = first_separate_info; i != NULL; i = i->next)
    #####: 5236:	    dump_bfd (i->handle, false);
        -: 5237:	}
        -: 5238:    }
        -: 5239:
        -: 5240:  /* Adjust user-specified start and stop limits for targets that use
        -: 5241:     signed addresses.  */
      293: 5242:  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      293: 5243:      && (bed = get_elf_backend_data (abfd)) != NULL
      293: 5244:      && bed->sign_extend_vma)
        -: 5245:    {
    #####: 5246:      start_address = sign_extend_address (abfd, start_address,
    #####: 5247:					   bed->s->arch_size);
    #####: 5248:      stop_address = sign_extend_address (abfd, stop_address,
    #####: 5249:					  bed->s->arch_size);
        -: 5250:    }
        -: 5251:
        -: 5252:  /* If we are adjusting section VMA's, change them all now.  Changing
        -: 5253:     the BFD information is a hack.  However, we must do it, or
        -: 5254:     bfd_find_nearest_line will not do the right thing.  */
      293: 5255:  if (adjust_section_vma != 0)
        -: 5256:    {
    #####: 5257:      bool has_reloc = (abfd->flags & HAS_RELOC);
    #####: 5258:      bfd_map_over_sections (abfd, adjust_addresses, &has_reloc);
        -: 5259:    }
        -: 5260:
     293*: 5261:  if (is_mainfile || process_links)
        -: 5262:    {
      293: 5263:      if (! dump_debugging_tags && ! suppress_bfd_header)
      293: 5264:	printf (_("\n%s:     file format %s\n"),
        -: 5265:		sanitize_string (bfd_get_filename (abfd)),
      293: 5266:		abfd->xvec->name);
      293: 5267:      if (dump_ar_hdrs)
    #####: 5268:	print_arelt_descr (stdout, abfd, true, false);
      293: 5269:      if (dump_file_header)
    #####: 5270:	dump_bfd_header (abfd);
      293: 5271:      if (dump_private_headers)
    #####: 5272:	dump_bfd_private_header (abfd);
      293: 5273:      if (dump_private_options != NULL)
    #####: 5274:	dump_target_specific (abfd);
      293: 5275:      if (! dump_debugging_tags && ! suppress_bfd_header)
      293: 5276:	putchar ('\n');
        -: 5277:    }
        -: 5278:
      293: 5279:  if (dump_symtab
      293: 5280:      || dump_reloc_info
      293: 5281:      || disassemble
    #####: 5282:      || dump_debugging
    #####: 5283:      || dump_dwarf_section_info)
        -: 5284:    {
      293: 5285:      syms = slurp_symtab (abfd);
        -: 5286:
        -: 5287:      /* If following links, load any symbol tables from the linked files as well.  */
      293: 5288:      if (do_follow_links && is_mainfile)
        -: 5289:	{
        -: 5290:	  separate_info * i;
        -: 5291:
     293*: 5292:	  for (i = first_separate_info; i != NULL; i = i->next)
        -: 5293:	    {
        -: 5294:	      asymbol **  extra_syms;
    #####: 5295:	      long        old_symcount = symcount;
        -: 5296:
    #####: 5297:	      extra_syms = slurp_symtab (i->handle);
        -: 5298:
    #####: 5299:	      if (extra_syms)
        -: 5300:		{
    #####: 5301:		  if (old_symcount == 0)
        -: 5302:		    {
    #####: 5303:		      syms = extra_syms;
        -: 5304:		    }
        -: 5305:		  else
        -: 5306:		    {
    #####: 5307:		      syms = xrealloc (syms, ((symcount + old_symcount + 1)
        -: 5308:					      * sizeof (asymbol *)));
    #####: 5309:		      memcpy (syms + old_symcount,
        -: 5310:			      extra_syms,
    #####: 5311:			      (symcount + 1) * sizeof (asymbol *));
        -: 5312:		    }
        -: 5313:		}
        -: 5314:
    #####: 5315:	      symcount += old_symcount;
        -: 5316:	    }
        -: 5317:	}
        -: 5318:    }
        -: 5319:
     293*: 5320:  if (is_mainfile || process_links)
        -: 5321:    {
      293: 5322:      if (dump_section_headers)
    #####: 5323:	dump_headers (abfd);
        -: 5324:
      293: 5325:      if (dump_dynamic_symtab || dump_dynamic_reloc_info
      293: 5326:	  || (disassemble && bfd_get_dynamic_symtab_upper_bound (abfd) > 0))
    #####: 5327:	dynsyms = slurp_dynamic_symtab (abfd);
        -: 5328:
      293: 5329:      if (disassemble)
        -: 5330:	{
      293: 5331:	  synthcount = bfd_get_synthetic_symtab (abfd, symcount, syms,
        -: 5332:						 dynsymcount, dynsyms,
        -: 5333:						 &synthsyms);
      293: 5334:	  if (synthcount < 0)
    #####: 5335:	    synthcount = 0;
        -: 5336:	}
        -: 5337:
      293: 5338:      if (dump_symtab)
    #####: 5339:	dump_symbols (abfd, false);
      293: 5340:      if (dump_dynamic_symtab)
    #####: 5341:	dump_symbols (abfd, true);
        -: 5342:    }
      293: 5343:  if (dump_dwarf_section_info)
    #####: 5344:    dump_dwarf (abfd, is_mainfile);
     293*: 5345:  if (is_mainfile || process_links)
        -: 5346:    {
      293: 5347:      if (dump_ctf_section_info)
    #####: 5348:	dump_ctf (abfd, dump_ctf_section_name, dump_ctf_parent_name);
      293: 5349:      if (dump_stab_section_info)
    #####: 5350:	dump_stabs (abfd);
     293*: 5351:      if (dump_reloc_info && ! disassemble)
    #####: 5352:	dump_relocs (abfd);
     293*: 5353:      if (dump_dynamic_reloc_info && ! disassemble)
    #####: 5354:	dump_dynamic_relocs (abfd);
      293: 5355:      if (dump_section_contents)
    #####: 5356:	dump_data (abfd);
      293: 5357:      if (disassemble)
      293: 5358:	disassemble_data (abfd);
        -: 5359:    }
        -: 5360:
      293: 5361:  if (dump_debugging)
        -: 5362:    {
        -: 5363:      void *dhandle;
        -: 5364:
    #####: 5365:      dhandle = read_debugging_info (abfd, syms, symcount, true);
    #####: 5366:      if (dhandle != NULL)
        -: 5367:	{
    #####: 5368:	  if (!print_debugging_info (stdout, dhandle, abfd, syms,
        -: 5369:				     bfd_demangle,
        -: 5370:				     dump_debugging_tags != 0))
        -: 5371:	    {
    #####: 5372:	      non_fatal (_("%s: printing debugging information failed"),
        -: 5373:			 bfd_get_filename (abfd));
    #####: 5374:	      exit_status = 1;
        -: 5375:	    }
        -: 5376:
    #####: 5377:	  free (dhandle);
        -: 5378:	}
        -: 5379:      /* PR 6483: If there was no STABS debug info in the file, try
        -: 5380:	 DWARF instead.  */
    #####: 5381:      else if (! dump_dwarf_section_info)
        -: 5382:	{
    #####: 5383:	  dwarf_select_sections_all ();
    #####: 5384:	  dump_dwarf (abfd, is_mainfile);
        -: 5385:	}
        -: 5386:    }
        -: 5387:
      293: 5388:  if (syms)
        -: 5389:    {
    #####: 5390:      free (syms);
    #####: 5391:      syms = NULL;
        -: 5392:    }
        -: 5393:
      293: 5394:  if (dynsyms)
        -: 5395:    {
    #####: 5396:      free (dynsyms);
    #####: 5397:      dynsyms = NULL;
        -: 5398:    }
        -: 5399:
      293: 5400:  if (synthsyms)
        -: 5401:    {
    #####: 5402:      free (synthsyms);
    #####: 5403:      synthsyms = NULL;
        -: 5404:    }
        -: 5405:
      293: 5406:  symcount = 0;
      293: 5407:  dynsymcount = 0;
      293: 5408:  synthcount = 0;
        -: 5409:
      293: 5410:  if (is_mainfile)
      293: 5411:    free_debug_memory ();
      293: 5412:}
        -: 5413:
        -: 5414:static void
      399: 5415:display_object_bfd (bfd *abfd)
        -: 5416:{
        -: 5417:  char **matching;
        -: 5418:
      399: 5419:  if (bfd_check_format_matches (abfd, bfd_object, &matching))
        -: 5420:    {
      278: 5421:      dump_bfd (abfd, true);
      293: 5422:      return;
        -: 5423:    }
        -: 5424:
      121: 5425:  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
        -: 5426:    {
    #####: 5427:      nonfatal (bfd_get_filename (abfd));
    #####: 5428:      list_matching_formats (matching);
    #####: 5429:      return;
        -: 5430:    }
        -: 5431:
      121: 5432:  if (bfd_get_error () != bfd_error_file_not_recognized)
        -: 5433:    {
    #####: 5434:      nonfatal (bfd_get_filename (abfd));
    #####: 5435:      return;
        -: 5436:    }
        -: 5437:
      121: 5438:  if (bfd_check_format_matches (abfd, bfd_core, &matching))
        -: 5439:    {
       15: 5440:      dump_bfd (abfd, true);
       15: 5441:      return;
        -: 5442:    }
        -: 5443:
      106: 5444:  nonfatal (bfd_get_filename (abfd));
        -: 5445:
      106: 5446:  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    #####: 5447:    list_matching_formats (matching);
        -: 5448:}
        -: 5449:
        -: 5450:static void
      399: 5451:display_any_bfd (bfd *file, int level)
        -: 5452:{
        -: 5453:  /* Decompress sections unless dumping the section contents.  */
      399: 5454:  if (!dump_section_contents)
      399: 5455:    file->flags |= BFD_DECOMPRESS;
        -: 5456:
        -: 5457:  /* If the file is an archive, process all of its elements.  */
      399: 5458:  if (bfd_check_format (file, bfd_archive))
        -: 5459:    {
    #####: 5460:      bfd *arfile = NULL;
    #####: 5461:      bfd *last_arfile = NULL;
        -: 5462:
    #####: 5463:      if (level == 0)
    #####: 5464:	printf (_("In archive %s:\n"), sanitize_string (bfd_get_filename (file)));
    #####: 5465:      else if (level > 100)
        -: 5466:	{
        -: 5467:	  /* Prevent corrupted files from spinning us into an
        -: 5468:	     infinite loop.  100 is an arbitrary heuristic.  */
    #####: 5469:	  fatal (_("Archive nesting is too deep"));
        -: 5470:	  return;
        -: 5471:	}
        -: 5472:      else
    #####: 5473:	printf (_("In nested archive %s:\n"),
        -: 5474:		sanitize_string (bfd_get_filename (file)));
        -: 5475:
        -: 5476:      for (;;)
        -: 5477:	{
    #####: 5478:	  bfd_set_error (bfd_error_no_error);
        -: 5479:
    #####: 5480:	  arfile = bfd_openr_next_archived_file (file, arfile);
    #####: 5481:	  if (arfile == NULL)
        -: 5482:	    {
    #####: 5483:	      if (bfd_get_error () != bfd_error_no_more_archived_files)
    #####: 5484:		nonfatal (bfd_get_filename (file));
    #####: 5485:	      break;
        -: 5486:	    }
        -: 5487:
    #####: 5488:	  display_any_bfd (arfile, level + 1);
        -: 5489:
    #####: 5490:	  if (last_arfile != NULL)
        -: 5491:	    {
    #####: 5492:	      bfd_close (last_arfile);
        -: 5493:	      /* PR 17512: file: ac585d01.  */
    #####: 5494:	      if (arfile == last_arfile)
        -: 5495:		{
    #####: 5496:		  last_arfile = NULL;
    #####: 5497:		  break;
        -: 5498:		}
        -: 5499:	    }
    #####: 5500:	  last_arfile = arfile;
        -: 5501:	}
        -: 5502:
    #####: 5503:      if (last_arfile != NULL)
    #####: 5504:	bfd_close (last_arfile);
        -: 5505:    }
        -: 5506:  else
      399: 5507:    display_object_bfd (file);
        -: 5508:}
        -: 5509:
        -: 5510:static void
      399: 5511:display_file (char *filename, char *target, bool last_file)
        -: 5512:{
        -: 5513:  bfd *file;
        -: 5514:
      399: 5515:  if (get_file_size (filename) < 1)
        -: 5516:    {
    #####: 5517:      exit_status = 1;
    #####: 5518:      return;
        -: 5519:    }
        -: 5520:
      399: 5521:  file = bfd_openr (filename, target);
      399: 5522:  if (file == NULL)
        -: 5523:    {
    #####: 5524:      nonfatal (filename);
    #####: 5525:      return;
        -: 5526:    }
        -: 5527:
      399: 5528:  display_any_bfd (file, 0);
        -: 5529:
        -: 5530:  /* This is an optimization to improve the speed of objdump, especially when
        -: 5531:     dumping a file with lots of associated debug informatiom.  Calling
        -: 5532:     bfd_close on such a file can take a non-trivial amount of time as there
        -: 5533:     are lots of lists to walk and buffers to free.  This is only really
        -: 5534:     necessary however if we are about to load another file and we need the
        -: 5535:     memory back.  Otherwise, if we are about to exit, then we can save (a lot
        -: 5536:     of) time by only doing a quick close, and allowing the OS to reclaim the
        -: 5537:     memory for us.  */
      399: 5538:  if (! last_file)
      398: 5539:    bfd_close (file);
        -: 5540:  else
        1: 5541:    bfd_close_all_done (file);
        -: 5542:}
        -: 5543:
        -: 5544:int
        1: 5545:main (int argc, char **argv)
        -: 5546:{
        -: 5547:  int c;
        1: 5548:  char *target = default_target;
        1: 5549:  bool seenflag = false;
        -: 5550:
        -: 5551:#ifdef HAVE_LC_MESSAGES
        1: 5552:  setlocale (LC_MESSAGES, "");
        -: 5553:#endif
        1: 5554:  setlocale (LC_CTYPE, "");
        -: 5555:
        1: 5556:  bindtextdomain (PACKAGE, LOCALEDIR);
        1: 5557:  textdomain (PACKAGE);
        -: 5558:
        1: 5559:  program_name = *argv;
        1: 5560:  xmalloc_set_program_name (program_name);
        1: 5561:  bfd_set_error_program_name (program_name);
        -: 5562:
        -: 5563:  START_PROGRESS (program_name, 0);
        -: 5564:
        1: 5565:  expandargv (&argc, &argv);
        -: 5566:
        1: 5567:  if (bfd_init () != BFD_INIT_MAGIC)
    #####: 5568:    fatal (_("fatal error: libbfd ABI mismatch"));
        1: 5569:  set_default_bfd_target ();
        -: 5570:
        3: 5571:  while ((c = getopt_long (argc, argv,
        -: 5572:			   "CDE:FGHI:LM:P:RSTU:VW::ab:defghij:lm:prstvwxz",
        -: 5573:			   long_options, (int *) 0))
        -: 5574:	 != EOF)
        -: 5575:    {
        2: 5576:      switch (c)
        -: 5577:	{
    #####: 5578:	case 0:
    #####: 5579:	  break;		/* We've been given a long option.  */
    #####: 5580:	case 'm':
    #####: 5581:	  machine = optarg;
    #####: 5582:	  break;
    #####: 5583:	case 'M':
        -: 5584:	  {
        -: 5585:	    char *options;
    #####: 5586:	    if (disassembler_options)
        -: 5587:	      /* Ignore potential memory leak for now.  */
    #####: 5588:	      options = concat (disassembler_options, ",",
        -: 5589:				optarg, (const char *) NULL);
        -: 5590:	    else
    #####: 5591:	      options = optarg;
    #####: 5592:	    disassembler_options = remove_whitespace_and_extra_commas (options);
        -: 5593:	  }
    #####: 5594:	  break;
    #####: 5595:	case 'j':
    #####: 5596:	  add_only (optarg);
    #####: 5597:	  break;
    #####: 5598:	case 'F':
    #####: 5599:	  display_file_offsets = true;
    #####: 5600:	  break;
    #####: 5601:	case 'l':
    #####: 5602:	  with_line_numbers = true;
    #####: 5603:	  break;
    #####: 5604:	case 'b':
    #####: 5605:	  target = optarg;
    #####: 5606:	  break;
    #####: 5607:	case 'C':
    #####: 5608:	  do_demangle = true;
    #####: 5609:	  if (optarg != NULL)
        -: 5610:	    {
        -: 5611:	      enum demangling_styles style;
        -: 5612:
    #####: 5613:	      style = cplus_demangle_name_to_style (optarg);
    #####: 5614:	      if (style == unknown_demangling)
    #####: 5615:		fatal (_("unknown demangling style `%s'"),
        -: 5616:		       optarg);
        -: 5617:
    #####: 5618:	      cplus_demangle_set_style (style);
        -: 5619:	    }
    #####: 5620:	  break;
    #####: 5621:	case OPTION_RECURSE_LIMIT:
    #####: 5622:	  demangle_flags &= ~ DMGL_NO_RECURSE_LIMIT;
    #####: 5623:	  break;
    #####: 5624:	case OPTION_NO_RECURSE_LIMIT:
    #####: 5625:	  demangle_flags |= DMGL_NO_RECURSE_LIMIT;
    #####: 5626:	  break;
    #####: 5627:	case 'w':
    #####: 5628:	  do_wide = wide_output = true;
    #####: 5629:	  break;
    #####: 5630:	case OPTION_ADJUST_VMA:
    #####: 5631:	  adjust_section_vma = parse_vma (optarg, "--adjust-vma");
    #####: 5632:	  break;
    #####: 5633:	case OPTION_START_ADDRESS:
    #####: 5634:	  start_address = parse_vma (optarg, "--start-address");
    #####: 5635:	  if ((stop_address != (bfd_vma) -1) && stop_address <= start_address)
    #####: 5636:	    fatal (_("error: the start address should be before the end address"));
    #####: 5637:	  break;
    #####: 5638:	case OPTION_STOP_ADDRESS:
    #####: 5639:	  stop_address = parse_vma (optarg, "--stop-address");
    #####: 5640:	  if ((start_address != (bfd_vma) -1) && stop_address <= start_address)
    #####: 5641:	    fatal (_("error: the stop address should be after the start address"));
    #####: 5642:	  break;
    #####: 5643:	case OPTION_PREFIX:
    #####: 5644:	  prefix = optarg;
    #####: 5645:	  prefix_length = strlen (prefix);
        -: 5646:	  /* Remove an unnecessary trailing '/' */
    #####: 5647:	  while (IS_DIR_SEPARATOR (prefix[prefix_length - 1]))
    #####: 5648:	    prefix_length--;
    #####: 5649:	  break;
    #####: 5650:	case OPTION_PREFIX_STRIP:
    #####: 5651:	  prefix_strip = atoi (optarg);
    #####: 5652:	  if (prefix_strip < 0)
    #####: 5653:	    fatal (_("error: prefix strip must be non-negative"));
    #####: 5654:	  break;
    #####: 5655:	case OPTION_INSN_WIDTH:
    #####: 5656:	  insn_width = strtoul (optarg, NULL, 0);
    #####: 5657:	  if (insn_width <= 0)
    #####: 5658:	    fatal (_("error: instruction width must be positive"));
    #####: 5659:	  break;
    #####: 5660:	case OPTION_INLINES:
    #####: 5661:	  unwind_inlines = true;
    #####: 5662:	  break;
    #####: 5663:	case OPTION_VISUALIZE_JUMPS:
    #####: 5664:	  visualize_jumps = true;
    #####: 5665:	  color_output = false;
    #####: 5666:	  extended_color_output = false;
    #####: 5667:	  if (optarg != NULL)
        -: 5668:	    {
    #####: 5669:	      if (streq (optarg, "color"))
    #####: 5670:		color_output = true;
    #####: 5671:	      else if (streq (optarg, "extended-color"))
        -: 5672:		{
    #####: 5673:		  color_output = true;
    #####: 5674:		  extended_color_output = true;
        -: 5675:		}
    #####: 5676:	      else if (streq (optarg, "off"))
    #####: 5677:		visualize_jumps = false;
        -: 5678:	      else
    #####: 5679:		nonfatal (_("unrecognized argument to --visualize-option"));
        -: 5680:	    }
    #####: 5681:	  break;
    #####: 5682:	case OPTION_DISASSEMBLER_COLOR:
    #####: 5683:	  if (streq (optarg, "off"))
    #####: 5684:	    disassembler_color = false;
    #####: 5685:	  else if (streq (optarg, "color"))
    #####: 5686:	    disassembler_color = true;
    #####: 5687:	  else if (streq (optarg, "extended-color"))
    #####: 5688:	    disassembler_extended_color = true;
        -: 5689:	  else
    #####: 5690:	    nonfatal (_("unrecognized argument to --disassembler-color"));
    #####: 5691:	  break;
    #####: 5692:	case 'E':
    #####: 5693:	  if (strcmp (optarg, "B") == 0)
    #####: 5694:	    endian = BFD_ENDIAN_BIG;
    #####: 5695:	  else if (strcmp (optarg, "L") == 0)
    #####: 5696:	    endian = BFD_ENDIAN_LITTLE;
        -: 5697:	  else
        -: 5698:	    {
    #####: 5699:	      nonfatal (_("unrecognized -E option"));
    #####: 5700:	      usage (stderr, 1);
        -: 5701:	    }
    #####: 5702:	  break;
    #####: 5703:	case OPTION_ENDIAN:
    #####: 5704:	  if (strncmp (optarg, "big", strlen (optarg)) == 0)
    #####: 5705:	    endian = BFD_ENDIAN_BIG;
    #####: 5706:	  else if (strncmp (optarg, "little", strlen (optarg)) == 0)
    #####: 5707:	    endian = BFD_ENDIAN_LITTLE;
        -: 5708:	  else
        -: 5709:	    {
    #####: 5710:	      non_fatal (_("unrecognized --endian type `%s'"), optarg);
    #####: 5711:	      exit_status = 1;
    #####: 5712:	      usage (stderr, 1);
        -: 5713:	    }
    #####: 5714:	  break;
        -: 5715:
    #####: 5716:	case 'f':
    #####: 5717:	  dump_file_header = true;
    #####: 5718:	  seenflag = true;
    #####: 5719:	  break;
    #####: 5720:	case 'i':
    #####: 5721:	  formats_info = true;
    #####: 5722:	  seenflag = true;
    #####: 5723:	  break;
    #####: 5724:	case 'I':
    #####: 5725:	  add_include_path (optarg);
    #####: 5726:	  break;
    #####: 5727:	case 'p':
    #####: 5728:	  dump_private_headers = true;
    #####: 5729:	  seenflag = true;
    #####: 5730:	  break;
    #####: 5731:	case 'P':
    #####: 5732:	  dump_private_options = optarg;
    #####: 5733:	  seenflag = true;
    #####: 5734:	  break;
    #####: 5735:	case 'x':
    #####: 5736:	  dump_private_headers = true;
    #####: 5737:	  dump_symtab = true;
    #####: 5738:	  dump_reloc_info = true;
    #####: 5739:	  dump_file_header = true;
    #####: 5740:	  dump_ar_hdrs = true;
    #####: 5741:	  dump_section_headers = true;
    #####: 5742:	  seenflag = true;
    #####: 5743:	  break;
    #####: 5744:	case 't':
    #####: 5745:	  dump_symtab = true;
    #####: 5746:	  seenflag = true;
    #####: 5747:	  break;
    #####: 5748:	case 'T':
    #####: 5749:	  dump_dynamic_symtab = true;
    #####: 5750:	  seenflag = true;
    #####: 5751:	  break;
    #####: 5752:	case 'd':
    #####: 5753:	  disassemble = true;
    #####: 5754:	  seenflag = true;
    #####: 5755:	  disasm_sym = optarg;
    #####: 5756:	  break;
    #####: 5757:	case 'z':
    #####: 5758:	  disassemble_zeroes = true;
    #####: 5759:	  break;
        1: 5760:	case 'D':
        1: 5761:	  disassemble = true;
        1: 5762:	  disassemble_all = true;
        1: 5763:	  seenflag = true;
        1: 5764:	  break;
        1: 5765:	case 'S':
        1: 5766:	  disassemble = true;
        1: 5767:	  with_source_code = true;
        1: 5768:	  seenflag = true;
        1: 5769:	  break;
    #####: 5770:	case OPTION_SOURCE_COMMENT:
    #####: 5771:	  disassemble = true;
    #####: 5772:	  with_source_code = true;
    #####: 5773:	  seenflag = true;
    #####: 5774:	  if (optarg)
    #####: 5775:	    source_comment = xstrdup (sanitize_string (optarg));
        -: 5776:	  else
    #####: 5777:	    source_comment = xstrdup ("# ");
    #####: 5778:	  break;
    #####: 5779:	case 'g':
    #####: 5780:	  dump_debugging = 1;
    #####: 5781:	  seenflag = true;
    #####: 5782:	  break;
    #####: 5783:	case 'e':
    #####: 5784:	  dump_debugging = 1;
    #####: 5785:	  dump_debugging_tags = 1;
    #####: 5786:	  do_demangle = true;
    #####: 5787:	  seenflag = true;
    #####: 5788:	  break;
    #####: 5789:	case 'L':
    #####: 5790:	  process_links = true;
    #####: 5791:	  do_follow_links = true;
    #####: 5792:	  break;
    #####: 5793:	case 'W':
    #####: 5794:	  seenflag = true;
    #####: 5795:	  if (optarg)
        -: 5796:	    {
    #####: 5797:	      if (dwarf_select_sections_by_letters (optarg))
    #####: 5798:		dump_dwarf_section_info = true;
        -: 5799:	    }
        -: 5800:	  else
        -: 5801:	    {
    #####: 5802:	      dump_dwarf_section_info = true;
    #####: 5803:	      dwarf_select_sections_all ();
        -: 5804:	    }
    #####: 5805:	  break;
    #####: 5806:	case OPTION_DWARF:
    #####: 5807:	  seenflag = true;
    #####: 5808:	  if (optarg)
        -: 5809:	    {
    #####: 5810:	      if (dwarf_select_sections_by_names (optarg))
    #####: 5811:		dump_dwarf_section_info = true;
        -: 5812:	    }
        -: 5813:	  else
        -: 5814:	    {
    #####: 5815:	      dwarf_select_sections_all ();
    #####: 5816:	      dump_dwarf_section_info = true;
        -: 5817:	    }
    #####: 5818:	  break;
    #####: 5819:	case OPTION_DWARF_DEPTH:
        -: 5820:	  {
        -: 5821:	    char *cp;
    #####: 5822:	    dwarf_cutoff_level = strtoul (optarg, & cp, 0);
        -: 5823:	  }
    #####: 5824:	  break;
    #####: 5825:	case OPTION_DWARF_START:
        -: 5826:	  {
        -: 5827:	    char *cp;
    #####: 5828:	    dwarf_start_die = strtoul (optarg, & cp, 0);
    #####: 5829:	    suppress_bfd_header = 1;
        -: 5830:	  }
    #####: 5831:	  break;
    #####: 5832:	case OPTION_DWARF_CHECK:
    #####: 5833:	  dwarf_check = true;
    #####: 5834:	  break;
        -: 5835:#ifdef ENABLE_LIBCTF
    #####: 5836:	case OPTION_CTF:
    #####: 5837:	  dump_ctf_section_info = true;
    #####: 5838:	  if (optarg)
    #####: 5839:	    dump_ctf_section_name = xstrdup (optarg);
    #####: 5840:	  seenflag = true;
    #####: 5841:	  break;
    #####: 5842:	case OPTION_CTF_PARENT:
    #####: 5843:	  dump_ctf_parent_name = xstrdup (optarg);
    #####: 5844:	  break;
        -: 5845:#endif
    #####: 5846:	case 'G':
    #####: 5847:	  dump_stab_section_info = true;
    #####: 5848:	  seenflag = true;
    #####: 5849:	  break;
    #####: 5850:	case 's':
    #####: 5851:	  dump_section_contents = true;
    #####: 5852:	  seenflag = true;
    #####: 5853:	  break;
    #####: 5854:	case 'r':
    #####: 5855:	  dump_reloc_info = true;
    #####: 5856:	  seenflag = true;
    #####: 5857:	  break;
    #####: 5858:	case 'R':
    #####: 5859:	  dump_dynamic_reloc_info = true;
    #####: 5860:	  seenflag = true;
    #####: 5861:	  break;
    #####: 5862:	case 'a':
    #####: 5863:	  dump_ar_hdrs = true;
    #####: 5864:	  seenflag = true;
    #####: 5865:	  break;
    #####: 5866:	case 'h':
    #####: 5867:	  dump_section_headers = true;
    #####: 5868:	  seenflag = true;
    #####: 5869:	  break;
    #####: 5870:	case 'v':
        -: 5871:	case 'V':
    #####: 5872:	  show_version = true;
    #####: 5873:	  seenflag = true;
    #####: 5874:	  break;
        -: 5875:
    #####: 5876:	case 'U':
    #####: 5877:	  if (streq (optarg, "default") || streq (optarg, "d"))
    #####: 5878:	    unicode_display = unicode_default;
    #####: 5879:	  else if (streq (optarg, "locale") || streq (optarg, "l"))
    #####: 5880:	    unicode_display = unicode_locale;
    #####: 5881:	  else if (streq (optarg, "escape") || streq (optarg, "e"))
    #####: 5882:	    unicode_display = unicode_escape;
    #####: 5883:	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
    #####: 5884:	    unicode_display = unicode_invalid;
    #####: 5885:	  else if (streq (optarg, "hex") || streq (optarg, "x"))
    #####: 5886:	    unicode_display = unicode_hex;
    #####: 5887:	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
    #####: 5888:	    unicode_display = unicode_highlight;
        -: 5889:	  else
    #####: 5890:	    fatal (_("invalid argument to -U/--unicode: %s"), optarg);
    #####: 5891:	  break;
        -: 5892:
    #####: 5893:	case 'H':
    #####: 5894:	  usage (stdout, 0);
        -: 5895:	  /* No need to set seenflag or to break - usage() does not return.  */
    #####: 5896:	default:
    #####: 5897:	  usage (stderr, 1);
        -: 5898:	}
        -: 5899:    }
        -: 5900:
        1: 5901:  if (show_version)
    #####: 5902:    print_version ("objdump");
        -: 5903:
        1: 5904:  if (!seenflag)
    #####: 5905:    usage (stderr, 2);
        -: 5906:
        2: 5907:  dump_any_debugging = (dump_debugging
        1: 5908:			|| dump_dwarf_section_info
       2*: 5909:			|| process_links);
        -: 5910:
        1: 5911:  if (formats_info)
    #####: 5912:    exit_status = display_info ();
        -: 5913:  else
        -: 5914:    {
        1: 5915:      if (optind == argc)
    #####: 5916:	display_file ("a.out", target, true);
        -: 5917:      else
      400: 5918:	for (; optind < argc;)
        -: 5919:	  {
      399: 5920:	    display_file (argv[optind], target, optind == argc - 1);
      399: 5921:	    optind++;
        -: 5922:	  }
        -: 5923:    }
        -: 5924:
        1: 5925:  free_only_list ();
        1: 5926:  free (dump_ctf_section_name);
        1: 5927:  free (dump_ctf_parent_name);
        1: 5928:  free ((void *) source_comment);
        -: 5929:
        -: 5930:  END_PROGRESS (program_name);
        -: 5931:
        1: 5932:  return exit_status;
        -: 5933:}
