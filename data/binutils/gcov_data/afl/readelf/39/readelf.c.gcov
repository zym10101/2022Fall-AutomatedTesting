        -:    0:Source:readelf.c
        -:    0:Graph:readelf.gcno
        -:    0:Data:readelf.gcda
        -:    0:Runs:39
        -:    1:/* readelf.c -- display contents of an ELF format file
        -:    2:   Copyright (C) 1998-2022 Free Software Foundation, Inc.
        -:    3:
        -:    4:   Originally developed by Eric Youngdale <eric@andante.jic.com>
        -:    5:   Modifications by Nick Clifton <nickc@redhat.com>
        -:    6:
        -:    7:   This file is part of GNU Binutils.
        -:    8:
        -:    9:   This program is free software; you can redistribute it and/or modify
        -:   10:   it under the terms of the GNU General Public License as published by
        -:   11:   the Free Software Foundation; either version 3 of the License, or
        -:   12:   (at your option) any later version.
        -:   13:
        -:   14:   This program is distributed in the hope that it will be useful,
        -:   15:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   16:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   17:   GNU General Public License for more details.
        -:   18:
        -:   19:   You should have received a copy of the GNU General Public License
        -:   20:   along with this program; if not, write to the Free Software
        -:   21:   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
        -:   22:   02110-1301, USA.  */
        -:   23:
        -:   24:/* The difference between readelf and objdump:
        -:   25:
        -:   26:  Both programs are capable of displaying the contents of ELF format files,
        -:   27:  so why does the binutils project have two file dumpers ?
        -:   28:
        -:   29:  The reason is that objdump sees an ELF file through a BFD filter of the
        -:   30:  world; if BFD has a bug where, say, it disagrees about a machine constant
        -:   31:  in e_flags, then the odds are good that it will remain internally
        -:   32:  consistent.  The linker sees it the BFD way, objdump sees it the BFD way,
        -:   33:  GAS sees it the BFD way.  There was need for a tool to go find out what
        -:   34:  the file actually says.
        -:   35:
        -:   36:  This is why the readelf program does not link against the BFD library - it
        -:   37:  exists as an independent program to help verify the correct working of BFD.
        -:   38:
        -:   39:  There is also the case that readelf can provide more information about an
        -:   40:  ELF file than is provided by objdump.  In particular it can display DWARF
        -:   41:  debugging information which (at the moment) objdump cannot.  */
        -:   42:
        -:   43:#include "sysdep.h"
        -:   44:#include <assert.h>
        -:   45:#include <time.h>
        -:   46:#include <zlib.h>
        -:   47:#include <wchar.h>
        -:   48:
        -:   49:#if defined HAVE_MSGPACK
        -:   50:#include <msgpack.h>
        -:   51:#endif
        -:   52:
        -:   53:#if __GNUC__ >= 2
        -:   54:/* Define BFD64 here, even if our default architecture is 32 bit ELF
        -:   55:   as this will allow us to read in and parse 64bit and 32bit ELF files.
        -:   56:   Only do this if we believe that the compiler can support a 64 bit
        -:   57:   data type.  For now we only rely on GCC being able to do this.  */
        -:   58:#define BFD64
        -:   59:#endif
        -:   60:
        -:   61:#include "bfd.h"
        -:   62:#include "bucomm.h"
        -:   63:#include "elfcomm.h"
        -:   64:#include "demanguse.h"
        -:   65:#include "dwarf.h"
        -:   66:#include "ctf-api.h"
        -:   67:#include "demangle.h"
        -:   68:
        -:   69:#include "elf/common.h"
        -:   70:#include "elf/external.h"
        -:   71:#include "elf/internal.h"
        -:   72:
        -:   73:
        -:   74:/* Included here, before RELOC_MACROS_GEN_FUNC is defined, so that
        -:   75:   we can obtain the H8 reloc numbers.  We need these for the
        -:   76:   get_reloc_size() function.  We include h8.h again after defining
        -:   77:   RELOC_MACROS_GEN_FUNC so that we get the naming function as well.  */
        -:   78:
        -:   79:#include "elf/h8.h"
        -:   80:#undef _ELF_H8_H
        -:   81:
        -:   82:/* Undo the effects of #including reloc-macros.h.  */
        -:   83:
        -:   84:#undef START_RELOC_NUMBERS
        -:   85:#undef RELOC_NUMBER
        -:   86:#undef FAKE_RELOC
        -:   87:#undef EMPTY_RELOC
        -:   88:#undef END_RELOC_NUMBERS
        -:   89:#undef _RELOC_MACROS_H
        -:   90:
        -:   91:/* The following headers use the elf/reloc-macros.h file to
        -:   92:   automatically generate relocation recognition functions
        -:   93:   such as elf_mips_reloc_type()  */
        -:   94:
        -:   95:#define RELOC_MACROS_GEN_FUNC
        -:   96:
        -:   97:#include "elf/aarch64.h"
        -:   98:#include "elf/alpha.h"
        -:   99:#include "elf/amdgpu.h"
        -:  100:#include "elf/arc.h"
        -:  101:#include "elf/arm.h"
        -:  102:#include "elf/avr.h"
        -:  103:#include "elf/bfin.h"
        -:  104:#include "elf/cr16.h"
        -:  105:#include "elf/cris.h"
        -:  106:#include "elf/crx.h"
        -:  107:#include "elf/csky.h"
        -:  108:#include "elf/d10v.h"
        -:  109:#include "elf/d30v.h"
        -:  110:#include "elf/dlx.h"
        -:  111:#include "elf/bpf.h"
        -:  112:#include "elf/epiphany.h"
        -:  113:#include "elf/fr30.h"
        -:  114:#include "elf/frv.h"
        -:  115:#include "elf/ft32.h"
        -:  116:#include "elf/h8.h"
        -:  117:#include "elf/hppa.h"
        -:  118:#include "elf/i386.h"
        -:  119:#include "elf/i370.h"
        -:  120:#include "elf/i860.h"
        -:  121:#include "elf/i960.h"
        -:  122:#include "elf/ia64.h"
        -:  123:#include "elf/ip2k.h"
        -:  124:#include "elf/lm32.h"
        -:  125:#include "elf/iq2000.h"
        -:  126:#include "elf/m32c.h"
        -:  127:#include "elf/m32r.h"
        -:  128:#include "elf/m68k.h"
        -:  129:#include "elf/m68hc11.h"
        -:  130:#include "elf/s12z.h"
        -:  131:#include "elf/mcore.h"
        -:  132:#include "elf/mep.h"
        -:  133:#include "elf/metag.h"
        -:  134:#include "elf/microblaze.h"
        -:  135:#include "elf/mips.h"
        -:  136:#include "elf/mmix.h"
        -:  137:#include "elf/mn10200.h"
        -:  138:#include "elf/mn10300.h"
        -:  139:#include "elf/moxie.h"
        -:  140:#include "elf/mt.h"
        -:  141:#include "elf/msp430.h"
        -:  142:#include "elf/nds32.h"
        -:  143:#include "elf/nfp.h"
        -:  144:#include "elf/nios2.h"
        -:  145:#include "elf/or1k.h"
        -:  146:#include "elf/pj.h"
        -:  147:#include "elf/ppc.h"
        -:  148:#include "elf/ppc64.h"
        -:  149:#include "elf/pru.h"
        -:  150:#include "elf/riscv.h"
        -:  151:#include "elf/rl78.h"
        -:  152:#include "elf/rx.h"
        -:  153:#include "elf/s390.h"
        -:  154:#include "elf/score.h"
        -:  155:#include "elf/sh.h"
        -:  156:#include "elf/sparc.h"
        -:  157:#include "elf/spu.h"
        -:  158:#include "elf/tic6x.h"
        -:  159:#include "elf/tilegx.h"
        -:  160:#include "elf/tilepro.h"
        -:  161:#include "elf/v850.h"
        -:  162:#include "elf/vax.h"
        -:  163:#include "elf/visium.h"
        -:  164:#include "elf/wasm32.h"
        -:  165:#include "elf/x86-64.h"
        -:  166:#include "elf/xgate.h"
        -:  167:#include "elf/xstormy16.h"
        -:  168:#include "elf/xtensa.h"
        -:  169:#include "elf/z80.h"
        -:  170:#include "elf/loongarch.h"
        -:  171:
        -:  172:#include "getopt.h"
        -:  173:#include "libiberty.h"
        -:  174:#include "safe-ctype.h"
        -:  175:#include "filenames.h"
        -:  176:
        -:  177:#ifndef offsetof
        -:  178:#define offsetof(TYPE, MEMBER) ((size_t) &(((TYPE *) 0)->MEMBER))
        -:  179:#endif
        -:  180:
        -:  181:typedef struct elf_section_list
        -:  182:{
        -:  183:  Elf_Internal_Shdr *        hdr;
        -:  184:  struct elf_section_list *  next;
        -:  185:} elf_section_list;
        -:  186:
        -:  187:/* Flag bits indicating particular types of dump.  */
        -:  188:#define HEX_DUMP	(1 << 0)	/* The -x command line switch.  */
        -:  189:#define DISASS_DUMP	(1 << 1)	/* The -i command line switch.  */
        -:  190:#define DEBUG_DUMP	(1 << 2)	/* The -w command line switch.  */
        -:  191:#define STRING_DUMP     (1 << 3)	/* The -p command line switch.  */
        -:  192:#define RELOC_DUMP      (1 << 4)	/* The -R command line switch.  */
        -:  193:#define CTF_DUMP	(1 << 5)	/* The --ctf command line switch.  */
        -:  194:
        -:  195:typedef unsigned char dump_type;
        -:  196:
        -:  197:/* A linked list of the section names for which dumps were requested.  */
        -:  198:struct dump_list_entry
        -:  199:{
        -:  200:  char *                    name;
        -:  201:  dump_type                 type;
        -:  202:  struct dump_list_entry *  next;
        -:  203:};
        -:  204:
        -:  205:/* A dynamic array of flags indicating for which sections a dump
        -:  206:   has been requested via command line switches.  */
        -:  207:struct dump_data
        -:  208:{
        -:  209:  dump_type *          dump_sects;
        -:  210:  unsigned int         num_dump_sects;
        -:  211:};
        -:  212:
        -:  213:static struct dump_data cmdline;
        -:  214:
        -:  215:static struct dump_list_entry * dump_sects_byname;
        -:  216:
        -:  217:char * program_name = "readelf";
        -:  218:
        -:  219:static bool show_name = false;
        -:  220:static bool do_dynamic = false;
        -:  221:static bool do_syms = false;
        -:  222:static bool do_dyn_syms = false;
        -:  223:static bool do_lto_syms = false;
        -:  224:static bool do_reloc = false;
        -:  225:static bool do_sections = false;
        -:  226:static bool do_section_groups = false;
        -:  227:static bool do_section_details = false;
        -:  228:static bool do_segments = false;
        -:  229:static bool do_unwind = false;
        -:  230:static bool do_using_dynamic = false;
        -:  231:static bool do_header = false;
        -:  232:static bool do_dump = false;
        -:  233:static bool do_version = false;
        -:  234:static bool do_histogram = false;
        -:  235:static bool do_debugging = false;
        -:  236:static bool do_ctf = false;
        -:  237:static bool do_arch = false;
        -:  238:static bool do_notes = false;
        -:  239:static bool do_archive_index = false;
        -:  240:static bool check_all = false;
        -:  241:static bool is_32bit_elf = false;
        -:  242:static bool decompress_dumps = false;
        -:  243:static bool do_not_show_symbol_truncation = false;
        -:  244:static bool do_demangle = false;	/* Pretty print C++ symbol names.  */
        -:  245:static bool process_links = false;
        -:  246:static bool dump_any_debugging = false;
        -:  247:static int demangle_flags = DMGL_ANSI | DMGL_PARAMS;
        -:  248:static int sym_base = 0;
        -:  249:
        -:  250:static char *dump_ctf_parent_name;
        -:  251:static char *dump_ctf_symtab_name;
        -:  252:static char *dump_ctf_strtab_name;
        -:  253:
        -:  254:struct group_list
        -:  255:{
        -:  256:  struct group_list *  next;
        -:  257:  unsigned int         section_index;
        -:  258:};
        -:  259:
        -:  260:struct group
        -:  261:{
        -:  262:  struct group_list *  root;
        -:  263:  unsigned int         group_index;
        -:  264:};
        -:  265:
        -:  266:typedef struct filedata
        -:  267:{
        -:  268:  const char *         file_name;
        -:  269:  bool                 is_separate;
        -:  270:  FILE *               handle;
        -:  271:  bfd_size_type        file_size;
        -:  272:  Elf_Internal_Ehdr    file_header;
        -:  273:  unsigned long        archive_file_offset;
        -:  274:  unsigned long        archive_file_size;
        -:  275:  /* Everything below this point is cleared out by free_filedata.  */
        -:  276:  Elf_Internal_Shdr *  section_headers;
        -:  277:  Elf_Internal_Phdr *  program_headers;
        -:  278:  char *               string_table;
        -:  279:  unsigned long        string_table_length;
        -:  280:  unsigned long        dynamic_addr;
        -:  281:  bfd_size_type        dynamic_size;
        -:  282:  size_t               dynamic_nent;
        -:  283:  Elf_Internal_Dyn *   dynamic_section;
        -:  284:  Elf_Internal_Shdr *  dynamic_strtab_section;
        -:  285:  char *               dynamic_strings;
        -:  286:  unsigned long        dynamic_strings_length;
        -:  287:  Elf_Internal_Shdr *  dynamic_symtab_section;
        -:  288:  unsigned long        num_dynamic_syms;
        -:  289:  Elf_Internal_Sym *   dynamic_symbols;
        -:  290:  bfd_vma              version_info[16];
        -:  291:  unsigned int         dynamic_syminfo_nent;
        -:  292:  Elf_Internal_Syminfo * dynamic_syminfo;
        -:  293:  unsigned long        dynamic_syminfo_offset;
        -:  294:  bfd_size_type        nbuckets;
        -:  295:  bfd_size_type        nchains;
        -:  296:  bfd_vma *            buckets;
        -:  297:  bfd_vma *            chains;
        -:  298:  bfd_size_type        ngnubuckets;
        -:  299:  bfd_size_type        ngnuchains;
        -:  300:  bfd_vma *            gnubuckets;
        -:  301:  bfd_vma *            gnuchains;
        -:  302:  bfd_vma *            mipsxlat;
        -:  303:  bfd_vma              gnusymidx;
        -:  304:  char *               program_interpreter;
        -:  305:  bfd_vma              dynamic_info[DT_ENCODING];
        -:  306:  bfd_vma              dynamic_info_DT_GNU_HASH;
        -:  307:  bfd_vma              dynamic_info_DT_MIPS_XHASH;
        -:  308:  elf_section_list *   symtab_shndx_list;
        -:  309:  size_t               group_count;
        -:  310:  struct group *       section_groups;
        -:  311:  struct group **      section_headers_groups;
        -:  312:  /* A dynamic array of flags indicating for which sections a dump of
        -:  313:     some kind has been requested.  It is reset on a per-object file
        -:  314:     basis and then initialised from the cmdline_dump_sects array,
        -:  315:     the results of interpreting the -w switch, and the
        -:  316:     dump_sects_byname list.  */
        -:  317:  struct dump_data     dump;
        -:  318:} Filedata;
        -:  319:
        -:  320:/* How to print a vma value.  */
        -:  321:typedef enum print_mode
        -:  322:{
        -:  323:  HEX,
        -:  324:  HEX_5,
        -:  325:  DEC,
        -:  326:  DEC_5,
        -:  327:  UNSIGNED,
        -:  328:  UNSIGNED_5,
        -:  329:  PREFIX_HEX,
        -:  330:  PREFIX_HEX_5,
        -:  331:  FULL_HEX,
        -:  332:  LONG_HEX,
        -:  333:  OCTAL,
        -:  334:  OCTAL_5
        -:  335:}
        -:  336:print_mode;
        -:  337:
        -:  338:typedef enum unicode_display_type
        -:  339:{
        -:  340:  unicode_default = 0,
        -:  341:  unicode_locale,
        -:  342:  unicode_escape,
        -:  343:  unicode_hex,
        -:  344:  unicode_highlight,
        -:  345:  unicode_invalid
        -:  346:} unicode_display_type;
        -:  347:
        -:  348:static unicode_display_type unicode_display = unicode_default;
        -:  349:
        -:  350:typedef enum
        -:  351:{
        -:  352:  reltype_unknown,
        -:  353:  reltype_rel,
        -:  354:  reltype_rela,
        -:  355:  reltype_relr
        -:  356:} relocation_type;
        -:  357:
        -:  358:/* Versioned symbol info.  */
        -:  359:enum versioned_symbol_info
        -:  360:{
        -:  361:  symbol_undefined,
        -:  362:  symbol_hidden,
        -:  363:  symbol_public
        -:  364:};
        -:  365:
        -:  366:static const char * get_symbol_version_string
        -:  367:  (Filedata *, bool, const char *, unsigned long, unsigned,
        -:  368:   Elf_Internal_Sym *, enum versioned_symbol_info *, unsigned short *);
        -:  369:
        -:  370:#define UNKNOWN -1
        -:  371:
        -:  372:static inline const char *
     6329:  373:section_name (const Filedata *filedata, const Elf_Internal_Shdr *hdr)
        -:  374:{
     6329:  375:  return filedata->string_table + hdr->sh_name;
        -:  376:}
        -:  377:
        -:  378:static inline bool
      271:  379:section_name_valid (const Filedata *filedata, const Elf_Internal_Shdr *hdr)
        -:  380:{
        -:  381:  return (hdr != NULL
      271:  382:	  && filedata->string_table != NULL
      542:  383:	  && hdr->sh_name < filedata->string_table_length);
        -:  384:}
        -:  385:
        -:  386:static inline const char *
     8337:  387:section_name_print (const Filedata *filedata, const Elf_Internal_Shdr *hdr)
        -:  388:{
     8337:  389:  if (hdr == NULL)
    #####:  390:    return _("<none>");
     8337:  391:  if (filedata->string_table == NULL)
     1829:  392:    return _("<no-strings>");
     6508:  393:  if (hdr->sh_name >= filedata->string_table_length)
      392:  394:    return _("<corrupt>");
     6116:  395:  return section_name (filedata, hdr);
        -:  396:}
        -:  397:
        -:  398:#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order!  */
        -:  399:
        -:  400:static inline bool
      160:  401:valid_symbol_name (const char *strtab, size_t strtab_size, uint64_t offset)
        -:  402:{
      160:  403:  return strtab != NULL && offset < strtab_size;
        -:  404:}
        -:  405:
        -:  406:static inline bool
       18:  407:valid_dynamic_name (const Filedata *filedata, uint64_t offset)
        -:  408:{
       18:  409:  return valid_symbol_name (filedata->dynamic_strings,
        -:  410:			    filedata->dynamic_strings_length, offset);
        -:  411:}
        -:  412:
        -:  413:/* GET_DYNAMIC_NAME asssumes that VALID_DYNAMIC_NAME has
        -:  414:   already been called and verified that the string exists.  */
        -:  415:static inline const char *
    #####:  416:get_dynamic_name (const Filedata *filedata, size_t offset)
        -:  417:{
    #####:  418:  return filedata->dynamic_strings + offset;
        -:  419:}
        -:  420:
        -:  421:#define REMOVE_ARCH_BITS(ADDR)			\
        -:  422:  do						\
        -:  423:    {						\
        -:  424:      if (filedata->file_header.e_machine == EM_ARM)	\
        -:  425:	(ADDR) &= ~1;				\
        -:  426:    }						\
        -:  427:  while (0)
        -:  428:
        -:  429:/* Get the correct GNU hash section name.  */
        -:  430:#define GNU_HASH_SECTION_NAME(filedata)		\
        -:  431:  filedata->dynamic_info_DT_MIPS_XHASH ? ".MIPS.xhash" : ".gnu.hash"
        -:  432:
        -:  433:/* Print a BFD_VMA to an internal buffer, for use in error messages.
        -:  434:   BFD_FMA_FMT can't be used in translated strings.  */
        -:  435:
        -:  436:static const char *
      596:  437:bfd_vmatoa (char *fmtch, bfd_vma value)
        -:  438:{
        -:  439:  /* bfd_vmatoa is used more then once in a printf call for output.
        -:  440:     Cycle through an array of buffers.  */
        -:  441:  static int buf_pos = 0;
        -:  442:  static struct bfd_vmatoa_buf
        -:  443:  {
        -:  444:    char place[64];
        -:  445:  } buf[4];
        -:  446:  char *ret;
        -:  447:  char fmt[32];
        -:  448:
      596:  449:  ret = buf[buf_pos++].place;
      596:  450:  buf_pos %= ARRAY_SIZE (buf);
        -:  451:
      596:  452:  sprintf (fmt, "%%%s%s", BFD_VMA_FMT, fmtch);
      596:  453:  snprintf (ret, sizeof (buf[0].place), fmt, value);
      596:  454:  return ret;
        -:  455:}
        -:  456:
        -:  457:/* Retrieve NMEMB structures, each SIZE bytes long from FILEDATA starting at
        -:  458:   OFFSET + the offset of the current archive member, if we are examining an
        -:  459:   archive.  Put the retrieved data into VAR, if it is not NULL.  Otherwise
        -:  460:   allocate a buffer using malloc and fill that.  In either case return the
        -:  461:   pointer to the start of the retrieved data or NULL if something went wrong.
        -:  462:   If something does go wrong and REASON is not NULL then emit an error
        -:  463:   message using REASON as part of the context.  */
        -:  464:
        -:  465:static void *
     4385:  466:get_data (void *         var,
        -:  467:	  Filedata *     filedata,
        -:  468:	  unsigned long  offset,
        -:  469:	  bfd_size_type  size,
        -:  470:	  bfd_size_type  nmemb,
        -:  471:	  const char *   reason)
        -:  472:{
        -:  473:  void * mvar;
     4385:  474:  bfd_size_type amt = size * nmemb;
        -:  475:
     4385:  476:  if (size == 0 || nmemb == 0)
        8:  477:    return NULL;
        -:  478:
        -:  479:  /* If the size_t type is smaller than the bfd_size_type, eg because
        -:  480:     you are building a 32-bit tool on a 64-bit host, then make sure
        -:  481:     that when the sizes are cast to (size_t) no information is lost.  */
        -:  482:  if ((size_t) size != size
        -:  483:      || (size_t) nmemb != nmemb
        -:  484:      || (size_t) amt != amt)
        -:  485:    {
        -:  486:      if (reason)
        -:  487:	error (_("Size truncation prevents reading %s"
        -:  488:		 " elements of size %s for %s\n"),
        -:  489:	       bfd_vmatoa ("u", nmemb), bfd_vmatoa ("u", size), reason);
        -:  490:      return NULL;
        -:  491:    }
        -:  492:
        -:  493:  /* Check for size overflow.  */
     4377:  494:  if (amt / size != nmemb || (size_t) amt + 1 == 0)
        -:  495:    {
    #####:  496:      if (reason)
    #####:  497:	error (_("Size overflow prevents reading %s"
        -:  498:		 " elements of size %s for %s\n"),
        -:  499:	       bfd_vmatoa ("u", nmemb), bfd_vmatoa ("u", size), reason);
    #####:  500:      return NULL;
        -:  501:    }
        -:  502:
        -:  503:  /* Be kind to memory checkers (eg valgrind, address sanitizer) by not
        -:  504:     attempting to allocate memory when the read is bound to fail.  */
     4377:  505:  if (filedata->archive_file_offset > filedata->file_size
     4377:  506:      || offset > filedata->file_size - filedata->archive_file_offset
     3804:  507:      || amt > filedata->file_size - filedata->archive_file_offset - offset)
        -:  508:    {
      847:  509:      if (reason)
      596:  510:	error (_("Reading %s bytes extends past end of file for %s\n"),
        -:  511:	       bfd_vmatoa ("u", amt), reason);
      847:  512:      return NULL;
        -:  513:    }
        -:  514:
     3530:  515:  if (fseek (filedata->handle, filedata->archive_file_offset + offset,
        -:  516:	     SEEK_SET))
        -:  517:    {
    #####:  518:      if (reason)
    #####:  519:	error (_("Unable to seek to 0x%lx for %s\n"),
    #####:  520:	       filedata->archive_file_offset + offset, reason);
    #####:  521:      return NULL;
        -:  522:    }
        -:  523:
     3530:  524:  mvar = var;
     3530:  525:  if (mvar == NULL)
        -:  526:    {
        -:  527:      /* + 1 so that we can '\0' terminate invalid string table sections.  */
     3530:  528:      mvar = malloc ((size_t) amt + 1);
        -:  529:
     3530:  530:      if (mvar == NULL)
        -:  531:	{
    #####:  532:	  if (reason)
    #####:  533:	    error (_("Out of memory allocating %s bytes for %s\n"),
        -:  534:		   bfd_vmatoa ("u", amt), reason);
    #####:  535:	  return NULL;
        -:  536:	}
        -:  537:
     3530:  538:      ((char *) mvar)[amt] = '\0';
        -:  539:    }
        -:  540:
     3530:  541:  if (fread (mvar, (size_t) size, (size_t) nmemb, filedata->handle) != nmemb)
        -:  542:    {
    #####:  543:      if (reason)
    #####:  544:	error (_("Unable to read in %s bytes of %s\n"),
        -:  545:	       bfd_vmatoa ("u", amt), reason);
    #####:  546:      if (mvar != var)
    #####:  547:	free (mvar);
    #####:  548:      return NULL;
        -:  549:    }
        -:  550:
     3530:  551:  return mvar;
        -:  552:}
        -:  553:
        -:  554:/* Print a VMA value in the MODE specified.
        -:  555:   Returns the number of characters displayed.  */
        -:  556:
        -:  557:static unsigned int
     8126:  558:print_vma (bfd_vma vma, print_mode mode)
        -:  559:{
     8126:  560:  unsigned int nc = 0;
        -:  561:
     8126:  562:  switch (mode)
        -:  563:    {
       80:  564:    case FULL_HEX:
       80:  565:      nc = printf ("0x");
        -:  566:      /* Fall through.  */
     3730:  567:    case LONG_HEX:
        -:  568:#ifdef BFD64
     3730:  569:      if (is_32bit_elf)
     3730:  570:	return nc + printf ("%8.8" BFD_VMA_FMT "x", vma);
        -:  571:#endif
    #####:  572:      printf_vma (vma);
    #####:  573:      return nc + 16;
        -:  574:
      143:  575:    case DEC_5:
      143:  576:      if (vma <= 99999)
       82:  577:	return printf ("%5" BFD_VMA_FMT "d", vma);
        -:  578:      /* Fall through.  */
        -:  579:    case PREFIX_HEX:
     1532:  580:      nc = printf ("0x");
        -:  581:      /* Fall through.  */
     1532:  582:    case HEX:
     1532:  583:      return nc + printf ("%" BFD_VMA_FMT "x", vma);
        -:  584:
    #####:  585:    case PREFIX_HEX_5:
    #####:  586:      nc = printf ("0x");
        -:  587:      /* Fall through.  */
    #####:  588:    case HEX_5:
    #####:  589:      return nc + printf ("%05" BFD_VMA_FMT "x", vma);
        -:  590:
     2782:  591:    case DEC:
     2782:  592:      return printf ("%" BFD_VMA_FMT "d", vma);
        -:  593:
    #####:  594:    case UNSIGNED:
    #####:  595:      return printf ("%" BFD_VMA_FMT "u", vma);
        -:  596:
    #####:  597:    case UNSIGNED_5:
    #####:  598:      return printf ("%5" BFD_VMA_FMT "u", vma);
        -:  599:
    #####:  600:    case OCTAL:
    #####:  601:      return printf ("%" BFD_VMA_FMT "o", vma);
        -:  602:
    #####:  603:    case OCTAL_5:
    #####:  604:      return printf ("%5" BFD_VMA_FMT "o", vma);
        -:  605:
    #####:  606:    default:
        -:  607:      /* FIXME: Report unrecognised mode ?  */
    #####:  608:      return 0;
        -:  609:    }
        -:  610:}
        -:  611:
        -:  612:
        -:  613:/* Display a symbol on stdout.  Handles the display of control characters and
        -:  614:   multibye characters (assuming the host environment supports them).
        -:  615:
        -:  616:   Display at most abs(WIDTH) characters, truncating as necessary, unless do_wide is true.
        -:  617:
        -:  618:   If truncation will happen and do_not_show_symbol_truncation is FALSE then display
        -:  619:   abs(WIDTH) - 5 characters followed by "[...]".
        -:  620:
        -:  621:   If WIDTH is negative then ensure that the output is at least (- WIDTH) characters,
        -:  622:   padding as necessary.
        -:  623:
        -:  624:   Returns the number of emitted characters.  */
        -:  625:
        -:  626:static unsigned int
     3655:  627:print_symbol (signed int width, const char * symbol)
        -:  628:{
     3655:  629:  bool extra_padding = false;
     3655:  630:  bool do_dots = false;
     3655:  631:  signed int num_printed = 0;
        -:  632:#ifdef HAVE_MBSTATE_T
        -:  633:  mbstate_t state;
        -:  634:#endif
        -:  635:  unsigned int width_remaining;
     3655:  636:  const void * alloced_symbol = NULL;
        -:  637:
     3655:  638:  if (width < 0)
        -:  639:    {
        -:  640:      /* Keep the width positive.  This helps the code below.  */
     3512:  641:      width = - width;
     3512:  642:      extra_padding = true;
        -:  643:    }
      143:  644:  else if (width == 0)
    #####:  645:    return 0;
        -:  646:
     3655:  647:  if (do_wide)
        -:  648:    /* Set the remaining width to a very large value.
        -:  649:       This simplifies the code below.  */
    #####:  650:    width_remaining = INT_MAX;
        -:  651:  else
        -:  652:    {
     3655:  653:      width_remaining = width;
     3655:  654:      if (! do_not_show_symbol_truncation
     3655:  655:	  && (int) strlen (symbol) > width)
        -:  656:	{
        4:  657:	  width_remaining -= 5;
        4:  658:	  if ((int) width_remaining < 0)
    #####:  659:	    width_remaining = 0;
        4:  660:	  do_dots = true;
        -:  661:	}
        -:  662:    }
        -:  663:
        -:  664:#ifdef HAVE_MBSTATE_T
        -:  665:  /* Initialise the multibyte conversion state.  */
     3655:  666:  memset (& state, 0, sizeof (state));
        -:  667:#endif
        -:  668:
    3655*:  669:  if (do_demangle && *symbol)
        -:  670:    {
    #####:  671:      const char * res = cplus_demangle (symbol, demangle_flags);
        -:  672:
    #####:  673:      if (res != NULL)
    #####:  674:	alloced_symbol = symbol = res;
        -:  675:    }
        -:  676:
    27420:  677:  while (width_remaining)
        -:  678:    {
        -:  679:      size_t  n;
    27407:  680:      const char c = *symbol++;
        -:  681:
    27407:  682:      if (c == 0)
     3632:  683:	break;
        -:  684:
    23775:  685:      if (ISPRINT (c))
        -:  686:	{
    21967:  687:	  putchar (c);
    21967:  688:	  width_remaining --;
    21967:  689:	  num_printed ++;
        -:  690:	}
     1808:  691:      else if (ISCNTRL (c))
        -:  692:	{
        -:  693:	  /* Do not print control characters directly as they can affect terminal
        -:  694:	     settings.  Such characters usually appear in the names generated
        -:  695:	     by the assembler for local labels.  */
        -:  696:
      788:  697:	  if (width_remaining < 2)
       10:  698:	    break;
        -:  699:
      778:  700:	  printf ("^%c", c + 0x40);
      778:  701:	  width_remaining -= 2;
      778:  702:	  num_printed += 2;
        -:  703:	}
     1020:  704:      else if (c == 0x7f)
        -:  705:	{
    #####:  706:	  if (width_remaining < 5)
    #####:  707:	    break;
    #####:  708:	  printf ("<DEL>");
    #####:  709:	  width_remaining -= 5;
    #####:  710:	  num_printed += 5;
        -:  711:	}
     1020:  712:      else if (unicode_display != unicode_locale
     1020:  713:	       && unicode_display != unicode_default)
    #####:  714:	{
        -:  715:	  /* Display unicode characters as something else.  */
        -:  716:	  unsigned char bytes[4];
        -:  717:	  bool          is_utf8;
        -:  718:	  unsigned int  nbytes;
        -:  719:
    #####:  720:	  bytes[0] = c;
        -:  721:
    #####:  722:	  if (bytes[0] < 0xc0)
        -:  723:	    {
    #####:  724:	      nbytes = 1;
    #####:  725:	      is_utf8 = false;
        -:  726:	    }
        -:  727:	  else
        -:  728:	    {
    #####:  729:	      bytes[1] = *symbol++;
        -:  730:
    #####:  731:	      if ((bytes[1] & 0xc0) != 0x80)
        -:  732:		{
    #####:  733:		  is_utf8 = false;
        -:  734:		  /* Do not consume this character.  It may only
        -:  735:		     be the first byte in the sequence that was
        -:  736:		     corrupt.  */
    #####:  737:		  --symbol;
    #####:  738:		  nbytes = 1;
        -:  739:		}
    #####:  740:	      else if ((bytes[0] & 0x20) == 0)
        -:  741:		{
    #####:  742:		  is_utf8 = true;
    #####:  743:		  nbytes = 2;
        -:  744:		}
        -:  745:	      else
        -:  746:		{
    #####:  747:		  bytes[2] = *symbol++;
        -:  748:
    #####:  749:		  if ((bytes[2] & 0xc0) != 0x80)
        -:  750:		    {
    #####:  751:		      is_utf8 = false;
    #####:  752:		      symbol -= 2;
    #####:  753:		      nbytes = 1;
        -:  754:		    }
    #####:  755:		  else if ((bytes[0] & 0x10) == 0)
        -:  756:		    {
    #####:  757:		      is_utf8 = true;
    #####:  758:		      nbytes = 3;
        -:  759:		    }
        -:  760:		  else
        -:  761:		    {
    #####:  762:		      bytes[3] = *symbol++;
        -:  763:
    #####:  764:		      nbytes = 4;
        -:  765:
    #####:  766:		      if ((bytes[3] & 0xc0) != 0x80)
        -:  767:			{
    #####:  768:			  is_utf8 = false;
    #####:  769:			  symbol -= 3;
    #####:  770:			  nbytes = 1;
        -:  771:			}
        -:  772:		      else
    #####:  773:			is_utf8 = true;
        -:  774:		    }
        -:  775:		}
        -:  776:	    }
        -:  777:
    #####:  778:	  if (unicode_display == unicode_invalid)
    #####:  779:	    is_utf8 = false;
        -:  780:
    #####:  781:	  if (unicode_display == unicode_hex || ! is_utf8)
    #####:  782:	    {
        -:  783:	      unsigned int i;
        -:  784:
    #####:  785:	      if (width_remaining < (nbytes * 2) + 2)
    #####:  786:		break;
        -:  787:	  
    #####:  788:	      putchar (is_utf8 ? '<' : '{');
    #####:  789:	      printf ("0x");
    #####:  790:	      for (i = 0; i < nbytes; i++)
    #####:  791:		printf ("%02x", bytes[i]);
    #####:  792:	      putchar (is_utf8 ? '>' : '}');
        -:  793:	    }
        -:  794:	  else
        -:  795:	    {
    #####:  796:	      if (unicode_display == unicode_highlight && isatty (1))
    #####:  797:		printf ("\x1B[31;47m"); /* Red.  */
        -:  798:	      
    #####:  799:	      switch (nbytes)
        -:  800:		{
    #####:  801:		case 2:
    #####:  802:		  if (width_remaining < 6)
    #####:  803:		    break;
    #####:  804:		  printf ("\\u%02x%02x",
    #####:  805:			  (bytes[0] & 0x1c) >> 2, 
    #####:  806:			  ((bytes[0] & 0x03) << 6) | (bytes[1] & 0x3f));
    #####:  807:		  break;
    #####:  808:		case 3:
    #####:  809:		  if (width_remaining < 6)
    #####:  810:		    break;
    #####:  811:		  printf ("\\u%02x%02x",
    #####:  812:			  ((bytes[0] & 0x0f) << 4) | ((bytes[1] & 0x3c) >> 2),
    #####:  813:			  ((bytes[1] & 0x03) << 6) | (bytes[2] & 0x3f));
    #####:  814:		  break;
    #####:  815:		case 4:
    #####:  816:		  if (width_remaining < 8)
    #####:  817:		    break;
    #####:  818:		  printf ("\\u%02x%02x%02x",
    #####:  819:			  ((bytes[0] & 0x07) << 6) | ((bytes[1] & 0x3c) >> 2),
    #####:  820:			  ((bytes[1] & 0x03) << 6) | ((bytes[2] & 0x3c) >> 2),
    #####:  821:			  ((bytes[2] & 0x03) << 6) | (bytes[3] & 0x3f));
        -:  822:		  
    #####:  823:		  break;
    #####:  824:		default:
        -:  825:		  /* URG.  */
    #####:  826:		  break;
        -:  827:		}
        -:  828:
    #####:  829:	      if (unicode_display == unicode_highlight && isatty (1))
    #####:  830:		printf ("\033[0m"); /* Default colour.  */
        -:  831:	    }
        -:  832:	  
    #####:  833:	  if (bytes[nbytes - 1] == 0)
    #####:  834:	    break;
        -:  835:	}
        -:  836:      else
        -:  837:	{
        -:  838:#ifdef HAVE_MBSTATE_T
        -:  839:	  wchar_t w;
        -:  840:#endif
        -:  841:	  /* Let printf do the hard work of displaying multibyte characters.  */
     1020:  842:	  printf ("%.1s", symbol - 1);
     1020:  843:	  width_remaining --;
     1020:  844:	  num_printed ++;
        -:  845:
        -:  846:#ifdef HAVE_MBSTATE_T
        -:  847:	  /* Try to find out how many bytes made up the character that was
        -:  848:	     just printed.  Advance the symbol pointer past the bytes that
        -:  849:	     were displayed.  */
     1020:  850:	  n = mbrtowc (& w, symbol - 1, MB_CUR_MAX, & state);
        -:  851:#else
        -:  852:	  n = 1;
        -:  853:#endif
     1020:  854:	  if (n != (size_t) -1 && n != (size_t) -2 && n > 0)
      901:  855:	    symbol += (n - 1);
        -:  856:	}
        -:  857:    }
        -:  858:
     3655:  859:  if (do_dots)
        4:  860:    num_printed += printf ("[...]");
        -:  861:
     3655:  862:  if (extra_padding && num_printed < width)
        -:  863:    {
        -:  864:      /* Fill in the remaining spaces.  */
     3499:  865:      printf ("%-*s", width - num_printed, " ");
     3499:  866:      num_printed = width;
        -:  867:    }
        -:  868:
     3655:  869:  free ((void *) alloced_symbol);
     3655:  870:  return num_printed;
        -:  871:}
        -:  872:
        -:  873:/* Returns a pointer to a static buffer containing a printable version of
        -:  874:   the given section's name.  Like print_symbol, except that it does not try
        -:  875:   to print multibyte characters, it just interprets them as hex values.  */
        -:  876:
        -:  877:static const char *
     1322:  878:printable_section_name (Filedata * filedata, const Elf_Internal_Shdr * sec)
        -:  879:{
        -:  880:#define MAX_PRINT_SEC_NAME_LEN 256
        -:  881:  static char  sec_name_buf [MAX_PRINT_SEC_NAME_LEN + 1];
     1322:  882:  const char * name = section_name_print (filedata, sec);
     1322:  883:  char *       buf = sec_name_buf;
        -:  884:  char         c;
     1322:  885:  unsigned int remaining = MAX_PRINT_SEC_NAME_LEN;
        -:  886:
     8188:  887:  while ((c = * name ++) != 0)
        -:  888:    {
     6866:  889:      if (ISCNTRL (c))
        -:  890:	{
      330:  891:	  if (remaining < 2)
    #####:  892:	    break;
        -:  893:
      330:  894:	  * buf ++ = '^';
      330:  895:	  * buf ++ = c + 0x40;
      330:  896:	  remaining -= 2;
        -:  897:	}
     6536:  898:      else if (ISPRINT (c))
        -:  899:	{
     6129:  900:	  * buf ++ = c;
     6129:  901:	  remaining -= 1;
        -:  902:	}
        -:  903:      else
        -:  904:	{
        -:  905:	  static char hex[17] = "0123456789ABCDEF";
        -:  906:
      407:  907:	  if (remaining < 4)
    #####:  908:	    break;
      407:  909:	  * buf ++ = '<';
      407:  910:	  * buf ++ = hex[(c & 0xf0) >> 4];
      407:  911:	  * buf ++ = hex[c & 0x0f];
      407:  912:	  * buf ++ = '>';
      407:  913:	  remaining -= 4;
        -:  914:	}
        -:  915:
     6866:  916:      if (remaining == 0)
    #####:  917:	break;
        -:  918:    }
        -:  919:
     1322:  920:  * buf = 0;
     1322:  921:  return sec_name_buf;
        -:  922:}
        -:  923:
        -:  924:static const char *
    #####:  925:printable_section_name_from_index (Filedata * filedata, unsigned long ndx)
        -:  926:{
    #####:  927:  if (ndx >= filedata->file_header.e_shnum)
    #####:  928:    return _("<corrupt>");
        -:  929:
    #####:  930:  return printable_section_name (filedata, filedata->section_headers + ndx);
        -:  931:}
        -:  932:
        -:  933:/* Return a pointer to section NAME, or NULL if no such section exists.  */
        -:  934:
        -:  935:static Elf_Internal_Shdr *
       47:  936:find_section (Filedata * filedata, const char * name)
        -:  937:{
        -:  938:  unsigned int i;
        -:  939:
       47:  940:  if (filedata->section_headers == NULL)
    #####:  941:    return NULL;
        -:  942:
      235:  943:  for (i = 0; i < filedata->file_header.e_shnum; i++)
      188:  944:    if (section_name_valid (filedata, filedata->section_headers + i)
      143:  945:	&& streq (section_name (filedata, filedata->section_headers + i),
        -:  946:		  name))
    #####:  947:      return filedata->section_headers + i;
        -:  948:
       47:  949:  return NULL;
        -:  950:}
        -:  951:
        -:  952:/* Return a pointer to a section containing ADDR, or NULL if no such
        -:  953:   section exists.  */
        -:  954:
        -:  955:static Elf_Internal_Shdr *
    #####:  956:find_section_by_address (Filedata * filedata, bfd_vma addr)
        -:  957:{
        -:  958:  unsigned int i;
        -:  959:
    #####:  960:  if (filedata->section_headers == NULL)
    #####:  961:    return NULL;
        -:  962:
    #####:  963:  for (i = 0; i < filedata->file_header.e_shnum; i++)
        -:  964:    {
    #####:  965:      Elf_Internal_Shdr *sec = filedata->section_headers + i;
        -:  966:
    #####:  967:      if (addr >= sec->sh_addr && addr < sec->sh_addr + sec->sh_size)
    #####:  968:	return sec;
        -:  969:    }
        -:  970:
    #####:  971:  return NULL;
        -:  972:}
        -:  973:
        -:  974:static Elf_Internal_Shdr *
    #####:  975:find_section_by_type (Filedata * filedata, unsigned int type)
        -:  976:{
        -:  977:  unsigned int i;
        -:  978:
    #####:  979:  if (filedata->section_headers == NULL)
    #####:  980:    return NULL;
        -:  981:
    #####:  982:  for (i = 0; i < filedata->file_header.e_shnum; i++)
        -:  983:    {
    #####:  984:      Elf_Internal_Shdr *sec = filedata->section_headers + i;
        -:  985:
    #####:  986:      if (sec->sh_type == type)
    #####:  987:	return sec;
        -:  988:    }
        -:  989:
    #####:  990:  return NULL;
        -:  991:}
        -:  992:
        -:  993:/* Return a pointer to section NAME, or NULL if no such section exists,
        -:  994:   restricted to the list of sections given in SET.  */
        -:  995:
        -:  996:static Elf_Internal_Shdr *
    #####:  997:find_section_in_set (Filedata * filedata, const char * name, unsigned int * set)
        -:  998:{
        -:  999:  unsigned int i;
        -: 1000:
    #####: 1001:  if (filedata->section_headers == NULL)
    #####: 1002:    return NULL;
        -: 1003:
    #####: 1004:  if (set != NULL)
        -: 1005:    {
    #####: 1006:      while ((i = *set++) > 0)
        -: 1007:	{
        -: 1008:	  /* See PR 21156 for a reproducer.  */
    #####: 1009:	  if (i >= filedata->file_header.e_shnum)
    #####: 1010:	    continue; /* FIXME: Should we issue an error message ?  */
        -: 1011:
    #####: 1012:	  if (section_name_valid (filedata, filedata->section_headers + i)
    #####: 1013:	      && streq (section_name (filedata, filedata->section_headers + i),
        -: 1014:			name))
    #####: 1015:	    return filedata->section_headers + i;
        -: 1016:	}
        -: 1017:    }
        -: 1018:
    #####: 1019:  return find_section (filedata, name);
        -: 1020:}
        -: 1021:
        -: 1022:/* Return TRUE if the current file is for IA-64 machine and OpenVMS ABI.
        -: 1023:   This OS has so many departures from the ELF standard that we test it at
        -: 1024:   many places.  */
        -: 1025:
        -: 1026:static inline bool
       60: 1027:is_ia64_vms (Filedata * filedata)
        -: 1028:{
       60: 1029:  return filedata->file_header.e_machine == EM_IA_64
      60*: 1030:    && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_OPENVMS;
        -: 1031:}
        -: 1032:
        -: 1033:/* Guess the relocation size commonly used by the specific machines.  */
        -: 1034:
        -: 1035:static bool
    #####: 1036:guess_is_rela (unsigned int e_machine)
        -: 1037:{
    #####: 1038:  switch (e_machine)
        -: 1039:    {
        -: 1040:      /* Targets that use REL relocations.  */
    #####: 1041:    case EM_386:
        -: 1042:    case EM_IAMCU:
        -: 1043:    case EM_960:
        -: 1044:    case EM_ARM:
        -: 1045:    case EM_D10V:
        -: 1046:    case EM_CYGNUS_D10V:
        -: 1047:    case EM_DLX:
        -: 1048:    case EM_MIPS:
        -: 1049:    case EM_MIPS_RS3_LE:
        -: 1050:    case EM_CYGNUS_M32R:
        -: 1051:    case EM_SCORE:
        -: 1052:    case EM_XGATE:
        -: 1053:    case EM_NFP:
        -: 1054:    case EM_BPF:
    #####: 1055:      return false;
        -: 1056:
        -: 1057:      /* Targets that use RELA relocations.  */
    #####: 1058:    case EM_68K:
        -: 1059:    case EM_860:
        -: 1060:    case EM_AARCH64:
        -: 1061:    case EM_ADAPTEVA_EPIPHANY:
        -: 1062:    case EM_ALPHA:
        -: 1063:    case EM_ALTERA_NIOS2:
        -: 1064:    case EM_ARC:
        -: 1065:    case EM_ARC_COMPACT:
        -: 1066:    case EM_ARC_COMPACT2:
        -: 1067:    case EM_AVR:
        -: 1068:    case EM_AVR_OLD:
        -: 1069:    case EM_BLACKFIN:
        -: 1070:    case EM_CR16:
        -: 1071:    case EM_CRIS:
        -: 1072:    case EM_CRX:
        -: 1073:    case EM_CSKY:
        -: 1074:    case EM_D30V:
        -: 1075:    case EM_CYGNUS_D30V:
        -: 1076:    case EM_FR30:
        -: 1077:    case EM_FT32:
        -: 1078:    case EM_CYGNUS_FR30:
        -: 1079:    case EM_CYGNUS_FRV:
        -: 1080:    case EM_H8S:
        -: 1081:    case EM_H8_300:
        -: 1082:    case EM_H8_300H:
        -: 1083:    case EM_IA_64:
        -: 1084:    case EM_IP2K:
        -: 1085:    case EM_IP2K_OLD:
        -: 1086:    case EM_IQ2000:
        -: 1087:    case EM_LATTICEMICO32:
        -: 1088:    case EM_M32C_OLD:
        -: 1089:    case EM_M32C:
        -: 1090:    case EM_M32R:
        -: 1091:    case EM_MCORE:
        -: 1092:    case EM_CYGNUS_MEP:
        -: 1093:    case EM_METAG:
        -: 1094:    case EM_MMIX:
        -: 1095:    case EM_MN10200:
        -: 1096:    case EM_CYGNUS_MN10200:
        -: 1097:    case EM_MN10300:
        -: 1098:    case EM_CYGNUS_MN10300:
        -: 1099:    case EM_MOXIE:
        -: 1100:    case EM_MSP430:
        -: 1101:    case EM_MSP430_OLD:
        -: 1102:    case EM_MT:
        -: 1103:    case EM_NDS32:
        -: 1104:    case EM_NIOS32:
        -: 1105:    case EM_OR1K:
        -: 1106:    case EM_PPC64:
        -: 1107:    case EM_PPC:
        -: 1108:    case EM_TI_PRU:
        -: 1109:    case EM_RISCV:
        -: 1110:    case EM_RL78:
        -: 1111:    case EM_RX:
        -: 1112:    case EM_S390:
        -: 1113:    case EM_S390_OLD:
        -: 1114:    case EM_SH:
        -: 1115:    case EM_SPARC:
        -: 1116:    case EM_SPARC32PLUS:
        -: 1117:    case EM_SPARCV9:
        -: 1118:    case EM_SPU:
        -: 1119:    case EM_TI_C6000:
        -: 1120:    case EM_TILEGX:
        -: 1121:    case EM_TILEPRO:
        -: 1122:    case EM_V800:
        -: 1123:    case EM_V850:
        -: 1124:    case EM_CYGNUS_V850:
        -: 1125:    case EM_VAX:
        -: 1126:    case EM_VISIUM:
        -: 1127:    case EM_X86_64:
        -: 1128:    case EM_L1OM:
        -: 1129:    case EM_K1OM:
        -: 1130:    case EM_XSTORMY16:
        -: 1131:    case EM_XTENSA:
        -: 1132:    case EM_XTENSA_OLD:
        -: 1133:    case EM_MICROBLAZE:
        -: 1134:    case EM_MICROBLAZE_OLD:
        -: 1135:    case EM_WEBASSEMBLY:
    #####: 1136:      return true;
        -: 1137:
    #####: 1138:    case EM_68HC05:
        -: 1139:    case EM_68HC08:
        -: 1140:    case EM_68HC11:
        -: 1141:    case EM_68HC16:
        -: 1142:    case EM_FX66:
        -: 1143:    case EM_ME16:
        -: 1144:    case EM_MMA:
        -: 1145:    case EM_NCPU:
        -: 1146:    case EM_NDR1:
        -: 1147:    case EM_PCP:
        -: 1148:    case EM_ST100:
        -: 1149:    case EM_ST19:
        -: 1150:    case EM_ST7:
        -: 1151:    case EM_ST9PLUS:
        -: 1152:    case EM_STARCORE:
        -: 1153:    case EM_SVX:
        -: 1154:    case EM_TINYJ:
        -: 1155:    default:
    #####: 1156:      warn (_("Don't know about relocations on this machine architecture\n"));
    #####: 1157:      return false;
        -: 1158:    }
        -: 1159:}
        -: 1160:
        -: 1161:/* Load RELA type relocations from FILEDATA at REL_OFFSET extending for REL_SIZE bytes.
        -: 1162:   Returns TRUE upon success, FALSE otherwise.  If successful then a
        -: 1163:   pointer to a malloc'ed buffer containing the relocs is placed in *RELASP,
        -: 1164:   and the number of relocs loaded is placed in *NRELASP.  It is the caller's
        -: 1165:   responsibility to free the allocated buffer.  */
        -: 1166:
        -: 1167:static bool
        3: 1168:slurp_rela_relocs (Filedata *            filedata,
        -: 1169:		   unsigned long         rel_offset,
        -: 1170:		   unsigned long         rel_size,
        -: 1171:		   Elf_Internal_Rela **  relasp,
        -: 1172:		   unsigned long *       nrelasp)
        -: 1173:{
        -: 1174:  Elf_Internal_Rela * relas;
        -: 1175:  size_t nrelas;
        -: 1176:  unsigned int i;
        -: 1177:
        3: 1178:  if (is_32bit_elf)
        -: 1179:    {
        -: 1180:      Elf32_External_Rela * erelas;
        -: 1181:
        3: 1182:      erelas = (Elf32_External_Rela *) get_data (NULL, filedata, rel_offset, 1,
        3: 1183:                                                 rel_size, _("32-bit relocation data"));
        3: 1184:      if (!erelas)
    #####: 1185:	return false;
        -: 1186:
        3: 1187:      nrelas = rel_size / sizeof (Elf32_External_Rela);
        -: 1188:
        3: 1189:      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
        -: 1190:                                             sizeof (Elf_Internal_Rela));
        -: 1191:
        3: 1192:      if (relas == NULL)
        -: 1193:	{
    #####: 1194:	  free (erelas);
    #####: 1195:	  error (_("out of memory parsing relocs\n"));
    #####: 1196:	  return false;
        -: 1197:	}
        -: 1198:
       36: 1199:      for (i = 0; i < nrelas; i++)
        -: 1200:	{
       33: 1201:	  relas[i].r_offset = BYTE_GET (erelas[i].r_offset);
       33: 1202:	  relas[i].r_info   = BYTE_GET (erelas[i].r_info);
       33: 1203:	  relas[i].r_addend = BYTE_GET_SIGNED (erelas[i].r_addend);
        -: 1204:	}
        -: 1205:
        3: 1206:      free (erelas);
        -: 1207:    }
        -: 1208:  else
        -: 1209:    {
        -: 1210:      Elf64_External_Rela * erelas;
        -: 1211:
    #####: 1212:      erelas = (Elf64_External_Rela *) get_data (NULL, filedata, rel_offset, 1,
    #####: 1213:                                                 rel_size, _("64-bit relocation data"));
    #####: 1214:      if (!erelas)
    #####: 1215:	return false;
        -: 1216:
    #####: 1217:      nrelas = rel_size / sizeof (Elf64_External_Rela);
        -: 1218:
    #####: 1219:      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
        -: 1220:                                             sizeof (Elf_Internal_Rela));
        -: 1221:
    #####: 1222:      if (relas == NULL)
        -: 1223:	{
    #####: 1224:	  free (erelas);
    #####: 1225:	  error (_("out of memory parsing relocs\n"));
    #####: 1226:	  return false;
        -: 1227:	}
        -: 1228:
    #####: 1229:      for (i = 0; i < nrelas; i++)
        -: 1230:	{
    #####: 1231:	  relas[i].r_offset = BYTE_GET (erelas[i].r_offset);
    #####: 1232:	  relas[i].r_info   = BYTE_GET (erelas[i].r_info);
    #####: 1233:	  relas[i].r_addend = BYTE_GET_SIGNED (erelas[i].r_addend);
        -: 1234:
        -: 1235:	  /* The #ifdef BFD64 below is to prevent a compile time
        -: 1236:	     warning.  We know that if we do not have a 64 bit data
        -: 1237:	     type that we will never execute this code anyway.  */
        -: 1238:#ifdef BFD64
    #####: 1239:	  if (filedata->file_header.e_machine == EM_MIPS
    #####: 1240:	      && filedata->file_header.e_ident[EI_DATA] != ELFDATA2MSB)
        -: 1241:	    {
        -: 1242:	      /* In little-endian objects, r_info isn't really a
        -: 1243:		 64-bit little-endian value: it has a 32-bit
        -: 1244:		 little-endian symbol index followed by four
        -: 1245:		 individual byte fields.  Reorder INFO
        -: 1246:		 accordingly.  */
    #####: 1247:	      bfd_vma inf = relas[i].r_info;
    #####: 1248:	      inf = (((inf & 0xffffffff) << 32)
    #####: 1249:		      | ((inf >> 56) & 0xff)
    #####: 1250:		      | ((inf >> 40) & 0xff00)
    #####: 1251:		      | ((inf >> 24) & 0xff0000)
    #####: 1252:		      | ((inf >> 8) & 0xff000000));
    #####: 1253:	      relas[i].r_info = inf;
        -: 1254:	    }
        -: 1255:#endif /* BFD64 */
        -: 1256:	}
        -: 1257:
    #####: 1258:      free (erelas);
        -: 1259:    }
        -: 1260:
        3: 1261:  *relasp = relas;
        3: 1262:  *nrelasp = nrelas;
        3: 1263:  return true;
        -: 1264:}
        -: 1265:
        -: 1266:/* Load REL type relocations from FILEDATA at REL_OFFSET extending for REL_SIZE bytes.
        -: 1267:   Returns TRUE upon success, FALSE otherwise.  If successful then a
        -: 1268:   pointer to a malloc'ed buffer containing the relocs is placed in *RELSP,
        -: 1269:   and the number of relocs loaded is placed in *NRELSP.  It is the caller's
        -: 1270:   responsibility to free the allocated buffer.  */
        -: 1271:
        -: 1272:static bool
       14: 1273:slurp_rel_relocs (Filedata *            filedata,
        -: 1274:		  unsigned long         rel_offset,
        -: 1275:		  unsigned long         rel_size,
        -: 1276:		  Elf_Internal_Rela **  relsp,
        -: 1277:		  unsigned long *       nrelsp)
        -: 1278:{
        -: 1279:  Elf_Internal_Rela * rels;
        -: 1280:  size_t nrels;
        -: 1281:  unsigned int i;
        -: 1282:
       14: 1283:  if (is_32bit_elf)
        -: 1284:    {
        -: 1285:      Elf32_External_Rel * erels;
        -: 1286:
       14: 1287:      erels = (Elf32_External_Rel *) get_data (NULL, filedata, rel_offset, 1,
       14: 1288:                                               rel_size, _("32-bit relocation data"));
       14: 1289:      if (!erels)
    #####: 1290:	return false;
        -: 1291:
       14: 1292:      nrels = rel_size / sizeof (Elf32_External_Rel);
        -: 1293:
       14: 1294:      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));
        -: 1295:
       14: 1296:      if (rels == NULL)
        -: 1297:	{
    #####: 1298:	  free (erels);
    #####: 1299:	  error (_("out of memory parsing relocs\n"));
    #####: 1300:	  return false;
        -: 1301:	}
        -: 1302:
       41: 1303:      for (i = 0; i < nrels; i++)
        -: 1304:	{
       27: 1305:	  rels[i].r_offset = BYTE_GET (erels[i].r_offset);
       27: 1306:	  rels[i].r_info   = BYTE_GET (erels[i].r_info);
       27: 1307:	  rels[i].r_addend = 0;
        -: 1308:	}
        -: 1309:
       14: 1310:      free (erels);
        -: 1311:    }
        -: 1312:  else
        -: 1313:    {
        -: 1314:      Elf64_External_Rel * erels;
        -: 1315:
    #####: 1316:      erels = (Elf64_External_Rel *) get_data (NULL, filedata, rel_offset, 1,
    #####: 1317:                                               rel_size, _("64-bit relocation data"));
    #####: 1318:      if (!erels)
    #####: 1319:	return false;
        -: 1320:
    #####: 1321:      nrels = rel_size / sizeof (Elf64_External_Rel);
        -: 1322:
    #####: 1323:      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));
        -: 1324:
    #####: 1325:      if (rels == NULL)
        -: 1326:	{
    #####: 1327:	  free (erels);
    #####: 1328:	  error (_("out of memory parsing relocs\n"));
    #####: 1329:	  return false;
        -: 1330:	}
        -: 1331:
    #####: 1332:      for (i = 0; i < nrels; i++)
        -: 1333:	{
    #####: 1334:	  rels[i].r_offset = BYTE_GET (erels[i].r_offset);
    #####: 1335:	  rels[i].r_info   = BYTE_GET (erels[i].r_info);
    #####: 1336:	  rels[i].r_addend = 0;
        -: 1337:
        -: 1338:	  /* The #ifdef BFD64 below is to prevent a compile time
        -: 1339:	     warning.  We know that if we do not have a 64 bit data
        -: 1340:	     type that we will never execute this code anyway.  */
        -: 1341:#ifdef BFD64
    #####: 1342:	  if (filedata->file_header.e_machine == EM_MIPS
    #####: 1343:	      && filedata->file_header.e_ident[EI_DATA] != ELFDATA2MSB)
        -: 1344:	    {
        -: 1345:	      /* In little-endian objects, r_info isn't really a
        -: 1346:		 64-bit little-endian value: it has a 32-bit
        -: 1347:		 little-endian symbol index followed by four
        -: 1348:		 individual byte fields.  Reorder INFO
        -: 1349:		 accordingly.  */
    #####: 1350:	      bfd_vma inf = rels[i].r_info;
    #####: 1351:	      inf = (((inf & 0xffffffff) << 32)
    #####: 1352:		     | ((inf >> 56) & 0xff)
    #####: 1353:		     | ((inf >> 40) & 0xff00)
    #####: 1354:		     | ((inf >> 24) & 0xff0000)
    #####: 1355:		     | ((inf >> 8) & 0xff000000));
    #####: 1356:	      rels[i].r_info = inf;
        -: 1357:	    }
        -: 1358:#endif /* BFD64 */
        -: 1359:	}
        -: 1360:
    #####: 1361:      free (erels);
        -: 1362:    }
        -: 1363:
       14: 1364:  *relsp = rels;
       14: 1365:  *nrelsp = nrels;
       14: 1366:  return true;
        -: 1367:}
        -: 1368:
        -: 1369:static bool
        3: 1370:slurp_relr_relocs (Filedata * filedata,
        -: 1371:		   unsigned long relr_offset,
        -: 1372:		   unsigned long relr_size,
        -: 1373:		   bfd_vma ** relrsp,
        -: 1374:		   unsigned long * nrelrsp)
        -: 1375:{
        -: 1376:  void *relrs;
        3: 1377:  size_t size = 0, nentries, i;
        3: 1378:  bfd_vma base = 0, addr, entry;
        -: 1379:
        3: 1380:  relrs = get_data (NULL, filedata, relr_offset, 1, relr_size,
        3: 1381:		    _("RELR relocation data"));
        3: 1382:  if (!relrs)
        1: 1383:    return false;
        -: 1384:
        2: 1385:  if (is_32bit_elf)
        2: 1386:    nentries = relr_size / sizeof (Elf32_External_Relr);
        -: 1387:  else
    #####: 1388:    nentries = relr_size / sizeof (Elf64_External_Relr);
        7: 1389:  for (i = 0; i < nentries; i++)
        -: 1390:    {
        5: 1391:      if (is_32bit_elf)
        5: 1392:	entry = BYTE_GET (((Elf32_External_Relr *)relrs)[i].r_data);
        -: 1393:      else
    #####: 1394:	entry = BYTE_GET (((Elf64_External_Relr *)relrs)[i].r_data);
        5: 1395:      if ((entry & 1) == 0)
        3: 1396:	size++;
        -: 1397:      else
       61: 1398:	while ((entry >>= 1) != 0)
       59: 1399:	  if ((entry & 1) == 1)
       25: 1400:	    size++;
        -: 1401:    }
        -: 1402:
        2: 1403:  *relrsp = (bfd_vma *) malloc (size * sizeof (bfd_vma));
        2: 1404:  if (*relrsp == NULL)
        -: 1405:    {
    #####: 1406:      free (relrs);
    #####: 1407:      error (_("out of memory parsing relocs\n"));
    #####: 1408:      return false;
        -: 1409:    }
        -: 1410:
        2: 1411:  size = 0;
        7: 1412:  for (i = 0; i < nentries; i++)
        -: 1413:    {
       5*: 1414:      const bfd_vma entry_bytes = is_32bit_elf ? 4 : 8;
        -: 1415:
        5: 1416:      if (is_32bit_elf)
        5: 1417:	entry = BYTE_GET (((Elf32_External_Relr *)relrs)[i].r_data);
        -: 1418:      else
    #####: 1419:	entry = BYTE_GET (((Elf64_External_Relr *)relrs)[i].r_data);
        5: 1420:      if ((entry & 1) == 0)
        -: 1421:	{
        3: 1422:	  (*relrsp)[size++] = entry;
        3: 1423:	  base = entry + entry_bytes;
        -: 1424:	}
        -: 1425:      else
        -: 1426:	{
       61: 1427:	  for (addr = base; (entry >>= 1) != 0; addr += entry_bytes)
       59: 1428:	    if ((entry & 1) != 0)
       25: 1429:	      (*relrsp)[size++] = addr;
        2: 1430:	  base += entry_bytes * (entry_bytes * CHAR_BIT - 1);
        -: 1431:	}
        -: 1432:    }
        -: 1433:
        2: 1434:  *nrelrsp = size;
        2: 1435:  free (relrs);
        2: 1436:  return true;
        -: 1437:}
        -: 1438:
        -: 1439:/* Returns the reloc type extracted from the reloc info field.  */
        -: 1440:
        -: 1441:static unsigned int
       60: 1442:get_reloc_type (Filedata * filedata, bfd_vma reloc_info)
        -: 1443:{
       60: 1444:  if (is_32bit_elf)
       60: 1445:    return ELF32_R_TYPE (reloc_info);
        -: 1446:
    #####: 1447:  switch (filedata->file_header.e_machine)
        -: 1448:    {
    #####: 1449:    case EM_MIPS:
        -: 1450:      /* Note: We assume that reloc_info has already been adjusted for us.  */
    #####: 1451:      return ELF64_MIPS_R_TYPE (reloc_info);
        -: 1452:
    #####: 1453:    case EM_SPARCV9:
    #####: 1454:      return ELF64_R_TYPE_ID (reloc_info);
        -: 1455:
    #####: 1456:    default:
    #####: 1457:      return ELF64_R_TYPE (reloc_info);
        -: 1458:    }
        -: 1459:}
        -: 1460:
        -: 1461:/* Return the symbol index extracted from the reloc info field.  */
        -: 1462:
        -: 1463:static bfd_vma
       60: 1464:get_reloc_symindex (bfd_vma reloc_info)
        -: 1465:{
      60*: 1466:  return is_32bit_elf ? ELF32_R_SYM (reloc_info) : ELF64_R_SYM (reloc_info);
        -: 1467:}
        -: 1468:
        -: 1469:static inline bool
    #####: 1470:uses_msp430x_relocs (Filedata * filedata)
        -: 1471:{
        -: 1472:  return
    #####: 1473:    filedata->file_header.e_machine == EM_MSP430 /* Paranoia.  */
        -: 1474:    /* GCC uses osabi == ELFOSBI_STANDALONE.  */
    #####: 1475:    && (((filedata->file_header.e_flags & EF_MSP430_MACH) == E_MSP430_MACH_MSP430X)
        -: 1476:	/* TI compiler uses ELFOSABI_NONE.  */
    #####: 1477:	|| (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_NONE));
        -: 1478:}
        -: 1479:
        -: 1480:/* Display the contents of the relocation data found at the specified
        -: 1481:   offset.  */
        -: 1482:
        -: 1483:static bool
       20: 1484:dump_relocations (Filedata *          filedata,
        -: 1485:		  unsigned long       rel_offset,
        -: 1486:		  unsigned long       rel_size,
        -: 1487:		  Elf_Internal_Sym *  symtab,
        -: 1488:		  unsigned long       nsyms,
        -: 1489:		  char *              strtab,
        -: 1490:		  unsigned long       strtablen,
        -: 1491:		  relocation_type     rel_type,
        -: 1492:		  bool                is_dynsym)
        -: 1493:{
        -: 1494:  unsigned long i;
        -: 1495:  Elf_Internal_Rela * rels;
       20: 1496:  bool res = true;
        -: 1497:
       20: 1498:  if (rel_type == reltype_unknown)
    #####: 1499:    rel_type = guess_is_rela (filedata->file_header.e_machine) ? reltype_rela : reltype_rel;
        -: 1500:
       20: 1501:  if (rel_type == reltype_rela)
        -: 1502:    {
        3: 1503:      if (!slurp_rela_relocs (filedata, rel_offset, rel_size, &rels, &rel_size))
    #####: 1504:	return false;
        -: 1505:    }
       17: 1506:  else if (rel_type == reltype_rel)
        -: 1507:    {
       14: 1508:      if (!slurp_rel_relocs (filedata, rel_offset, rel_size, &rels, &rel_size))
    #####: 1509:	return false;
        -: 1510:    }
        3: 1511:  else if (rel_type == reltype_relr)
        -: 1512:    {
        -: 1513:      bfd_vma * relrs;
        3: 1514:      const char *format
       3*: 1515:	  = is_32bit_elf ? "%08" BFD_VMA_FMT "x\n" : "%016" BFD_VMA_FMT "x\n";
        -: 1516:
        3: 1517:      if (!slurp_relr_relocs (filedata, rel_offset, rel_size, &relrs,
        -: 1518:			      &rel_size))
        1: 1519:	return false;
        -: 1520:
        2: 1521:      printf (ngettext ("  %lu offset\n", "  %lu offsets\n", rel_size), rel_size);
       30: 1522:      for (i = 0; i < rel_size; i++)
       28: 1523:	printf (format, relrs[i]);
        2: 1524:      free (relrs);
        2: 1525:      return true;
        -: 1526:    }
        -: 1527:
       17: 1528:  if (is_32bit_elf)
        -: 1529:    {
       17: 1530:      if (rel_type == reltype_rela)
        -: 1531:	{
        3: 1532:	  if (do_wide)
    #####: 1533:	    printf (_(" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\n"));
        -: 1534:	  else
        3: 1535:	    printf (_(" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n"));
        -: 1536:	}
        -: 1537:      else
        -: 1538:	{
       14: 1539:	  if (do_wide)
    #####: 1540:	    printf (_(" Offset     Info    Type                Sym. Value  Symbol's Name\n"));
        -: 1541:	  else
       14: 1542:	    printf (_(" Offset     Info    Type            Sym.Value  Sym. Name\n"));
        -: 1543:	}
        -: 1544:    }
        -: 1545:  else
        -: 1546:    {
    #####: 1547:      if (rel_type == reltype_rela)
        -: 1548:	{
    #####: 1549:	  if (do_wide)
    #####: 1550:	    printf (_("    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n"));
        -: 1551:	  else
    #####: 1552:	    printf (_("  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n"));
        -: 1553:	}
        -: 1554:      else
        -: 1555:	{
    #####: 1556:	  if (do_wide)
    #####: 1557:	    printf (_("    Offset             Info             Type               Symbol's Value  Symbol's Name\n"));
        -: 1558:	  else
    #####: 1559:	    printf (_("  Offset          Info           Type           Sym. Value    Sym. Name\n"));
        -: 1560:	}
        -: 1561:    }
        -: 1562:
       77: 1563:  for (i = 0; i < rel_size; i++)
        -: 1564:    {
        -: 1565:      const char * rtype;
        -: 1566:      bfd_vma offset;
        -: 1567:      bfd_vma inf;
        -: 1568:      bfd_vma symtab_index;
        -: 1569:      bfd_vma type;
        -: 1570:
       60: 1571:      offset = rels[i].r_offset;
       60: 1572:      inf    = rels[i].r_info;
        -: 1573:
       60: 1574:      type = get_reloc_type (filedata, inf);
       60: 1575:      symtab_index = get_reloc_symindex  (inf);
        -: 1576:
       60: 1577:      if (is_32bit_elf)
        -: 1578:	{
       60: 1579:	  printf ("%8.8lx  %8.8lx ",
        -: 1580:		  (unsigned long) offset & 0xffffffff,
        -: 1581:		  (unsigned long) inf & 0xffffffff);
        -: 1582:	}
        -: 1583:      else
        -: 1584:	{
    #####: 1585:	  printf (do_wide
    #####: 1586:		  ? "%16.16" BFD_VMA_FMT "x  %16.16" BFD_VMA_FMT "x "
        -: 1587:		  : "%12.12" BFD_VMA_FMT "x  %12.12" BFD_VMA_FMT "x ",
        -: 1588:		  offset, inf);
        -: 1589:	}
        -: 1590:
       60: 1591:      switch (filedata->file_header.e_machine)
        -: 1592:	{
       17: 1593:	default:
       17: 1594:	  rtype = NULL;
       17: 1595:	  break;
        -: 1596:
    #####: 1597:	case EM_AARCH64:
    #####: 1598:	  rtype = elf_aarch64_reloc_type (type);
    #####: 1599:	  break;
        -: 1600:
    #####: 1601:	case EM_M32R:
        -: 1602:	case EM_CYGNUS_M32R:
    #####: 1603:	  rtype = elf_m32r_reloc_type (type);
    #####: 1604:	  break;
        -: 1605:
       29: 1606:	case EM_386:
        -: 1607:	case EM_IAMCU:
       29: 1608:	  rtype = elf_i386_reloc_type (type);
       29: 1609:	  break;
        -: 1610:
        1: 1611:	case EM_68HC11:
        -: 1612:	case EM_68HC12:
        1: 1613:	  rtype = elf_m68hc11_reloc_type (type);
        1: 1614:	  break;
        -: 1615:
    #####: 1616:	case EM_S12Z:
    #####: 1617:	  rtype = elf_s12z_reloc_type (type);
    #####: 1618:	  break;
        -: 1619:
        3: 1620:	case EM_68K:
        3: 1621:	  rtype = elf_m68k_reloc_type (type);
        3: 1622:	  break;
        -: 1623:
    #####: 1624:	case EM_960:
    #####: 1625:	  rtype = elf_i960_reloc_type (type);
    #####: 1626:	  break;
        -: 1627:
    #####: 1628:	case EM_AVR:
        -: 1629:	case EM_AVR_OLD:
    #####: 1630:	  rtype = elf_avr_reloc_type (type);
    #####: 1631:	  break;
        -: 1632:
    #####: 1633:	case EM_OLD_SPARCV9:
        -: 1634:	case EM_SPARC32PLUS:
        -: 1635:	case EM_SPARCV9:
        -: 1636:	case EM_SPARC:
    #####: 1637:	  rtype = elf_sparc_reloc_type (type);
    #####: 1638:	  break;
        -: 1639:
    #####: 1640:	case EM_SPU:
    #####: 1641:	  rtype = elf_spu_reloc_type (type);
    #####: 1642:	  break;
        -: 1643:
    #####: 1644:	case EM_V800:
    #####: 1645:	  rtype = v800_reloc_type (type);
    #####: 1646:	  break;
        1: 1647:	case EM_V850:
        -: 1648:	case EM_CYGNUS_V850:
        1: 1649:	  rtype = v850_reloc_type (type);
        1: 1650:	  break;
        -: 1651:
    #####: 1652:	case EM_D10V:
        -: 1653:	case EM_CYGNUS_D10V:
    #####: 1654:	  rtype = elf_d10v_reloc_type (type);
    #####: 1655:	  break;
        -: 1656:
    #####: 1657:	case EM_D30V:
        -: 1658:	case EM_CYGNUS_D30V:
    #####: 1659:	  rtype = elf_d30v_reloc_type (type);
    #####: 1660:	  break;
        -: 1661:
    #####: 1662:	case EM_DLX:
    #####: 1663:	  rtype = elf_dlx_reloc_type (type);
    #####: 1664:	  break;
        -: 1665:
    #####: 1666:	case EM_SH:
    #####: 1667:	  rtype = elf_sh_reloc_type (type);
    #####: 1668:	  break;
        -: 1669:
    #####: 1670:	case EM_MN10300:
        -: 1671:	case EM_CYGNUS_MN10300:
    #####: 1672:	  rtype = elf_mn10300_reloc_type (type);
    #####: 1673:	  break;
        -: 1674:
    #####: 1675:	case EM_MN10200:
        -: 1676:	case EM_CYGNUS_MN10200:
    #####: 1677:	  rtype = elf_mn10200_reloc_type (type);
    #####: 1678:	  break;
        -: 1679:
    #####: 1680:	case EM_FR30:
        -: 1681:	case EM_CYGNUS_FR30:
    #####: 1682:	  rtype = elf_fr30_reloc_type (type);
    #####: 1683:	  break;
        -: 1684:
    #####: 1685:	case EM_CYGNUS_FRV:
    #####: 1686:	  rtype = elf_frv_reloc_type (type);
    #####: 1687:	  break;
        -: 1688:
    #####: 1689:	case EM_CSKY:
    #####: 1690:	  rtype = elf_csky_reloc_type (type);
    #####: 1691:	  break;
        -: 1692:
    #####: 1693:	case EM_FT32:
    #####: 1694:	  rtype = elf_ft32_reloc_type (type);
    #####: 1695:	  break;
        -: 1696:
    #####: 1697:	case EM_MCORE:
    #####: 1698:	  rtype = elf_mcore_reloc_type (type);
    #####: 1699:	  break;
        -: 1700:
    #####: 1701:	case EM_MMIX:
    #####: 1702:	  rtype = elf_mmix_reloc_type (type);
    #####: 1703:	  break;
        -: 1704:
    #####: 1705:	case EM_MOXIE:
    #####: 1706:	  rtype = elf_moxie_reloc_type (type);
    #####: 1707:	  break;
        -: 1708:
    #####: 1709:	case EM_MSP430:
    #####: 1710:	  if (uses_msp430x_relocs (filedata))
        -: 1711:	    {
    #####: 1712:	      rtype = elf_msp430x_reloc_type (type);
    #####: 1713:	      break;
        -: 1714:	    }
        -: 1715:	  /* Fall through.  */
        -: 1716:	case EM_MSP430_OLD:
    #####: 1717:	  rtype = elf_msp430_reloc_type (type);
    #####: 1718:	  break;
        -: 1719:
    #####: 1720:	case EM_NDS32:
    #####: 1721:	  rtype = elf_nds32_reloc_type (type);
    #####: 1722:	  break;
        -: 1723:
    #####: 1724:	case EM_PPC:
    #####: 1725:	  rtype = elf_ppc_reloc_type (type);
    #####: 1726:	  break;
        -: 1727:
    #####: 1728:	case EM_PPC64:
    #####: 1729:	  rtype = elf_ppc64_reloc_type (type);
    #####: 1730:	  break;
        -: 1731:
        2: 1732:	case EM_MIPS:
        -: 1733:	case EM_MIPS_RS3_LE:
        2: 1734:	  rtype = elf_mips_reloc_type (type);
        2: 1735:	  break;
        -: 1736:
    #####: 1737:	case EM_RISCV:
    #####: 1738:	  rtype = elf_riscv_reloc_type (type);
    #####: 1739:	  break;
        -: 1740:
    #####: 1741:	case EM_ALPHA:
    #####: 1742:	  rtype = elf_alpha_reloc_type (type);
    #####: 1743:	  break;
        -: 1744:
    #####: 1745:	case EM_ARM:
    #####: 1746:	  rtype = elf_arm_reloc_type (type);
    #####: 1747:	  break;
        -: 1748:
    #####: 1749:	case EM_ARC:
        -: 1750:	case EM_ARC_COMPACT:
        -: 1751:	case EM_ARC_COMPACT2:
    #####: 1752:	  rtype = elf_arc_reloc_type (type);
    #####: 1753:	  break;
        -: 1754:
        4: 1755:	case EM_PARISC:
        4: 1756:	  rtype = elf_hppa_reloc_type (type);
        4: 1757:	  break;
        -: 1758:
    #####: 1759:	case EM_H8_300:
        -: 1760:	case EM_H8_300H:
        -: 1761:	case EM_H8S:
    #####: 1762:	  rtype = elf_h8_reloc_type (type);
    #####: 1763:	  break;
        -: 1764:
    #####: 1765:	case EM_OR1K:
    #####: 1766:	  rtype = elf_or1k_reloc_type (type);
    #####: 1767:	  break;
        -: 1768:
    #####: 1769:	case EM_PJ:
        -: 1770:	case EM_PJ_OLD:
    #####: 1771:	  rtype = elf_pj_reloc_type (type);
    #####: 1772:	  break;
    #####: 1773:	case EM_IA_64:
    #####: 1774:	  rtype = elf_ia64_reloc_type (type);
    #####: 1775:	  break;
        -: 1776:
    #####: 1777:	case EM_CRIS:
    #####: 1778:	  rtype = elf_cris_reloc_type (type);
    #####: 1779:	  break;
        -: 1780:
    #####: 1781:	case EM_860:
    #####: 1782:	  rtype = elf_i860_reloc_type (type);
    #####: 1783:	  break;
        -: 1784:
    #####: 1785:	case EM_X86_64:
        -: 1786:	case EM_L1OM:
        -: 1787:	case EM_K1OM:
    #####: 1788:	  rtype = elf_x86_64_reloc_type (type);
    #####: 1789:	  break;
        -: 1790:
    #####: 1791:	case EM_S370:
    #####: 1792:	  rtype = i370_reloc_type (type);
    #####: 1793:	  break;
        -: 1794:
        3: 1795:	case EM_S390_OLD:
        -: 1796:	case EM_S390:
        3: 1797:	  rtype = elf_s390_reloc_type (type);
        3: 1798:	  break;
        -: 1799:
    #####: 1800:	case EM_SCORE:
    #####: 1801:	  rtype = elf_score_reloc_type (type);
    #####: 1802:	  break;
        -: 1803:
    #####: 1804:	case EM_XSTORMY16:
    #####: 1805:	  rtype = elf_xstormy16_reloc_type (type);
    #####: 1806:	  break;
        -: 1807:
    #####: 1808:	case EM_CRX:
    #####: 1809:	  rtype = elf_crx_reloc_type (type);
    #####: 1810:	  break;
        -: 1811:
    #####: 1812:	case EM_VAX:
    #####: 1813:	  rtype = elf_vax_reloc_type (type);
    #####: 1814:	  break;
        -: 1815:
    #####: 1816:	case EM_VISIUM:
    #####: 1817:	  rtype = elf_visium_reloc_type (type);
    #####: 1818:	  break;
        -: 1819:
    #####: 1820:        case EM_BPF:
    #####: 1821:          rtype = elf_bpf_reloc_type (type);
    #####: 1822:          break;
        -: 1823:
    #####: 1824:	case EM_ADAPTEVA_EPIPHANY:
    #####: 1825:	  rtype = elf_epiphany_reloc_type (type);
    #####: 1826:	  break;
        -: 1827:
    #####: 1828:	case EM_IP2K:
        -: 1829:	case EM_IP2K_OLD:
    #####: 1830:	  rtype = elf_ip2k_reloc_type (type);
    #####: 1831:	  break;
        -: 1832:
    #####: 1833:	case EM_IQ2000:
    #####: 1834:	  rtype = elf_iq2000_reloc_type (type);
    #####: 1835:	  break;
        -: 1836:
    #####: 1837:	case EM_XTENSA_OLD:
        -: 1838:	case EM_XTENSA:
    #####: 1839:	  rtype = elf_xtensa_reloc_type (type);
    #####: 1840:	  break;
        -: 1841:
    #####: 1842:	case EM_LATTICEMICO32:
    #####: 1843:	  rtype = elf_lm32_reloc_type (type);
    #####: 1844:	  break;
        -: 1845:
    #####: 1846:	case EM_M32C_OLD:
        -: 1847:	case EM_M32C:
    #####: 1848:	  rtype = elf_m32c_reloc_type (type);
    #####: 1849:	  break;
        -: 1850:
    #####: 1851:	case EM_MT:
    #####: 1852:	  rtype = elf_mt_reloc_type (type);
    #####: 1853:	  break;
        -: 1854:
    #####: 1855:	case EM_BLACKFIN:
    #####: 1856:	  rtype = elf_bfin_reloc_type (type);
    #####: 1857:	  break;
        -: 1858:
    #####: 1859:	case EM_CYGNUS_MEP:
    #####: 1860:	  rtype = elf_mep_reloc_type (type);
    #####: 1861:	  break;
        -: 1862:
    #####: 1863:	case EM_CR16:
    #####: 1864:	  rtype = elf_cr16_reloc_type (type);
    #####: 1865:	  break;
        -: 1866:
    #####: 1867:	case EM_MICROBLAZE:
        -: 1868:	case EM_MICROBLAZE_OLD:
    #####: 1869:	  rtype = elf_microblaze_reloc_type (type);
    #####: 1870:	  break;
        -: 1871:
    #####: 1872:	case EM_RL78:
    #####: 1873:	  rtype = elf_rl78_reloc_type (type);
    #####: 1874:	  break;
        -: 1875:
    #####: 1876:	case EM_RX:
    #####: 1877:	  rtype = elf_rx_reloc_type (type);
    #####: 1878:	  break;
        -: 1879:
    #####: 1880:	case EM_METAG:
    #####: 1881:	  rtype = elf_metag_reloc_type (type);
    #####: 1882:	  break;
        -: 1883:
    #####: 1884:	case EM_TI_C6000:
    #####: 1885:	  rtype = elf_tic6x_reloc_type (type);
    #####: 1886:	  break;
        -: 1887:
    #####: 1888:	case EM_TILEGX:
    #####: 1889:	  rtype = elf_tilegx_reloc_type (type);
    #####: 1890:	  break;
        -: 1891:
    #####: 1892:	case EM_TILEPRO:
    #####: 1893:	  rtype = elf_tilepro_reloc_type (type);
    #####: 1894:	  break;
        -: 1895:
    #####: 1896:	case EM_WEBASSEMBLY:
    #####: 1897:	  rtype = elf_wasm32_reloc_type (type);
    #####: 1898:	  break;
        -: 1899:
    #####: 1900:	case EM_XGATE:
    #####: 1901:	  rtype = elf_xgate_reloc_type (type);
    #####: 1902:	  break;
        -: 1903:
    #####: 1904:	case EM_ALTERA_NIOS2:
    #####: 1905:	  rtype = elf_nios2_reloc_type (type);
    #####: 1906:	  break;
        -: 1907:
    #####: 1908:	case EM_TI_PRU:
    #####: 1909:	  rtype = elf_pru_reloc_type (type);
    #####: 1910:	  break;
        -: 1911:
    #####: 1912:	case EM_NFP:
    #####: 1913:	  if (EF_NFP_MACH (filedata->file_header.e_flags) == E_NFP_MACH_3200)
    #####: 1914:	    rtype = elf_nfp3200_reloc_type (type);
        -: 1915:	  else
    #####: 1916:	    rtype = elf_nfp_reloc_type (type);
    #####: 1917:	  break;
        -: 1918:
    #####: 1919:	case EM_Z80:
    #####: 1920:	  rtype = elf_z80_reloc_type (type);
    #####: 1921:	  break;
        -: 1922:
    #####: 1923:	case EM_LOONGARCH:
    #####: 1924:	  rtype = elf_loongarch_reloc_type (type);
    #####: 1925:	  break;
        -: 1926:
    #####: 1927:	case EM_AMDGPU:
    #####: 1928:	  rtype = elf_amdgpu_reloc_type (type);
    #####: 1929:	  break;
        -: 1930:	}
        -: 1931:
       60: 1932:      if (rtype == NULL)
       37: 1933:	printf (_("unrecognized: %-7lx"), (unsigned long) type & 0xffffffff);
        -: 1934:      else
      23*: 1935:	printf (do_wide ? "%-22s" : "%-17.17s", rtype);
        -: 1936:
       60: 1937:      if (filedata->file_header.e_machine == EM_ALPHA
    #####: 1938:	  && rtype != NULL
    #####: 1939:	  && streq (rtype, "R_ALPHA_LITUSE")
    #####: 1940:	  && rel_type == reltype_rela)
        -: 1941:	{
    #####: 1942:	  switch (rels[i].r_addend)
        -: 1943:	    {
    #####: 1944:	    case LITUSE_ALPHA_ADDR:   rtype = "ADDR";   break;
    #####: 1945:	    case LITUSE_ALPHA_BASE:   rtype = "BASE";   break;
    #####: 1946:	    case LITUSE_ALPHA_BYTOFF: rtype = "BYTOFF"; break;
    #####: 1947:	    case LITUSE_ALPHA_JSR:    rtype = "JSR";    break;
    #####: 1948:	    case LITUSE_ALPHA_TLSGD:  rtype = "TLSGD";  break;
    #####: 1949:	    case LITUSE_ALPHA_TLSLDM: rtype = "TLSLDM"; break;
    #####: 1950:	    case LITUSE_ALPHA_JSRDIRECT: rtype = "JSRDIRECT"; break;
    #####: 1951:	    default: rtype = NULL;
        -: 1952:	    }
        -: 1953:
    #####: 1954:	  if (rtype)
    #####: 1955:	    printf (" (%s)", rtype);
        -: 1956:	  else
        -: 1957:	    {
    #####: 1958:	      putchar (' ');
    #####: 1959:	      printf (_("<unknown addend: %lx>"),
    #####: 1960:		      (unsigned long) rels[i].r_addend);
    #####: 1961:	      res = false;
        -: 1962:	    }
        -: 1963:	}
       60: 1964:      else if (symtab_index)
        -: 1965:	{
      47*: 1966:	  if (symtab == NULL || symtab_index >= nsyms)
        -: 1967:	    {
       47: 1968:	      error (_(" bad symbol index: %08lx in reloc\n"),
        -: 1969:		     (unsigned long) symtab_index);
       47: 1970:	      res = false;
        -: 1971:	    }
        -: 1972:	  else
        -: 1973:	    {
        -: 1974:	      Elf_Internal_Sym * psym;
        -: 1975:	      const char * version_string;
        -: 1976:	      enum versioned_symbol_info sym_info;
        -: 1977:	      unsigned short vna_other;
        -: 1978:
    #####: 1979:	      psym = symtab + symtab_index;
        -: 1980:
        -: 1981:	      version_string
    #####: 1982:		= get_symbol_version_string (filedata, is_dynsym,
        -: 1983:					     strtab, strtablen,
        -: 1984:					     symtab_index,
        -: 1985:					     psym,
        -: 1986:					     &sym_info,
        -: 1987:					     &vna_other);
        -: 1988:
    #####: 1989:	      printf (" ");
        -: 1990:
    #####: 1991:	      if (ELF_ST_TYPE (psym->st_info) == STT_GNU_IFUNC)
        -: 1992:		{
        -: 1993:		  const char * name;
        -: 1994:		  unsigned int len;
    #####: 1995:		  unsigned int width = is_32bit_elf ? 8 : 14;
        -: 1996:
        -: 1997:		  /* Relocations against GNU_IFUNC symbols do not use the value
        -: 1998:		     of the symbol as the address to relocate against.  Instead
        -: 1999:		     they invoke the function named by the symbol and use its
        -: 2000:		     result as the address for relocation.
        -: 2001:
        -: 2002:		     To indicate this to the user, do not display the value of
        -: 2003:		     the symbol in the "Symbols's Value" field.  Instead show
        -: 2004:		     its name followed by () as a hint that the symbol is
        -: 2005:		     invoked.  */
        -: 2006:
    #####: 2007:		  if (strtab == NULL
    #####: 2008:		      || psym->st_name == 0
    #####: 2009:		      || psym->st_name >= strtablen)
    #####: 2010:		    name = "??";
        -: 2011:		  else
    #####: 2012:		    name = strtab + psym->st_name;
        -: 2013:
    #####: 2014:		  len = print_symbol (width, name);
    #####: 2015:		  if (version_string)
    #####: 2016:		    printf (sym_info == symbol_public ? "@@%s" : "@%s",
        -: 2017:			    version_string);
    #####: 2018:		  printf ("()%-*s", len <= width ? (width + 1) - len : 1, " ");
        -: 2019:		}
        -: 2020:	      else
        -: 2021:		{
    #####: 2022:		  print_vma (psym->st_value, LONG_HEX);
        -: 2023:
    #####: 2024:		  printf (is_32bit_elf ? "   " : " ");
        -: 2025:		}
        -: 2026:
    #####: 2027:	      if (psym->st_name == 0)
        -: 2028:		{
    #####: 2029:		  const char * sec_name = "<null>";
        -: 2030:		  char name_buf[40];
        -: 2031:
    #####: 2032:		  if (ELF_ST_TYPE (psym->st_info) == STT_SECTION)
        -: 2033:		    {
    #####: 2034:		      if (psym->st_shndx < filedata->file_header.e_shnum
    #####: 2035:			  && filedata->section_headers != NULL)
    #####: 2036:			sec_name = section_name_print (filedata,
    #####: 2037:						       filedata->section_headers
    #####: 2038:						       + psym->st_shndx);
    #####: 2039:		      else if (psym->st_shndx == SHN_ABS)
    #####: 2040:			sec_name = "ABS";
    #####: 2041:		      else if (psym->st_shndx == SHN_COMMON)
    #####: 2042:			sec_name = "COMMON";
    #####: 2043:		      else if ((filedata->file_header.e_machine == EM_MIPS
    #####: 2044:				&& psym->st_shndx == SHN_MIPS_SCOMMON)
    #####: 2045:			       || (filedata->file_header.e_machine == EM_TI_C6000
    #####: 2046:				   && psym->st_shndx == SHN_TIC6X_SCOMMON))
    #####: 2047:			sec_name = "SCOMMON";
    #####: 2048:		      else if (filedata->file_header.e_machine == EM_MIPS
    #####: 2049:			       && psym->st_shndx == SHN_MIPS_SUNDEFINED)
    #####: 2050:			sec_name = "SUNDEF";
    #####: 2051:		      else if ((filedata->file_header.e_machine == EM_X86_64
    #####: 2052:				|| filedata->file_header.e_machine == EM_L1OM
    #####: 2053:				|| filedata->file_header.e_machine == EM_K1OM)
    #####: 2054:			       && psym->st_shndx == SHN_X86_64_LCOMMON)
    #####: 2055:			sec_name = "LARGE_COMMON";
    #####: 2056:		      else if (filedata->file_header.e_machine == EM_IA_64
    #####: 2057:			       && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_HPUX
    #####: 2058:			       && psym->st_shndx == SHN_IA_64_ANSI_COMMON)
    #####: 2059:			sec_name = "ANSI_COM";
    #####: 2060:		      else if (is_ia64_vms (filedata)
    #####: 2061:			       && psym->st_shndx == SHN_IA_64_VMS_SYMVEC)
    #####: 2062:			sec_name = "VMS_SYMVEC";
        -: 2063:		      else
        -: 2064:			{
    #####: 2065:			  sprintf (name_buf, "<section 0x%x>",
        -: 2066:				   (unsigned int) psym->st_shndx);
    #####: 2067:			  sec_name = name_buf;
        -: 2068:			}
        -: 2069:		    }
    #####: 2070:		  print_symbol (22, sec_name);
        -: 2071:		}
    #####: 2072:	      else if (strtab == NULL)
    #####: 2073:		printf (_("<string table index: %3ld>"), psym->st_name);
    #####: 2074:	      else if (psym->st_name >= strtablen)
        -: 2075:		{
    #####: 2076:		  error (_("<corrupt string table index: %3ld>\n"),
        -: 2077:			 psym->st_name);
    #####: 2078:		  res = false;
        -: 2079:		}
        -: 2080:	      else
        -: 2081:		{
    #####: 2082:		  print_symbol (22, strtab + psym->st_name);
    #####: 2083:		  if (version_string)
    #####: 2084:		    printf (sym_info == symbol_public ? "@@%s" : "@%s",
        -: 2085:			    version_string);
        -: 2086:		}
        -: 2087:
    #####: 2088:	      if (rel_type == reltype_rela)
        -: 2089:		{
    #####: 2090:		  bfd_vma off = rels[i].r_addend;
        -: 2091:
    #####: 2092:		  if ((bfd_signed_vma) off < 0)
    #####: 2093:		    printf (" - %" BFD_VMA_FMT "x", - off);
        -: 2094:		  else
    #####: 2095:		    printf (" + %" BFD_VMA_FMT "x", off);
        -: 2096:		}
        -: 2097:	    }
        -: 2098:	}
       13: 2099:      else if (rel_type == reltype_rela)
        -: 2100:	{
       11: 2101:	  bfd_vma off = rels[i].r_addend;
        -: 2102:
      11*: 2103:	  printf ("%*c", is_32bit_elf ? 12 : 20, ' ');
       11: 2104:	  if ((bfd_signed_vma) off < 0)
    #####: 2105:	    printf ("-%" BFD_VMA_FMT "x", - off);
        -: 2106:	  else
       11: 2107:	    printf ("%" BFD_VMA_FMT "x", off);
        -: 2108:	}
        -: 2109:
       60: 2110:      if (filedata->file_header.e_machine == EM_SPARCV9
    #####: 2111:	  && rtype != NULL
    #####: 2112:	  && streq (rtype, "R_SPARC_OLO10"))
    #####: 2113:	printf (" + %lx", (unsigned long) ELF64_R_TYPE_DATA (inf));
        -: 2114:
       60: 2115:      putchar ('\n');
        -: 2116:
        -: 2117:#ifdef BFD64
      60*: 2118:      if (! is_32bit_elf && filedata->file_header.e_machine == EM_MIPS)
        -: 2119:	{
    #####: 2120:	  bfd_vma type2 = ELF64_MIPS_R_TYPE2 (inf);
    #####: 2121:	  bfd_vma type3 = ELF64_MIPS_R_TYPE3 (inf);
    #####: 2122:	  const char * rtype2 = elf_mips_reloc_type (type2);
    #####: 2123:	  const char * rtype3 = elf_mips_reloc_type (type3);
        -: 2124:
    #####: 2125:	  printf ("                    Type2: ");
        -: 2126:
    #####: 2127:	  if (rtype2 == NULL)
    #####: 2128:	    printf (_("unrecognized: %-7lx"),
        -: 2129:		    (unsigned long) type2 & 0xffffffff);
        -: 2130:	  else
    #####: 2131:	    printf ("%-17.17s", rtype2);
        -: 2132:
    #####: 2133:	  printf ("\n                    Type3: ");
        -: 2134:
    #####: 2135:	  if (rtype3 == NULL)
    #####: 2136:	    printf (_("unrecognized: %-7lx"),
        -: 2137:		    (unsigned long) type3 & 0xffffffff);
        -: 2138:	  else
    #####: 2139:	    printf ("%-17.17s", rtype3);
        -: 2140:
    #####: 2141:	  putchar ('\n');
        -: 2142:	}
        -: 2143:#endif /* BFD64 */
        -: 2144:    }
        -: 2145:
       17: 2146:  free (rels);
        -: 2147:
       17: 2148:  return res;
        -: 2149:}
        -: 2150:
        -: 2151:static const char *
    #####: 2152:get_aarch64_dynamic_type (unsigned long type)
        -: 2153:{
    #####: 2154:  switch (type)
        -: 2155:    {
    #####: 2156:    case DT_AARCH64_BTI_PLT:  return "AARCH64_BTI_PLT";
    #####: 2157:    case DT_AARCH64_PAC_PLT:  return "AARCH64_PAC_PLT";
    #####: 2158:    case DT_AARCH64_VARIANT_PCS:  return "AARCH64_VARIANT_PCS";
    #####: 2159:    default:
    #####: 2160:      return NULL;
        -: 2161:    }
        -: 2162:}
        -: 2163:
        -: 2164:static const char *
    #####: 2165:get_mips_dynamic_type (unsigned long type)
        -: 2166:{
    #####: 2167:  switch (type)
        -: 2168:    {
    #####: 2169:    case DT_MIPS_RLD_VERSION: return "MIPS_RLD_VERSION";
    #####: 2170:    case DT_MIPS_TIME_STAMP: return "MIPS_TIME_STAMP";
    #####: 2171:    case DT_MIPS_ICHECKSUM: return "MIPS_ICHECKSUM";
    #####: 2172:    case DT_MIPS_IVERSION: return "MIPS_IVERSION";
    #####: 2173:    case DT_MIPS_FLAGS: return "MIPS_FLAGS";
    #####: 2174:    case DT_MIPS_BASE_ADDRESS: return "MIPS_BASE_ADDRESS";
    #####: 2175:    case DT_MIPS_MSYM: return "MIPS_MSYM";
    #####: 2176:    case DT_MIPS_CONFLICT: return "MIPS_CONFLICT";
    #####: 2177:    case DT_MIPS_LIBLIST: return "MIPS_LIBLIST";
    #####: 2178:    case DT_MIPS_LOCAL_GOTNO: return "MIPS_LOCAL_GOTNO";
    #####: 2179:    case DT_MIPS_CONFLICTNO: return "MIPS_CONFLICTNO";
    #####: 2180:    case DT_MIPS_LIBLISTNO: return "MIPS_LIBLISTNO";
    #####: 2181:    case DT_MIPS_SYMTABNO: return "MIPS_SYMTABNO";
    #####: 2182:    case DT_MIPS_UNREFEXTNO: return "MIPS_UNREFEXTNO";
    #####: 2183:    case DT_MIPS_GOTSYM: return "MIPS_GOTSYM";
    #####: 2184:    case DT_MIPS_HIPAGENO: return "MIPS_HIPAGENO";
    #####: 2185:    case DT_MIPS_RLD_MAP: return "MIPS_RLD_MAP";
    #####: 2186:    case DT_MIPS_RLD_MAP_REL: return "MIPS_RLD_MAP_REL";
    #####: 2187:    case DT_MIPS_DELTA_CLASS: return "MIPS_DELTA_CLASS";
    #####: 2188:    case DT_MIPS_DELTA_CLASS_NO: return "MIPS_DELTA_CLASS_NO";
    #####: 2189:    case DT_MIPS_DELTA_INSTANCE: return "MIPS_DELTA_INSTANCE";
    #####: 2190:    case DT_MIPS_DELTA_INSTANCE_NO: return "MIPS_DELTA_INSTANCE_NO";
    #####: 2191:    case DT_MIPS_DELTA_RELOC: return "MIPS_DELTA_RELOC";
    #####: 2192:    case DT_MIPS_DELTA_RELOC_NO: return "MIPS_DELTA_RELOC_NO";
    #####: 2193:    case DT_MIPS_DELTA_SYM: return "MIPS_DELTA_SYM";
    #####: 2194:    case DT_MIPS_DELTA_SYM_NO: return "MIPS_DELTA_SYM_NO";
    #####: 2195:    case DT_MIPS_DELTA_CLASSSYM: return "MIPS_DELTA_CLASSSYM";
    #####: 2196:    case DT_MIPS_DELTA_CLASSSYM_NO: return "MIPS_DELTA_CLASSSYM_NO";
    #####: 2197:    case DT_MIPS_CXX_FLAGS: return "MIPS_CXX_FLAGS";
    #####: 2198:    case DT_MIPS_PIXIE_INIT: return "MIPS_PIXIE_INIT";
    #####: 2199:    case DT_MIPS_SYMBOL_LIB: return "MIPS_SYMBOL_LIB";
    #####: 2200:    case DT_MIPS_LOCALPAGE_GOTIDX: return "MIPS_LOCALPAGE_GOTIDX";
    #####: 2201:    case DT_MIPS_LOCAL_GOTIDX: return "MIPS_LOCAL_GOTIDX";
    #####: 2202:    case DT_MIPS_HIDDEN_GOTIDX: return "MIPS_HIDDEN_GOTIDX";
    #####: 2203:    case DT_MIPS_PROTECTED_GOTIDX: return "MIPS_PROTECTED_GOTIDX";
    #####: 2204:    case DT_MIPS_OPTIONS: return "MIPS_OPTIONS";
    #####: 2205:    case DT_MIPS_INTERFACE: return "MIPS_INTERFACE";
    #####: 2206:    case DT_MIPS_DYNSTR_ALIGN: return "MIPS_DYNSTR_ALIGN";
    #####: 2207:    case DT_MIPS_INTERFACE_SIZE: return "MIPS_INTERFACE_SIZE";
    #####: 2208:    case DT_MIPS_RLD_TEXT_RESOLVE_ADDR: return "MIPS_RLD_TEXT_RESOLVE_ADDR";
    #####: 2209:    case DT_MIPS_PERF_SUFFIX: return "MIPS_PERF_SUFFIX";
    #####: 2210:    case DT_MIPS_COMPACT_SIZE: return "MIPS_COMPACT_SIZE";
    #####: 2211:    case DT_MIPS_GP_VALUE: return "MIPS_GP_VALUE";
    #####: 2212:    case DT_MIPS_AUX_DYNAMIC: return "MIPS_AUX_DYNAMIC";
    #####: 2213:    case DT_MIPS_PLTGOT: return "MIPS_PLTGOT";
    #####: 2214:    case DT_MIPS_RWPLT: return "MIPS_RWPLT";
    #####: 2215:    case DT_MIPS_XHASH: return "MIPS_XHASH";
    #####: 2216:    default:
    #####: 2217:      return NULL;
        -: 2218:    }
        -: 2219:}
        -: 2220:
        -: 2221:static const char *
    #####: 2222:get_sparc64_dynamic_type (unsigned long type)
        -: 2223:{
    #####: 2224:  switch (type)
        -: 2225:    {
    #####: 2226:    case DT_SPARC_REGISTER: return "SPARC_REGISTER";
    #####: 2227:    default:
    #####: 2228:      return NULL;
        -: 2229:    }
        -: 2230:}
        -: 2231:
        -: 2232:static const char *
    #####: 2233:get_ppc_dynamic_type (unsigned long type)
        -: 2234:{
    #####: 2235:  switch (type)
        -: 2236:    {
    #####: 2237:    case DT_PPC_GOT:    return "PPC_GOT";
    #####: 2238:    case DT_PPC_OPT:    return "PPC_OPT";
    #####: 2239:    default:
    #####: 2240:      return NULL;
        -: 2241:    }
        -: 2242:}
        -: 2243:
        -: 2244:static const char *
    #####: 2245:get_ppc64_dynamic_type (unsigned long type)
        -: 2246:{
    #####: 2247:  switch (type)
        -: 2248:    {
    #####: 2249:    case DT_PPC64_GLINK:  return "PPC64_GLINK";
    #####: 2250:    case DT_PPC64_OPD:    return "PPC64_OPD";
    #####: 2251:    case DT_PPC64_OPDSZ:  return "PPC64_OPDSZ";
    #####: 2252:    case DT_PPC64_OPT:    return "PPC64_OPT";
    #####: 2253:    default:
    #####: 2254:      return NULL;
        -: 2255:    }
        -: 2256:}
        -: 2257:
        -: 2258:static const char *
        1: 2259:get_parisc_dynamic_type (unsigned long type)
        -: 2260:{
        1: 2261:  switch (type)
        -: 2262:    {
    #####: 2263:    case DT_HP_LOAD_MAP:	return "HP_LOAD_MAP";
    #####: 2264:    case DT_HP_DLD_FLAGS:	return "HP_DLD_FLAGS";
    #####: 2265:    case DT_HP_DLD_HOOK:	return "HP_DLD_HOOK";
    #####: 2266:    case DT_HP_UX10_INIT:	return "HP_UX10_INIT";
    #####: 2267:    case DT_HP_UX10_INITSZ:	return "HP_UX10_INITSZ";
    #####: 2268:    case DT_HP_PREINIT:		return "HP_PREINIT";
    #####: 2269:    case DT_HP_PREINITSZ:	return "HP_PREINITSZ";
    #####: 2270:    case DT_HP_NEEDED:		return "HP_NEEDED";
    #####: 2271:    case DT_HP_TIME_STAMP:	return "HP_TIME_STAMP";
    #####: 2272:    case DT_HP_CHECKSUM:	return "HP_CHECKSUM";
    #####: 2273:    case DT_HP_GST_SIZE:	return "HP_GST_SIZE";
    #####: 2274:    case DT_HP_GST_VERSION:	return "HP_GST_VERSION";
    #####: 2275:    case DT_HP_GST_HASHVAL:	return "HP_GST_HASHVAL";
    #####: 2276:    case DT_HP_EPLTREL:		return "HP_GST_EPLTREL";
    #####: 2277:    case DT_HP_EPLTRELSZ:	return "HP_GST_EPLTRELSZ";
    #####: 2278:    case DT_HP_FILTERED:	return "HP_FILTERED";
    #####: 2279:    case DT_HP_FILTER_TLS:	return "HP_FILTER_TLS";
    #####: 2280:    case DT_HP_COMPAT_FILTERED:	return "HP_COMPAT_FILTERED";
    #####: 2281:    case DT_HP_LAZYLOAD:	return "HP_LAZYLOAD";
    #####: 2282:    case DT_HP_BIND_NOW_COUNT:	return "HP_BIND_NOW_COUNT";
    #####: 2283:    case DT_PLT:		return "PLT";
    #####: 2284:    case DT_PLT_SIZE:		return "PLT_SIZE";
    #####: 2285:    case DT_DLT:		return "DLT";
    #####: 2286:    case DT_DLT_SIZE:		return "DLT_SIZE";
        1: 2287:    default:
        1: 2288:      return NULL;
        -: 2289:    }
        -: 2290:}
        -: 2291:
        -: 2292:static const char *
    #####: 2293:get_ia64_dynamic_type (unsigned long type)
        -: 2294:{
    #####: 2295:  switch (type)
        -: 2296:    {
    #####: 2297:    case DT_IA_64_PLT_RESERVE:         return "IA_64_PLT_RESERVE";
    #####: 2298:    case DT_IA_64_VMS_SUBTYPE:         return "VMS_SUBTYPE";
    #####: 2299:    case DT_IA_64_VMS_IMGIOCNT:        return "VMS_IMGIOCNT";
    #####: 2300:    case DT_IA_64_VMS_LNKFLAGS:        return "VMS_LNKFLAGS";
    #####: 2301:    case DT_IA_64_VMS_VIR_MEM_BLK_SIZ: return "VMS_VIR_MEM_BLK_SIZ";
    #####: 2302:    case DT_IA_64_VMS_IDENT:           return "VMS_IDENT";
    #####: 2303:    case DT_IA_64_VMS_NEEDED_IDENT:    return "VMS_NEEDED_IDENT";
    #####: 2304:    case DT_IA_64_VMS_IMG_RELA_CNT:    return "VMS_IMG_RELA_CNT";
    #####: 2305:    case DT_IA_64_VMS_SEG_RELA_CNT:    return "VMS_SEG_RELA_CNT";
    #####: 2306:    case DT_IA_64_VMS_FIXUP_RELA_CNT:  return "VMS_FIXUP_RELA_CNT";
    #####: 2307:    case DT_IA_64_VMS_FIXUP_NEEDED:    return "VMS_FIXUP_NEEDED";
    #####: 2308:    case DT_IA_64_VMS_SYMVEC_CNT:      return "VMS_SYMVEC_CNT";
    #####: 2309:    case DT_IA_64_VMS_XLATED:          return "VMS_XLATED";
    #####: 2310:    case DT_IA_64_VMS_STACKSIZE:       return "VMS_STACKSIZE";
    #####: 2311:    case DT_IA_64_VMS_UNWINDSZ:        return "VMS_UNWINDSZ";
    #####: 2312:    case DT_IA_64_VMS_UNWIND_CODSEG:   return "VMS_UNWIND_CODSEG";
    #####: 2313:    case DT_IA_64_VMS_UNWIND_INFOSEG:  return "VMS_UNWIND_INFOSEG";
    #####: 2314:    case DT_IA_64_VMS_LINKTIME:        return "VMS_LINKTIME";
    #####: 2315:    case DT_IA_64_VMS_SEG_NO:          return "VMS_SEG_NO";
    #####: 2316:    case DT_IA_64_VMS_SYMVEC_OFFSET:   return "VMS_SYMVEC_OFFSET";
    #####: 2317:    case DT_IA_64_VMS_SYMVEC_SEG:      return "VMS_SYMVEC_SEG";
    #####: 2318:    case DT_IA_64_VMS_UNWIND_OFFSET:   return "VMS_UNWIND_OFFSET";
    #####: 2319:    case DT_IA_64_VMS_UNWIND_SEG:      return "VMS_UNWIND_SEG";
    #####: 2320:    case DT_IA_64_VMS_STRTAB_OFFSET:   return "VMS_STRTAB_OFFSET";
    #####: 2321:    case DT_IA_64_VMS_SYSVER_OFFSET:   return "VMS_SYSVER_OFFSET";
    #####: 2322:    case DT_IA_64_VMS_IMG_RELA_OFF:    return "VMS_IMG_RELA_OFF";
    #####: 2323:    case DT_IA_64_VMS_SEG_RELA_OFF:    return "VMS_SEG_RELA_OFF";
    #####: 2324:    case DT_IA_64_VMS_FIXUP_RELA_OFF:  return "VMS_FIXUP_RELA_OFF";
    #####: 2325:    case DT_IA_64_VMS_PLTGOT_OFFSET:   return "VMS_PLTGOT_OFFSET";
    #####: 2326:    case DT_IA_64_VMS_PLTGOT_SEG:      return "VMS_PLTGOT_SEG";
    #####: 2327:    case DT_IA_64_VMS_FPMODE:          return "VMS_FPMODE";
    #####: 2328:    default:
    #####: 2329:      return NULL;
        -: 2330:    }
        -: 2331:}
        -: 2332:
        -: 2333:static const char *
        1: 2334:get_solaris_section_type (unsigned long type)
        -: 2335:{
        1: 2336:  switch (type)
        -: 2337:    {
    #####: 2338:    case 0x6fffffee: return "SUNW_ancillary";
    #####: 2339:    case 0x6fffffef: return "SUNW_capchain";
    #####: 2340:    case 0x6ffffff0: return "SUNW_capinfo";
    #####: 2341:    case 0x6ffffff1: return "SUNW_symsort";
    #####: 2342:    case 0x6ffffff2: return "SUNW_tlssort";
    #####: 2343:    case 0x6ffffff3: return "SUNW_LDYNSYM";
    #####: 2344:    case 0x6ffffff4: return "SUNW_dof";
    #####: 2345:    case 0x6ffffff5: return "SUNW_cap";
    #####: 2346:    case 0x6ffffff6: return "SUNW_SIGNATURE";
    #####: 2347:    case 0x6ffffff7: return "SUNW_ANNOTATE";
    #####: 2348:    case 0x6ffffff8: return "SUNW_DEBUGSTR";
    #####: 2349:    case 0x6ffffff9: return "SUNW_DEBUG";
    #####: 2350:    case 0x6ffffffa: return "SUNW_move";
    #####: 2351:    case 0x6ffffffb: return "SUNW_COMDAT";
    #####: 2352:    case 0x6ffffffc: return "SUNW_syminfo";
    #####: 2353:    case 0x6ffffffd: return "SUNW_verdef";
    #####: 2354:    case 0x6ffffffe: return "SUNW_verneed";
    #####: 2355:    case 0x6fffffff: return "SUNW_versym";
    #####: 2356:    case 0x70000000: return "SPARC_GOTDATA";
        1: 2357:    default: return NULL;
        -: 2358:    }
        -: 2359:}
        -: 2360:
        -: 2361:static const char *
    #####: 2362:get_alpha_dynamic_type (unsigned long type)
        -: 2363:{
    #####: 2364:  switch (type)
        -: 2365:    {
    #####: 2366:    case DT_ALPHA_PLTRO: return "ALPHA_PLTRO";
    #####: 2367:    default: return NULL;
        -: 2368:    }
        -: 2369:}
        -: 2370:
        -: 2371:static const char *
    #####: 2372:get_score_dynamic_type (unsigned long type)
        -: 2373:{
    #####: 2374:  switch (type)
        -: 2375:    {
    #####: 2376:    case DT_SCORE_BASE_ADDRESS: return "SCORE_BASE_ADDRESS";
    #####: 2377:    case DT_SCORE_LOCAL_GOTNO:  return "SCORE_LOCAL_GOTNO";
    #####: 2378:    case DT_SCORE_SYMTABNO:     return "SCORE_SYMTABNO";
    #####: 2379:    case DT_SCORE_GOTSYM:       return "SCORE_GOTSYM";
    #####: 2380:    case DT_SCORE_UNREFEXTNO:   return "SCORE_UNREFEXTNO";
    #####: 2381:    case DT_SCORE_HIPAGENO:     return "SCORE_HIPAGENO";
    #####: 2382:    default:                    return NULL;
        -: 2383:    }
        -: 2384:}
        -: 2385:
        -: 2386:static const char *
    #####: 2387:get_tic6x_dynamic_type (unsigned long type)
        -: 2388:{
    #####: 2389:  switch (type)
        -: 2390:    {
    #####: 2391:    case DT_C6000_GSYM_OFFSET: return "C6000_GSYM_OFFSET";
    #####: 2392:    case DT_C6000_GSTR_OFFSET: return "C6000_GSTR_OFFSET";
    #####: 2393:    case DT_C6000_DSBT_BASE:   return "C6000_DSBT_BASE";
    #####: 2394:    case DT_C6000_DSBT_SIZE:   return "C6000_DSBT_SIZE";
    #####: 2395:    case DT_C6000_PREEMPTMAP:  return "C6000_PREEMPTMAP";
    #####: 2396:    case DT_C6000_DSBT_INDEX:  return "C6000_DSBT_INDEX";
    #####: 2397:    default:                   return NULL;
        -: 2398:    }
        -: 2399:}
        -: 2400:
        -: 2401:static const char *
    #####: 2402:get_nios2_dynamic_type (unsigned long type)
        -: 2403:{
    #####: 2404:  switch (type)
        -: 2405:    {
    #####: 2406:    case DT_NIOS2_GP: return "NIOS2_GP";
    #####: 2407:    default:          return NULL;
        -: 2408:    }
        -: 2409:}
        -: 2410:
        -: 2411:static const char *
        1: 2412:get_solaris_dynamic_type (unsigned long type)
        -: 2413:{
        1: 2414:  switch (type)
        -: 2415:    {
    #####: 2416:    case 0x6000000d: return "SUNW_AUXILIARY";
    #####: 2417:    case 0x6000000e: return "SUNW_RTLDINF";
    #####: 2418:    case 0x6000000f: return "SUNW_FILTER";
    #####: 2419:    case 0x60000010: return "SUNW_CAP";
    #####: 2420:    case 0x60000011: return "SUNW_SYMTAB";
    #####: 2421:    case 0x60000012: return "SUNW_SYMSZ";
    #####: 2422:    case 0x60000013: return "SUNW_SORTENT";
    #####: 2423:    case 0x60000014: return "SUNW_SYMSORT";
    #####: 2424:    case 0x60000015: return "SUNW_SYMSORTSZ";
    #####: 2425:    case 0x60000016: return "SUNW_TLSSORT";
    #####: 2426:    case 0x60000017: return "SUNW_TLSSORTSZ";
    #####: 2427:    case 0x60000018: return "SUNW_CAPINFO";
    #####: 2428:    case 0x60000019: return "SUNW_STRPAD";
    #####: 2429:    case 0x6000001a: return "SUNW_CAPCHAIN";
    #####: 2430:    case 0x6000001b: return "SUNW_LDMACH";
    #####: 2431:    case 0x6000001d: return "SUNW_CAPCHAINENT";
    #####: 2432:    case 0x6000001f: return "SUNW_CAPCHAINSZ";
    #####: 2433:    case 0x60000021: return "SUNW_PARENT";
    #####: 2434:    case 0x60000023: return "SUNW_ASLR";
    #####: 2435:    case 0x60000025: return "SUNW_RELAX";
    #####: 2436:    case 0x60000029: return "SUNW_NXHEAP";
    #####: 2437:    case 0x6000002b: return "SUNW_NXSTACK";
        -: 2438:
    #####: 2439:    case 0x70000001: return "SPARC_REGISTER";
    #####: 2440:    case 0x7ffffffd: return "AUXILIARY";
    #####: 2441:    case 0x7ffffffe: return "USED";
    #####: 2442:    case 0x7fffffff: return "FILTER";
        -: 2443:
        1: 2444:    default: return NULL;
        -: 2445:    }
        -: 2446:}
        -: 2447:
        -: 2448:static const char *
    #####: 2449:get_riscv_dynamic_type (unsigned long type)
        -: 2450:{
    #####: 2451:  switch (type)
        -: 2452:    {
    #####: 2453:    case DT_RISCV_VARIANT_CC:	return "RISCV_VARIANT_CC";
    #####: 2454:    default:
    #####: 2455:      return NULL;
        -: 2456:    }
        -: 2457:}
        -: 2458:
        -: 2459:static const char *
       80: 2460:get_dynamic_type (Filedata * filedata, unsigned long type)
        -: 2461:{
        -: 2462:  static char buff[64];
        -: 2463:
       80: 2464:  switch (type)
        -: 2465:    {
       13: 2466:    case DT_NULL:	return "NULL";
        1: 2467:    case DT_NEEDED:	return "NEEDED";
    #####: 2468:    case DT_PLTRELSZ:	return "PLTRELSZ";
    #####: 2469:    case DT_PLTGOT:	return "PLTGOT";
    #####: 2470:    case DT_HASH:	return "HASH";
    #####: 2471:    case DT_STRTAB:	return "STRTAB";
        1: 2472:    case DT_SYMTAB:	return "SYMTAB";
    #####: 2473:    case DT_RELA:	return "RELA";
    #####: 2474:    case DT_RELASZ:	return "RELASZ";
    #####: 2475:    case DT_RELAENT:	return "RELAENT";
    #####: 2476:    case DT_STRSZ:	return "STRSZ";
    #####: 2477:    case DT_SYMENT:	return "SYMENT";
        1: 2478:    case DT_INIT:	return "INIT";
    #####: 2479:    case DT_FINI:	return "FINI";
    #####: 2480:    case DT_SONAME:	return "SONAME";
    #####: 2481:    case DT_RPATH:	return "RPATH";
        1: 2482:    case DT_SYMBOLIC:	return "SYMBOLIC";
    #####: 2483:    case DT_REL:	return "REL";
    #####: 2484:    case DT_RELSZ:	return "RELSZ";
    #####: 2485:    case DT_RELENT:	return "RELENT";
    #####: 2486:    case DT_RELR:	return "RELR";
    #####: 2487:    case DT_RELRSZ:	return "RELRSZ";
    #####: 2488:    case DT_RELRENT:	return "RELRENT";
    #####: 2489:    case DT_PLTREL:	return "PLTREL";
    #####: 2490:    case DT_DEBUG:	return "DEBUG";
    #####: 2491:    case DT_TEXTREL:	return "TEXTREL";
    #####: 2492:    case DT_JMPREL:	return "JMPREL";
    #####: 2493:    case DT_BIND_NOW:   return "BIND_NOW";
    #####: 2494:    case DT_INIT_ARRAY: return "INIT_ARRAY";
    #####: 2495:    case DT_FINI_ARRAY: return "FINI_ARRAY";
    #####: 2496:    case DT_INIT_ARRAYSZ: return "INIT_ARRAYSZ";
    #####: 2497:    case DT_FINI_ARRAYSZ: return "FINI_ARRAYSZ";
    #####: 2498:    case DT_RUNPATH:    return "RUNPATH";
    #####: 2499:    case DT_FLAGS:      return "FLAGS";
        -: 2500:
        1: 2501:    case DT_PREINIT_ARRAY: return "PREINIT_ARRAY";
    #####: 2502:    case DT_PREINIT_ARRAYSZ: return "PREINIT_ARRAYSZ";
    #####: 2503:    case DT_SYMTAB_SHNDX: return "SYMTAB_SHNDX";
        -: 2504:
    #####: 2505:    case DT_CHECKSUM:	return "CHECKSUM";
    #####: 2506:    case DT_PLTPADSZ:	return "PLTPADSZ";
    #####: 2507:    case DT_MOVEENT:	return "MOVEENT";
    #####: 2508:    case DT_MOVESZ:	return "MOVESZ";
    #####: 2509:    case DT_FEATURE:	return "FEATURE";
    #####: 2510:    case DT_POSFLAG_1:	return "POSFLAG_1";
    #####: 2511:    case DT_SYMINSZ:	return "SYMINSZ";
    #####: 2512:    case DT_SYMINENT:	return "SYMINENT"; /* aka VALRNGHI */
        -: 2513:
    #####: 2514:    case DT_ADDRRNGLO:  return "ADDRRNGLO";
    #####: 2515:    case DT_CONFIG:	return "CONFIG";
    #####: 2516:    case DT_DEPAUDIT:	return "DEPAUDIT";
    #####: 2517:    case DT_AUDIT:	return "AUDIT";
    #####: 2518:    case DT_PLTPAD:	return "PLTPAD";
    #####: 2519:    case DT_MOVETAB:	return "MOVETAB";
    #####: 2520:    case DT_SYMINFO:	return "SYMINFO"; /* aka ADDRRNGHI */
        -: 2521:
    #####: 2522:    case DT_VERSYM:	return "VERSYM";
        -: 2523:
    #####: 2524:    case DT_TLSDESC_GOT: return "TLSDESC_GOT";
    #####: 2525:    case DT_TLSDESC_PLT: return "TLSDESC_PLT";
    #####: 2526:    case DT_RELACOUNT:	return "RELACOUNT";
    #####: 2527:    case DT_RELCOUNT:	return "RELCOUNT";
    #####: 2528:    case DT_FLAGS_1:	return "FLAGS_1";
    #####: 2529:    case DT_VERDEF:	return "VERDEF";
    #####: 2530:    case DT_VERDEFNUM:	return "VERDEFNUM";
    #####: 2531:    case DT_VERNEED:	return "VERNEED";
    #####: 2532:    case DT_VERNEEDNUM:	return "VERNEEDNUM";
        -: 2533:
    #####: 2534:    case DT_AUXILIARY:	return "AUXILIARY";
    #####: 2535:    case DT_USED:	return "USED";
        1: 2536:    case DT_FILTER:	return "FILTER";
        -: 2537:
    #####: 2538:    case DT_GNU_PRELINKED: return "GNU_PRELINKED";
    #####: 2539:    case DT_GNU_CONFLICT: return "GNU_CONFLICT";
    #####: 2540:    case DT_GNU_CONFLICTSZ: return "GNU_CONFLICTSZ";
    #####: 2541:    case DT_GNU_LIBLIST: return "GNU_LIBLIST";
    #####: 2542:    case DT_GNU_LIBLISTSZ: return "GNU_LIBLISTSZ";
    #####: 2543:    case DT_GNU_HASH:	return "GNU_HASH";
    #####: 2544:    case DT_GNU_FLAGS_1: return "GNU_FLAGS_1";
        -: 2545:
       61: 2546:    default:
       61: 2547:      if ((type >= DT_LOPROC) && (type <= DT_HIPROC))
        8: 2548:	{
        -: 2549:	  const char * result;
        -: 2550:
        8: 2551:	  switch (filedata->file_header.e_machine)
        -: 2552:	    {
    #####: 2553:	    case EM_AARCH64:
    #####: 2554:	      result = get_aarch64_dynamic_type (type);
    #####: 2555:	      break;
    #####: 2556:	    case EM_MIPS:
        -: 2557:	    case EM_MIPS_RS3_LE:
    #####: 2558:	      result = get_mips_dynamic_type (type);
    #####: 2559:	      break;
    #####: 2560:	    case EM_SPARCV9:
    #####: 2561:	      result = get_sparc64_dynamic_type (type);
    #####: 2562:	      break;
    #####: 2563:	    case EM_PPC:
    #####: 2564:	      result = get_ppc_dynamic_type (type);
    #####: 2565:	      break;
    #####: 2566:	    case EM_PPC64:
    #####: 2567:	      result = get_ppc64_dynamic_type (type);
    #####: 2568:	      break;
    #####: 2569:	    case EM_IA_64:
    #####: 2570:	      result = get_ia64_dynamic_type (type);
    #####: 2571:	      break;
    #####: 2572:	    case EM_ALPHA:
    #####: 2573:	      result = get_alpha_dynamic_type (type);
    #####: 2574:	      break;
    #####: 2575:	    case EM_SCORE:
    #####: 2576:	      result = get_score_dynamic_type (type);
    #####: 2577:	      break;
    #####: 2578:	    case EM_TI_C6000:
    #####: 2579:	      result = get_tic6x_dynamic_type (type);
    #####: 2580:	      break;
    #####: 2581:	    case EM_ALTERA_NIOS2:
    #####: 2582:	      result = get_nios2_dynamic_type (type);
    #####: 2583:	      break;
    #####: 2584:	    case EM_RISCV:
    #####: 2585:	      result = get_riscv_dynamic_type (type);
    #####: 2586:	      break;
        8: 2587:	    default:
        8: 2588:	      if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
    #####: 2589:		result = get_solaris_dynamic_type (type);
        -: 2590:	      else
        8: 2591:		result = NULL;
        8: 2592:	      break;
        -: 2593:	    }
        -: 2594:
        8: 2595:	  if (result != NULL)
    #####: 2596:	    return result;
        -: 2597:
        8: 2598:	  snprintf (buff, sizeof (buff), _("Processor Specific: %lx"), type);
        -: 2599:	}
       53: 2600:      else if (((type >= DT_LOOS) && (type <= DT_HIOS))
       37: 2601:	       || (filedata->file_header.e_machine == EM_PARISC
       1*: 2602:		   && (type >= OLD_DT_LOOS) && (type <= OLD_DT_HIOS)))
       16: 2603:	{
        -: 2604:	  const char * result;
        -: 2605:
       16: 2606:	  switch (filedata->file_header.e_machine)
        -: 2607:	    {
        1: 2608:	    case EM_PARISC:
        1: 2609:	      result = get_parisc_dynamic_type (type);
        1: 2610:	      break;
    #####: 2611:	    case EM_IA_64:
    #####: 2612:	      result = get_ia64_dynamic_type (type);
    #####: 2613:	      break;
       15: 2614:	    default:
       15: 2615:	      if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
        1: 2616:		result = get_solaris_dynamic_type (type);
        -: 2617:	      else
       14: 2618:		result = NULL;
       15: 2619:	      break;
        -: 2620:	    }
        -: 2621:
       16: 2622:	  if (result != NULL)
    #####: 2623:	    return result;
        -: 2624:
       16: 2625:	  snprintf (buff, sizeof (buff), _("Operating System specific: %lx"),
        -: 2626:		    type);
        -: 2627:	}
        -: 2628:      else
       37: 2629:	snprintf (buff, sizeof (buff), _("<unknown>: %lx"), type);
        -: 2630:
       61: 2631:      return buff;
        -: 2632:    }
        -: 2633:}
        -: 2634:
        -: 2635:static bool get_program_headers (Filedata *);
        -: 2636:static bool get_dynamic_section (Filedata *);
        -: 2637:
        -: 2638:static void
       74: 2639:locate_dynamic_section (Filedata *filedata)
        -: 2640:{
       74: 2641:  unsigned long dynamic_addr = 0;
       74: 2642:  bfd_size_type dynamic_size = 0;
        -: 2643:
       74: 2644:  if (filedata->file_header.e_phnum != 0
       65: 2645:      && get_program_headers (filedata))
        -: 2646:    {
        -: 2647:      Elf_Internal_Phdr *segment;
        -: 2648:      unsigned int i;
        -: 2649:
       41: 2650:      for (i = 0, segment = filedata->program_headers;
      154: 2651:	   i < filedata->file_header.e_phnum;
      113: 2652:	   i++, segment++)
        -: 2653:	{
      116: 2654:	  if (segment->p_type == PT_DYNAMIC)
        -: 2655:	    {
        3: 2656:	      dynamic_addr = segment->p_offset;
        3: 2657:	      dynamic_size = segment->p_filesz;
        -: 2658:
        3: 2659:	      if (filedata->section_headers != NULL)
        -: 2660:		{
        -: 2661:		  Elf_Internal_Shdr *sec;
        -: 2662:
        3: 2663:		  sec = find_section (filedata, ".dynamic");
        3: 2664:		  if (sec != NULL)
        -: 2665:		    {
    #####: 2666:		      if (sec->sh_size == 0
    #####: 2667:			  || sec->sh_type == SHT_NOBITS)
        -: 2668:			{
    #####: 2669:			  dynamic_addr = 0;
    #####: 2670:			  dynamic_size = 0;
        -: 2671:			}
        -: 2672:		      else
        -: 2673:			{
    #####: 2674:			  dynamic_addr = sec->sh_offset;
    #####: 2675:			  dynamic_size = sec->sh_size;
        -: 2676:			}
        -: 2677:		    }
        -: 2678:		}
        -: 2679:
        3: 2680:	      if (dynamic_addr > filedata->file_size
        3: 2681:		  || (dynamic_size > filedata->file_size - dynamic_addr))
        -: 2682:		{
    #####: 2683:		  dynamic_addr = 0;
    #####: 2684:		  dynamic_size = 0;
        -: 2685:		}
        3: 2686:	      break;
        -: 2687:	    }
        -: 2688:	}
        -: 2689:    }
       74: 2690:  filedata->dynamic_addr = dynamic_addr;
       74: 2691:  filedata->dynamic_size = dynamic_size ? dynamic_size : 1;
       74: 2692:}
        -: 2693:
        -: 2694:static bool
       74: 2695:is_pie (Filedata *filedata)
        -: 2696:{
        -: 2697:  Elf_Internal_Dyn *entry;
        -: 2698:
       74: 2699:  if (filedata->dynamic_size == 0)
       74: 2700:    locate_dynamic_section (filedata);
       74: 2701:  if (filedata->dynamic_size <= 1)
       71: 2702:    return false;
        -: 2703:
        3: 2704:  if (!get_dynamic_section (filedata))
    #####: 2705:    return false;
        -: 2706:
        3: 2707:  for (entry = filedata->dynamic_section;
        7: 2708:       entry < filedata->dynamic_section + filedata->dynamic_nent;
        4: 2709:       entry++)
        -: 2710:    {
        4: 2711:      if (entry->d_tag == DT_FLAGS_1)
        -: 2712:	{
    #####: 2713:	  if ((entry->d_un.d_val & DF_1_PIE) != 0)
    #####: 2714:	    return true;
    #####: 2715:	  break;
        -: 2716:	}
        -: 2717:    }
        3: 2718:  return false;
        -: 2719:}
        -: 2720:
        -: 2721:static char *
     1391: 2722:get_file_type (Filedata *filedata)
        -: 2723:{
     1391: 2724:  unsigned e_type = filedata->file_header.e_type;
        -: 2725:  static char buff[64];
        -: 2726:
     1391: 2727:  switch (e_type)
        -: 2728:    {
       67: 2729:    case ET_NONE: return _("NONE (None)");
        9: 2730:    case ET_REL:  return _("REL (Relocatable file)");
      971: 2731:    case ET_EXEC: return _("EXEC (Executable file)");
       74: 2732:    case ET_DYN:
       74: 2733:      if (is_pie (filedata))
    #####: 2734:	return _("DYN (Position-Independent Executable file)");
        -: 2735:      else
       74: 2736:	return _("DYN (Shared object file)");
        7: 2737:    case ET_CORE: return _("CORE (Core file)");
        -: 2738:
      263: 2739:    default:
      263: 2740:      if ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC))
       26: 2741:	snprintf (buff, sizeof (buff), _("Processor Specific: (%x)"), e_type);
      237: 2742:      else if ((e_type >= ET_LOOS) && (e_type <= ET_HIOS))
        2: 2743:	snprintf (buff, sizeof (buff), _("OS Specific: (%x)"), e_type);
        -: 2744:      else
      235: 2745:	snprintf (buff, sizeof (buff), _("<unknown>: %x"), e_type);
      263: 2746:      return buff;
        -: 2747:    }
        -: 2748:}
        -: 2749:
        -: 2750:static char *
     1448: 2751:get_machine_name (unsigned e_machine)
        -: 2752:{
        -: 2753:  static char buff[64]; /* XXX */
        -: 2754:
     1448: 2755:  switch (e_machine)
        -: 2756:    {
        -: 2757:      /* Please keep this switch table sorted by increasing EM_ value.  */
        -: 2758:      /* 0 */
       17: 2759:    case EM_NONE:		return _("None");
       16: 2760:    case EM_M32:		return "WE32100";
       18: 2761:    case EM_SPARC:		return "Sparc";
      521: 2762:    case EM_386:		return "Intel 80386";
       22: 2763:    case EM_68K:		return "MC68000";
        2: 2764:    case EM_88K:		return "MC88000";
        2: 2765:    case EM_IAMCU:		return "Intel MCU";
        5: 2766:    case EM_860:		return "Intel 80860";
       38: 2767:    case EM_MIPS:		return "MIPS R3000";
        3: 2768:    case EM_S370:		return "IBM System/370";
        -: 2769:      /* 10 */
       20: 2770:    case EM_MIPS_RS3_LE:	return "MIPS R4000 big-endian";
        7: 2771:    case EM_OLD_SPARCV9:	return "Sparc v9 (old)";
       24: 2772:    case EM_PARISC:		return "HPPA";
        3: 2773:    case EM_VPP550:		return "Fujitsu VPP500";
        3: 2774:    case EM_SPARC32PLUS:	return "Sparc v8+" ;
       12: 2775:    case EM_960:		return "Intel 80960";
        6: 2776:    case EM_PPC:		return "PowerPC";
        -: 2777:      /* 20 */
        5: 2778:    case EM_PPC64:		return "PowerPC64";
       12: 2779:    case EM_S390_OLD:
       12: 2780:    case EM_S390:		return "IBM S/390";
        3: 2781:    case EM_SPU:		return "SPU";
        -: 2782:      /* 30 */
       18: 2783:    case EM_V800:		return "Renesas V850 (using RH850 ABI)";
        7: 2784:    case EM_FR20:		return "Fujitsu FR20";
        3: 2785:    case EM_RH32:		return "TRW RH32";
        2: 2786:    case EM_MCORE:		return "MCORE";
        -: 2787:      /* 40 */
       35: 2788:    case EM_ARM:		return "ARM";
        3: 2789:    case EM_OLD_ALPHA:		return "Digital Alpha (old)";
       18: 2790:    case EM_SH:			return "Renesas / SuperH SH";
        6: 2791:    case EM_SPARCV9:		return "Sparc v9";
        2: 2792:    case EM_TRICORE:		return "Siemens Tricore";
        2: 2793:    case EM_ARC:		return "ARC";
        2: 2794:    case EM_H8_300:		return "Renesas H8/300";
        2: 2795:    case EM_H8_300H:		return "Renesas H8/300H";
        2: 2796:    case EM_H8S:		return "Renesas H8S";
        2: 2797:    case EM_H8_500:		return "Renesas H8/500";
        -: 2798:      /* 50 */
        4: 2799:    case EM_IA_64:		return "Intel IA-64";
        2: 2800:    case EM_MIPS_X:		return "Stanford MIPS-X";
        4: 2801:    case EM_COLDFIRE:		return "Motorola Coldfire";
        3: 2802:    case EM_68HC12:		return "Motorola MC68HC12 Microcontroller";
        3: 2803:    case EM_MMA:		return "Fujitsu Multimedia Accelerator";
        2: 2804:    case EM_PCP:		return "Siemens PCP";
        3: 2805:    case EM_NCPU:		return "Sony nCPU embedded RISC processor";
        2: 2806:    case EM_NDR1:		return "Denso NDR1 microprocesspr";
        2: 2807:    case EM_STARCORE:		return "Motorola Star*Core processor";
        2: 2808:    case EM_ME16:		return "Toyota ME16 processor";
        -: 2809:      /* 60 */
        2: 2810:    case EM_ST100:		return "STMicroelectronics ST100 processor";
        2: 2811:    case EM_TINYJ:		return "Advanced Logic Corp. TinyJ embedded processor";
        3: 2812:    case EM_X86_64:		return "Advanced Micro Devices X86-64";
        3: 2813:    case EM_PDSP:		return "Sony DSP processor";
        3: 2814:    case EM_PDP10:		return "Digital Equipment Corp. PDP-10";
        2: 2815:    case EM_PDP11:		return "Digital Equipment Corp. PDP-11";
        3: 2816:    case EM_FX66:		return "Siemens FX66 microcontroller";
       21: 2817:    case EM_ST9PLUS:		return "STMicroelectronics ST9+ 8/16 bit microcontroller";
        3: 2818:    case EM_ST7:		return "STMicroelectronics ST7 8-bit microcontroller";
        2: 2819:    case EM_68HC16:		return "Motorola MC68HC16 Microcontroller";
        -: 2820:      /* 70 */
        5: 2821:    case EM_68HC11:		return "Motorola MC68HC11 Microcontroller";
        2: 2822:    case EM_68HC08:		return "Motorola MC68HC08 Microcontroller";
        3: 2823:    case EM_68HC05:		return "Motorola MC68HC05 Microcontroller";
        3: 2824:    case EM_SVX:		return "Silicon Graphics SVx";
        3: 2825:    case EM_ST19:		return "STMicroelectronics ST19 8-bit microcontroller";
        3: 2826:    case EM_VAX:		return "Digital VAX";
        3: 2827:    case EM_CRIS:		return "Axis Communications 32-bit embedded processor";
        2: 2828:    case EM_JAVELIN:		return "Infineon Technologies 32-bit embedded cpu";
        2: 2829:    case EM_FIREPATH:		return "Element 14 64-bit DSP processor";
        2: 2830:    case EM_ZSP:		return "LSI Logic's 16-bit DSP processor";
        -: 2831:      /* 80 */
        2: 2832:    case EM_MMIX:		return "Donald Knuth's educational 64-bit processor";
        2: 2833:    case EM_HUANY:		return "Harvard Universitys's machine-independent object format";
        3: 2834:    case EM_PRISM:		return "Vitesse Prism";
        5: 2835:    case EM_AVR_OLD:
        5: 2836:    case EM_AVR:		return "Atmel AVR 8-bit microcontroller";
        3: 2837:    case EM_CYGNUS_FR30:
        3: 2838:    case EM_FR30:		return "Fujitsu FR30";
        3: 2839:    case EM_CYGNUS_D10V:
        3: 2840:    case EM_D10V:		return "d10v";
        4: 2841:    case EM_CYGNUS_D30V:
        4: 2842:    case EM_D30V:		return "d30v";
       18: 2843:    case EM_CYGNUS_V850:
       18: 2844:    case EM_V850:		return "Renesas V850";
        3: 2845:    case EM_CYGNUS_M32R:
        3: 2846:    case EM_M32R:		return "Renesas M32R (formerly Mitsubishi M32r)";
        2: 2847:    case EM_CYGNUS_MN10300:
        2: 2848:    case EM_MN10300:		return "mn10300";
        -: 2849:      /* 90 */
        2: 2850:    case EM_CYGNUS_MN10200:
        2: 2851:    case EM_MN10200:		return "mn10200";
        4: 2852:    case EM_PJ:			return "picoJava";
        3: 2853:    case EM_OR1K:		return "OpenRISC 1000";
        3: 2854:    case EM_ARC_COMPACT:	return "ARCompact";
        2: 2855:    case EM_XTENSA_OLD:
        2: 2856:    case EM_XTENSA:		return "Tensilica Xtensa Processor";
        3: 2857:    case EM_VIDEOCORE:		return "Alphamosaic VideoCore processor";
        3: 2858:    case EM_TMM_GPP:		return "Thompson Multimedia General Purpose Processor";
        3: 2859:    case EM_NS32K:		return "National Semiconductor 32000 series";
        3: 2860:    case EM_TPC:		return "Tenor Network TPC processor";
        3: 2861:    case EM_SNP1K:	        return "Trebia SNP 1000 processor";
        -: 2862:      /* 100 */
        3: 2863:    case EM_ST200:		return "STMicroelectronics ST200 microcontroller";
        3: 2864:    case EM_IP2K_OLD:
        3: 2865:    case EM_IP2K:		return "Ubicom IP2xxx 8-bit microcontrollers";
        2: 2866:    case EM_MAX:		return "MAX Processor";
        2: 2867:    case EM_CR:			return "National Semiconductor CompactRISC";
        2: 2868:    case EM_F2MC16:		return "Fujitsu F2MC16";
        2: 2869:    case EM_MSP430:		return "Texas Instruments msp430 microcontroller";
        3: 2870:    case EM_BLACKFIN:		return "Analog Devices Blackfin";
        3: 2871:    case EM_SE_C33:		return "S1C33 Family of Seiko Epson processors";
        2: 2872:    case EM_SEP:		return "Sharp embedded microprocessor";
        2: 2873:    case EM_ARCA:		return "Arca RISC microprocessor";
        -: 2874:      /* 110 */
        2: 2875:    case EM_UNICORE:		return "Unicore";
        2: 2876:    case EM_EXCESS:		return "eXcess 16/32/64-bit configurable embedded CPU";
        3: 2877:    case EM_DXP:		return "Icera Semiconductor Inc. Deep Execution Processor";
        2: 2878:    case EM_ALTERA_NIOS2:	return "Altera Nios II";
        2: 2879:    case EM_CRX:		return "National Semiconductor CRX microprocessor";
        3: 2880:    case EM_XGATE:		return "Motorola XGATE embedded processor";
        2: 2881:    case EM_C166:
        2: 2882:    case EM_XC16X:		return "Infineon Technologies xc16x";
        3: 2883:    case EM_M16C:		return "Renesas M16C series microprocessors";
        2: 2884:    case EM_DSPIC30F:		return "Microchip Technology dsPIC30F Digital Signal Controller";
        2: 2885:    case EM_CE:			return "Freescale Communication Engine RISC core";
        -: 2886:      /* 120 */
        2: 2887:    case EM_M32C:	        return "Renesas M32c";
        -: 2888:      /* 130 */
       26: 2889:    case EM_TSK3000:		return "Altium TSK3000 core";
        2: 2890:    case EM_RS08:		return "Freescale RS08 embedded processor";
        3: 2891:    case EM_ECOG2:		return "Cyan Technology eCOG2 microprocessor";
        3: 2892:    case EM_SCORE:		return "SUNPLUS S+Core";
        3: 2893:    case EM_DSP24:		return "New Japan Radio (NJR) 24-bit DSP Processor";
        2: 2894:    case EM_VIDEOCORE3:		return "Broadcom VideoCore III processor";
        2: 2895:    case EM_LATTICEMICO32:	return "Lattice Mico32";
        3: 2896:    case EM_SE_C17:		return "Seiko Epson C17 family";
        -: 2897:      /* 140 */
        6: 2898:    case EM_TI_C6000:		return "Texas Instruments TMS320C6000 DSP family";
        2: 2899:    case EM_TI_C2000:		return "Texas Instruments TMS320C2000 DSP family";
        2: 2900:    case EM_TI_C5500:		return "Texas Instruments TMS320C55x DSP family";
        2: 2901:    case EM_TI_PRU:		return "TI PRU I/O processor";
        -: 2902:      /* 160 */
        3: 2903:    case EM_MMDSP_PLUS:		return "STMicroelectronics 64bit VLIW Data Signal Processor";
        3: 2904:    case EM_CYPRESS_M8C:	return "Cypress M8C microprocessor";
        1: 2905:    case EM_R32C:		return "Renesas R32C series microprocessors";
        2: 2906:    case EM_TRIMEDIA:		return "NXP Semiconductors TriMedia architecture family";
        3: 2907:    case EM_QDSP6:		return "QUALCOMM DSP6 Processor";
        3: 2908:    case EM_8051:		return "Intel 8051 and variants";
        2: 2909:    case EM_STXP7X:		return "STMicroelectronics STxP7x family";
        5: 2910:    case EM_NDS32:		return "Andes Technology compact code size embedded RISC processor family";
        1: 2911:    case EM_ECOG1X:		return "Cyan Technology eCOG1X family";
        1: 2912:    case EM_MAXQ30:		return "Dallas Semiconductor MAXQ30 Core microcontrollers";
        -: 2913:      /* 170 */
        3: 2914:    case EM_XIMO16:		return "New Japan Radio (NJR) 16-bit DSP Processor";
        3: 2915:    case EM_MANIK:		return "M2000 Reconfigurable RISC Microprocessor";
        2: 2916:    case EM_CRAYNV2:		return "Cray Inc. NV2 vector architecture";
        3: 2917:    case EM_RX:			return "Renesas RX";
    #####: 2918:    case EM_METAG:		return "Imagination Technologies Meta processor architecture";
        2: 2919:    case EM_MCST_ELBRUS:	return "MCST Elbrus general purpose hardware architecture";
        1: 2920:    case EM_ECOG16:		return "Cyan Technology eCOG16 family";
        3: 2921:    case EM_CR16:
        -: 2922:    case EM_MICROBLAZE:
        3: 2923:    case EM_MICROBLAZE_OLD:	return "Xilinx MicroBlaze";
        2: 2924:    case EM_ETPU:		return "Freescale Extended Time Processing Unit";
        2: 2925:    case EM_SLE9X:		return "Infineon Technologies SLE9X core";
        -: 2926:      /* 180 */
        5: 2927:    case EM_L1OM:		return "Intel L1OM";
        3: 2928:    case EM_K1OM:		return "Intel K1OM";
        2: 2929:    case EM_INTEL182:		return "Intel (reserved)";
        3: 2930:    case EM_AARCH64:		return "AArch64";
        2: 2931:    case EM_ARM184:		return "ARM (reserved)";
        2: 2932:    case EM_AVR32:		return "Atmel Corporation 32-bit microprocessor";
        2: 2933:    case EM_STM8:		return "STMicroeletronics STM8 8-bit microcontroller";
        3: 2934:    case EM_TILE64:		return "Tilera TILE64 multicore architecture family";
        3: 2935:    case EM_TILEPRO:		return "Tilera TILEPro multicore architecture family";
        -: 2936:      /* 190 */
        3: 2937:    case EM_CUDA:		return "NVIDIA CUDA architecture";
        2: 2938:    case EM_TILEGX:		return "Tilera TILE-Gx multicore architecture family";
        2: 2939:    case EM_CLOUDSHIELD:	return "CloudShield architecture family";
        3: 2940:    case EM_COREA_1ST:		return "KIPO-KAIST Core-A 1st generation processor family";
        3: 2941:    case EM_COREA_2ND:		return "KIPO-KAIST Core-A 2nd generation processor family";
        7: 2942:    case EM_ARC_COMPACT2:	return "ARCv2";
        4: 2943:    case EM_OPEN8:		return "Open8 8-bit RISC soft processor core";
        5: 2944:    case EM_RL78:		return "Renesas RL78";
        4: 2945:    case EM_VIDEOCORE5:		return "Broadcom VideoCore V processor";
        2: 2946:    case EM_78K0R:		return "Renesas 78K0R";
        -: 2947:      /* 200 */
        4: 2948:    case EM_56800EX:		return "Freescale 56800EX Digital Signal Controller (DSC)";
        2: 2949:    case EM_BA1:		return "Beyond BA1 CPU architecture";
        2: 2950:    case EM_BA2:		return "Beyond BA2 CPU architecture";
        2: 2951:    case EM_XCORE:		return "XMOS xCORE processor family";
        3: 2952:    case EM_MCHP_PIC:		return "Microchip 8-bit PIC(r) family";
        4: 2953:    case EM_INTELGT:		return "Intel Graphics Technology";
        -: 2954:      /* 210 */
        4: 2955:    case EM_KM32:		return "KM211 KM32 32-bit processor";
        2: 2956:    case EM_KMX32:		return "KM211 KMX32 32-bit processor";
        3: 2957:    case EM_KMX16:		return "KM211 KMX16 16-bit processor";
        3: 2958:    case EM_KMX8:		return "KM211 KMX8 8-bit processor";
        3: 2959:    case EM_KVARC:		return "KM211 KVARC processor";
        2: 2960:    case EM_CDP:		return "Paneve CDP architecture family";
        3: 2961:    case EM_COGE:		return "Cognitive Smart Memory Processor";
        3: 2962:    case EM_COOL:		return "Bluechip Systems CoolEngine";
        3: 2963:    case EM_NORC:		return "Nanoradio Optimized RISC";
        3: 2964:    case EM_CSR_KALIMBA:	return "CSR Kalimba architecture family";
        -: 2965:      /* 220 */
        5: 2966:    case EM_Z80:		return "Zilog Z80";
        6: 2967:    case EM_VISIUM:		return "CDS VISIUMcore processor";
        3: 2968:    case EM_FT32:               return "FTDI Chip FT32";
        2: 2969:    case EM_MOXIE:              return "Moxie";
        8: 2970:    case EM_AMDGPU: 	 	return "AMD GPU";
        -: 2971:      /* 230 (all reserved) */
        -: 2972:      /* 240 */
        8: 2973:    case EM_RISCV: 	 	return "RISC-V";
        3: 2974:    case EM_LANAI:		return "Lanai 32-bit processor";
        2: 2975:    case EM_CEVA:		return "CEVA Processor Architecture Family";
        3: 2976:    case EM_CEVA_X2:		return "CEVA X2 Processor Family";
        3: 2977:    case EM_BPF:		return "Linux BPF";
        2: 2978:    case EM_GRAPHCORE_IPU:	return "Graphcore Intelligent Processing Unit";
        3: 2979:    case EM_IMG1:		return "Imagination Technologies";
        -: 2980:      /* 250 */
        6: 2981:    case EM_NFP:		return "Netronome Flow Processor";
        2: 2982:    case EM_VE:			return "NEC Vector Engine";
        4: 2983:    case EM_CSKY:		return "C-SKY";
        3: 2984:    case EM_ARC_COMPACT3_64:	return "Synopsys ARCv2.3 64-bit";
        3: 2985:    case EM_MCS6502:		return "MOS Technology MCS 6502 processor";
        3: 2986:    case EM_ARC_COMPACT3:	return "Synopsys ARCv2.3 32-bit";
        3: 2987:    case EM_KVX:		return "Kalray VLIW core of the MPPA processor family";
        4: 2988:    case EM_65816:		return "WDC 65816/65C816";
        6: 2989:    case EM_LOONGARCH:		return "LoongArch";
        5: 2990:    case EM_KF32:		return "ChipON KungFu32";
        -: 2991:
        -: 2992:      /* Large numbers...  */
    #####: 2993:    case EM_MT:                 return "Morpho Techologies MT processor";
        3: 2994:    case EM_ALPHA:		return "Alpha";
    #####: 2995:    case EM_WEBASSEMBLY:	return "Web Assembly";
    #####: 2996:    case EM_DLX:		return "OpenDLX";
    #####: 2997:    case EM_XSTORMY16:		return "Sanyo XStormy16 CPU core";
    #####: 2998:    case EM_IQ2000:       	return "Vitesse IQ2000";
    #####: 2999:    case EM_M32C_OLD:
    #####: 3000:    case EM_NIOS32:		return "Altera Nios";
    #####: 3001:    case EM_CYGNUS_MEP:         return "Toshiba MeP Media Engine";
    #####: 3002:    case EM_ADAPTEVA_EPIPHANY:	return "Adapteva EPIPHANY";
    #####: 3003:    case EM_CYGNUS_FRV:		return "Fujitsu FR-V";
    #####: 3004:    case EM_S12Z:               return "Freescale S12Z";
        -: 3005:
       86: 3006:    default:
       86: 3007:      snprintf (buff, sizeof (buff), _("<unknown>: 0x%x"), e_machine);
       86: 3008:      return buff;
        -: 3009:    }
        -: 3010:}
        -: 3011:
        -: 3012:static void
        4: 3013:decode_ARC_machine_flags (unsigned e_flags, unsigned e_machine, char buf[])
        -: 3014:{
        -: 3015:  /* ARC has two machine types EM_ARC_COMPACT and EM_ARC_COMPACT2.  Some
        -: 3016:     other compilers don't specify an architecture type in the e_flags, and
        -: 3017:     instead use EM_ARC_COMPACT for old ARC600, ARC601, and ARC700
        -: 3018:     architectures, and switch to EM_ARC_COMPACT2 for newer ARCEM and ARCHS
        -: 3019:     architectures.
        -: 3020:
        -: 3021:     Th GNU tools follows this use of EM_ARC_COMPACT and EM_ARC_COMPACT2,
        -: 3022:     but also sets a specific architecture type in the e_flags field.
        -: 3023:
        -: 3024:     However, when decoding the flags we don't worry if we see an
        -: 3025:     unexpected pairing, for example EM_ARC_COMPACT machine type, with
        -: 3026:     ARCEM architecture type.  */
        -: 3027:
        4: 3028:  switch (e_flags & EF_ARC_MACH_MSK)
        -: 3029:    {
        -: 3030:      /* We only expect these to occur for EM_ARC_COMPACT2.  */
    #####: 3031:    case EF_ARC_CPU_ARCV2EM:
    #####: 3032:      strcat (buf, ", ARC EM");
    #####: 3033:      break;
    #####: 3034:    case EF_ARC_CPU_ARCV2HS:
    #####: 3035:      strcat (buf, ", ARC HS");
    #####: 3036:      break;
        -: 3037:
        -: 3038:      /* We only expect these to occur for EM_ARC_COMPACT.  */
    #####: 3039:    case E_ARC_MACH_ARC600:
    #####: 3040:      strcat (buf, ", ARC600");
    #####: 3041:      break;
        1: 3042:    case E_ARC_MACH_ARC601:
        1: 3043:      strcat (buf, ", ARC601");
        1: 3044:      break;
    #####: 3045:    case E_ARC_MACH_ARC700:
    #####: 3046:      strcat (buf, ", ARC700");
    #####: 3047:      break;
        -: 3048:
        -: 3049:      /* The only times we should end up here are (a) A corrupt ELF, (b) A
        -: 3050:         new ELF with new architecture being read by an old version of
        -: 3051:         readelf, or (c) An ELF built with non-GNU compiler that does not
        -: 3052:         set the architecture in the e_flags.  */
        3: 3053:    default:
        3: 3054:      if (e_machine == EM_ARC_COMPACT)
        1: 3055:        strcat (buf, ", Unknown ARCompact");
        -: 3056:      else
        2: 3057:        strcat (buf, ", Unknown ARC");
        3: 3058:      break;
        -: 3059:    }
        -: 3060:
        4: 3061:  switch (e_flags & EF_ARC_OSABI_MSK)
        -: 3062:    {
        2: 3063:    case E_ARC_OSABI_ORIG:
        2: 3064:      strcat (buf, ", (ABI:legacy)");
        2: 3065:      break;
    #####: 3066:    case E_ARC_OSABI_V2:
    #####: 3067:      strcat (buf, ", (ABI:v2)");
    #####: 3068:      break;
        -: 3069:      /* Only upstream 3.9+ kernels will support ARCv2 ISA.  */
    #####: 3070:    case E_ARC_OSABI_V3:
    #####: 3071:      strcat (buf, ", v3 no-legacy-syscalls ABI");
    #####: 3072:      break;
    #####: 3073:    case E_ARC_OSABI_V4:
    #####: 3074:      strcat (buf, ", v4 ABI");
    #####: 3075:      break;
        2: 3076:    default:
        2: 3077:      strcat (buf, ", unrecognised ARC OSABI flag");
        2: 3078:      break;
        -: 3079:    }
        4: 3080:}
        -: 3081:
        -: 3082:static void
       32: 3083:decode_ARM_machine_flags (unsigned e_flags, char buf[])
        -: 3084:{
        -: 3085:  unsigned eabi;
       32: 3086:  bool unknown = false;
        -: 3087:
       32: 3088:  eabi = EF_ARM_EABI_VERSION (e_flags);
       32: 3089:  e_flags &= ~ EF_ARM_EABIMASK;
        -: 3090:
        -: 3091:  /* Handle "generic" ARM flags.  */
       32: 3092:  if (e_flags & EF_ARM_RELEXEC)
        -: 3093:    {
        9: 3094:      strcat (buf, ", relocatable executable");
        9: 3095:      e_flags &= ~ EF_ARM_RELEXEC;
        -: 3096:    }
        -: 3097:
       32: 3098:  if (e_flags & EF_ARM_PIC)
        -: 3099:    {
        7: 3100:      strcat (buf, ", position independent");
        7: 3101:      e_flags &= ~ EF_ARM_PIC;
        -: 3102:    }
        -: 3103:
        -: 3104:  /* Now handle EABI specific flags.  */
       32: 3105:  switch (eabi)
        -: 3106:    {
        3: 3107:    default:
        3: 3108:      strcat (buf, ", <unrecognized EABI>");
        3: 3109:      if (e_flags)
        2: 3110:	unknown = true;
        3: 3111:      break;
        -: 3112:
        5: 3113:    case EF_ARM_EABI_VER1:
        5: 3114:      strcat (buf, ", Version1 EABI");
       24: 3115:      while (e_flags)
        -: 3116:	{
        -: 3117:	  unsigned flag;
        -: 3118:
        -: 3119:	  /* Process flags one bit at a time.  */
       19: 3120:	  flag = e_flags & - e_flags;
       19: 3121:	  e_flags &= ~ flag;
        -: 3122:
        -: 3123:	  switch (flag)
        -: 3124:	    {
        2: 3125:	    case EF_ARM_SYMSARESORTED: /* Conflicts with EF_ARM_INTERWORK.  */
        2: 3126:	      strcat (buf, ", sorted symbol tables");
        2: 3127:	      break;
        -: 3128:
       17: 3129:	    default:
       17: 3130:	      unknown = true;
       17: 3131:	      break;
        -: 3132:	    }
        -: 3133:	}
        5: 3134:      break;
        -: 3135:
    #####: 3136:    case EF_ARM_EABI_VER2:
    #####: 3137:      strcat (buf, ", Version2 EABI");
    #####: 3138:      while (e_flags)
        -: 3139:	{
        -: 3140:	  unsigned flag;
        -: 3141:
        -: 3142:	  /* Process flags one bit at a time.  */
    #####: 3143:	  flag = e_flags & - e_flags;
    #####: 3144:	  e_flags &= ~ flag;
        -: 3145:
        -: 3146:	  switch (flag)
        -: 3147:	    {
    #####: 3148:	    case EF_ARM_SYMSARESORTED: /* Conflicts with EF_ARM_INTERWORK.  */
    #####: 3149:	      strcat (buf, ", sorted symbol tables");
    #####: 3150:	      break;
        -: 3151:
    #####: 3152:	    case EF_ARM_DYNSYMSUSESEGIDX:
    #####: 3153:	      strcat (buf, ", dynamic symbols use segment index");
    #####: 3154:	      break;
        -: 3155:
    #####: 3156:	    case EF_ARM_MAPSYMSFIRST:
    #####: 3157:	      strcat (buf, ", mapping symbols precede others");
    #####: 3158:	      break;
        -: 3159:
    #####: 3160:	    default:
    #####: 3161:	      unknown = true;
    #####: 3162:	      break;
        -: 3163:	    }
        -: 3164:	}
    #####: 3165:      break;
        -: 3166:
        1: 3167:    case EF_ARM_EABI_VER3:
        1: 3168:      strcat (buf, ", Version3 EABI");
        1: 3169:      break;
        -: 3170:
        5: 3171:    case EF_ARM_EABI_VER4:
        5: 3172:      strcat (buf, ", Version4 EABI");
       16: 3173:      while (e_flags)
        -: 3174:	{
        -: 3175:	  unsigned flag;
        -: 3176:
        -: 3177:	  /* Process flags one bit at a time.  */
       11: 3178:	  flag = e_flags & - e_flags;
       11: 3179:	  e_flags &= ~ flag;
        -: 3180:
        -: 3181:	  switch (flag)
        -: 3182:	    {
        4: 3183:	    case EF_ARM_BE8:
        4: 3184:	      strcat (buf, ", BE8");
        4: 3185:	      break;
        -: 3186:
    #####: 3187:	    case EF_ARM_LE8:
    #####: 3188:	      strcat (buf, ", LE8");
    #####: 3189:	      break;
        -: 3190:
        7: 3191:	    default:
        7: 3192:	      unknown = true;
        7: 3193:	      break;
        -: 3194:	    }
        -: 3195:	}
        5: 3196:      break;
        -: 3197:
        2: 3198:    case EF_ARM_EABI_VER5:
        2: 3199:      strcat (buf, ", Version5 EABI");
        3: 3200:      while (e_flags)
        -: 3201:	{
        -: 3202:	  unsigned flag;
        -: 3203:
        -: 3204:	  /* Process flags one bit at a time.  */
        1: 3205:	  flag = e_flags & - e_flags;
        1: 3206:	  e_flags &= ~ flag;
        -: 3207:
        -: 3208:	  switch (flag)
        -: 3209:	    {
    #####: 3210:	    case EF_ARM_BE8:
    #####: 3211:	      strcat (buf, ", BE8");
    #####: 3212:	      break;
        -: 3213:
    #####: 3214:	    case EF_ARM_LE8:
    #####: 3215:	      strcat (buf, ", LE8");
    #####: 3216:	      break;
        -: 3217:
    #####: 3218:	    case EF_ARM_ABI_FLOAT_SOFT: /* Conflicts with EF_ARM_SOFT_FLOAT.  */
    #####: 3219:	      strcat (buf, ", soft-float ABI");
    #####: 3220:	      break;
        -: 3221:
    #####: 3222:	    case EF_ARM_ABI_FLOAT_HARD: /* Conflicts with EF_ARM_VFP_FLOAT.  */
    #####: 3223:	      strcat (buf, ", hard-float ABI");
    #####: 3224:	      break;
        -: 3225:
        1: 3226:	    default:
        1: 3227:	      unknown = true;
        1: 3228:	      break;
        -: 3229:	    }
        -: 3230:	}
        2: 3231:      break;
        -: 3232:
       16: 3233:    case EF_ARM_EABI_UNKNOWN:
       16: 3234:      strcat (buf, ", GNU EABI");
       93: 3235:      while (e_flags)
        -: 3236:	{
        -: 3237:	  unsigned flag;
        -: 3238:
        -: 3239:	  /* Process flags one bit at a time.  */
       77: 3240:	  flag = e_flags & - e_flags;
       77: 3241:	  e_flags &= ~ flag;
        -: 3242:
        -: 3243:	  switch (flag)
        -: 3244:	    {
        6: 3245:	    case EF_ARM_INTERWORK:
        6: 3246:	      strcat (buf, ", interworking enabled");
        6: 3247:	      break;
        -: 3248:
        6: 3249:	    case EF_ARM_APCS_26:
        6: 3250:	      strcat (buf, ", uses APCS/26");
        6: 3251:	      break;
        -: 3252:
        5: 3253:	    case EF_ARM_APCS_FLOAT:
        5: 3254:	      strcat (buf, ", uses APCS/float");
        5: 3255:	      break;
        -: 3256:
    #####: 3257:	    case EF_ARM_PIC:
    #####: 3258:	      strcat (buf, ", position independent");
    #####: 3259:	      break;
        -: 3260:
        3: 3261:	    case EF_ARM_ALIGN8:
        3: 3262:	      strcat (buf, ", 8 bit structure alignment");
        3: 3263:	      break;
        -: 3264:
        5: 3265:	    case EF_ARM_NEW_ABI:
        5: 3266:	      strcat (buf, ", uses new ABI");
        5: 3267:	      break;
        -: 3268:
        2: 3269:	    case EF_ARM_OLD_ABI:
        2: 3270:	      strcat (buf, ", uses old ABI");
        2: 3271:	      break;
        -: 3272:
        3: 3273:	    case EF_ARM_SOFT_FLOAT:
        3: 3274:	      strcat (buf, ", software FP");
        3: 3275:	      break;
        -: 3276:
        4: 3277:	    case EF_ARM_VFP_FLOAT:
        4: 3278:	      strcat (buf, ", VFP");
        4: 3279:	      break;
        -: 3280:
        6: 3281:	    case EF_ARM_MAVERICK_FLOAT:
        6: 3282:	      strcat (buf, ", Maverick FP");
        6: 3283:	      break;
        -: 3284:
       37: 3285:	    default:
       37: 3286:	      unknown = true;
       37: 3287:	      break;
        -: 3288:	    }
        -: 3289:	}
        -: 3290:    }
        -: 3291:
       32: 3292:  if (unknown)
       23: 3293:    strcat (buf,_(", <unknown>"));
       32: 3294:}
        -: 3295:
        -: 3296:static void
        4: 3297:decode_AVR_machine_flags (unsigned e_flags, char buf[], size_t size)
        -: 3298:{
        4: 3299:  --size; /* Leave space for null terminator.  */
        -: 3300:
        4: 3301:  switch (e_flags & EF_AVR_MACH)
        -: 3302:    {
        1: 3303:    case E_AVR_MACH_AVR1:
        1: 3304:      strncat (buf, ", avr:1", size);
        1: 3305:      break;
    #####: 3306:    case E_AVR_MACH_AVR2:
    #####: 3307:      strncat (buf, ", avr:2", size);
    #####: 3308:      break;
    #####: 3309:    case E_AVR_MACH_AVR25:
    #####: 3310:      strncat (buf, ", avr:25", size);
    #####: 3311:      break;
    #####: 3312:    case E_AVR_MACH_AVR3:
    #####: 3313:      strncat (buf, ", avr:3", size);
    #####: 3314:      break;
    #####: 3315:    case E_AVR_MACH_AVR31:
    #####: 3316:      strncat (buf, ", avr:31", size);
    #####: 3317:      break;
    #####: 3318:    case E_AVR_MACH_AVR35:
    #####: 3319:      strncat (buf, ", avr:35", size);
    #####: 3320:      break;
    #####: 3321:    case E_AVR_MACH_AVR4:
    #####: 3322:      strncat (buf, ", avr:4", size);
    #####: 3323:      break;
    #####: 3324:    case E_AVR_MACH_AVR5:
    #####: 3325:      strncat (buf, ", avr:5", size);
    #####: 3326:      break;
    #####: 3327:    case E_AVR_MACH_AVR51:
    #####: 3328:      strncat (buf, ", avr:51", size);
    #####: 3329:      break;
    #####: 3330:    case E_AVR_MACH_AVR6:
    #####: 3331:      strncat (buf, ", avr:6", size);
    #####: 3332:      break;
    #####: 3333:    case E_AVR_MACH_AVRTINY:
    #####: 3334:      strncat (buf, ", avr:100", size);
    #####: 3335:      break;
    #####: 3336:    case E_AVR_MACH_XMEGA1:
    #####: 3337:      strncat (buf, ", avr:101", size);
    #####: 3338:      break;
    #####: 3339:    case E_AVR_MACH_XMEGA2:
    #####: 3340:      strncat (buf, ", avr:102", size);
    #####: 3341:      break;
        1: 3342:    case E_AVR_MACH_XMEGA3:
        1: 3343:      strncat (buf, ", avr:103", size);
        1: 3344:      break;
    #####: 3345:    case E_AVR_MACH_XMEGA4:
    #####: 3346:      strncat (buf, ", avr:104", size);
    #####: 3347:      break;
    #####: 3348:    case E_AVR_MACH_XMEGA5:
    #####: 3349:      strncat (buf, ", avr:105", size);
    #####: 3350:      break;
    #####: 3351:    case E_AVR_MACH_XMEGA6:
    #####: 3352:      strncat (buf, ", avr:106", size);
    #####: 3353:      break;
    #####: 3354:    case E_AVR_MACH_XMEGA7:
    #####: 3355:      strncat (buf, ", avr:107", size);
    #####: 3356:      break;
        2: 3357:    default:
        2: 3358:      strncat (buf, ", avr:<unknown>", size);
        2: 3359:      break;
        -: 3360:    }
        -: 3361:
        4: 3362:  size -= strlen (buf);
        4: 3363:  if (e_flags & EF_AVR_LINKRELAX_PREPARED)
        2: 3364:    strncat (buf, ", link-relax", size);
        4: 3365:}
        -: 3366:
        -: 3367:static void
        3: 3368:decode_NDS32_machine_flags (unsigned e_flags, char buf[], size_t size)
        -: 3369:{
        -: 3370:  unsigned abi;
        -: 3371:  unsigned arch;
        -: 3372:  unsigned config;
        -: 3373:  unsigned version;
        3: 3374:  bool has_fpu = false;
        3: 3375:  unsigned int r = 0;
        -: 3376:
        -: 3377:  static const char *ABI_STRINGS[] =
        -: 3378:  {
        -: 3379:    "ABI v0", /* use r5 as return register; only used in N1213HC */
        -: 3380:    "ABI v1", /* use r0 as return register */
        -: 3381:    "ABI v2", /* use r0 as return register and don't reserve 24 bytes for arguments */
        -: 3382:    "ABI v2fp", /* for FPU */
        -: 3383:    "AABI",
        -: 3384:    "ABI2 FP+"
        -: 3385:  };
        -: 3386:  static const char *VER_STRINGS[] =
        -: 3387:  {
        -: 3388:    "Andes ELF V1.3 or older",
        -: 3389:    "Andes ELF V1.3.1",
        -: 3390:    "Andes ELF V1.4"
        -: 3391:  };
        -: 3392:  static const char *ARCH_STRINGS[] =
        -: 3393:  {
        -: 3394:    "",
        -: 3395:    "Andes Star v1.0",
        -: 3396:    "Andes Star v2.0",
        -: 3397:    "Andes Star v3.0",
        -: 3398:    "Andes Star v3.0m"
        -: 3399:  };
        -: 3400:
        3: 3401:  abi = EF_NDS_ABI & e_flags;
        3: 3402:  arch = EF_NDS_ARCH & e_flags;
        3: 3403:  config = EF_NDS_INST & e_flags;
        3: 3404:  version = EF_NDS32_ELF_VERSION & e_flags;
        -: 3405:
        3: 3406:  memset (buf, 0, size);
        -: 3407:
        3: 3408:  switch (abi)
        -: 3409:    {
        1: 3410:    case E_NDS_ABI_V0:
        -: 3411:    case E_NDS_ABI_V1:
        -: 3412:    case E_NDS_ABI_V2:
        -: 3413:    case E_NDS_ABI_V2FP:
        -: 3414:    case E_NDS_ABI_AABI:
        -: 3415:    case E_NDS_ABI_V2FP_PLUS:
        -: 3416:      /* In case there are holes in the array.  */
        1: 3417:      r += snprintf (buf + r, size - r, ", %s", ABI_STRINGS[abi >> EF_NDS_ABI_SHIFT]);
        1: 3418:      break;
        -: 3419:
        2: 3420:    default:
        2: 3421:      r += snprintf (buf + r, size - r, ", <unrecognized ABI>");
        2: 3422:      break;
        -: 3423:    }
        -: 3424:
        3: 3425:  switch (version)
        -: 3426:    {
        2: 3427:    case E_NDS32_ELF_VER_1_2:
        -: 3428:    case E_NDS32_ELF_VER_1_3:
        -: 3429:    case E_NDS32_ELF_VER_1_4:
        2: 3430:      r += snprintf (buf + r, size - r, ", %s", VER_STRINGS[version >> EF_NDS32_ELF_VERSION_SHIFT]);
        2: 3431:      break;
        -: 3432:
        1: 3433:    default:
        1: 3434:      r += snprintf (buf + r, size - r, ", <unrecognized ELF version number>");
        1: 3435:      break;
        -: 3436:    }
        -: 3437:
        3: 3438:  if (E_NDS_ABI_V0 == abi)
        -: 3439:    {
        -: 3440:      /* OLD ABI; only used in N1213HC, has performance extension 1.  */
        1: 3441:      r += snprintf (buf + r, size - r, ", Andes Star v1.0, N1213HC, MAC, PERF1");
        1: 3442:      if (arch == E_NDS_ARCH_STAR_V1_0)
    #####: 3443:	r += snprintf (buf + r, size -r, ", 16b"); /* has 16-bit instructions */
        1: 3444:      return;
        -: 3445:    }
        -: 3446:
        2: 3447:  switch (arch)
        -: 3448:    {
    #####: 3449:    case E_NDS_ARCH_STAR_V1_0:
        -: 3450:    case E_NDS_ARCH_STAR_V2_0:
        -: 3451:    case E_NDS_ARCH_STAR_V3_0:
        -: 3452:    case E_NDS_ARCH_STAR_V3_M:
    #####: 3453:      r += snprintf (buf + r, size - r, ", %s", ARCH_STRINGS[arch >> EF_NDS_ARCH_SHIFT]);
    #####: 3454:      break;
        -: 3455:
        2: 3456:    default:
        2: 3457:      r += snprintf (buf + r, size - r, ", <unrecognized architecture>");
        -: 3458:      /* ARCH version determines how the e_flags are interpreted.
        -: 3459:	 If it is unknown, we cannot proceed.  */
        2: 3460:      return;
        -: 3461:    }
        -: 3462:
        -: 3463:  /* Newer ABI; Now handle architecture specific flags.  */
    #####: 3464:  if (arch == E_NDS_ARCH_STAR_V1_0)
        -: 3465:    {
    #####: 3466:      if (config & E_NDS32_HAS_MFUSR_PC_INST)
    #####: 3467:	r += snprintf (buf + r, size -r, ", MFUSR_PC");
        -: 3468:
    #####: 3469:      if (!(config & E_NDS32_HAS_NO_MAC_INST))
    #####: 3470:	r += snprintf (buf + r, size -r, ", MAC");
        -: 3471:
    #####: 3472:      if (config & E_NDS32_HAS_DIV_INST)
    #####: 3473:	r += snprintf (buf + r, size -r, ", DIV");
        -: 3474:
    #####: 3475:      if (config & E_NDS32_HAS_16BIT_INST)
    #####: 3476:	r += snprintf (buf + r, size -r, ", 16b");
        -: 3477:    }
        -: 3478:  else
        -: 3479:    {
    #####: 3480:      if (config & E_NDS32_HAS_MFUSR_PC_INST)
        -: 3481:	{
    #####: 3482:	  if (version <= E_NDS32_ELF_VER_1_3)
    #####: 3483:	    r += snprintf (buf + r, size -r, ", [B8]");
        -: 3484:	  else
    #####: 3485:	    r += snprintf (buf + r, size -r, ", EX9");
        -: 3486:	}
        -: 3487:
    #####: 3488:      if (config & E_NDS32_HAS_MAC_DX_INST)
    #####: 3489:	r += snprintf (buf + r, size -r, ", MAC_DX");
        -: 3490:
    #####: 3491:      if (config & E_NDS32_HAS_DIV_DX_INST)
    #####: 3492:	r += snprintf (buf + r, size -r, ", DIV_DX");
        -: 3493:
    #####: 3494:      if (config & E_NDS32_HAS_16BIT_INST)
        -: 3495:	{
    #####: 3496:	  if (version <= E_NDS32_ELF_VER_1_3)
    #####: 3497:	    r += snprintf (buf + r, size -r, ", 16b");
        -: 3498:	  else
    #####: 3499:	    r += snprintf (buf + r, size -r, ", IFC");
        -: 3500:	}
        -: 3501:    }
        -: 3502:
    #####: 3503:  if (config & E_NDS32_HAS_EXT_INST)
    #####: 3504:    r += snprintf (buf + r, size -r, ", PERF1");
        -: 3505:
    #####: 3506:  if (config & E_NDS32_HAS_EXT2_INST)
    #####: 3507:    r += snprintf (buf + r, size -r, ", PERF2");
        -: 3508:
    #####: 3509:  if (config & E_NDS32_HAS_FPU_INST)
        -: 3510:    {
    #####: 3511:      has_fpu = true;
    #####: 3512:      r += snprintf (buf + r, size -r, ", FPU_SP");
        -: 3513:    }
        -: 3514:
    #####: 3515:  if (config & E_NDS32_HAS_FPU_DP_INST)
        -: 3516:    {
    #####: 3517:      has_fpu = true;
    #####: 3518:      r += snprintf (buf + r, size -r, ", FPU_DP");
        -: 3519:    }
        -: 3520:
    #####: 3521:  if (config & E_NDS32_HAS_FPU_MAC_INST)
        -: 3522:    {
    #####: 3523:      has_fpu = true;
    #####: 3524:      r += snprintf (buf + r, size -r, ", FPU_MAC");
        -: 3525:    }
        -: 3526:
    #####: 3527:  if (has_fpu)
        -: 3528:    {
    #####: 3529:      switch ((config & E_NDS32_FPU_REG_CONF) >> E_NDS32_FPU_REG_CONF_SHIFT)
        -: 3530:	{
    #####: 3531:	case E_NDS32_FPU_REG_8SP_4DP:
    #####: 3532:	  r += snprintf (buf + r, size -r, ", FPU_REG:8/4");
    #####: 3533:	  break;
    #####: 3534:	case E_NDS32_FPU_REG_16SP_8DP:
    #####: 3535:	  r += snprintf (buf + r, size -r, ", FPU_REG:16/8");
    #####: 3536:	  break;
    #####: 3537:	case E_NDS32_FPU_REG_32SP_16DP:
    #####: 3538:	  r += snprintf (buf + r, size -r, ", FPU_REG:32/16");
    #####: 3539:	  break;
    #####: 3540:	case E_NDS32_FPU_REG_32SP_32DP:
    #####: 3541:	  r += snprintf (buf + r, size -r, ", FPU_REG:32/32");
    #####: 3542:	  break;
        -: 3543:	}
    #####: 3544:    }
        -: 3545:
    #####: 3546:  if (config & E_NDS32_HAS_AUDIO_INST)
    #####: 3547:    r += snprintf (buf + r, size -r, ", AUDIO");
        -: 3548:
    #####: 3549:  if (config & E_NDS32_HAS_STRING_INST)
    #####: 3550:    r += snprintf (buf + r, size -r, ", STR");
        -: 3551:
    #####: 3552:  if (config & E_NDS32_HAS_REDUCED_REGS)
    #####: 3553:    r += snprintf (buf + r, size -r, ", 16REG");
        -: 3554:
    #####: 3555:  if (config & E_NDS32_HAS_VIDEO_INST)
        -: 3556:    {
    #####: 3557:      if (version <= E_NDS32_ELF_VER_1_3)
    #####: 3558:	r += snprintf (buf + r, size -r, ", VIDEO");
        -: 3559:      else
    #####: 3560:	r += snprintf (buf + r, size -r, ", SATURATION");
        -: 3561:    }
        -: 3562:
    #####: 3563:  if (config & E_NDS32_HAS_ENCRIPT_INST)
    #####: 3564:    r += snprintf (buf + r, size -r, ", ENCRP");
        -: 3565:
    #####: 3566:  if (config & E_NDS32_HAS_L2C_INST)
    #####: 3567:    r += snprintf (buf + r, size -r, ", L2C");
        -: 3568:}
        -: 3569:
        -: 3570:static void
        5: 3571:decode_AMDGPU_machine_flags (Filedata *filedata, unsigned int e_flags,
        -: 3572:			     char *buf)
        -: 3573:{
        5: 3574:  unsigned char *e_ident = filedata->file_header.e_ident;
        5: 3575:  unsigned char osabi = e_ident[EI_OSABI];
        5: 3576:  unsigned char abiversion = e_ident[EI_ABIVERSION];
        -: 3577:  unsigned int mach;
        -: 3578:
        -: 3579:  /* HSA OS ABI v2 used a different encoding, but we don't need to support it,
        -: 3580:     it has been deprecated for a while.
        -: 3581:
        -: 3582:     The PAL, MESA3D and NONE OS ABIs are not properly versioned, at the time
        -: 3583:     of writing, they use the same flags as HSA v3, so the code below uses that
        -: 3584:     assumption.  */
       5*: 3585:  if (osabi == ELFOSABI_AMDGPU_HSA && abiversion < ELFABIVERSION_AMDGPU_HSA_V3)
    #####: 3586:    return;
        -: 3587:
        5: 3588:  mach = e_flags & EF_AMDGPU_MACH;
        5: 3589:  switch (mach)
        -: 3590:    {
        -: 3591:#define AMDGPU_CASE(code, string) \
        -: 3592:  case code: strcat (buf, ", " string); break;
        1: 3593:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX600, "gfx600")
        1: 3594:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX601, "gfx601")
    #####: 3595:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX700, "gfx700")
    #####: 3596:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX701, "gfx701")
    #####: 3597:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX702, "gfx702")
    #####: 3598:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX703, "gfx703")
    #####: 3599:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX704, "gfx704")
    #####: 3600:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX801, "gfx801")
    #####: 3601:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX802, "gfx802")
    #####: 3602:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX803, "gfx803")
    #####: 3603:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX810, "gfx810")
    #####: 3604:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX900, "gfx900")
    #####: 3605:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX902, "gfx902")
    #####: 3606:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX904, "gfx904")
    #####: 3607:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX906, "gfx906")
    #####: 3608:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX908, "gfx908")
    #####: 3609:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX909, "gfx909")
    #####: 3610:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX90C, "gfx90c")
    #####: 3611:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX1010, "gfx1010")
    #####: 3612:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX1011, "gfx1011")
    #####: 3613:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX1012, "gfx1012")
    #####: 3614:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX1030, "gfx1030")
    #####: 3615:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX1031, "gfx1031")
    #####: 3616:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX1032, "gfx1032")
    #####: 3617:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX1033, "gfx1033")
    #####: 3618:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX602, "gfx602")
    #####: 3619:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX705, "gfx705")
    #####: 3620:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX805, "gfx805")
    #####: 3621:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX1035, "gfx1035")
    #####: 3622:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX1034, "gfx1034")
    #####: 3623:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX90A, "gfx90a")
    #####: 3624:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX940, "gfx940")
    #####: 3625:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX1013, "gfx1013")
    #####: 3626:    AMDGPU_CASE (EF_AMDGPU_MACH_AMDGCN_GFX1036, "gfx1036")
        3: 3627:    default:
        3: 3628:      sprintf (buf, _(", <unknown AMDGPU GPU type: %#x>"), mach);
        3: 3629:      break;
        -: 3630:#undef AMDGPU_CASE
        -: 3631:    }
        -: 3632:
        5: 3633:  buf += strlen (buf);
        5: 3634:  e_flags &= ~EF_AMDGPU_MACH;
        -: 3635:
        5: 3636:  if ((osabi == ELFOSABI_AMDGPU_HSA
    #####: 3637:       && abiversion == ELFABIVERSION_AMDGPU_HSA_V3)
        5: 3638:      || osabi != ELFOSABI_AMDGPU_HSA)
        -: 3639:    {
        -: 3640:      /* For HSA v3 and other OS ABIs.  */
        5: 3641:      if (e_flags & EF_AMDGPU_FEATURE_XNACK_V3)
        -: 3642:	{
        1: 3643:	  strcat (buf, ", xnack on");
        1: 3644:	  buf += strlen (buf);
        1: 3645:	  e_flags &= ~EF_AMDGPU_FEATURE_XNACK_V3;
        -: 3646:	}
        -: 3647:
        5: 3648:      if (e_flags & EF_AMDGPU_FEATURE_SRAMECC_V3)
        -: 3649:	{
        1: 3650:	  strcat (buf, ", sramecc on");
        1: 3651:	  buf += strlen (buf);
        1: 3652:	  e_flags &= ~EF_AMDGPU_FEATURE_SRAMECC_V3;
        -: 3653:	}
        -: 3654:    }
        -: 3655:  else
        -: 3656:    {
        -: 3657:      /* For HSA v4+.  */
        -: 3658:      int xnack, sramecc;
        -: 3659:
    #####: 3660:      xnack = e_flags & EF_AMDGPU_FEATURE_XNACK_V4;
    #####: 3661:      switch (xnack)
        -: 3662:	{
    #####: 3663:	case EF_AMDGPU_FEATURE_XNACK_UNSUPPORTED_V4:
    #####: 3664:	  break;
        -: 3665:
    #####: 3666:	case EF_AMDGPU_FEATURE_XNACK_ANY_V4:
    #####: 3667:	  strcat (buf, ", xnack any");
    #####: 3668:	  break;
        -: 3669:
    #####: 3670:	case EF_AMDGPU_FEATURE_XNACK_OFF_V4:
    #####: 3671:	  strcat (buf, ", xnack off");
    #####: 3672:	  break;
        -: 3673:
    #####: 3674:	case EF_AMDGPU_FEATURE_XNACK_ON_V4:
    #####: 3675:	  strcat (buf, ", xnack on");
    #####: 3676:	  break;
        -: 3677:
    #####: 3678:	default:
    #####: 3679:	  sprintf (buf, _(", <unknown xnack value: %#x>"), xnack);
    #####: 3680:	  break;
        -: 3681:	}
        -: 3682:
    #####: 3683:      buf += strlen (buf);
    #####: 3684:      e_flags &= ~EF_AMDGPU_FEATURE_XNACK_V4;
        -: 3685:
    #####: 3686:      sramecc = e_flags & EF_AMDGPU_FEATURE_SRAMECC_V4;
    #####: 3687:      switch (sramecc)
        -: 3688:	{
    #####: 3689:	case EF_AMDGPU_FEATURE_SRAMECC_UNSUPPORTED_V4:
    #####: 3690:	  break;
        -: 3691:
    #####: 3692:	case EF_AMDGPU_FEATURE_SRAMECC_ANY_V4:
    #####: 3693:	  strcat (buf, ", sramecc any");
    #####: 3694:	  break;
        -: 3695:
    #####: 3696:	case EF_AMDGPU_FEATURE_SRAMECC_OFF_V4:
    #####: 3697:	  strcat (buf, ", sramecc off");
    #####: 3698:	  break;
        -: 3699:
    #####: 3700:	case EF_AMDGPU_FEATURE_SRAMECC_ON_V4:
    #####: 3701:	  strcat (buf, ", sramecc on");
    #####: 3702:	  break;
        -: 3703:
    #####: 3704:	default:
    #####: 3705:	  sprintf (buf, _(", <unknown sramecc value: %#x>"), sramecc);
    #####: 3706:	  break;
        -: 3707:	}
        -: 3708:
    #####: 3709:      buf += strlen (buf);
    #####: 3710:      e_flags &= ~EF_AMDGPU_FEATURE_SRAMECC_V4;
        -: 3711:    }
        -: 3712:
        5: 3713:  if (e_flags != 0)
        4: 3714:    sprintf (buf, _(", unknown flags bits: %#x"), e_flags);
        -: 3715:}
        -: 3716:
        -: 3717:static char *
     1391: 3718:get_machine_flags (Filedata * filedata, unsigned e_flags, unsigned e_machine)
        -: 3719:{
        -: 3720:  static char buf[1024];
        -: 3721:
     1391: 3722:  buf[0] = '\0';
        -: 3723:
     1391: 3724:  if (e_flags)
        -: 3725:    {
      420: 3726:      switch (e_machine)
        -: 3727:	{
      225: 3728:	default:
      225: 3729:	  break;
        -: 3730:
        4: 3731:	case EM_ARC_COMPACT2:
        -: 3732:	case EM_ARC_COMPACT:
        4: 3733:          decode_ARC_machine_flags (e_flags, e_machine, buf);
        4: 3734:          break;
        -: 3735:
       32: 3736:	case EM_ARM:
       32: 3737:	  decode_ARM_machine_flags (e_flags, buf);
       32: 3738:	  break;
        -: 3739:
        4: 3740:        case EM_AVR:
        4: 3741:          decode_AVR_machine_flags (e_flags, buf, sizeof buf);
        4: 3742:          break;
        -: 3743:
        2: 3744:	case EM_BLACKFIN:
        2: 3745:	  if (e_flags & EF_BFIN_PIC)
    #####: 3746:	    strcat (buf, ", PIC");
        -: 3747:
        2: 3748:	  if (e_flags & EF_BFIN_FDPIC)
    #####: 3749:	    strcat (buf, ", FDPIC");
        -: 3750:
        2: 3751:	  if (e_flags & EF_BFIN_CODE_IN_L1)
        1: 3752:	    strcat (buf, ", code in L1");
        -: 3753:
        2: 3754:	  if (e_flags & EF_BFIN_DATA_IN_L1)
        1: 3755:	    strcat (buf, ", data in L1");
        -: 3756:
        2: 3757:	  break;
        -: 3758:
    #####: 3759:	case EM_CYGNUS_FRV:
    #####: 3760:	  switch (e_flags & EF_FRV_CPU_MASK)
        -: 3761:	    {
    #####: 3762:	    case EF_FRV_CPU_GENERIC:
    #####: 3763:	      break;
        -: 3764:
    #####: 3765:	    default:
    #####: 3766:	      strcat (buf, ", fr???");
    #####: 3767:	      break;
        -: 3768:
    #####: 3769:	    case EF_FRV_CPU_FR300:
    #####: 3770:	      strcat (buf, ", fr300");
    #####: 3771:	      break;
        -: 3772:
    #####: 3773:	    case EF_FRV_CPU_FR400:
    #####: 3774:	      strcat (buf, ", fr400");
    #####: 3775:	      break;
    #####: 3776:	    case EF_FRV_CPU_FR405:
    #####: 3777:	      strcat (buf, ", fr405");
    #####: 3778:	      break;
        -: 3779:
    #####: 3780:	    case EF_FRV_CPU_FR450:
    #####: 3781:	      strcat (buf, ", fr450");
    #####: 3782:	      break;
        -: 3783:
    #####: 3784:	    case EF_FRV_CPU_FR500:
    #####: 3785:	      strcat (buf, ", fr500");
    #####: 3786:	      break;
    #####: 3787:	    case EF_FRV_CPU_FR550:
    #####: 3788:	      strcat (buf, ", fr550");
    #####: 3789:	      break;
        -: 3790:
    #####: 3791:	    case EF_FRV_CPU_SIMPLE:
    #####: 3792:	      strcat (buf, ", simple");
    #####: 3793:	      break;
    #####: 3794:	    case EF_FRV_CPU_TOMCAT:
    #####: 3795:	      strcat (buf, ", tomcat");
    #####: 3796:	      break;
        -: 3797:	    }
    #####: 3798:	  break;
        -: 3799:
       16: 3800:	case EM_68K:
       16: 3801:	  if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
        1: 3802:	    strcat (buf, ", m68000");
       15: 3803:	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
        1: 3804:	    strcat (buf, ", cpu32");
       14: 3805:	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
        1: 3806:	    strcat (buf, ", fido_a");
        -: 3807:	  else
        -: 3808:	    {
       13: 3809:	      char const * isa = _("unknown");
       13: 3810:	      char const * mac = _("unknown mac");
       13: 3811:	      char const * additional = NULL;
        -: 3812:
       13: 3813:	      switch (e_flags & EF_M68K_CF_ISA_MASK)
        -: 3814:		{
        1: 3815:		case EF_M68K_CF_ISA_A_NODIV:
        1: 3816:		  isa = "A";
        1: 3817:		  additional = ", nodiv";
        1: 3818:		  break;
        1: 3819:		case EF_M68K_CF_ISA_A:
        1: 3820:		  isa = "A";
        1: 3821:		  break;
        1: 3822:		case EF_M68K_CF_ISA_A_PLUS:
        1: 3823:		  isa = "A+";
        1: 3824:		  break;
        1: 3825:		case EF_M68K_CF_ISA_B_NOUSP:
        1: 3826:		  isa = "B";
        1: 3827:		  additional = ", nousp";
        1: 3828:		  break;
        2: 3829:		case EF_M68K_CF_ISA_B:
        2: 3830:		  isa = "B";
        2: 3831:		  break;
        1: 3832:		case EF_M68K_CF_ISA_C:
        1: 3833:		  isa = "C";
        1: 3834:		  break;
        1: 3835:		case EF_M68K_CF_ISA_C_NODIV:
        1: 3836:		  isa = "C";
        1: 3837:		  additional = ", nodiv";
        1: 3838:		  break;
        -: 3839:		}
       13: 3840:	      strcat (buf, ", cf, isa ");
       13: 3841:	      strcat (buf, isa);
       13: 3842:	      if (additional)
        3: 3843:		strcat (buf, additional);
       13: 3844:	      if (e_flags & EF_M68K_CF_FLOAT)
        2: 3845:		strcat (buf, ", float");
       13: 3846:	      switch (e_flags & EF_M68K_CF_MAC_MASK)
        -: 3847:		{
        7: 3848:		case 0:
        7: 3849:		  mac = NULL;
        7: 3850:		  break;
        3: 3851:		case EF_M68K_CF_MAC:
        3: 3852:		  mac = "mac";
        3: 3853:		  break;
        2: 3854:		case EF_M68K_CF_EMAC:
        2: 3855:		  mac = "emac";
        2: 3856:		  break;
        1: 3857:		case EF_M68K_CF_EMAC_B:
        1: 3858:		  mac = "emac_b";
        1: 3859:		  break;
        -: 3860:		}
       13: 3861:	      if (mac)
        -: 3862:		{
        6: 3863:		  strcat (buf, ", ");
        6: 3864:		  strcat (buf, mac);
        -: 3865:		}
        -: 3866:	    }
       16: 3867:	  break;
        -: 3868:
        5: 3869:	case EM_AMDGPU:
        5: 3870:	  decode_AMDGPU_machine_flags (filedata, e_flags, buf);
        5: 3871:	  break;
        -: 3872:
    #####: 3873:	case EM_CYGNUS_MEP:
    #####: 3874:	  switch (e_flags & EF_MEP_CPU_MASK)
        -: 3875:	    {
    #####: 3876:	    case EF_MEP_CPU_MEP: strcat (buf, ", generic MeP"); break;
    #####: 3877:	    case EF_MEP_CPU_C2: strcat (buf, ", MeP C2"); break;
    #####: 3878:	    case EF_MEP_CPU_C3: strcat (buf, ", MeP C3"); break;
    #####: 3879:	    case EF_MEP_CPU_C4: strcat (buf, ", MeP C4"); break;
    #####: 3880:	    case EF_MEP_CPU_C5: strcat (buf, ", MeP C5"); break;
    #####: 3881:	    case EF_MEP_CPU_H1: strcat (buf, ", MeP H1"); break;
    #####: 3882:	    default: strcat (buf, _(", <unknown MeP cpu type>")); break;
        -: 3883:	    }
        -: 3884:
    #####: 3885:	  switch (e_flags & EF_MEP_COP_MASK)
        -: 3886:	    {
    #####: 3887:	    case EF_MEP_COP_NONE: break;
    #####: 3888:	    case EF_MEP_COP_AVC: strcat (buf, ", AVC coprocessor"); break;
    #####: 3889:	    case EF_MEP_COP_AVC2: strcat (buf, ", AVC2 coprocessor"); break;
    #####: 3890:	    case EF_MEP_COP_FMAX: strcat (buf, ", FMAX coprocessor"); break;
    #####: 3891:	    case EF_MEP_COP_IVC2: strcat (buf, ", IVC2 coprocessor"); break;
    #####: 3892:	    default: strcat (buf, _("<unknown MeP copro type>")); break;
        -: 3893:	    }
        -: 3894:
    #####: 3895:	  if (e_flags & EF_MEP_LIBRARY)
    #####: 3896:	    strcat (buf, ", Built for Library");
        -: 3897:
    #####: 3898:	  if (e_flags & EF_MEP_INDEX_MASK)
    #####: 3899:	    sprintf (buf + strlen (buf), ", Configuration Index: %#x",
        -: 3900:		     e_flags & EF_MEP_INDEX_MASK);
        -: 3901:
    #####: 3902:	  if (e_flags & ~ EF_MEP_ALL_FLAGS)
    #####: 3903:	    sprintf (buf + strlen (buf), _(", unknown flags bits: %#x"),
        -: 3904:		     e_flags & ~ EF_MEP_ALL_FLAGS);
    #####: 3905:	  break;
        -: 3906:
        3: 3907:	case EM_PPC:
        3: 3908:	  if (e_flags & EF_PPC_EMB)
        1: 3909:	    strcat (buf, ", emb");
        -: 3910:
        3: 3911:	  if (e_flags & EF_PPC_RELOCATABLE)
        1: 3912:	    strcat (buf, _(", relocatable"));
        -: 3913:
        3: 3914:	  if (e_flags & EF_PPC_RELOCATABLE_LIB)
        1: 3915:	    strcat (buf, _(", relocatable-lib"));
        3: 3916:	  break;
        -: 3917:
        2: 3918:	case EM_PPC64:
        2: 3919:	  if (e_flags & EF_PPC64_ABI)
        -: 3920:	    {
        1: 3921:	      char abi[] = ", abiv0";
        -: 3922:
        1: 3923:	      abi[6] += e_flags & EF_PPC64_ABI;
        1: 3924:	      strcat (buf, abi);
        -: 3925:	    }
        2: 3926:	  break;
        -: 3927:
       13: 3928:	case EM_V800:
       13: 3929:	  if ((e_flags & EF_RH850_ABI) == EF_RH850_ABI)
        1: 3930:	    strcat (buf, ", RH850 ABI");
        -: 3931:
       13: 3932:	  if (e_flags & EF_V800_850E3)
        2: 3933:	    strcat (buf, ", V3 architecture");
        -: 3934:
       13: 3935:	  if ((e_flags & (EF_RH850_FPU_DOUBLE | EF_RH850_FPU_SINGLE)) == 0)
        8: 3936:	    strcat (buf, ", FPU not used");
        -: 3937:
       13: 3938:	  if ((e_flags & (EF_RH850_REGMODE22 | EF_RH850_REGMODE32)) == 0)
       10: 3939:	    strcat (buf, ", regmode: COMMON");
        -: 3940:
       13: 3941:	  if ((e_flags & (EF_RH850_GP_FIX | EF_RH850_GP_NOFIX)) == 0)
       10: 3942:	    strcat (buf, ", r4 not used");
        -: 3943:
       13: 3944:	  if ((e_flags & (EF_RH850_EP_FIX | EF_RH850_EP_NOFIX)) == 0)
        9: 3945:	    strcat (buf, ", r30 not used");
        -: 3946:
       13: 3947:	  if ((e_flags & (EF_RH850_TP_FIX | EF_RH850_TP_NOFIX)) == 0)
       11: 3948:	    strcat (buf, ", r5 not used");
        -: 3949:
       13: 3950:	  if ((e_flags & (EF_RH850_REG2_RESERVE | EF_RH850_REG2_NORESERVE)) == 0)
        9: 3951:	    strcat (buf, ", r2 not used");
        -: 3952:
       57: 3953:	  for (e_flags &= 0xFFFF; e_flags; e_flags &= ~ (e_flags & - e_flags))
        -: 3954:	    {
       44: 3955:	      switch (e_flags & - e_flags)
        -: 3956:		{
        3: 3957:		case EF_RH850_FPU_DOUBLE: strcat (buf, ", double precision FPU"); break;
        3: 3958:		case EF_RH850_FPU_SINGLE: strcat (buf, ", single precision FPU"); break;
        1: 3959:		case EF_RH850_REGMODE22: strcat (buf, ", regmode:22"); break;
        3: 3960:		case EF_RH850_REGMODE32: strcat (buf, ", regmode:23"); break;
        3: 3961:		case EF_RH850_GP_FIX: strcat (buf, ", r4 fixed"); break;
        3: 3962:		case EF_RH850_GP_NOFIX: strcat (buf, ", r4 free"); break;
        2: 3963:		case EF_RH850_EP_FIX: strcat (buf, ", r30 fixed"); break;
        4: 3964:		case EF_RH850_EP_NOFIX: strcat (buf, ", r30 free"); break;
        2: 3965:		case EF_RH850_TP_FIX: strcat (buf, ", r5 fixed"); break;
        2: 3966:		case EF_RH850_TP_NOFIX: strcat (buf, ", r5 free"); break;
        3: 3967:		case EF_RH850_REG2_RESERVE: strcat (buf, ", r2 fixed"); break;
        2: 3968:		case EF_RH850_REG2_NORESERVE: strcat (buf, ", r2 free"); break;
       13: 3969:		default: break;
        -: 3970:		}
        -: 3971:	    }
       13: 3972:	  break;
        -: 3973:
        9: 3974:	case EM_V850:
        -: 3975:	case EM_CYGNUS_V850:
        9: 3976:	  switch (e_flags & EF_V850_ARCH)
        -: 3977:	    {
        1: 3978:	    case E_V850E3V5_ARCH:
        1: 3979:	      strcat (buf, ", v850e3v5");
        1: 3980:	      break;
        1: 3981:	    case E_V850E2V3_ARCH:
        1: 3982:	      strcat (buf, ", v850e2v3");
        1: 3983:	      break;
        1: 3984:	    case E_V850E2_ARCH:
        1: 3985:	      strcat (buf, ", v850e2");
        1: 3986:	      break;
        1: 3987:            case E_V850E1_ARCH:
        1: 3988:              strcat (buf, ", v850e1");
        1: 3989:	      break;
        1: 3990:	    case E_V850E_ARCH:
        1: 3991:	      strcat (buf, ", v850e");
        1: 3992:	      break;
        2: 3993:	    case E_V850_ARCH:
        2: 3994:	      strcat (buf, ", v850");
        2: 3995:	      break;
        2: 3996:	    default:
        2: 3997:	      strcat (buf, _(", unknown v850 architecture variant"));
        2: 3998:	      break;
        -: 3999:	    }
        9: 4000:	  break;
        -: 4001:
        1: 4002:	case EM_M32R:
        -: 4003:	case EM_CYGNUS_M32R:
        1: 4004:	  if ((e_flags & EF_M32R_ARCH) == E_M32R_ARCH)
        1: 4005:	    strcat (buf, ", m32r");
        1: 4006:	  break;
        -: 4007:
       35: 4008:	case EM_MIPS:
        -: 4009:	case EM_MIPS_RS3_LE:
       35: 4010:	  if (e_flags & EF_MIPS_NOREORDER)
       10: 4011:	    strcat (buf, ", noreorder");
        -: 4012:
       35: 4013:	  if (e_flags & EF_MIPS_PIC)
        6: 4014:	    strcat (buf, ", pic");
        -: 4015:
       35: 4016:	  if (e_flags & EF_MIPS_CPIC)
        9: 4017:	    strcat (buf, ", cpic");
        -: 4018:
       35: 4019:	  if (e_flags & EF_MIPS_UCODE)
        6: 4020:	    strcat (buf, ", ugen_reserved");
        -: 4021:
       35: 4022:	  if (e_flags & EF_MIPS_ABI2)
        6: 4023:	    strcat (buf, ", abi2");
        -: 4024:
       35: 4025:	  if (e_flags & EF_MIPS_OPTIONS_FIRST)
        9: 4026:	    strcat (buf, ", odk first");
        -: 4027:
       35: 4028:	  if (e_flags & EF_MIPS_32BITMODE)
       13: 4029:	    strcat (buf, ", 32bitmode");
        -: 4030:
       35: 4031:	  if (e_flags & EF_MIPS_NAN2008)
       11: 4032:	    strcat (buf, ", nan2008");
        -: 4033:
       35: 4034:	  if (e_flags & EF_MIPS_FP64)
        6: 4035:	    strcat (buf, ", fp64");
        -: 4036:
       35: 4037:	  switch ((e_flags & EF_MIPS_MACH))
        -: 4038:	    {
    #####: 4039:	    case E_MIPS_MACH_3900: strcat (buf, ", 3900"); break;
        1: 4040:	    case E_MIPS_MACH_4010: strcat (buf, ", 4010"); break;
        1: 4041:	    case E_MIPS_MACH_4100: strcat (buf, ", 4100"); break;
        1: 4042:	    case E_MIPS_MACH_4111: strcat (buf, ", 4111"); break;
    #####: 4043:	    case E_MIPS_MACH_4120: strcat (buf, ", 4120"); break;
        1: 4044:	    case E_MIPS_MACH_4650: strcat (buf, ", 4650"); break;
    #####: 4045:	    case E_MIPS_MACH_5400: strcat (buf, ", 5400"); break;
    #####: 4046:	    case E_MIPS_MACH_5500: strcat (buf, ", 5500"); break;
    #####: 4047:	    case E_MIPS_MACH_5900: strcat (buf, ", 5900"); break;
    #####: 4048:	    case E_MIPS_MACH_SB1:  strcat (buf, ", sb1");  break;
        1: 4049:	    case E_MIPS_MACH_9000: strcat (buf, ", 9000"); break;
    #####: 4050:  	    case E_MIPS_MACH_LS2E: strcat (buf, ", loongson-2e"); break;
    #####: 4051:  	    case E_MIPS_MACH_LS2F: strcat (buf, ", loongson-2f"); break;
        1: 4052:	    case E_MIPS_MACH_GS464: strcat (buf, ", gs464"); break;
        1: 4053:	    case E_MIPS_MACH_GS464E: strcat (buf, ", gs464e"); break;
        1: 4054:	    case E_MIPS_MACH_GS264E: strcat (buf, ", gs264e"); break;
    #####: 4055:	    case E_MIPS_MACH_OCTEON: strcat (buf, ", octeon"); break;
    #####: 4056:	    case E_MIPS_MACH_OCTEON2: strcat (buf, ", octeon2"); break;
    #####: 4057:	    case E_MIPS_MACH_OCTEON3: strcat (buf, ", octeon3"); break;
        1: 4058:	    case E_MIPS_MACH_XLR:  strcat (buf, ", xlr"); break;
        1: 4059:	    case E_MIPS_MACH_IAMR2:  strcat (buf, ", interaptiv-mr2"); break;
       11: 4060:	    case 0:
        -: 4061:	    /* We simply ignore the field in this case to avoid confusion:
        -: 4062:	       MIPS ELF does not specify EF_MIPS_MACH, it is a GNU
        -: 4063:	       extension.  */
       11: 4064:	      break;
       14: 4065:	    default: strcat (buf, _(", unknown CPU")); break;
        -: 4066:	    }
        -: 4067:
       35: 4068:	  switch ((e_flags & EF_MIPS_ABI))
        -: 4069:	    {
        2: 4070:	    case E_MIPS_ABI_O32: strcat (buf, ", o32"); break;
        1: 4071:	    case E_MIPS_ABI_O64: strcat (buf, ", o64"); break;
        1: 4072:	    case E_MIPS_ABI_EABI32: strcat (buf, ", eabi32"); break;
        3: 4073:	    case E_MIPS_ABI_EABI64: strcat (buf, ", eabi64"); break;
       13: 4074:	    case 0:
        -: 4075:	    /* We simply ignore the field in this case to avoid confusion:
        -: 4076:	       MIPS ELF does not specify EF_MIPS_ABI, it is a GNU extension.
        -: 4077:	       This means it is likely to be an o32 file, but not for
        -: 4078:	       sure.  */
       13: 4079:	      break;
       15: 4080:	    default: strcat (buf, _(", unknown ABI")); break;
        -: 4081:	    }
        -: 4082:
       35: 4083:	  if (e_flags & EF_MIPS_ARCH_ASE_MDMX)
        5: 4084:	    strcat (buf, ", mdmx");
        -: 4085:
       35: 4086:	  if (e_flags & EF_MIPS_ARCH_ASE_M16)
        9: 4087:	    strcat (buf, ", mips16");
        -: 4088:
       35: 4089:	  if (e_flags & EF_MIPS_ARCH_ASE_MICROMIPS)
        7: 4090:	    strcat (buf, ", micromips");
        -: 4091:
       35: 4092:	  switch ((e_flags & EF_MIPS_ARCH))
        -: 4093:	    {
       14: 4094:	    case E_MIPS_ARCH_1: strcat (buf, ", mips1"); break;
        2: 4095:	    case E_MIPS_ARCH_2: strcat (buf, ", mips2"); break;
        1: 4096:	    case E_MIPS_ARCH_3: strcat (buf, ", mips3"); break;
        1: 4097:	    case E_MIPS_ARCH_4: strcat (buf, ", mips4"); break;
        1: 4098:	    case E_MIPS_ARCH_5: strcat (buf, ", mips5"); break;
        1: 4099:	    case E_MIPS_ARCH_32: strcat (buf, ", mips32"); break;
        1: 4100:	    case E_MIPS_ARCH_32R2: strcat (buf, ", mips32r2"); break;
        5: 4101:	    case E_MIPS_ARCH_32R6: strcat (buf, ", mips32r6"); break;
        2: 4102:	    case E_MIPS_ARCH_64: strcat (buf, ", mips64"); break;
        4: 4103:	    case E_MIPS_ARCH_64R2: strcat (buf, ", mips64r2"); break;
        2: 4104:	    case E_MIPS_ARCH_64R6: strcat (buf, ", mips64r6"); break;
        1: 4105:	    default: strcat (buf, _(", unknown ISA")); break;
        -: 4106:	    }
       35: 4107:	  break;
        -: 4108:
        3: 4109:	case EM_NDS32:
        3: 4110:	  decode_NDS32_machine_flags (e_flags, buf, sizeof buf);
        3: 4111:	  break;
        -: 4112:
        2: 4113:	case EM_NFP:
        2: 4114:	  switch (EF_NFP_MACH (e_flags))
        -: 4115:	    {
    #####: 4116:	    case E_NFP_MACH_3200:
    #####: 4117:	      strcat (buf, ", NFP-32xx");
    #####: 4118:	      break;
    #####: 4119:	    case E_NFP_MACH_6000:
    #####: 4120:	      strcat (buf, ", NFP-6xxx");
    #####: 4121:	      break;
        -: 4122:	    }
        2: 4123:	  break;
        -: 4124:
        3: 4125:	case EM_RISCV:
        3: 4126:	  if (e_flags & EF_RISCV_RVC)
        1: 4127:	    strcat (buf, ", RVC");
        -: 4128:
        3: 4129:	  if (e_flags & EF_RISCV_RVE)
        1: 4130:	    strcat (buf, ", RVE");
        -: 4131:
        3: 4132:	  switch (e_flags & EF_RISCV_FLOAT_ABI)
        -: 4133:	    {
        1: 4134:	    case EF_RISCV_FLOAT_ABI_SOFT:
        1: 4135:	      strcat (buf, ", soft-float ABI");
        1: 4136:	      break;
        -: 4137:
    #####: 4138:	    case EF_RISCV_FLOAT_ABI_SINGLE:
    #####: 4139:	      strcat (buf, ", single-float ABI");
    #####: 4140:	      break;
        -: 4141:
        1: 4142:	    case EF_RISCV_FLOAT_ABI_DOUBLE:
        1: 4143:	      strcat (buf, ", double-float ABI");
        1: 4144:	      break;
        -: 4145:
        1: 4146:	    case EF_RISCV_FLOAT_ABI_QUAD:
        1: 4147:	      strcat (buf, ", quad-float ABI");
        1: 4148:	      break;
        -: 4149:	    }
        3: 4150:	  break;
        -: 4151:
       18: 4152:	case EM_SH:
       18: 4153:	  switch ((e_flags & EF_SH_MACH_MASK))
        -: 4154:	    {
        1: 4155:	    case EF_SH1: strcat (buf, ", sh1"); break;
        1: 4156:	    case EF_SH2: strcat (buf, ", sh2"); break;
    #####: 4157:	    case EF_SH3: strcat (buf, ", sh3"); break;
        1: 4158:	    case EF_SH_DSP: strcat (buf, ", sh-dsp"); break;
        1: 4159:	    case EF_SH3_DSP: strcat (buf, ", sh3-dsp"); break;
        1: 4160:	    case EF_SH4AL_DSP: strcat (buf, ", sh4al-dsp"); break;
        1: 4161:	    case EF_SH3E: strcat (buf, ", sh3e"); break;
        1: 4162:	    case EF_SH4: strcat (buf, ", sh4"); break;
        1: 4163:	    case EF_SH5: strcat (buf, ", sh5"); break;
        1: 4164:	    case EF_SH2E: strcat (buf, ", sh2e"); break;
    #####: 4165:	    case EF_SH4A: strcat (buf, ", sh4a"); break;
    #####: 4166:	    case EF_SH2A: strcat (buf, ", sh2a"); break;
        1: 4167:	    case EF_SH4_NOFPU: strcat (buf, ", sh4-nofpu"); break;
    #####: 4168:	    case EF_SH4A_NOFPU: strcat (buf, ", sh4a-nofpu"); break;
        1: 4169:	    case EF_SH2A_NOFPU: strcat (buf, ", sh2a-nofpu"); break;
        1: 4170:	    case EF_SH3_NOMMU: strcat (buf, ", sh3-nommu"); break;
        1: 4171:	    case EF_SH4_NOMMU_NOFPU: strcat (buf, ", sh4-nommu-nofpu"); break;
    #####: 4172:	    case EF_SH2A_SH4_NOFPU: strcat (buf, ", sh2a-nofpu-or-sh4-nommu-nofpu"); break;
        1: 4173:	    case EF_SH2A_SH3_NOFPU: strcat (buf, ", sh2a-nofpu-or-sh3-nommu"); break;
    #####: 4174:	    case EF_SH2A_SH4: strcat (buf, ", sh2a-or-sh4"); break;
    #####: 4175:	    case EF_SH2A_SH3E: strcat (buf, ", sh2a-or-sh3e"); break;
        4: 4176:	    default: strcat (buf, _(", unknown ISA")); break;
        -: 4177:	    }
        -: 4178:
       18: 4179:	  if (e_flags & EF_SH_PIC)
        4: 4180:	    strcat (buf, ", pic");
        -: 4181:
       18: 4182:	  if (e_flags & EF_SH_FDPIC)
        4: 4183:	    strcat (buf, ", fdpic");
       18: 4184:	  break;
        -: 4185:
        2: 4186:        case EM_OR1K:
        2: 4187:          if (e_flags & EF_OR1K_NODELAY)
        1: 4188:            strcat (buf, ", no delay");
        2: 4189:          break;
        -: 4190:
        5: 4191:	case EM_SPARCV9:
        5: 4192:	  if (e_flags & EF_SPARC_32PLUS)
        1: 4193:	    strcat (buf, ", v8+");
        -: 4194:
        5: 4195:	  if (e_flags & EF_SPARC_SUN_US1)
        1: 4196:	    strcat (buf, ", ultrasparcI");
        -: 4197:
        5: 4198:	  if (e_flags & EF_SPARC_SUN_US3)
        1: 4199:	    strcat (buf, ", ultrasparcIII");
        -: 4200:
        5: 4201:	  if (e_flags & EF_SPARC_HAL_R1)
        3: 4202:	    strcat (buf, ", halr1");
        -: 4203:
        5: 4204:	  if (e_flags & EF_SPARC_LEDATA)
        1: 4205:	    strcat (buf, ", ledata");
        -: 4206:
        5: 4207:	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_TSO)
        3: 4208:	    strcat (buf, ", tso");
        -: 4209:
        5: 4210:	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_PSO)
    #####: 4211:	    strcat (buf, ", pso");
        -: 4212:
        5: 4213:	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_RMO)
        1: 4214:	    strcat (buf, ", rmo");
        5: 4215:	  break;
        -: 4216:
        6: 4217:	case EM_PARISC:
        6: 4218:	  switch (e_flags & EF_PARISC_ARCH)
        -: 4219:	    {
    #####: 4220:	    case EFA_PARISC_1_0:
    #####: 4221:	      strcpy (buf, ", PA-RISC 1.0");
    #####: 4222:	      break;
    #####: 4223:	    case EFA_PARISC_1_1:
    #####: 4224:	      strcpy (buf, ", PA-RISC 1.1");
    #####: 4225:	      break;
    #####: 4226:	    case EFA_PARISC_2_0:
    #####: 4227:	      strcpy (buf, ", PA-RISC 2.0");
    #####: 4228:	      break;
        6: 4229:	    default:
        6: 4230:	      break;
        -: 4231:	    }
        6: 4232:	  if (e_flags & EF_PARISC_TRAPNIL)
        1: 4233:	    strcat (buf, ", trapnil");
        6: 4234:	  if (e_flags & EF_PARISC_EXT)
        1: 4235:	    strcat (buf, ", ext");
        6: 4236:	  if (e_flags & EF_PARISC_LSB)
        3: 4237:	    strcat (buf, ", lsb");
        6: 4238:	  if (e_flags & EF_PARISC_WIDE)
        4: 4239:	    strcat (buf, ", wide");
        6: 4240:	  if (e_flags & EF_PARISC_NO_KABP)
        2: 4241:	    strcat (buf, ", no kabp");
        6: 4242:	  if (e_flags & EF_PARISC_LAZYSWAP)
        2: 4243:	    strcat (buf, ", lazyswap");
        6: 4244:	  break;
        -: 4245:
        4: 4246:	case EM_PJ:
        -: 4247:	case EM_PJ_OLD:
        4: 4248:	  if ((e_flags & EF_PICOJAVA_NEWCALLS) == EF_PICOJAVA_NEWCALLS)
        1: 4249:	    strcat (buf, ", new calling convention");
        -: 4250:
        4: 4251:	  if ((e_flags & EF_PICOJAVA_GNUCALLS) == EF_PICOJAVA_GNUCALLS)
        1: 4252:	    strcat (buf, ", gnu calling convention");
        4: 4253:	  break;
        -: 4254:
        3: 4255:	case EM_IA_64:
        3: 4256:	  if ((e_flags & EF_IA_64_ABI64))
        1: 4257:	    strcat (buf, ", 64-bit");
        -: 4258:	  else
        2: 4259:	    strcat (buf, ", 32-bit");
        3: 4260:	  if ((e_flags & EF_IA_64_REDUCEDFP))
        1: 4261:	    strcat (buf, ", reduced fp model");
        3: 4262:	  if ((e_flags & EF_IA_64_NOFUNCDESC_CONS_GP))
        1: 4263:	    strcat (buf, ", no function descriptors, constant gp");
        2: 4264:	  else if ((e_flags & EF_IA_64_CONS_GP))
        1: 4265:	    strcat (buf, ", constant gp");
        3: 4266:	  if ((e_flags & EF_IA_64_ABSOLUTE))
        1: 4267:	    strcat (buf, ", absolute");
        3: 4268:          if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_OPENVMS)
        -: 4269:            {
    #####: 4270:              if ((e_flags & EF_IA_64_VMS_LINKAGES))
    #####: 4271:                strcat (buf, ", vms_linkages");
    #####: 4272:              switch ((e_flags & EF_IA_64_VMS_COMCOD))
        -: 4273:                {
    #####: 4274:                case EF_IA_64_VMS_COMCOD_SUCCESS:
    #####: 4275:                  break;
    #####: 4276:                case EF_IA_64_VMS_COMCOD_WARNING:
    #####: 4277:                  strcat (buf, ", warning");
    #####: 4278:                  break;
    #####: 4279:                case EF_IA_64_VMS_COMCOD_ERROR:
    #####: 4280:                  strcat (buf, ", error");
    #####: 4281:                  break;
    #####: 4282:                case EF_IA_64_VMS_COMCOD_ABORT:
    #####: 4283:                  strcat (buf, ", abort");
    #####: 4284:                  break;
    #####: 4285:                default:
    #####: 4286:		  warn (_("Unrecognised IA64 VMS Command Code: %x\n"),
        -: 4287:			e_flags & EF_IA_64_VMS_COMCOD);
    #####: 4288:		  strcat (buf, ", <unknown>");
        -: 4289:                }
        3: 4290:            }
        3: 4291:	  break;
        -: 4292:
        2: 4293:	case EM_VAX:
        2: 4294:	  if ((e_flags & EF_VAX_NONPIC))
    #####: 4295:	    strcat (buf, ", non-PIC");
        2: 4296:	  if ((e_flags & EF_VAX_DFLOAT))
    #####: 4297:	    strcat (buf, ", D-Float");
        2: 4298:	  if ((e_flags & EF_VAX_GFLOAT))
        1: 4299:	    strcat (buf, ", G-Float");
        2: 4300:	  break;
        -: 4301:
        3: 4302:        case EM_VISIUM:
        3: 4303:	  if (e_flags & EF_VISIUM_ARCH_MCM)
        1: 4304:	    strcat (buf, ", mcm");
        2: 4305:	  else if (e_flags & EF_VISIUM_ARCH_MCM24)
    #####: 4306:	    strcat (buf, ", mcm24");
        3: 4307:	  if (e_flags & EF_VISIUM_ARCH_GR6)
        1: 4308:	    strcat (buf, ", gr6");
        3: 4309:	  break;
        -: 4310:
        2: 4311:	case EM_RL78:
        2: 4312:	  switch (e_flags & E_FLAG_RL78_CPU_MASK)
        -: 4313:	    {
        1: 4314:	    case E_FLAG_RL78_ANY_CPU: break;
    #####: 4315:	    case E_FLAG_RL78_G10: strcat (buf, ", G10"); break;
        1: 4316:	    case E_FLAG_RL78_G13: strcat (buf, ", G13"); break;
    #####: 4317:	    case E_FLAG_RL78_G14: strcat (buf, ", G14"); break;
        -: 4318:	    }
        2: 4319:	  if (e_flags & E_FLAG_RL78_64BIT_DOUBLES)
        1: 4320:	    strcat (buf, ", 64-bit doubles");
        2: 4321:	  break;
        -: 4322:
        2: 4323:	case EM_RX:
        2: 4324:	  if (e_flags & E_FLAG_RX_64BIT_DOUBLES)
        1: 4325:	    strcat (buf, ", 64-bit doubles");
        2: 4326:	  if (e_flags & E_FLAG_RX_DSP)
        1: 4327:	    strcat (buf, ", dsp");
        2: 4328:	  if (e_flags & E_FLAG_RX_PID)
        1: 4329:	    strcat (buf, ", pid");
        2: 4330:	  if (e_flags & E_FLAG_RX_ABI)
    #####: 4331:	    strcat (buf, ", RX ABI");
        2: 4332:	  if (e_flags & E_FLAG_RX_SINSNS_SET)
    #####: 4333:	    strcat (buf, e_flags & E_FLAG_RX_SINSNS_YES
        -: 4334:		    ? ", uses String instructions" : ", bans String instructions");
        2: 4335:	  if (e_flags & E_FLAG_RX_V2)
    #####: 4336:	    strcat (buf, ", V2");
        2: 4337:	  if (e_flags & E_FLAG_RX_V3)
    #####: 4338:	    strcat (buf, ", V3");
        2: 4339:	  break;
        -: 4340:
        3: 4341:	case EM_S390:
        3: 4342:	  if (e_flags & EF_S390_HIGH_GPRS)
        1: 4343:	    strcat (buf, ", highgprs");
        3: 4344:	  break;
        -: 4345:
        3: 4346:	case EM_TI_C6000:
        3: 4347:	  if ((e_flags & EF_C6000_REL))
        1: 4348:	    strcat (buf, ", relocatable module");
        3: 4349:	  break;
        -: 4350:
        1: 4351:	case EM_MSP430:
        1: 4352:	  strcat (buf, _(": architecture variant: "));
        1: 4353:	  switch (e_flags & EF_MSP430_MACH)
        -: 4354:	    {
    #####: 4355:	    case E_MSP430_MACH_MSP430x11: strcat (buf, "MSP430x11"); break;
    #####: 4356:	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, "MSP430x11x1 "); break;
    #####: 4357:	    case E_MSP430_MACH_MSP430x12: strcat (buf, "MSP430x12"); break;
    #####: 4358:	    case E_MSP430_MACH_MSP430x13: strcat (buf, "MSP430x13"); break;
    #####: 4359:	    case E_MSP430_MACH_MSP430x14: strcat (buf, "MSP430x14"); break;
    #####: 4360:	    case E_MSP430_MACH_MSP430x15: strcat (buf, "MSP430x15"); break;
    #####: 4361:	    case E_MSP430_MACH_MSP430x16: strcat (buf, "MSP430x16"); break;
    #####: 4362:	    case E_MSP430_MACH_MSP430x31: strcat (buf, "MSP430x31"); break;
    #####: 4363:	    case E_MSP430_MACH_MSP430x32: strcat (buf, "MSP430x32"); break;
    #####: 4364:	    case E_MSP430_MACH_MSP430x33: strcat (buf, "MSP430x33"); break;
    #####: 4365:	    case E_MSP430_MACH_MSP430x41: strcat (buf, "MSP430x41"); break;
    #####: 4366:	    case E_MSP430_MACH_MSP430x42: strcat (buf, "MSP430x42"); break;
    #####: 4367:	    case E_MSP430_MACH_MSP430x43: strcat (buf, "MSP430x43"); break;
    #####: 4368:	    case E_MSP430_MACH_MSP430x44: strcat (buf, "MSP430x44"); break;
    #####: 4369:	    case E_MSP430_MACH_MSP430X  : strcat (buf, "MSP430X"); break;
        1: 4370:	    default:
        1: 4371:	      strcat (buf, _(": unknown")); break;
        -: 4372:	    }
        -: 4373:
        1: 4374:	  if (e_flags & ~ EF_MSP430_MACH)
        1: 4375:	    strcat (buf, _(": unknown extra flag bits also present"));
        1: 4376:	  break;
        -: 4377:
        2: 4378:	case EM_Z80:
        2: 4379:	  switch (e_flags & EF_Z80_MACH_MSK)
        -: 4380:	    {
    #####: 4381:	    case EF_Z80_MACH_Z80: strcat (buf, ", Z80"); break;
    #####: 4382:	    case EF_Z80_MACH_Z180: strcat (buf, ", Z180"); break;
    #####: 4383:	    case EF_Z80_MACH_R800: strcat (buf, ", R800"); break;
    #####: 4384:	    case EF_Z80_MACH_EZ80_Z80: strcat (buf, ", EZ80"); break;
    #####: 4385:	    case EF_Z80_MACH_EZ80_ADL: strcat (buf, ", EZ80, ADL"); break;
    #####: 4386:	    case EF_Z80_MACH_GBZ80: strcat (buf, ", GBZ80"); break;
    #####: 4387:	    case EF_Z80_MACH_Z80N: strcat (buf, ", Z80N"); break;
        2: 4388:	    default:
        2: 4389:	      strcat (buf, _(", unknown")); break;
        -: 4390:	    }
        2: 4391:	  break;
        5: 4392:	case EM_LOONGARCH:
        5: 4393:	  if (EF_LOONGARCH_IS_LP64 (e_flags))
        1: 4394:	    strcat (buf, ", LP64");
        4: 4395:	  else if (EF_LOONGARCH_IS_ILP32 (e_flags))
        3: 4396:	    strcat (buf, ", ILP32");
        -: 4397:
        5: 4398:	  if (EF_LOONGARCH_IS_SOFT_FLOAT (e_flags))
        1: 4399:	    strcat (buf, ", SOFT-FLOAT");
        4: 4400:	  else if (EF_LOONGARCH_IS_SINGLE_FLOAT (e_flags))
        2: 4401:	    strcat (buf, ", SINGLE-FLOAT");
        2: 4402:	  else if (EF_LOONGARCH_IS_DOUBLE_FLOAT (e_flags))
        1: 4403:	    strcat (buf, ", DOUBLE-FLOAT");
        -: 4404:
        5: 4405:	  break;
        -: 4406:	}
      971: 4407:    }
        -: 4408:
     1391: 4409:  return buf;
        -: 4410:}
        -: 4411:
        -: 4412:static const char *
     1391: 4413:get_osabi_name (Filedata * filedata, unsigned int osabi)
        -: 4414:{
        -: 4415:  static char buff[32];
        -: 4416:
     1391: 4417:  switch (osabi)
        -: 4418:    {
     1243: 4419:    case ELFOSABI_NONE:		return "UNIX - System V";
        9: 4420:    case ELFOSABI_HPUX:		return "UNIX - HP-UX";
        2: 4421:    case ELFOSABI_NETBSD:	return "UNIX - NetBSD";
        6: 4422:    case ELFOSABI_GNU:		return "UNIX - GNU";
        3: 4423:    case ELFOSABI_SOLARIS:	return "UNIX - Solaris";
        2: 4424:    case ELFOSABI_AIX:		return "UNIX - AIX";
        8: 4425:    case ELFOSABI_IRIX:		return "UNIX - IRIX";
        7: 4426:    case ELFOSABI_FREEBSD:	return "UNIX - FreeBSD";
        2: 4427:    case ELFOSABI_TRU64:	return "UNIX - TRU64";
    #####: 4428:    case ELFOSABI_MODESTO:	return "Novell - Modesto";
        3: 4429:    case ELFOSABI_OPENBSD:	return "UNIX - OpenBSD";
        1: 4430:    case ELFOSABI_OPENVMS:	return "VMS - OpenVMS";
    #####: 4431:    case ELFOSABI_NSK:		return "HP - Non-Stop Kernel";
    #####: 4432:    case ELFOSABI_AROS:		return "AROS";
        2: 4433:    case ELFOSABI_FENIXOS:	return "FenixOS";
        1: 4434:    case ELFOSABI_CLOUDABI:	return "Nuxi CloudABI";
        1: 4435:    case ELFOSABI_OPENVOS:	return "Stratus Technologies OpenVOS";
      101: 4436:    default:
      101: 4437:      if (osabi >= 64)
       83: 4438:	switch (filedata->file_header.e_machine)
        -: 4439:	  {
        1: 4440:	  case EM_AMDGPU:
        -: 4441:	    switch (osabi)
        -: 4442:	      {
    #####: 4443:	      case ELFOSABI_AMDGPU_HSA:    return "AMD HSA";
    #####: 4444:	      case ELFOSABI_AMDGPU_PAL:    return "AMD PAL";
    #####: 4445:	      case ELFOSABI_AMDGPU_MESA3D: return "AMD Mesa3D";
        1: 4446:	      default:
        1: 4447:		break;
        -: 4448:	      }
        1: 4449:	    break;
        -: 4450:
        3: 4451:	  case EM_ARM:
        -: 4452:	    switch (osabi)
        -: 4453:	      {
    #####: 4454:	      case ELFOSABI_ARM:	return "ARM";
    #####: 4455:	      case ELFOSABI_ARM_FDPIC:	return "ARM FDPIC";
        3: 4456:	      default:
        3: 4457:		break;
        -: 4458:	      }
        3: 4459:	    break;
        -: 4460:
        1: 4461:	  case EM_MSP430:
        -: 4462:	  case EM_MSP430_OLD:
        -: 4463:	  case EM_VISIUM:
        -: 4464:	    switch (osabi)
        -: 4465:	      {
    #####: 4466:	      case ELFOSABI_STANDALONE:	return _("Standalone App");
        1: 4467:	      default:
        1: 4468:		break;
        -: 4469:	      }
        1: 4470:	    break;
        -: 4471:
        1: 4472:	  case EM_TI_C6000:
        -: 4473:	    switch (osabi)
        -: 4474:	      {
    #####: 4475:	      case ELFOSABI_C6000_ELFABI:	return _("Bare-metal C6000");
    #####: 4476:	      case ELFOSABI_C6000_LINUX:	return "Linux C6000";
        1: 4477:	      default:
        1: 4478:		break;
        -: 4479:	      }
        1: 4480:	    break;
        -: 4481:
       77: 4482:	  default:
       77: 4483:	    break;
        -: 4484:	  }
       18: 4485:      snprintf (buff, sizeof (buff), _("<unknown: %x>"), osabi);
      101: 4486:      return buff;
        -: 4487:    }
        -: 4488:}
        -: 4489:
        -: 4490:static const char *
    #####: 4491:get_aarch64_segment_type (unsigned long type)
        -: 4492:{
    #####: 4493:  switch (type)
        -: 4494:    {
    #####: 4495:    case PT_AARCH64_ARCHEXT:  return "AARCH64_ARCHEXT";
    #####: 4496:    default:                  return NULL;
        -: 4497:    }
        -: 4498:}
        -: 4499:
        -: 4500:static const char *
        1: 4501:get_arm_segment_type (unsigned long type)
        -: 4502:{
        1: 4503:  switch (type)
        -: 4504:    {
    #####: 4505:    case PT_ARM_EXIDX: return "EXIDX";
        1: 4506:    default:           return NULL;
        -: 4507:    }
        -: 4508:}
        -: 4509:
        -: 4510:static const char *
        1: 4511:get_s390_segment_type (unsigned long type)
        -: 4512:{
        1: 4513:  switch (type)
        -: 4514:    {
    #####: 4515:    case PT_S390_PGSTE: return "S390_PGSTE";
        1: 4516:    default:            return NULL;
        -: 4517:    }
        -: 4518:}
        -: 4519:
        -: 4520:static const char *
        1: 4521:get_mips_segment_type (unsigned long type)
        -: 4522:{
        1: 4523:  switch (type)
        -: 4524:    {
    #####: 4525:    case PT_MIPS_REGINFO:   return "REGINFO";
    #####: 4526:    case PT_MIPS_RTPROC:    return "RTPROC";
    #####: 4527:    case PT_MIPS_OPTIONS:   return "OPTIONS";
    #####: 4528:    case PT_MIPS_ABIFLAGS:  return "ABIFLAGS";
        1: 4529:    default:                return NULL;
        -: 4530:    }
        -: 4531:}
        -: 4532:
        -: 4533:static const char *
        1: 4534:get_parisc_segment_type (unsigned long type)
        -: 4535:{
        1: 4536:  switch (type)
        -: 4537:    {
    #####: 4538:    case PT_PARISC_ARCHEXT:	return "PARISC_ARCHEXT";
    #####: 4539:    case PT_PARISC_UNWIND:	return "PARISC_UNWIND";
    #####: 4540:    case PT_PARISC_WEAKORDER:	return "PARISC_WEAKORDER";
        1: 4541:    default:                    return NULL;
        -: 4542:    }
        -: 4543:}
        -: 4544:
        -: 4545:static const char *
    #####: 4546:get_ia64_segment_type (unsigned long type)
        -: 4547:{
    #####: 4548:  switch (type)
        -: 4549:    {
    #####: 4550:    case PT_IA_64_ARCHEXT:	return "IA_64_ARCHEXT";
    #####: 4551:    case PT_IA_64_UNWIND:	return "IA_64_UNWIND";
    #####: 4552:    default:                    return NULL;
        -: 4553:    }
        -: 4554:}
        -: 4555:
        -: 4556:static const char *
    #####: 4557:get_tic6x_segment_type (unsigned long type)
        -: 4558:{
    #####: 4559:  switch (type)
        -: 4560:    {
    #####: 4561:    case PT_C6000_PHATTR:  return "C6000_PHATTR";
    #####: 4562:    default:               return NULL;
        -: 4563:    }
        -: 4564:}
        -: 4565:
        -: 4566:static const char *
    #####: 4567:get_riscv_segment_type (unsigned long type)
        -: 4568:{
    #####: 4569:  switch (type)
        -: 4570:    {
    #####: 4571:    case PT_RISCV_ATTRIBUTES: return "RISCV_ATTRIBUTES";
    #####: 4572:    default:                  return NULL;
        -: 4573:    }
        -: 4574:}
        -: 4575:
        -: 4576:static const char *
        1: 4577:get_hpux_segment_type (unsigned long type, unsigned e_machine)
        -: 4578:{
        1: 4579:  if (e_machine == EM_PARISC)
    #####: 4580:    switch (type)
        -: 4581:      {
    #####: 4582:      case PT_HP_TLS:		return "HP_TLS";
    #####: 4583:      case PT_HP_CORE_NONE:	return "HP_CORE_NONE";
    #####: 4584:      case PT_HP_CORE_VERSION:	return "HP_CORE_VERSION";
    #####: 4585:      case PT_HP_CORE_KERNEL:	return "HP_CORE_KERNEL";
    #####: 4586:      case PT_HP_CORE_COMM:	return "HP_CORE_COMM";
    #####: 4587:      case PT_HP_CORE_PROC:	return "HP_CORE_PROC";
    #####: 4588:      case PT_HP_CORE_LOADABLE:	return "HP_CORE_LOADABLE";
    #####: 4589:      case PT_HP_CORE_STACK:	return "HP_CORE_STACK";
    #####: 4590:      case PT_HP_CORE_SHM:	return "HP_CORE_SHM";
    #####: 4591:      case PT_HP_CORE_MMF:	return "HP_CORE_MMF";
    #####: 4592:      case PT_HP_PARALLEL:	return "HP_PARALLEL";
    #####: 4593:      case PT_HP_FASTBIND:	return "HP_FASTBIND";
    #####: 4594:      case PT_HP_OPT_ANNOT:	return "HP_OPT_ANNOT";
    #####: 4595:      case PT_HP_HSL_ANNOT:	return "HP_HSL_ANNOT";
    #####: 4596:      case PT_HP_STACK:		return "HP_STACK";
    #####: 4597:      case PT_HP_CORE_UTSNAME:	return "HP_CORE_UTSNAME";
    #####: 4598:      default:			return NULL;
        -: 4599:      }
        -: 4600:
        1: 4601:  if (e_machine == EM_IA_64)
    #####: 4602:    switch (type)
        -: 4603:      {
    #####: 4604:      case PT_HP_TLS:		 return "HP_TLS";
    #####: 4605:      case PT_IA_64_HP_OPT_ANOT: return "HP_OPT_ANNOT";
    #####: 4606:      case PT_IA_64_HP_HSL_ANOT: return "HP_HSL_ANNOT";
    #####: 4607:      case PT_IA_64_HP_STACK:	 return "HP_STACK";
    #####: 4608:      default:			 return NULL;
        -: 4609:      }
        -: 4610:
        1: 4611:  return NULL;
        -: 4612:}
        -: 4613:
        -: 4614:static const char *
    #####: 4615:get_solaris_segment_type (unsigned long type)
        -: 4616:{
    #####: 4617:  switch (type)
        -: 4618:    {
    #####: 4619:    case 0x6464e550: return "PT_SUNW_UNWIND";
    #####: 4620:    case 0x6474e550: return "PT_SUNW_EH_FRAME";
    #####: 4621:    case 0x6ffffff7: return "PT_LOSUNW";
    #####: 4622:    case 0x6ffffffa: return "PT_SUNWBSS";
    #####: 4623:    case 0x6ffffffb: return "PT_SUNWSTACK";
    #####: 4624:    case 0x6ffffffc: return "PT_SUNWDTRACE";
    #####: 4625:    case 0x6ffffffd: return "PT_SUNWCAP";
    #####: 4626:    case 0x6fffffff: return "PT_HISUNW";
    #####: 4627:    default:         return NULL;
        -: 4628:    }
        -: 4629:}
        -: 4630:
        -: 4631:static const char *
     2129: 4632:get_segment_type (Filedata * filedata, unsigned long p_type)
        -: 4633:{
        -: 4634:  static char buff[32];
        -: 4635:
     2129: 4636:  switch (p_type)
        -: 4637:    {
      106: 4638:    case PT_NULL:	return "NULL";
     1443: 4639:    case PT_LOAD:	return "LOAD";
       43: 4640:    case PT_DYNAMIC:	return "DYNAMIC";
        7: 4641:    case PT_INTERP:	return "INTERP";
       16: 4642:    case PT_NOTE:	return "NOTE";
        8: 4643:    case PT_SHLIB:	return "SHLIB";
       49: 4644:    case PT_PHDR:	return "PHDR";
        2: 4645:    case PT_TLS:	return "TLS";
    #####: 4646:    case PT_GNU_EH_FRAME: return "GNU_EH_FRAME";
    #####: 4647:    case PT_GNU_STACK:	return "GNU_STACK";
    #####: 4648:    case PT_GNU_RELRO:  return "GNU_RELRO";
    #####: 4649:    case PT_GNU_PROPERTY: return "GNU_PROPERTY";
        -: 4650:
    #####: 4651:    case PT_OPENBSD_RANDOMIZE: return "OPENBSD_RANDOMIZE";
    #####: 4652:    case PT_OPENBSD_WXNEEDED: return "OPENBSD_WXNEEDED";
    #####: 4653:    case PT_OPENBSD_BOOTDATA: return "OPENBSD_BOOTDATA";
        -: 4654:
      455: 4655:    default:
      455: 4656:      if ((p_type >= PT_LOPROC) && (p_type <= PT_HIPROC))
       35: 4657:	{
        -: 4658:	  const char * result;
        -: 4659:
       35: 4660:	  switch (filedata->file_header.e_machine)
        -: 4661:	    {
    #####: 4662:	    case EM_AARCH64:
    #####: 4663:	      result = get_aarch64_segment_type (p_type);
    #####: 4664:	      break;
        1: 4665:	    case EM_ARM:
        1: 4666:	      result = get_arm_segment_type (p_type);
        1: 4667:	      break;
        1: 4668:	    case EM_MIPS:
        -: 4669:	    case EM_MIPS_RS3_LE:
        1: 4670:	      result = get_mips_segment_type (p_type);
        1: 4671:	      break;
        1: 4672:	    case EM_PARISC:
        1: 4673:	      result = get_parisc_segment_type (p_type);
        1: 4674:	      break;
    #####: 4675:	    case EM_IA_64:
    #####: 4676:	      result = get_ia64_segment_type (p_type);
    #####: 4677:	      break;
    #####: 4678:	    case EM_TI_C6000:
    #####: 4679:	      result = get_tic6x_segment_type (p_type);
    #####: 4680:	      break;
        1: 4681:	    case EM_S390:
        -: 4682:	    case EM_S390_OLD:
        1: 4683:	      result = get_s390_segment_type (p_type);
        1: 4684:	      break;
    #####: 4685:	    case EM_RISCV:
    #####: 4686:	      result = get_riscv_segment_type (p_type);
    #####: 4687:	      break;
       31: 4688:	    default:
       31: 4689:	      result = NULL;
       31: 4690:	      break;
        -: 4691:	    }
        -: 4692:
       35: 4693:	  if (result != NULL)
    #####: 4694:	    return result;
        -: 4695:
       35: 4696:	  sprintf (buff, "LOPROC+%#lx", p_type - PT_LOPROC);
        -: 4697:	}
      420: 4698:      else if ((p_type >= PT_LOOS) && (p_type <= PT_HIOS))
       40: 4699:	{
       40: 4700:	  const char * result = NULL;
        -: 4701:
       40: 4702:	  switch (filedata->file_header.e_ident[EI_OSABI])
        -: 4703:	    {
        3: 4704:	    case ELFOSABI_GNU:
        -: 4705:	    case ELFOSABI_FREEBSD:
        3: 4706:	      if (p_type >= PT_GNU_MBIND_LO && p_type <= PT_GNU_MBIND_HI)
        -: 4707:		{
    #####: 4708:		  sprintf (buff, "GNU_MBIND+%#lx", p_type - PT_GNU_MBIND_LO);
    #####: 4709:		  result = buff;
        -: 4710:		}
        3: 4711:	      break;
        1: 4712:	    case ELFOSABI_HPUX:
        1: 4713:	      result = get_hpux_segment_type (p_type,
        1: 4714:					      filedata->file_header.e_machine);
        1: 4715:	      break;
    #####: 4716:	    case ELFOSABI_SOLARIS:
    #####: 4717:	      result = get_solaris_segment_type (p_type);
    #####: 4718:	      break;
       36: 4719:	    default:
       36: 4720:	      break;
        -: 4721:	    }
       40: 4722:	  if (result != NULL)
    #####: 4723:	    return result;
        -: 4724:
       40: 4725:	  sprintf (buff, "LOOS+%#lx", p_type - PT_LOOS);
        -: 4726:	}
        -: 4727:      else
      380: 4728:	snprintf (buff, sizeof (buff), _("<unknown>: %lx"), p_type);
        -: 4729:
      455: 4730:      return buff;
        -: 4731:    }
        -: 4732:}
        -: 4733:
        -: 4734:static const char *
        1: 4735:get_arc_section_type_name (unsigned int sh_type)
        -: 4736:{
        1: 4737:  switch (sh_type)
        -: 4738:    {
    #####: 4739:    case SHT_ARC_ATTRIBUTES:      return "ARC_ATTRIBUTES";
        1: 4740:    default:
        1: 4741:      break;
        -: 4742:    }
        1: 4743:  return NULL;
        -: 4744:}
        -: 4745:
        -: 4746:static const char *
        4: 4747:get_mips_section_type_name (unsigned int sh_type)
        -: 4748:{
        4: 4749:  switch (sh_type)
        -: 4750:    {
    #####: 4751:    case SHT_MIPS_LIBLIST:	 return "MIPS_LIBLIST";
    #####: 4752:    case SHT_MIPS_MSYM:		 return "MIPS_MSYM";
    #####: 4753:    case SHT_MIPS_CONFLICT:	 return "MIPS_CONFLICT";
    #####: 4754:    case SHT_MIPS_GPTAB:	 return "MIPS_GPTAB";
    #####: 4755:    case SHT_MIPS_UCODE:	 return "MIPS_UCODE";
    #####: 4756:    case SHT_MIPS_DEBUG:	 return "MIPS_DEBUG";
    #####: 4757:    case SHT_MIPS_REGINFO:	 return "MIPS_REGINFO";
    #####: 4758:    case SHT_MIPS_PACKAGE:	 return "MIPS_PACKAGE";
    #####: 4759:    case SHT_MIPS_PACKSYM:	 return "MIPS_PACKSYM";
    #####: 4760:    case SHT_MIPS_RELD:		 return "MIPS_RELD";
    #####: 4761:    case SHT_MIPS_IFACE:	 return "MIPS_IFACE";
    #####: 4762:    case SHT_MIPS_CONTENT:	 return "MIPS_CONTENT";
    #####: 4763:    case SHT_MIPS_OPTIONS:	 return "MIPS_OPTIONS";
    #####: 4764:    case SHT_MIPS_SHDR:		 return "MIPS_SHDR";
    #####: 4765:    case SHT_MIPS_FDESC:	 return "MIPS_FDESC";
    #####: 4766:    case SHT_MIPS_EXTSYM:	 return "MIPS_EXTSYM";
    #####: 4767:    case SHT_MIPS_DENSE:	 return "MIPS_DENSE";
    #####: 4768:    case SHT_MIPS_PDESC:	 return "MIPS_PDESC";
    #####: 4769:    case SHT_MIPS_LOCSYM:	 return "MIPS_LOCSYM";
    #####: 4770:    case SHT_MIPS_AUXSYM:	 return "MIPS_AUXSYM";
    #####: 4771:    case SHT_MIPS_OPTSYM:	 return "MIPS_OPTSYM";
    #####: 4772:    case SHT_MIPS_LOCSTR:	 return "MIPS_LOCSTR";
    #####: 4773:    case SHT_MIPS_LINE:		 return "MIPS_LINE";
    #####: 4774:    case SHT_MIPS_RFDESC:	 return "MIPS_RFDESC";
    #####: 4775:    case SHT_MIPS_DELTASYM:	 return "MIPS_DELTASYM";
    #####: 4776:    case SHT_MIPS_DELTAINST:	 return "MIPS_DELTAINST";
    #####: 4777:    case SHT_MIPS_DELTACLASS:	 return "MIPS_DELTACLASS";
    #####: 4778:    case SHT_MIPS_DWARF:	 return "MIPS_DWARF";
    #####: 4779:    case SHT_MIPS_DELTADECL:	 return "MIPS_DELTADECL";
    #####: 4780:    case SHT_MIPS_SYMBOL_LIB:	 return "MIPS_SYMBOL_LIB";
    #####: 4781:    case SHT_MIPS_EVENTS:	 return "MIPS_EVENTS";
    #####: 4782:    case SHT_MIPS_TRANSLATE:	 return "MIPS_TRANSLATE";
    #####: 4783:    case SHT_MIPS_PIXIE:	 return "MIPS_PIXIE";
    #####: 4784:    case SHT_MIPS_XLATE:	 return "MIPS_XLATE";
    #####: 4785:    case SHT_MIPS_XLATE_DEBUG:	 return "MIPS_XLATE_DEBUG";
    #####: 4786:    case SHT_MIPS_WHIRL:	 return "MIPS_WHIRL";
    #####: 4787:    case SHT_MIPS_EH_REGION:	 return "MIPS_EH_REGION";
    #####: 4788:    case SHT_MIPS_XLATE_OLD:	 return "MIPS_XLATE_OLD";
    #####: 4789:    case SHT_MIPS_PDR_EXCEPTION: return "MIPS_PDR_EXCEPTION";
    #####: 4790:    case SHT_MIPS_ABIFLAGS:	 return "MIPS_ABIFLAGS";
    #####: 4791:    case SHT_MIPS_XHASH:	 return "MIPS_XHASH";
        4: 4792:    default:
        4: 4793:      break;
        -: 4794:    }
        4: 4795:  return NULL;
        -: 4796:}
        -: 4797:
        -: 4798:static const char *
        4: 4799:get_parisc_section_type_name (unsigned int sh_type)
        -: 4800:{
        4: 4801:  switch (sh_type)
        -: 4802:    {
    #####: 4803:    case SHT_PARISC_EXT:	return "PARISC_EXT";
    #####: 4804:    case SHT_PARISC_UNWIND:	return "PARISC_UNWIND";
    #####: 4805:    case SHT_PARISC_DOC:	return "PARISC_DOC";
    #####: 4806:    case SHT_PARISC_ANNOT:	return "PARISC_ANNOT";
    #####: 4807:    case SHT_PARISC_SYMEXTN:	return "PARISC_SYMEXTN";
    #####: 4808:    case SHT_PARISC_STUBS:	return "PARISC_STUBS";
    #####: 4809:    case SHT_PARISC_DLKM:	return "PARISC_DLKM";
        4: 4810:    default:             	return NULL;
        -: 4811:    }
        -: 4812:}
        -: 4813:
        -: 4814:static const char *
    #####: 4815:get_ia64_section_type_name (Filedata * filedata, unsigned int sh_type)
        -: 4816:{
        -: 4817:  /* If the top 8 bits are 0x78 the next 8 are the os/abi ID.  */
    #####: 4818:  if ((sh_type & 0xFF000000) == SHT_IA_64_LOPSREG)
    #####: 4819:    return get_osabi_name (filedata, (sh_type & 0x00FF0000) >> 16);
        -: 4820:
    #####: 4821:  switch (sh_type)
        -: 4822:    {
    #####: 4823:    case SHT_IA_64_EXT:		       return "IA_64_EXT";
    #####: 4824:    case SHT_IA_64_UNWIND:	       return "IA_64_UNWIND";
    #####: 4825:    case SHT_IA_64_PRIORITY_INIT:      return "IA_64_PRIORITY_INIT";
    #####: 4826:    case SHT_IA_64_VMS_TRACE:          return "VMS_TRACE";
    #####: 4827:    case SHT_IA_64_VMS_TIE_SIGNATURES: return "VMS_TIE_SIGNATURES";
    #####: 4828:    case SHT_IA_64_VMS_DEBUG:          return "VMS_DEBUG";
    #####: 4829:    case SHT_IA_64_VMS_DEBUG_STR:      return "VMS_DEBUG_STR";
    #####: 4830:    case SHT_IA_64_VMS_LINKAGES:       return "VMS_LINKAGES";
    #####: 4831:    case SHT_IA_64_VMS_SYMBOL_VECTOR:  return "VMS_SYMBOL_VECTOR";
    #####: 4832:    case SHT_IA_64_VMS_FIXUP:          return "VMS_FIXUP";
    #####: 4833:    default:
    #####: 4834:      break;
        -: 4835:    }
    #####: 4836:  return NULL;
        -: 4837:}
        -: 4838:
        -: 4839:static const char *
    #####: 4840:get_x86_64_section_type_name (unsigned int sh_type)
        -: 4841:{
    #####: 4842:  switch (sh_type)
        -: 4843:    {
    #####: 4844:    case SHT_X86_64_UNWIND:	return "X86_64_UNWIND";
    #####: 4845:    default:			return NULL;
        -: 4846:    }
        -: 4847:}
        -: 4848:
        -: 4849:static const char *
    #####: 4850:get_aarch64_section_type_name (unsigned int sh_type)
        -: 4851:{
    #####: 4852:  switch (sh_type)
        -: 4853:    {
    #####: 4854:    case SHT_AARCH64_ATTRIBUTES: return "AARCH64_ATTRIBUTES";
    #####: 4855:    default:			 return NULL;
        -: 4856:    }
        -: 4857:}
        -: 4858:
        -: 4859:static const char *
    #####: 4860:get_arm_section_type_name (unsigned int sh_type)
        -: 4861:{
    #####: 4862:  switch (sh_type)
        -: 4863:    {
    #####: 4864:    case SHT_ARM_EXIDX:           return "ARM_EXIDX";
    #####: 4865:    case SHT_ARM_PREEMPTMAP:      return "ARM_PREEMPTMAP";
    #####: 4866:    case SHT_ARM_ATTRIBUTES:      return "ARM_ATTRIBUTES";
    #####: 4867:    case SHT_ARM_DEBUGOVERLAY:    return "ARM_DEBUGOVERLAY";
    #####: 4868:    case SHT_ARM_OVERLAYSECTION:  return "ARM_OVERLAYSECTION";
    #####: 4869:    default:			  return NULL;
        -: 4870:    }
        -: 4871:}
        -: 4872:
        -: 4873:static const char *
    #####: 4874:get_tic6x_section_type_name (unsigned int sh_type)
        -: 4875:{
    #####: 4876:  switch (sh_type)
        -: 4877:    {
    #####: 4878:    case SHT_C6000_UNWIND:      return "C6000_UNWIND";
    #####: 4879:    case SHT_C6000_PREEMPTMAP:  return "C6000_PREEMPTMAP";
    #####: 4880:    case SHT_C6000_ATTRIBUTES:  return "C6000_ATTRIBUTES";
    #####: 4881:    case SHT_TI_ICODE:          return "TI_ICODE";
    #####: 4882:    case SHT_TI_XREF:           return "TI_XREF";
    #####: 4883:    case SHT_TI_HANDLER:        return "TI_HANDLER";
    #####: 4884:    case SHT_TI_INITINFO:       return "TI_INITINFO";
    #####: 4885:    case SHT_TI_PHATTRS:        return "TI_PHATTRS";
    #####: 4886:    default:                    return NULL;
        -: 4887:    }
        -: 4888:}
        -: 4889:
        -: 4890:static const char *
    #####: 4891:get_msp430_section_type_name (unsigned int sh_type)
        -: 4892:{
    #####: 4893:  switch (sh_type)
        -: 4894:    {
    #####: 4895:    case SHT_MSP430_SEC_FLAGS:    return "MSP430_SEC_FLAGS";
    #####: 4896:    case SHT_MSP430_SYM_ALIASES:  return "MSP430_SYM_ALIASES";
    #####: 4897:    case SHT_MSP430_ATTRIBUTES:   return "MSP430_ATTRIBUTES";
    #####: 4898:    default:                      return NULL;
        -: 4899:    }
        -: 4900:}
        -: 4901:
        -: 4902:static const char *
        1: 4903:get_nfp_section_type_name (unsigned int sh_type)
        -: 4904:{
        1: 4905:  switch (sh_type)
        -: 4906:    {
    #####: 4907:    case SHT_NFP_MECONFIG:	return "NFP_MECONFIG";
    #####: 4908:    case SHT_NFP_INITREG:	return "NFP_INITREG";
    #####: 4909:    case SHT_NFP_UDEBUG:	return "NFP_UDEBUG";
        1: 4910:    default:			return NULL;
        -: 4911:    }
        -: 4912:}
        -: 4913:
        -: 4914:static const char *
        8: 4915:get_v850_section_type_name (unsigned int sh_type)
        -: 4916:{
        8: 4917:  switch (sh_type)
        -: 4918:    {
    #####: 4919:    case SHT_V850_SCOMMON:  return "V850 Small Common";
    #####: 4920:    case SHT_V850_TCOMMON:  return "V850 Tiny Common";
    #####: 4921:    case SHT_V850_ZCOMMON:  return "V850 Zero Common";
        1: 4922:    case SHT_RENESAS_IOP:   return "RENESAS IOP";
    #####: 4923:    case SHT_RENESAS_INFO:  return "RENESAS INFO";
        7: 4924:    default:                return NULL;
        -: 4925:    }
        -: 4926:}
        -: 4927:
        -: 4928:static const char *
        1: 4929:get_riscv_section_type_name (unsigned int sh_type)
        -: 4930:{
        1: 4931:  switch (sh_type)
        -: 4932:    {
    #####: 4933:    case SHT_RISCV_ATTRIBUTES:  return "RISCV_ATTRIBUTES";
        1: 4934:    default: return NULL;
        -: 4935:    }
        -: 4936:}
        -: 4937:
        -: 4938:static const char *
        1: 4939:get_csky_section_type_name (unsigned int sh_type)
        -: 4940:{
        1: 4941:  switch (sh_type)
        -: 4942:    {
    #####: 4943:    case SHT_CSKY_ATTRIBUTES:  return "CSKY_ATTRIBUTES";
        1: 4944:    default:  return NULL;
        -: 4945:    }
        -: 4946:}
        -: 4947:
        -: 4948:static const char *
     3507: 4949:get_section_type_name (Filedata * filedata, unsigned int sh_type)
        -: 4950:{
        -: 4951:  static char buff[32];
        -: 4952:  const char * result;
        -: 4953:
     3507: 4954:  switch (sh_type)
        -: 4955:    {
      849: 4956:    case SHT_NULL:		return "NULL";
     1106: 4957:    case SHT_PROGBITS:		return "PROGBITS";
       53: 4958:    case SHT_SYMTAB:		return "SYMTAB";
      531: 4959:    case SHT_STRTAB:		return "STRTAB";
       63: 4960:    case SHT_RELA:		return "RELA";
        8: 4961:    case SHT_RELR:		return "RELR";
        8: 4962:    case SHT_HASH:		return "HASH";
        8: 4963:    case SHT_DYNAMIC:		return "DYNAMIC";
       19: 4964:    case SHT_NOTE:		return "NOTE";
       14: 4965:    case SHT_NOBITS:		return "NOBITS";
       94: 4966:    case SHT_REL:		return "REL";
        1: 4967:    case SHT_SHLIB:		return "SHLIB";
       65: 4968:    case SHT_DYNSYM:		return "DYNSYM";
        5: 4969:    case SHT_INIT_ARRAY:	return "INIT_ARRAY";
        2: 4970:    case SHT_FINI_ARRAY:	return "FINI_ARRAY";
        9: 4971:    case SHT_PREINIT_ARRAY:	return "PREINIT_ARRAY";
    #####: 4972:    case SHT_GNU_HASH:		return "GNU_HASH";
       57: 4973:    case SHT_GROUP:		return "GROUP";
        1: 4974:    case SHT_SYMTAB_SHNDX:	return "SYMTAB SECTION INDICES";
    #####: 4975:    case SHT_GNU_verdef:	return "VERDEF";
    #####: 4976:    case SHT_GNU_verneed:	return "VERNEED";
    #####: 4977:    case SHT_GNU_versym:	return "VERSYM";
    #####: 4978:    case 0x6ffffff0:		return "VERSYM";
    #####: 4979:    case 0x6ffffffc:		return "VERDEF";
    #####: 4980:    case 0x7ffffffd:		return "AUXILIARY";
        1: 4981:    case 0x7fffffff:		return "FILTER";
    #####: 4982:    case SHT_GNU_LIBLIST:	return "GNU_LIBLIST";
        -: 4983:
      613: 4984:    default:
      613: 4985:      if ((sh_type >= SHT_LOPROC) && (sh_type <= SHT_HIPROC))
        -: 4986:	{
       88: 4987:	  switch (filedata->file_header.e_machine)
        -: 4988:	    {
        1: 4989:	    case EM_ARC:
        -: 4990:	    case EM_ARC_COMPACT:
        -: 4991:	    case EM_ARC_COMPACT2:
        1: 4992:	      result = get_arc_section_type_name (sh_type);
        1: 4993:	      break;
        4: 4994:	    case EM_MIPS:
        -: 4995:	    case EM_MIPS_RS3_LE:
        4: 4996:	      result = get_mips_section_type_name (sh_type);
        4: 4997:	      break;
        4: 4998:	    case EM_PARISC:
        4: 4999:	      result = get_parisc_section_type_name (sh_type);
        4: 5000:	      break;
    #####: 5001:	    case EM_IA_64:
    #####: 5002:	      result = get_ia64_section_type_name (filedata, sh_type);
    #####: 5003:	      break;
    #####: 5004:	    case EM_X86_64:
        -: 5005:	    case EM_L1OM:
        -: 5006:	    case EM_K1OM:
    #####: 5007:	      result = get_x86_64_section_type_name (sh_type);
    #####: 5008:	      break;
    #####: 5009:	    case EM_AARCH64:
    #####: 5010:	      result = get_aarch64_section_type_name (sh_type);
    #####: 5011:	      break;
    #####: 5012:	    case EM_ARM:
    #####: 5013:	      result = get_arm_section_type_name (sh_type);
    #####: 5014:	      break;
    #####: 5015:	    case EM_TI_C6000:
    #####: 5016:	      result = get_tic6x_section_type_name (sh_type);
    #####: 5017:	      break;
    #####: 5018:	    case EM_MSP430:
    #####: 5019:	      result = get_msp430_section_type_name (sh_type);
    #####: 5020:	      break;
        1: 5021:	    case EM_NFP:
        1: 5022:	      result = get_nfp_section_type_name (sh_type);
        1: 5023:	      break;
        2: 5024:	    case EM_V800:
        -: 5025:	    case EM_V850:
        -: 5026:	    case EM_CYGNUS_V850:
        2: 5027:	      result = get_v850_section_type_name (sh_type);
        2: 5028:	      break;
        1: 5029:	    case EM_RISCV:
        1: 5030:	      result = get_riscv_section_type_name (sh_type);
        1: 5031:	      break;
        1: 5032:	    case EM_CSKY:
        1: 5033:	      result = get_csky_section_type_name (sh_type);
        1: 5034:	      break;
       74: 5035:	    default:
       74: 5036:	      result = NULL;
       74: 5037:	      break;
        -: 5038:	    }
        -: 5039:
       88: 5040:	  if (result != NULL)
    #####: 5041:	    return result;
        -: 5042:
       88: 5043:	  sprintf (buff, "LOPROC+%#x", sh_type - SHT_LOPROC);
        -: 5044:	}
      525: 5045:      else if ((sh_type >= SHT_LOOS) && (sh_type <= SHT_HIOS))
        -: 5046:	{
       59: 5047:	  switch (filedata->file_header.e_machine)
        -: 5048:	    {
    #####: 5049:	    case EM_IA_64:
    #####: 5050:	      result = get_ia64_section_type_name (filedata, sh_type);
    #####: 5051:	      break;
       59: 5052:	    default:
       59: 5053:	      if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
        1: 5054:		result = get_solaris_section_type (sh_type);
        -: 5055:	      else
        -: 5056:		{
        -: 5057:		  switch (sh_type)
        -: 5058:		    {
    #####: 5059:		    case SHT_GNU_INCREMENTAL_INPUTS: result = "GNU_INCREMENTAL_INPUTS"; break;
    #####: 5060:		    case SHT_GNU_ATTRIBUTES: result = "GNU_ATTRIBUTES"; break;
    #####: 5061:		    case SHT_GNU_HASH: result = "GNU_HASH"; break;
    #####: 5062:		    case SHT_GNU_LIBLIST: result = "GNU_LIBLIST"; break;
       58: 5063:		    default:
       58: 5064:		      result = NULL;
       58: 5065:		      break;
        -: 5066:		    }
        -: 5067:		}
       59: 5068:	      break;
        -: 5069:	    }
        -: 5070:
       59: 5071:	  if (result != NULL)
    #####: 5072:	    return result;
        -: 5073:
       59: 5074:	  sprintf (buff, "LOOS+%#x", sh_type - SHT_LOOS);
        -: 5075:	}
      466: 5076:      else if ((sh_type >= SHT_LOUSER) && (sh_type <= SHT_HIUSER))
        -: 5077:	{
       91: 5078:	  switch (filedata->file_header.e_machine)
        -: 5079:	    {
        6: 5080:	    case EM_V800:
        -: 5081:	    case EM_V850:
        -: 5082:	    case EM_CYGNUS_V850:
        6: 5083:	      result = get_v850_section_type_name (sh_type);
        6: 5084:	      break;
       85: 5085:	    default:
       85: 5086:	      result = NULL;
       85: 5087:	      break;
        -: 5088:	    }
        -: 5089:
       91: 5090:	  if (result != NULL)
        1: 5091:	    return result;
        -: 5092:
       90: 5093:	  sprintf (buff, "LOUSER+%#x", sh_type - SHT_LOUSER);
        -: 5094:	}
        -: 5095:      else
        -: 5096:	/* This message is probably going to be displayed in a 15
        -: 5097:	   character wide field, so put the hex value first.  */
      375: 5098:	snprintf (buff, sizeof (buff), _("%08x: <unknown>"), sh_type);
        -: 5099:
      612: 5100:      return buff;
        -: 5101:    }
        -: 5102:}
        -: 5103:
        -: 5104:enum long_option_values
        -: 5105:{
        -: 5106:  OPTION_DEBUG_DUMP = 512,
        -: 5107:  OPTION_DYN_SYMS,
        -: 5108:  OPTION_LTO_SYMS,
        -: 5109:  OPTION_DWARF_DEPTH,
        -: 5110:  OPTION_DWARF_START,
        -: 5111:  OPTION_DWARF_CHECK,
        -: 5112:  OPTION_CTF_DUMP,
        -: 5113:  OPTION_CTF_PARENT,
        -: 5114:  OPTION_CTF_SYMBOLS,
        -: 5115:  OPTION_CTF_STRINGS,
        -: 5116:  OPTION_WITH_SYMBOL_VERSIONS,
        -: 5117:  OPTION_RECURSE_LIMIT,
        -: 5118:  OPTION_NO_RECURSE_LIMIT,
        -: 5119:  OPTION_NO_DEMANGLING,
        -: 5120:  OPTION_SYM_BASE
        -: 5121:};
        -: 5122:
        -: 5123:static struct option options[] =
        -: 5124:{
        -: 5125: /* Note - This table is alpha-sorted on the 'val'
        -: 5126:    field in order to make adding new options easier.  */
        -: 5127:  {"arch-specific",    no_argument, 0, 'A'},
        -: 5128:  {"all",	       no_argument, 0, 'a'},
        -: 5129:  {"demangle",         optional_argument, 0, 'C'},
        -: 5130:  {"archive-index",    no_argument, 0, 'c'},
        -: 5131:  {"use-dynamic",      no_argument, 0, 'D'},
        -: 5132:  {"dynamic",	       no_argument, 0, 'd'},
        -: 5133:  {"headers",	       no_argument, 0, 'e'},
        -: 5134:  {"section-groups",   no_argument, 0, 'g'},
        -: 5135:  {"help",	       no_argument, 0, 'H'},
        -: 5136:  {"file-header",      no_argument, 0, 'h'},
        -: 5137:  {"histogram",	       no_argument, 0, 'I'},
        -: 5138:  {"lint",             no_argument, 0, 'L'},
        -: 5139:  {"enable-checks",    no_argument, 0, 'L'},
        -: 5140:  {"program-headers",  no_argument, 0, 'l'},
        -: 5141:  {"segments",	       no_argument, 0, 'l'},
        -: 5142:  {"full-section-name",no_argument, 0, 'N'},
        -: 5143:  {"notes",	       no_argument, 0, 'n'},
        -: 5144:  {"process-links",    no_argument, 0, 'P'},
        -: 5145:  {"string-dump",      required_argument, 0, 'p'},
        -: 5146:  {"relocated-dump",   required_argument, 0, 'R'},
        -: 5147:  {"relocs",	       no_argument, 0, 'r'},
        -: 5148:  {"section-headers",  no_argument, 0, 'S'},
        -: 5149:  {"sections",	       no_argument, 0, 'S'},
        -: 5150:  {"symbols",	       no_argument, 0, 's'},
        -: 5151:  {"syms",	       no_argument, 0, 's'},
        -: 5152:  {"silent-truncation",no_argument, 0, 'T'},
        -: 5153:  {"section-details",  no_argument, 0, 't'},
        -: 5154:  {"unicode",          required_argument, NULL, 'U'},
        -: 5155:  {"unwind",	       no_argument, 0, 'u'},
        -: 5156:  {"version-info",     no_argument, 0, 'V'},
        -: 5157:  {"version",	       no_argument, 0, 'v'},
        -: 5158:  {"wide",	       no_argument, 0, 'W'},
        -: 5159:  {"hex-dump",	       required_argument, 0, 'x'},
        -: 5160:  {"decompress",       no_argument, 0, 'z'},
        -: 5161:
        -: 5162:  {"no-demangle",      no_argument, 0, OPTION_NO_DEMANGLING},
        -: 5163:  {"recurse-limit",    no_argument, NULL, OPTION_RECURSE_LIMIT},
        -: 5164:  {"no-recurse-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
        -: 5165:  {"no-recursion-limit", no_argument, NULL, OPTION_NO_RECURSE_LIMIT},
        -: 5166:  {"dyn-syms",	       no_argument, 0, OPTION_DYN_SYMS},
        -: 5167:  {"lto-syms",         no_argument, 0, OPTION_LTO_SYMS},
        -: 5168:  {"debug-dump",       optional_argument, 0, OPTION_DEBUG_DUMP},
        -: 5169:  {"dwarf-depth",      required_argument, 0, OPTION_DWARF_DEPTH},
        -: 5170:  {"dwarf-start",      required_argument, 0, OPTION_DWARF_START},
        -: 5171:  {"dwarf-check",      no_argument, 0, OPTION_DWARF_CHECK},
        -: 5172:#ifdef ENABLE_LIBCTF
        -: 5173:  {"ctf",	       required_argument, 0, OPTION_CTF_DUMP},
        -: 5174:  {"ctf-symbols",      required_argument, 0, OPTION_CTF_SYMBOLS},
        -: 5175:  {"ctf-strings",      required_argument, 0, OPTION_CTF_STRINGS},
        -: 5176:  {"ctf-parent",       required_argument, 0, OPTION_CTF_PARENT},
        -: 5177:#endif
        -: 5178:  {"sym-base",	       optional_argument, 0, OPTION_SYM_BASE},
        -: 5179:
        -: 5180:  {0,		       no_argument, 0, 0}
        -: 5181:};
        -: 5182:
        -: 5183:static void
    #####: 5184:usage (FILE * stream)
        -: 5185:{
    #####: 5186:  fprintf (stream, _("Usage: readelf <option(s)> elf-file(s)\n"));
    #####: 5187:  fprintf (stream, _(" Display information about the contents of ELF format files\n"));
    #####: 5188:  fprintf (stream, _(" Options are:\n"));
    #####: 5189:  fprintf (stream, _("\
        -: 5190:  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n"));
    #####: 5191:  fprintf (stream, _("\
        -: 5192:  -h --file-header       Display the ELF file header\n"));
    #####: 5193:  fprintf (stream, _("\
        -: 5194:  -l --program-headers   Display the program headers\n"));
    #####: 5195:  fprintf (stream, _("\
        -: 5196:     --segments          An alias for --program-headers\n"));
    #####: 5197:  fprintf (stream, _("\
        -: 5198:  -S --section-headers   Display the sections' header\n"));
    #####: 5199:  fprintf (stream, _("\
        -: 5200:     --sections          An alias for --section-headers\n"));
    #####: 5201:  fprintf (stream, _("\
        -: 5202:  -g --section-groups    Display the section groups\n"));
    #####: 5203:  fprintf (stream, _("\
        -: 5204:  -t --section-details   Display the section details\n"));
    #####: 5205:  fprintf (stream, _("\
        -: 5206:  -e --headers           Equivalent to: -h -l -S\n"));
    #####: 5207:  fprintf (stream, _("\
        -: 5208:  -s --syms              Display the symbol table\n"));
    #####: 5209:  fprintf (stream, _("\
        -: 5210:     --symbols           An alias for --syms\n"));
    #####: 5211:  fprintf (stream, _("\
        -: 5212:     --dyn-syms          Display the dynamic symbol table\n"));
    #####: 5213:  fprintf (stream, _("\
        -: 5214:     --lto-syms          Display LTO symbol tables\n"));
    #####: 5215:  fprintf (stream, _("\
        -: 5216:     --sym-base=[0|8|10|16] \n\
        -: 5217:                         Force base for symbol sizes.  The options are \n\
        -: 5218:                         mixed (the default), octal, decimal, hexadecimal.\n"));
    #####: 5219:  fprintf (stream, _("\
        -: 5220:  -C --demangle[=STYLE]  Decode mangled/processed symbol names\n"));
    #####: 5221:  display_demangler_styles (stream, _("\
        -: 5222:                           STYLE can be "));
    #####: 5223:  fprintf (stream, _("\
        -: 5224:     --no-demangle       Do not demangle low-level symbol names.  (default)\n"));
    #####: 5225:  fprintf (stream, _("\
        -: 5226:     --recurse-limit     Enable a demangling recursion limit.  (default)\n"));
    #####: 5227:  fprintf (stream, _("\
        -: 5228:     --no-recurse-limit  Disable a demangling recursion limit\n"));
    #####: 5229:  fprintf (stream, _("\
        -: 5230:     -U[dlexhi] --unicode=[default|locale|escape|hex|highlight|invalid]\n\
        -: 5231:                         Display unicode characters as determined by the current locale\n\
        -: 5232:                          (default), escape sequences, \"<hex sequences>\", highlighted\n\
        -: 5233:                          escape sequences, or treat them as invalid and display as\n\
        -: 5234:                          \"{hex sequences}\"\n"));
    #####: 5235:  fprintf (stream, _("\
        -: 5236:  -n --notes             Display the core notes (if present)\n"));
    #####: 5237:  fprintf (stream, _("\
        -: 5238:  -r --relocs            Display the relocations (if present)\n"));
    #####: 5239:  fprintf (stream, _("\
        -: 5240:  -u --unwind            Display the unwind info (if present)\n"));
    #####: 5241:  fprintf (stream, _("\
        -: 5242:  -d --dynamic           Display the dynamic section (if present)\n"));
    #####: 5243:  fprintf (stream, _("\
        -: 5244:  -V --version-info      Display the version sections (if present)\n"));
    #####: 5245:  fprintf (stream, _("\
        -: 5246:  -A --arch-specific     Display architecture specific information (if any)\n"));
    #####: 5247:  fprintf (stream, _("\
        -: 5248:  -c --archive-index     Display the symbol/file index in an archive\n"));
    #####: 5249:  fprintf (stream, _("\
        -: 5250:  -D --use-dynamic       Use the dynamic section info when displaying symbols\n"));
    #####: 5251:  fprintf (stream, _("\
        -: 5252:  -L --lint|--enable-checks\n\
        -: 5253:                         Display warning messages for possible problems\n"));
    #####: 5254:  fprintf (stream, _("\
        -: 5255:  -x --hex-dump=<number|name>\n\
        -: 5256:                         Dump the contents of section <number|name> as bytes\n"));
    #####: 5257:  fprintf (stream, _("\
        -: 5258:  -p --string-dump=<number|name>\n\
        -: 5259:                         Dump the contents of section <number|name> as strings\n"));
    #####: 5260:  fprintf (stream, _("\
        -: 5261:  -R --relocated-dump=<number|name>\n\
        -: 5262:                         Dump the relocated contents of section <number|name>\n"));
    #####: 5263:  fprintf (stream, _("\
        -: 5264:  -z --decompress        Decompress section before dumping it\n"));
    #####: 5265:  fprintf (stream, _("\
        -: 5266:  -w --debug-dump[a/=abbrev, A/=addr, r/=aranges, c/=cu_index, L/=decodedline,\n\
        -: 5267:                  f/=frames, F/=frames-interp, g/=gdb_index, i/=info, o/=loc,\n\
        -: 5268:                  m/=macro, p/=pubnames, t/=pubtypes, R/=Ranges, l/=rawline,\n\
        -: 5269:                  s/=str, O/=str-offsets, u/=trace_abbrev, T/=trace_aranges,\n\
        -: 5270:                  U/=trace_info]\n\
        -: 5271:                         Display the contents of DWARF debug sections\n"));
    #####: 5272:  fprintf (stream, _("\
        -: 5273:  -wk --debug-dump=links Display the contents of sections that link to separate\n\
        -: 5274:                          debuginfo files\n"));
    #####: 5275:  fprintf (stream, _("\
        -: 5276:  -P --process-links     Display the contents of non-debug sections in separate\n\
        -: 5277:                          debuginfo files.  (Implies -wK)\n"));
        -: 5278:#if DEFAULT_FOR_FOLLOW_LINKS
    #####: 5279:  fprintf (stream, _("\
        -: 5280:  -wK --debug-dump=follow-links\n\
        -: 5281:                         Follow links to separate debug info files (default)\n"));
    #####: 5282:  fprintf (stream, _("\
        -: 5283:  -wN --debug-dump=no-follow-links\n\
        -: 5284:                         Do not follow links to separate debug info files\n"));
        -: 5285:#else
        -: 5286:  fprintf (stream, _("\
        -: 5287:  -wK --debug-dump=follow-links\n\
        -: 5288:                         Follow links to separate debug info files\n"));
        -: 5289:  fprintf (stream, _("\
        -: 5290:  -wN --debug-dump=no-follow-links\n\
        -: 5291:                         Do not follow links to separate debug info files\n\
        -: 5292:                          (default)\n"));
        -: 5293:#endif
        -: 5294:#if HAVE_LIBDEBUGINFOD
        -: 5295:  fprintf (stream, _("\
        -: 5296:  -wD --debug-dump=use-debuginfod\n\
        -: 5297:                         When following links, also query debuginfod servers (default)\n"));
        -: 5298:  fprintf (stream, _("\
        -: 5299:  -wE --debug-dump=do-not-use-debuginfod\n\
        -: 5300:                         When following links, do not query debuginfod servers\n"));
        -: 5301:#endif
    #####: 5302:  fprintf (stream, _("\
        -: 5303:  --dwarf-depth=N        Do not display DIEs at depth N or greater\n"));
    #####: 5304:  fprintf (stream, _("\
        -: 5305:  --dwarf-start=N        Display DIEs starting at offset N\n"));
        -: 5306:#ifdef ENABLE_LIBCTF
    #####: 5307:  fprintf (stream, _("\
        -: 5308:  --ctf=<number|name>    Display CTF info from section <number|name>\n"));
    #####: 5309:  fprintf (stream, _("\
        -: 5310:  --ctf-parent=<name>    Use CTF archive member <name> as the CTF parent\n"));
    #####: 5311:  fprintf (stream, _("\
        -: 5312:  --ctf-symbols=<number|name>\n\
        -: 5313:                         Use section <number|name> as the CTF external symtab\n"));
    #####: 5314:  fprintf (stream, _("\
        -: 5315:  --ctf-strings=<number|name>\n\
        -: 5316:                         Use section <number|name> as the CTF external strtab\n"));
        -: 5317:#endif
        -: 5318:
        -: 5319:#ifdef SUPPORT_DISASSEMBLY
        -: 5320:  fprintf (stream, _("\
        -: 5321:  -i --instruction-dump=<number|name>\n\
        -: 5322:                         Disassemble the contents of section <number|name>\n"));
        -: 5323:#endif
    #####: 5324:  fprintf (stream, _("\
        -: 5325:  -I --histogram         Display histogram of bucket list lengths\n"));
    #####: 5326:  fprintf (stream, _("\
        -: 5327:  -W --wide              Allow output width to exceed 80 characters\n"));
    #####: 5328:  fprintf (stream, _("\
        -: 5329:  -T --silent-truncation If a symbol name is truncated, do not add [...] suffix\n"));
    #####: 5330:  fprintf (stream, _("\
        -: 5331:  @<file>                Read options from <file>\n"));
    #####: 5332:  fprintf (stream, _("\
        -: 5333:  -H --help              Display this information\n"));
    #####: 5334:  fprintf (stream, _("\
        -: 5335:  -v --version           Display the version number of readelf\n"));
        -: 5336:
    #####: 5337:  if (REPORT_BUGS_TO[0] && stream == stdout)
    #####: 5338:    fprintf (stdout, _("Report bugs to %s\n"), REPORT_BUGS_TO);
        -: 5339:
    #####: 5340:  exit (stream == stdout ? 0 : 1);
        -: 5341:}
        -: 5342:
        -: 5343:/* Record the fact that the user wants the contents of section number
        -: 5344:   SECTION to be displayed using the method(s) encoded as flags bits
        -: 5345:   in TYPE.  Note, TYPE can be zero if we are creating the array for
        -: 5346:   the first time.  */
        -: 5347:
        -: 5348:static void
    #####: 5349:request_dump_bynumber (struct dump_data *dumpdata,
        -: 5350:		       unsigned int section, dump_type type)
        -: 5351:{
    #####: 5352:  if (section >= dumpdata->num_dump_sects)
        -: 5353:    {
        -: 5354:      dump_type * new_dump_sects;
        -: 5355:
    #####: 5356:      new_dump_sects = (dump_type *) calloc (section + 1,
        -: 5357:                                             sizeof (* new_dump_sects));
        -: 5358:
    #####: 5359:      if (new_dump_sects == NULL)
    #####: 5360:	error (_("Out of memory allocating dump request table.\n"));
        -: 5361:      else
        -: 5362:	{
    #####: 5363:	  if (dumpdata->dump_sects)
        -: 5364:	    {
        -: 5365:	      /* Copy current flag settings.  */
    #####: 5366:	      memcpy (new_dump_sects, dumpdata->dump_sects,
    #####: 5367:		      dumpdata->num_dump_sects * sizeof (* new_dump_sects));
        -: 5368:
    #####: 5369:	      free (dumpdata->dump_sects);
        -: 5370:	    }
        -: 5371:
    #####: 5372:	  dumpdata->dump_sects = new_dump_sects;
    #####: 5373:	  dumpdata->num_dump_sects = section + 1;
        -: 5374:	}
        -: 5375:    }
        -: 5376:
    #####: 5377:  if (dumpdata->dump_sects)
    #####: 5378:    dumpdata->dump_sects[section] |= type;
    #####: 5379:}
        -: 5380:
        -: 5381:/* Request a dump by section name.  */
        -: 5382:
        -: 5383:static void
    #####: 5384:request_dump_byname (const char * section, dump_type type)
        -: 5385:{
        -: 5386:  struct dump_list_entry * new_request;
        -: 5387:
        -: 5388:  new_request = (struct dump_list_entry *)
    #####: 5389:      malloc (sizeof (struct dump_list_entry));
    #####: 5390:  if (!new_request)
    #####: 5391:    error (_("Out of memory allocating dump request table.\n"));
        -: 5392:
    #####: 5393:  new_request->name = strdup (section);
    #####: 5394:  if (!new_request->name)
    #####: 5395:    error (_("Out of memory allocating dump request table.\n"));
        -: 5396:
    #####: 5397:  new_request->type = type;
        -: 5398:
    #####: 5399:  new_request->next = dump_sects_byname;
    #####: 5400:  dump_sects_byname = new_request;
    #####: 5401:}
        -: 5402:
        -: 5403:static inline void
    #####: 5404:request_dump (struct dump_data *dumpdata, dump_type type)
        -: 5405:{
        -: 5406:  int section;
        -: 5407:  char * cp;
        -: 5408:
    #####: 5409:  do_dump = true;
    #####: 5410:  section = strtoul (optarg, & cp, 0);
        -: 5411:
    #####: 5412:  if (! *cp && section >= 0)
    #####: 5413:    request_dump_bynumber (dumpdata, section, type);
        -: 5414:  else
    #####: 5415:    request_dump_byname (optarg, type);
    #####: 5416:}
        -: 5417:
        -: 5418:static void
       39: 5419:parse_args (struct dump_data *dumpdata, int argc, char ** argv)
        -: 5420:{
        -: 5421:  int c;
        -: 5422:
       39: 5423:  if (argc < 2)
    #####: 5424:    usage (stderr);
        -: 5425:
       78: 5426:  while ((c = getopt_long
        -: 5427:	  (argc, argv, "ACDHILNPR:STU:VWacdeghi:lnp:rstuvw::x:z", options, NULL)) != EOF)
        -: 5428:    {
       39: 5429:      switch (c)
        -: 5430:	{
    #####: 5431:	case 0:
        -: 5432:	  /* Long options.  */
    #####: 5433:	  break;
    #####: 5434:	case 'H':
    #####: 5435:	  usage (stdout);
    #####: 5436:	  break;
        -: 5437:
       39: 5438:	case 'a':
       39: 5439:	  do_syms = true;
       39: 5440:	  do_reloc = true;
       39: 5441:	  do_unwind = true;
       39: 5442:	  do_dynamic = true;
       39: 5443:	  do_header = true;
       39: 5444:	  do_sections = true;
       39: 5445:	  do_section_groups = true;
       39: 5446:	  do_segments = true;
       39: 5447:	  do_version = true;
       39: 5448:	  do_histogram = true;
       39: 5449:	  do_arch = true;
       39: 5450:	  do_notes = true;
       39: 5451:	  break;
        -: 5452:
    #####: 5453:	case 'g':
    #####: 5454:	  do_section_groups = true;
    #####: 5455:	  break;
    #####: 5456:	case 't':
        -: 5457:	case 'N':
    #####: 5458:	  do_sections = true;
    #####: 5459:	  do_section_details = true;
    #####: 5460:	  break;
    #####: 5461:	case 'e':
    #####: 5462:	  do_header = true;
    #####: 5463:	  do_sections = true;
    #####: 5464:	  do_segments = true;
    #####: 5465:	  break;
    #####: 5466:	case 'A':
    #####: 5467:	  do_arch = true;
    #####: 5468:	  break;
    #####: 5469:	case 'D':
    #####: 5470:	  do_using_dynamic = true;
    #####: 5471:	  break;
    #####: 5472:	case 'r':
    #####: 5473:	  do_reloc = true;
    #####: 5474:	  break;
    #####: 5475:	case 'u':
    #####: 5476:	  do_unwind = true;
    #####: 5477:	  break;
    #####: 5478:	case 'h':
    #####: 5479:	  do_header = true;
    #####: 5480:	  break;
    #####: 5481:	case 'l':
    #####: 5482:	  do_segments = true;
    #####: 5483:	  break;
    #####: 5484:	case 's':
    #####: 5485:	  do_syms = true;
    #####: 5486:	  break;
    #####: 5487:	case 'S':
    #####: 5488:	  do_sections = true;
    #####: 5489:	  break;
    #####: 5490:	case 'd':
    #####: 5491:	  do_dynamic = true;
    #####: 5492:	  break;
    #####: 5493:	case 'I':
    #####: 5494:	  do_histogram = true;
    #####: 5495:	  break;
    #####: 5496:	case 'n':
    #####: 5497:	  do_notes = true;
    #####: 5498:	  break;
    #####: 5499:	case 'c':
    #####: 5500:	  do_archive_index = true;
    #####: 5501:	  break;
    #####: 5502:	case 'L':
    #####: 5503:	  do_checks = true;
    #####: 5504:	  break;
    #####: 5505:	case 'P':
    #####: 5506:	  process_links = true;
    #####: 5507:	  do_follow_links = true;
    #####: 5508:	  dump_any_debugging = true;
    #####: 5509:	  break;
    #####: 5510:	case 'x':
    #####: 5511:	  request_dump (dumpdata, HEX_DUMP);
    #####: 5512:	  break;
    #####: 5513:	case 'p':
    #####: 5514:	  request_dump (dumpdata, STRING_DUMP);
    #####: 5515:	  break;
    #####: 5516:	case 'R':
    #####: 5517:	  request_dump (dumpdata, RELOC_DUMP);
    #####: 5518:	  break;
    #####: 5519:	case 'z':
    #####: 5520:	  decompress_dumps = true;
    #####: 5521:	  break;
    #####: 5522:	case 'w':
    #####: 5523:	  if (optarg == NULL)
        -: 5524:	    {
    #####: 5525:	      do_debugging = true;
    #####: 5526:	      do_dump = true;
    #####: 5527:	      dump_any_debugging = true;
    #####: 5528:	      dwarf_select_sections_all ();
        -: 5529:	    }
        -: 5530:	  else
        -: 5531:	    {
    #####: 5532:	      do_debugging = false;
    #####: 5533:	      if (dwarf_select_sections_by_letters (optarg))
        -: 5534:		{
    #####: 5535:		  do_dump = true;
    #####: 5536:		  dump_any_debugging = true;
        -: 5537:		}
        -: 5538:	    }
    #####: 5539:	  break;
    #####: 5540:	case OPTION_DEBUG_DUMP:
    #####: 5541:	  if (optarg == NULL)
        -: 5542:	    {
    #####: 5543:	      do_dump = true;
    #####: 5544:	      do_debugging = true;
    #####: 5545:	      dump_any_debugging = true;
    #####: 5546:	      dwarf_select_sections_all ();
        -: 5547:	    }
        -: 5548:	  else
        -: 5549:	    {
    #####: 5550:	      do_debugging = false;
    #####: 5551:	      if (dwarf_select_sections_by_names (optarg))
        -: 5552:		{
    #####: 5553:		  do_dump = true;
    #####: 5554:		  dump_any_debugging = true;
        -: 5555:		}
        -: 5556:	    }
    #####: 5557:	  break;
    #####: 5558:	case OPTION_DWARF_DEPTH:
        -: 5559:	  {
        -: 5560:	    char *cp;
        -: 5561:
    #####: 5562:	    dwarf_cutoff_level = strtoul (optarg, & cp, 0);
        -: 5563:	  }
    #####: 5564:	  break;
    #####: 5565:	case OPTION_DWARF_START:
        -: 5566:	  {
        -: 5567:	    char *cp;
        -: 5568:
    #####: 5569:	    dwarf_start_die = strtoul (optarg, & cp, 0);
        -: 5570:	  }
    #####: 5571:	  break;
    #####: 5572:	case OPTION_DWARF_CHECK:
    #####: 5573:	  dwarf_check = true;
    #####: 5574:	  break;
    #####: 5575:	case OPTION_CTF_DUMP:
    #####: 5576:	  do_ctf = true;
    #####: 5577:	  request_dump (dumpdata, CTF_DUMP);
    #####: 5578:	  break;
    #####: 5579:	case OPTION_CTF_SYMBOLS:
    #####: 5580:	  free (dump_ctf_symtab_name);
    #####: 5581:	  dump_ctf_symtab_name = strdup (optarg);
    #####: 5582:	  break;
    #####: 5583:	case OPTION_CTF_STRINGS:
    #####: 5584:	  free (dump_ctf_strtab_name);
    #####: 5585:	  dump_ctf_strtab_name = strdup (optarg);
    #####: 5586:	  break;
    #####: 5587:	case OPTION_CTF_PARENT:
    #####: 5588:	  free (dump_ctf_parent_name);
    #####: 5589:	  dump_ctf_parent_name = strdup (optarg);
    #####: 5590:	  break;
    #####: 5591:	case OPTION_DYN_SYMS:
    #####: 5592:	  do_dyn_syms = true;
    #####: 5593:	  break;
    #####: 5594:	case OPTION_LTO_SYMS:
    #####: 5595:	  do_lto_syms = true;
    #####: 5596:	  break;
        -: 5597:#ifdef SUPPORT_DISASSEMBLY
        -: 5598:	case 'i':
        -: 5599:	  request_dump (dumpdata, DISASS_DUMP);
        -: 5600:	  break;
        -: 5601:#endif
    #####: 5602:	case 'v':
    #####: 5603:	  print_version (program_name);
    #####: 5604:	  break;
    #####: 5605:	case 'V':
    #####: 5606:	  do_version = true;
    #####: 5607:	  break;
    #####: 5608:	case 'W':
    #####: 5609:	  do_wide = true;
    #####: 5610:	  break;
    #####: 5611:	case 'T':
    #####: 5612:	  do_not_show_symbol_truncation = true;
    #####: 5613:	  break;
    #####: 5614:	case 'C':
    #####: 5615:	  do_demangle = true;
    #####: 5616:	  if (optarg != NULL)
        -: 5617:	    {
        -: 5618:	      enum demangling_styles style;
        -: 5619:
    #####: 5620:	      style = cplus_demangle_name_to_style (optarg);
    #####: 5621:	      if (style == unknown_demangling)
    #####: 5622:		error (_("unknown demangling style `%s'"), optarg);
        -: 5623:
    #####: 5624:	      cplus_demangle_set_style (style);
        -: 5625:	    }
    #####: 5626:	  break;
    #####: 5627:	case OPTION_NO_DEMANGLING:
    #####: 5628:	  do_demangle = false;
    #####: 5629:	  break;
    #####: 5630:	case OPTION_RECURSE_LIMIT:
    #####: 5631:	  demangle_flags &= ~ DMGL_NO_RECURSE_LIMIT;
    #####: 5632:	  break;
    #####: 5633:	case OPTION_NO_RECURSE_LIMIT:
    #####: 5634:	  demangle_flags |= DMGL_NO_RECURSE_LIMIT;
    #####: 5635:	  break;
    #####: 5636:	case OPTION_WITH_SYMBOL_VERSIONS:
        -: 5637:	  /* Ignored for backward compatibility.  */
    #####: 5638:	  break;
        -: 5639:
    #####: 5640:	case 'U':
    #####: 5641:	  if (optarg == NULL)
    #####: 5642:	    error (_("Missing arg to -U/--unicode")); /* Can this happen ?  */
    #####: 5643:	  else if (streq (optarg, "default") || streq (optarg, "d"))
    #####: 5644:	    unicode_display = unicode_default;
    #####: 5645:	  else if (streq (optarg, "locale") || streq (optarg, "l"))
    #####: 5646:	    unicode_display = unicode_locale;
    #####: 5647:	  else if (streq (optarg, "escape") || streq (optarg, "e"))
    #####: 5648:	    unicode_display = unicode_escape;
    #####: 5649:	  else if (streq (optarg, "invalid") || streq (optarg, "i"))
    #####: 5650:	    unicode_display = unicode_invalid;
    #####: 5651:	  else if (streq (optarg, "hex") || streq (optarg, "x"))
    #####: 5652:	    unicode_display = unicode_hex;
    #####: 5653:	  else if (streq (optarg, "highlight") || streq (optarg, "h"))
    #####: 5654:	    unicode_display = unicode_highlight;
        -: 5655:	  else
    #####: 5656:	    error (_("invalid argument to -U/--unicode: %s"), optarg);
    #####: 5657:	  break;
        -: 5658:
    #####: 5659:	case OPTION_SYM_BASE:
    #####: 5660:	  sym_base = 0;
    #####: 5661:	  if (optarg != NULL)
        -: 5662:	    {
    #####: 5663:	      sym_base = strtoul (optarg, NULL, 0);
    #####: 5664:	      switch (sym_base)
        -: 5665:		{
    #####: 5666:		  case 0:
        -: 5667:		  case 8:
        -: 5668:		  case 10:
        -: 5669:		  case 16:
    #####: 5670:		    break;
        -: 5671:
    #####: 5672:		  default:
    #####: 5673:		    sym_base = 0;
    #####: 5674:		    break;
        -: 5675:		}
    #####: 5676:	    }
    #####: 5677:	  break;
        -: 5678:
    #####: 5679:	default:
        -: 5680:	  /* xgettext:c-format */
    #####: 5681:	  error (_("Invalid option '-%c'\n"), c);
        -: 5682:	  /* Fall through.  */
    #####: 5683:	case '?':
    #####: 5684:	  usage (stderr);
        -: 5685:	}
        -: 5686:    }
        -: 5687:
      39*: 5688:  if (!do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
    #####: 5689:      && !do_segments && !do_header && !do_dump && !do_version
    #####: 5690:      && !do_histogram && !do_debugging && !do_arch && !do_notes
    #####: 5691:      && !do_section_groups && !do_archive_index
    #####: 5692:      && !do_dyn_syms && !do_lto_syms)
        -: 5693:    {
    #####: 5694:      if (do_checks)
        -: 5695:	{
    #####: 5696:	  check_all = true;
    #####: 5697:	  do_dynamic = do_syms = do_reloc = do_unwind = do_sections = true;
    #####: 5698:	  do_segments = do_header = do_dump = do_version = true;
    #####: 5699:	  do_histogram = do_debugging = do_arch = do_notes = true;
    #####: 5700:	  do_section_groups = do_archive_index = do_dyn_syms = true;
    #####: 5701:	  do_lto_syms = true;
        -: 5702:	}
        -: 5703:      else
    #####: 5704:	usage (stderr);
        -: 5705:    }
       39: 5706:}
        -: 5707:
        -: 5708:static const char *
     1391: 5709:get_elf_class (unsigned int elf_class)
        -: 5710:{
        -: 5711:  static char buff[32];
        -: 5712:
     1391: 5713:  switch (elf_class)
        -: 5714:    {
       21: 5715:    case ELFCLASSNONE: return _("none");
     1301: 5716:    case ELFCLASS32:   return "ELF32";
        9: 5717:    case ELFCLASS64:   return "ELF64";
       60: 5718:    default:
       60: 5719:      snprintf (buff, sizeof (buff), _("<unknown: %x>"), elf_class);
       60: 5720:      return buff;
        -: 5721:    }
        -: 5722:}
        -: 5723:
        -: 5724:static const char *
     1391: 5725:get_data_encoding (unsigned int encoding)
        -: 5726:{
        -: 5727:  static char buff[32];
        -: 5728:
     1391: 5729:  switch (encoding)
        -: 5730:    {
       51: 5731:    case ELFDATANONE: return _("none");
     1253: 5732:    case ELFDATA2LSB: return _("2's complement, little endian");
        1: 5733:    case ELFDATA2MSB: return _("2's complement, big endian");
       86: 5734:    default:
       86: 5735:      snprintf (buff, sizeof (buff), _("<unknown: %x>"), encoding);
       86: 5736:      return buff;
        -: 5737:    }
        -: 5738:}
        -: 5739:
        -: 5740:/* Decode the data held in 'filedata->file_header'.  */
        -: 5741:
        -: 5742:static bool
     1397: 5743:process_file_header (Filedata * filedata)
        -: 5744:{
     1397: 5745:  Elf_Internal_Ehdr * header = & filedata->file_header;
        -: 5746:
     1397: 5747:  if (   header->e_ident[EI_MAG0] != ELFMAG0
     1396: 5748:      || header->e_ident[EI_MAG1] != ELFMAG1
     1394: 5749:      || header->e_ident[EI_MAG2] != ELFMAG2
     1393: 5750:      || header->e_ident[EI_MAG3] != ELFMAG3)
        -: 5751:    {
        6: 5752:      error
        6: 5753:	(_("Not an ELF file - it has the wrong magic bytes at the start\n"));
        6: 5754:      return false;
        -: 5755:    }
        -: 5756:
     1391: 5757:  if (! filedata->is_separate)
     1391: 5758:    init_dwarf_regnames_by_elf_machine_code (header->e_machine);
        -: 5759:
     1391: 5760:  if (do_header)
        -: 5761:    {
        -: 5762:      unsigned i;
        -: 5763:
     1391: 5764:      if (filedata->is_separate)
    #####: 5765:	printf (_("ELF Header in linked file '%s':\n"), filedata->file_name);
        -: 5766:      else
     1391: 5767:	printf (_("ELF Header:\n"));
     1391: 5768:      printf (_("  Magic:   "));
    23647: 5769:      for (i = 0; i < EI_NIDENT; i++)
    22256: 5770:	printf ("%2.2x ", header->e_ident[i]);
     1391: 5771:      printf ("\n");
     1391: 5772:      printf (_("  Class:                             %s\n"),
     1391: 5773:	      get_elf_class (header->e_ident[EI_CLASS]));
     1391: 5774:      printf (_("  Data:                              %s\n"),
     1391: 5775:	      get_data_encoding (header->e_ident[EI_DATA]));
      165: 5776:      printf (_("  Version:                           %d%s\n"),
     1391: 5777:	      header->e_ident[EI_VERSION],
     1391: 5778:	      (header->e_ident[EI_VERSION] == EV_CURRENT
     1226: 5779:	       ? _(" (current)")
      165: 5780:	       : (header->e_ident[EI_VERSION] != EV_NONE
      104: 5781:		  ? _(" <unknown>")
      165: 5782:		  : "")));
     1391: 5783:      printf (_("  OS/ABI:                            %s\n"),
     1391: 5784:	      get_osabi_name (filedata, header->e_ident[EI_OSABI]));
     1391: 5785:      printf (_("  ABI Version:                       %d\n"),
     1391: 5786:	      header->e_ident[EI_ABIVERSION]);
     1391: 5787:      printf (_("  Type:                              %s\n"),
        -: 5788:	      get_file_type (filedata));
     1391: 5789:      printf (_("  Machine:                           %s\n"),
     1391: 5790:	      get_machine_name (header->e_machine));
     1391: 5791:      printf (_("  Version:                           0x%lx\n"),
        -: 5792:	      header->e_version);
        -: 5793:
     1391: 5794:      printf (_("  Entry point address:               "));
     1391: 5795:      print_vma (header->e_entry, PREFIX_HEX);
     1391: 5796:      printf (_("\n  Start of program headers:          "));
     1391: 5797:      print_vma (header->e_phoff, DEC);
     1391: 5798:      printf (_(" (bytes into file)\n  Start of section headers:          "));
     1391: 5799:      print_vma (header->e_shoff, DEC);
     1391: 5800:      printf (_(" (bytes into file)\n"));
        -: 5801:
     1391: 5802:      printf (_("  Flags:                             0x%lx%s\n"),
        -: 5803:	      header->e_flags,
     1391: 5804:	      get_machine_flags (filedata, header->e_flags, header->e_machine));
     1391: 5805:      printf (_("  Size of this header:               %u (bytes)\n"),
        -: 5806:	      header->e_ehsize);
     1391: 5807:      printf (_("  Size of program headers:           %u (bytes)\n"),
        -: 5808:	      header->e_phentsize);
     1391: 5809:      printf (_("  Number of program headers:         %u"),
        -: 5810:	      header->e_phnum);
     1391: 5811:      if (filedata->section_headers != NULL
      966: 5812:	  && header->e_phnum == PN_XNUM
        2: 5813:	  && filedata->section_headers[0].sh_info != 0)
        1: 5814:	printf (" (%u)", filedata->section_headers[0].sh_info);
     1391: 5815:      putc ('\n', stdout);
     1391: 5816:      printf (_("  Size of section headers:           %u (bytes)\n"),
        -: 5817:	      header->e_shentsize);
     1391: 5818:      printf (_("  Number of section headers:         %u"),
        -: 5819:	      header->e_shnum);
     1391: 5820:      if (filedata->section_headers != NULL && header->e_shnum == SHN_UNDEF)
        -: 5821:	{
        8: 5822:	  header->e_shnum = filedata->section_headers[0].sh_size;
        8: 5823:	  printf (" (%u)", header->e_shnum);
        -: 5824:	}
     1391: 5825:      putc ('\n', stdout);
     1391: 5826:      printf (_("  Section header string table index: %u"),
        -: 5827:	      header->e_shstrndx);
     1391: 5828:      if (filedata->section_headers != NULL
      966: 5829:	  && header->e_shstrndx == (SHN_XINDEX & 0xffff))
        -: 5830:	{
        2: 5831:	  header->e_shstrndx = filedata->section_headers[0].sh_link;
        2: 5832:	  printf (" (%u)", header->e_shstrndx);
        -: 5833:	}
     1391: 5834:      if (header->e_shstrndx != SHN_UNDEF
     1258: 5835:	  && header->e_shstrndx >= header->e_shnum)
        -: 5836:	{
      222: 5837:	  header->e_shstrndx = SHN_UNDEF;
      222: 5838:	  printf (_(" <corrupt: out of range>"));
        -: 5839:	}
     1391: 5840:      putc ('\n', stdout);
        -: 5841:    }
        -: 5842:
     1391: 5843:  if (filedata->section_headers != NULL)
        -: 5844:    {
      966: 5845:      if (header->e_phnum == PN_XNUM
        2: 5846:	  && filedata->section_headers[0].sh_info != 0)
        -: 5847:	{
        -: 5848:	  /* Throw away any cached read of PN_XNUM headers.  */
        1: 5849:	  free (filedata->program_headers);
        1: 5850:	  filedata->program_headers = NULL;
        1: 5851:	  header->e_phnum = filedata->section_headers[0].sh_info;
        -: 5852:	}
      966: 5853:      if (header->e_shnum == SHN_UNDEF)
        4: 5854:	header->e_shnum = filedata->section_headers[0].sh_size;
      966: 5855:      if (header->e_shstrndx == (SHN_XINDEX & 0xffff))
    #####: 5856:	header->e_shstrndx = filedata->section_headers[0].sh_link;
      966: 5857:      if (header->e_shstrndx >= header->e_shnum)
        4: 5858:	header->e_shstrndx = SHN_UNDEF;
        -: 5859:    }
        -: 5860:
     1391: 5861:  return true;
        -: 5862:}
        -: 5863:
        -: 5864:/* Read in the program headers from FILEDATA and store them in PHEADERS.
        -: 5865:   Returns TRUE upon success, FALSE otherwise.  Loads 32-bit headers.  */
        -: 5866:
        -: 5867:static bool
     1226: 5868:get_32bit_program_headers (Filedata * filedata, Elf_Internal_Phdr * pheaders)
        -: 5869:{
        -: 5870:  Elf32_External_Phdr * phdrs;
        -: 5871:  Elf32_External_Phdr * external;
        -: 5872:  Elf_Internal_Phdr *   internal;
        -: 5873:  unsigned int i;
     1226: 5874:  unsigned int size = filedata->file_header.e_phentsize;
     1226: 5875:  unsigned int num  = filedata->file_header.e_phnum;
        -: 5876:
        -: 5877:  /* PR binutils/17531: Cope with unexpected section header sizes.  */
     1226: 5878:  if (size == 0 || num == 0)
      140: 5879:    return false;
     1086: 5880:  if (size < sizeof * phdrs)
        -: 5881:    {
       27: 5882:      error (_("The e_phentsize field in the ELF header is less than the size of an ELF program header\n"));
       27: 5883:      return false;
        -: 5884:    }
     1059: 5885:  if (size > sizeof * phdrs)
       80: 5886:    warn (_("The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"));
        -: 5887:
     1059: 5888:  phdrs = (Elf32_External_Phdr *) get_data (NULL, filedata, filedata->file_header.e_phoff,
     1059: 5889:                                            size, num, _("program headers"));
     1059: 5890:  if (phdrs == NULL)
      155: 5891:    return false;
        -: 5892:
      904: 5893:  for (i = 0, internal = pheaders, external = phdrs;
     3033: 5894:       i < filedata->file_header.e_phnum;
     2129: 5895:       i++, internal++, external++)
        -: 5896:    {
     2129: 5897:      internal->p_type   = BYTE_GET (external->p_type);
     2129: 5898:      internal->p_offset = BYTE_GET (external->p_offset);
     2129: 5899:      internal->p_vaddr  = BYTE_GET (external->p_vaddr);
     2129: 5900:      internal->p_paddr  = BYTE_GET (external->p_paddr);
     2129: 5901:      internal->p_filesz = BYTE_GET (external->p_filesz);
     2129: 5902:      internal->p_memsz  = BYTE_GET (external->p_memsz);
     2129: 5903:      internal->p_flags  = BYTE_GET (external->p_flags);
     2129: 5904:      internal->p_align  = BYTE_GET (external->p_align);
        -: 5905:    }
        -: 5906:
      904: 5907:  free (phdrs);
      904: 5908:  return true;
        -: 5909:}
        -: 5910:
        -: 5911:/* Read in the program headers from FILEDATA and store them in PHEADERS.
        -: 5912:   Returns TRUE upon success, FALSE otherwise.  Loads 64-bit headers.  */
        -: 5913:
        -: 5914:static bool
       12: 5915:get_64bit_program_headers (Filedata * filedata, Elf_Internal_Phdr * pheaders)
        -: 5916:{
        -: 5917:  Elf64_External_Phdr * phdrs;
        -: 5918:  Elf64_External_Phdr * external;
        -: 5919:  Elf_Internal_Phdr *   internal;
        -: 5920:  unsigned int i;
       12: 5921:  unsigned int size = filedata->file_header.e_phentsize;
       12: 5922:  unsigned int num  = filedata->file_header.e_phnum;
        -: 5923:
        -: 5924:  /* PR binutils/17531: Cope with unexpected section header sizes.  */
       12: 5925:  if (size == 0 || num == 0)
        8: 5926:    return false;
        4: 5927:  if (size < sizeof * phdrs)
        -: 5928:    {
        2: 5929:      error (_("The e_phentsize field in the ELF header is less than the size of an ELF program header\n"));
        2: 5930:      return false;
        -: 5931:    }
        2: 5932:  if (size > sizeof * phdrs)
        2: 5933:    warn (_("The e_phentsize field in the ELF header is larger than the size of an ELF program header\n"));
        -: 5934:
        2: 5935:  phdrs = (Elf64_External_Phdr *) get_data (NULL, filedata, filedata->file_header.e_phoff,
        2: 5936:                                            size, num, _("program headers"));
        2: 5937:  if (!phdrs)
        2: 5938:    return false;
        -: 5939:
    #####: 5940:  for (i = 0, internal = pheaders, external = phdrs;
    #####: 5941:       i < filedata->file_header.e_phnum;
    #####: 5942:       i++, internal++, external++)
        -: 5943:    {
    #####: 5944:      internal->p_type   = BYTE_GET (external->p_type);
    #####: 5945:      internal->p_flags  = BYTE_GET (external->p_flags);
    #####: 5946:      internal->p_offset = BYTE_GET (external->p_offset);
    #####: 5947:      internal->p_vaddr  = BYTE_GET (external->p_vaddr);
    #####: 5948:      internal->p_paddr  = BYTE_GET (external->p_paddr);
    #####: 5949:      internal->p_filesz = BYTE_GET (external->p_filesz);
    #####: 5950:      internal->p_memsz  = BYTE_GET (external->p_memsz);
    #####: 5951:      internal->p_align  = BYTE_GET (external->p_align);
        -: 5952:    }
        -: 5953:
    #####: 5954:  free (phdrs);
    #####: 5955:  return true;
        -: 5956:}
        -: 5957:
        -: 5958:/* Returns TRUE if the program headers were read into `program_headers'.  */
        -: 5959:
        -: 5960:static bool
     2701: 5961:get_program_headers (Filedata * filedata)
        -: 5962:{
        -: 5963:  Elf_Internal_Phdr * phdrs;
        -: 5964:
        -: 5965:  /* Check cache of prior read.  */
     2701: 5966:  if (filedata->program_headers != NULL)
      931: 5967:    return true;
        -: 5968:
        -: 5969:  /* Be kind to memory checkers by looking for
        -: 5970:     e_phnum values which we know must be invalid.  */
     3540: 5971:  if (filedata->file_header.e_phnum
     1770: 5972:      * (is_32bit_elf ? sizeof (Elf32_External_Phdr) : sizeof (Elf64_External_Phdr))
     1770: 5973:      >= filedata->file_size)
        -: 5974:    {
      532: 5975:      error (_("Too many program headers - %#x - the file is not that big\n"),
        -: 5976:	     filedata->file_header.e_phnum);
      532: 5977:      return false;
        -: 5978:    }
        -: 5979:
     1238: 5980:  phdrs = (Elf_Internal_Phdr *) cmalloc (filedata->file_header.e_phnum,
        -: 5981:					 sizeof (Elf_Internal_Phdr));
     1238: 5982:  if (phdrs == NULL)
        -: 5983:    {
    #####: 5984:      error (_("Out of memory reading %u program headers\n"),
        -: 5985:	     filedata->file_header.e_phnum);
    #####: 5986:      return false;
        -: 5987:    }
        -: 5988:
     1238: 5989:  if (is_32bit_elf
     1238: 5990:      ? get_32bit_program_headers (filedata, phdrs)
       12: 5991:      : get_64bit_program_headers (filedata, phdrs))
        -: 5992:    {
      904: 5993:      filedata->program_headers = phdrs;
      904: 5994:      return true;
        -: 5995:    }
        -: 5996:
      334: 5997:  free (phdrs);
      334: 5998:  return false;
        -: 5999:}
        -: 6000:
        -: 6001:/* Print program header info and locate dynamic section.  */
        -: 6002:
        -: 6003:static void
     1391: 6004:process_program_headers (Filedata * filedata)
        -: 6005:{
        -: 6006:  Elf_Internal_Phdr * segment;
        -: 6007:  unsigned int i;
     1391: 6008:  Elf_Internal_Phdr * previous_load = NULL;
        -: 6009:
     1391: 6010:  if (filedata->file_header.e_phnum == 0)
        -: 6011:    {
        -: 6012:      /* PR binutils/12467.  */
      128: 6013:      if (filedata->file_header.e_phoff != 0)
      118: 6014:	warn (_("possibly corrupt ELF header - it has a non-zero program"
        -: 6015:		" header offset, but no program headers\n"));
       10: 6016:      else if (do_segments)
        -: 6017:	{
       10: 6018:	  if (filedata->is_separate)
    #####: 6019:	    printf (_("\nThere are no program headers in linked file '%s'.\n"),
        -: 6020:		    filedata->file_name);
        -: 6021:	  else
       10: 6022:	    printf (_("\nThere are no program headers in this file.\n"));
        -: 6023:	}
      128: 6024:      goto no_headers;
        -: 6025:    }
        -: 6026:
     1263: 6027:  if (do_segments && !do_header)
        -: 6028:    {
    #####: 6029:      if (filedata->is_separate)
    #####: 6030:	printf ("\nIn linked file '%s' the ELF file type is %s\n",
        -: 6031:		filedata->file_name, get_file_type (filedata));
        -: 6032:      else
    #####: 6033:	printf (_("\nElf file type is %s\n"), get_file_type (filedata));
    #####: 6034:      printf (_("Entry point 0x%s\n"), bfd_vmatoa ("x", filedata->file_header.e_entry));
    #####: 6035:      printf (ngettext ("There is %d program header, starting at offset %s\n",
        -: 6036:			"There are %d program headers, starting at offset %s\n",
    #####: 6037:			filedata->file_header.e_phnum),
        -: 6038:	      filedata->file_header.e_phnum,
        -: 6039:	      bfd_vmatoa ("u", filedata->file_header.e_phoff));
        -: 6040:    }
        -: 6041:
     1263: 6042:  if (! get_program_headers (filedata))
      359: 6043:    goto no_headers;
        -: 6044:
      904: 6045:  if (do_segments)
        -: 6046:    {
      904: 6047:      if (filedata->file_header.e_phnum > 1)
      900: 6048:	printf (_("\nProgram Headers:\n"));
        -: 6049:      else
        4: 6050:	printf (_("\nProgram Headers:\n"));
        -: 6051:
      904: 6052:      if (is_32bit_elf)
      904: 6053:	printf
      904: 6054:	  (_("  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"));
    #####: 6055:      else if (do_wide)
    #####: 6056:	printf
    #####: 6057:	  (_("  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n"));
        -: 6058:      else
        -: 6059:	{
    #####: 6060:	  printf
    #####: 6061:	    (_("  Type           Offset             VirtAddr           PhysAddr\n"));
    #####: 6062:	  printf
    #####: 6063:	    (_("                 FileSiz            MemSiz              Flags  Align\n"));
        -: 6064:	}
        -: 6065:    }
        -: 6066:
      904: 6067:  unsigned long dynamic_addr = 0;
      904: 6068:  bfd_size_type dynamic_size = 0;
      904: 6069:  for (i = 0, segment = filedata->program_headers;
     3033: 6070:       i < filedata->file_header.e_phnum;
     2129: 6071:       i++, segment++)
        -: 6072:    {
     2129: 6073:      if (do_segments)
        -: 6074:	{
     2129: 6075:	  printf ("  %-14.14s ", get_segment_type (filedata, segment->p_type));
        -: 6076:
     2129: 6077:	  if (is_32bit_elf)
        -: 6078:	    {
     2129: 6079:	      printf ("0x%6.6lx ", (unsigned long) segment->p_offset);
     2129: 6080:	      printf ("0x%8.8lx ", (unsigned long) segment->p_vaddr);
     2129: 6081:	      printf ("0x%8.8lx ", (unsigned long) segment->p_paddr);
     2129: 6082:	      printf ("0x%5.5lx ", (unsigned long) segment->p_filesz);
     2129: 6083:	      printf ("0x%5.5lx ", (unsigned long) segment->p_memsz);
     6387: 6084:	      printf ("%c%c%c ",
     2129: 6085:		      (segment->p_flags & PF_R ? 'R' : ' '),
     2129: 6086:		      (segment->p_flags & PF_W ? 'W' : ' '),
     2129: 6087:		      (segment->p_flags & PF_X ? 'E' : ' '));
     2129: 6088:	      printf ("%#lx", (unsigned long) segment->p_align);
        -: 6089:	    }
    #####: 6090:	  else if (do_wide)
        -: 6091:	    {
        -: 6092:	      if ((unsigned long) segment->p_offset == segment->p_offset)
    #####: 6093:		printf ("0x%6.6lx ", (unsigned long) segment->p_offset);
        -: 6094:	      else
        -: 6095:		{
        -: 6096:		  print_vma (segment->p_offset, FULL_HEX);
        -: 6097:		  putchar (' ');
        -: 6098:		}
        -: 6099:
    #####: 6100:	      print_vma (segment->p_vaddr, FULL_HEX);
    #####: 6101:	      putchar (' ');
    #####: 6102:	      print_vma (segment->p_paddr, FULL_HEX);
    #####: 6103:	      putchar (' ');
        -: 6104:
        -: 6105:	      if ((unsigned long) segment->p_filesz == segment->p_filesz)
    #####: 6106:		printf ("0x%6.6lx ", (unsigned long) segment->p_filesz);
        -: 6107:	      else
        -: 6108:		{
        -: 6109:		  print_vma (segment->p_filesz, FULL_HEX);
        -: 6110:		  putchar (' ');
        -: 6111:		}
        -: 6112:
        -: 6113:	      if ((unsigned long) segment->p_memsz == segment->p_memsz)
    #####: 6114:		printf ("0x%6.6lx", (unsigned long) segment->p_memsz);
        -: 6115:	      else
        -: 6116:		{
        -: 6117:		  print_vma (segment->p_memsz, FULL_HEX);
        -: 6118:		}
        -: 6119:
    #####: 6120:	      printf (" %c%c%c ",
    #####: 6121:		      (segment->p_flags & PF_R ? 'R' : ' '),
    #####: 6122:		      (segment->p_flags & PF_W ? 'W' : ' '),
    #####: 6123:		      (segment->p_flags & PF_X ? 'E' : ' '));
        -: 6124:
        -: 6125:	      if ((unsigned long) segment->p_align == segment->p_align)
    #####: 6126:		printf ("%#lx", (unsigned long) segment->p_align);
        -: 6127:	      else
        -: 6128:		{
        -: 6129:		  print_vma (segment->p_align, PREFIX_HEX);
        -: 6130:		}
        -: 6131:	    }
        -: 6132:	  else
        -: 6133:	    {
    #####: 6134:	      print_vma (segment->p_offset, FULL_HEX);
    #####: 6135:	      putchar (' ');
    #####: 6136:	      print_vma (segment->p_vaddr, FULL_HEX);
    #####: 6137:	      putchar (' ');
    #####: 6138:	      print_vma (segment->p_paddr, FULL_HEX);
    #####: 6139:	      printf ("\n                 ");
    #####: 6140:	      print_vma (segment->p_filesz, FULL_HEX);
    #####: 6141:	      putchar (' ');
    #####: 6142:	      print_vma (segment->p_memsz, FULL_HEX);
    #####: 6143:	      printf ("  %c%c%c    ",
    #####: 6144:		      (segment->p_flags & PF_R ? 'R' : ' '),
    #####: 6145:		      (segment->p_flags & PF_W ? 'W' : ' '),
    #####: 6146:		      (segment->p_flags & PF_X ? 'E' : ' '));
    #####: 6147:	      print_vma (segment->p_align, PREFIX_HEX);
        -: 6148:	    }
        -: 6149:
     2129: 6150:	  putc ('\n', stdout);
        -: 6151:	}
        -: 6152:
     2129: 6153:      switch (segment->p_type)
        -: 6154:	{
     1443: 6155:	case PT_LOAD:
        -: 6156:#if 0 /* Do not warn about out of order PT_LOAD segments.  Although officially
        -: 6157:	 required by the ELF standard, several programs, including the Linux
        -: 6158:	 kernel, make use of non-ordered segments.  */
        -: 6159:	  if (previous_load
        -: 6160:	      && previous_load->p_vaddr > segment->p_vaddr)
        -: 6161:	    error (_("LOAD segments must be sorted in order of increasing VirtAddr\n"));
        -: 6162:#endif
     1443: 6163:	  if (segment->p_memsz < segment->p_filesz)
       78: 6164:	    error (_("the segment's file size is larger than its memory size\n"));
     1443: 6165:	  previous_load = segment;
     1443: 6166:	  break;
        -: 6167:
       49: 6168:	case PT_PHDR:
        -: 6169:	  /* PR 20815 - Verify that the program header is loaded into memory.  */
       49: 6170:	  if (i > 0 && previous_load != NULL)
       31: 6171:	    error (_("the PHDR segment must occur before any LOAD segment\n"));
       49: 6172:	  if (filedata->file_header.e_machine != EM_PARISC)
        -: 6173:	    {
        -: 6174:	      unsigned int j;
        -: 6175:
      225: 6176:	      for (j = 1; j < filedata->file_header.e_phnum; j++)
        -: 6177:		{
      179: 6178:		  Elf_Internal_Phdr *load = filedata->program_headers + j;
      179: 6179:		  if (load->p_type == PT_LOAD
       34: 6180:		      && load->p_offset <= segment->p_offset
       30: 6181:		      && (load->p_offset + load->p_filesz
       30: 6182:			  >= segment->p_offset + segment->p_filesz)
        6: 6183:		      && load->p_vaddr <= segment->p_vaddr
        3: 6184:		      && (load->p_vaddr + load->p_filesz
        3: 6185:			  >= segment->p_vaddr + segment->p_filesz))
        2: 6186:		    break;
        -: 6187:		}
       48: 6188:	      if (j == filedata->file_header.e_phnum)
       46: 6189:		error (_("the PHDR segment is not covered by a LOAD segment\n"));
        -: 6190:	    }
       49: 6191:	  break;
        -: 6192:
       43: 6193:	case PT_DYNAMIC:
       43: 6194:	  if (dynamic_addr)
    #####: 6195:	    error (_("more than one dynamic segment\n"));
        -: 6196:
        -: 6197:	  /* By default, assume that the .dynamic section is the first
        -: 6198:	     section in the DYNAMIC segment.  */
       43: 6199:	  dynamic_addr = segment->p_offset;
       43: 6200:	  dynamic_size = segment->p_filesz;
        -: 6201:
        -: 6202:	  /* Try to locate the .dynamic section. If there is
        -: 6203:	     a section header table, we can easily locate it.  */
       43: 6204:	  if (filedata->section_headers != NULL)
        -: 6205:	    {
        -: 6206:	      Elf_Internal_Shdr * sec;
        -: 6207:
       37: 6208:	      sec = find_section (filedata, ".dynamic");
      37*: 6209:	      if (sec == NULL || sec->sh_size == 0)
        -: 6210:		{
        -: 6211:		  /* A corresponding .dynamic section is expected, but on
        -: 6212:		     IA-64/OpenVMS it is OK for it to be missing.  */
       37: 6213:		  if (!is_ia64_vms (filedata))
       37: 6214:		    error (_("no .dynamic section in the dynamic segment\n"));
       37: 6215:		  break;
        -: 6216:		}
        -: 6217:
    #####: 6218:	      if (sec->sh_type == SHT_NOBITS)
        -: 6219:		{
    #####: 6220:		  dynamic_addr = 0;
    #####: 6221:		  dynamic_size = 0;
    #####: 6222:		  break;
        -: 6223:		}
        -: 6224:
    #####: 6225:	      dynamic_addr = sec->sh_offset;
    #####: 6226:	      dynamic_size = sec->sh_size;
        -: 6227:
        -: 6228:	      /* The PT_DYNAMIC segment, which is used by the run-time
        -: 6229:		 loader,  should exactly match the .dynamic section.  */
    #####: 6230:	      if (do_checks
    #####: 6231:		  && (dynamic_addr != segment->p_offset
    #####: 6232:		      || dynamic_size != segment->p_filesz))
    #####: 6233:		warn (_("\
        -: 6234:the .dynamic section is not the same as the dynamic segment\n"));
        -: 6235:	    }
        -: 6236:
        -: 6237:	  /* PR binutils/17512: Avoid corrupt dynamic section info in the
        -: 6238:	     segment.  Check this after matching against the section headers
        -: 6239:	     so we don't warn on debuginfo file (which have NOBITS .dynamic
        -: 6240:	     sections).  */
        6: 6241:	  if (dynamic_addr > filedata->file_size
        5: 6242:	      || (dynamic_size > filedata->file_size - dynamic_addr))
        -: 6243:	    {
        2: 6244:	      error (_("the dynamic segment offset + size exceeds the size of the file\n"));
        2: 6245:	      dynamic_addr = 0;
        2: 6246:	      dynamic_size = 0;
        -: 6247:	    }
        6: 6248:	  break;
        -: 6249:
        7: 6250:	case PT_INTERP:
        7: 6251:	  if (segment->p_offset >= filedata->file_size
        6: 6252:	      || segment->p_filesz > filedata->file_size - segment->p_offset
        5: 6253:	      || segment->p_filesz - 1 >= (size_t) -2
        4: 6254:	      || fseek (filedata->handle,
        4: 6255:			filedata->archive_file_offset + (long) segment->p_offset,
        -: 6256:			SEEK_SET))
        3: 6257:	    error (_("Unable to find program interpreter name\n"));
        -: 6258:	  else
        -: 6259:	    {
        4: 6260:	      size_t len = segment->p_filesz;
        4: 6261:	      free (filedata->program_interpreter);
        4: 6262:	      filedata->program_interpreter = xmalloc (len + 1);
        4: 6263:	      len = fread (filedata->program_interpreter, 1, len,
        -: 6264:			   filedata->handle);
        4: 6265:	      filedata->program_interpreter[len] = 0;
        -: 6266:
        4: 6267:	      if (do_segments)
        4: 6268:		printf (_("      [Requesting program interpreter: %s]\n"),
        -: 6269:		    filedata->program_interpreter);
        -: 6270:	    }
        7: 6271:	  break;
        -: 6272:	}
     2129: 6273:    }
        -: 6274:
      904: 6275:  if (do_segments
      904: 6276:      && filedata->section_headers != NULL
      809: 6277:      && filedata->string_table != NULL)
        -: 6278:    {
      629: 6279:      printf (_("\n Section to Segment mapping:\n"));
      629: 6280:      printf (_("  Segment Sections...\n"));
        -: 6281:
     2073: 6282:      for (i = 0; i < filedata->file_header.e_phnum; i++)
        -: 6283:	{
        -: 6284:	  unsigned int j;
        -: 6285:	  Elf_Internal_Shdr * section;
        -: 6286:
     1444: 6287:	  segment = filedata->program_headers + i;
     1444: 6288:	  section = filedata->section_headers + 1;
        -: 6289:
     1444: 6290:	  printf ("   %2.2d     ", i);
        -: 6291:
     5776: 6292:	  for (j = 1; j < filedata->file_header.e_shnum; j++, section++)
        -: 6293:	    {
     4332: 6294:	      if (!ELF_TBSS_SPECIAL (section, segment)
    4330*: 6295:		  && ELF_SECTION_IN_SEGMENT_STRICT (section, segment))
     1090: 6296:		printf ("%s ", printable_section_name (filedata, section));
        -: 6297:	    }
        -: 6298:
     1444: 6299:	  putc ('\n',stdout);
        -: 6300:	}
        -: 6301:    }
        -: 6302:
      904: 6303:  filedata->dynamic_addr = dynamic_addr;
      904: 6304:  filedata->dynamic_size = dynamic_size ? dynamic_size : 1;
      904: 6305:  return;
        -: 6306:
      487: 6307: no_headers:
      487: 6308:  filedata->dynamic_addr = 0;
      487: 6309:  filedata->dynamic_size = 1;
        -: 6310:}
        -: 6311:
        -: 6312:
        -: 6313:/* Find the file offset corresponding to VMA by using the program headers.  */
        -: 6314:
        -: 6315:static long
    #####: 6316:offset_from_vma (Filedata * filedata, bfd_vma vma, bfd_size_type size)
        -: 6317:{
        -: 6318:  Elf_Internal_Phdr * seg;
        -: 6319:
    #####: 6320:  if (! get_program_headers (filedata))
        -: 6321:    {
    #####: 6322:      warn (_("Cannot interpret virtual addresses without program headers.\n"));
    #####: 6323:      return (long) vma;
        -: 6324:    }
        -: 6325:
    #####: 6326:  for (seg = filedata->program_headers;
    #####: 6327:       seg < filedata->program_headers + filedata->file_header.e_phnum;
    #####: 6328:       ++seg)
        -: 6329:    {
    #####: 6330:      if (seg->p_type != PT_LOAD)
    #####: 6331:	continue;
        -: 6332:
    #####: 6333:      if (vma >= (seg->p_vaddr & -seg->p_align)
    #####: 6334:	  && vma + size <= seg->p_vaddr + seg->p_filesz)
    #####: 6335:	return vma - seg->p_vaddr + seg->p_offset;
        -: 6336:    }
        -: 6337:
    #####: 6338:  warn (_("Virtual address 0x%lx not located in any PT_LOAD segment.\n"),
        -: 6339:	(unsigned long) vma);
    #####: 6340:  return (long) vma;
        -: 6341:}
        -: 6342:
        -: 6343:
        -: 6344:/* Allocate memory and load the sections headers into FILEDATA->filedata->section_headers.
        -: 6345:   If PROBE is true, this is just a probe and we do not generate any error
        -: 6346:   messages if the load fails.  */
        -: 6347:
        -: 6348:static bool
     2647: 6349:get_32bit_section_headers (Filedata * filedata, bool probe)
        -: 6350:{
        -: 6351:  Elf32_External_Shdr * shdrs;
        -: 6352:  Elf_Internal_Shdr *   internal;
        -: 6353:  unsigned int          i;
     2647: 6354:  unsigned int          size = filedata->file_header.e_shentsize;
     2647: 6355:  unsigned int          num = probe ? 1 : filedata->file_header.e_shnum;
        -: 6356:
        -: 6357:  /* PR binutils/17531: Cope with unexpected section header sizes.  */
     2647: 6358:  if (size == 0 || num == 0)
      199: 6359:    return false;
     2448: 6360:  if (size < sizeof * shdrs)
        -: 6361:    {
       79: 6362:      if (! probe)
       31: 6363:	error (_("The e_shentsize field in the ELF header is less than the size of an ELF section header\n"));
       79: 6364:      return false;
        -: 6365:    }
     2369: 6366:  if (!probe && size > sizeof * shdrs)
      185: 6367:    warn (_("The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"));
        -: 6368:
     3523: 6369:  shdrs = (Elf32_External_Shdr *) get_data (NULL, filedata, filedata->file_header.e_shoff,
        -: 6370:                                            size, num,
     1154: 6371:					    probe ? NULL : _("section headers"));
     2369: 6372:  if (shdrs == NULL)
      519: 6373:    return false;
        -: 6374:
     1850: 6375:  filedata->section_headers = (Elf_Internal_Shdr *)
     1850: 6376:    cmalloc (num, sizeof (Elf_Internal_Shdr));
     1850: 6377:  if (filedata->section_headers == NULL)
        -: 6378:    {
    #####: 6379:      if (!probe)
    #####: 6380:	error (_("Out of memory reading %u section headers\n"), num);
    #####: 6381:      free (shdrs);
    #####: 6382:      return false;
        -: 6383:    }
        -: 6384:
     6325: 6385:  for (i = 0, internal = filedata->section_headers;
        -: 6386:       i < num;
     4475: 6387:       i++, internal++)
        -: 6388:    {
     4475: 6389:      internal->sh_name      = BYTE_GET (shdrs[i].sh_name);
     4475: 6390:      internal->sh_type      = BYTE_GET (shdrs[i].sh_type);
     4475: 6391:      internal->sh_flags     = BYTE_GET (shdrs[i].sh_flags);
     4475: 6392:      internal->sh_addr      = BYTE_GET (shdrs[i].sh_addr);
     4475: 6393:      internal->sh_offset    = BYTE_GET (shdrs[i].sh_offset);
     4475: 6394:      internal->sh_size      = BYTE_GET (shdrs[i].sh_size);
     4475: 6395:      internal->sh_link      = BYTE_GET (shdrs[i].sh_link);
     4475: 6396:      internal->sh_info      = BYTE_GET (shdrs[i].sh_info);
     4475: 6397:      internal->sh_addralign = BYTE_GET (shdrs[i].sh_addralign);
     4475: 6398:      internal->sh_entsize   = BYTE_GET (shdrs[i].sh_entsize);
     4475: 6399:      if (!probe && internal->sh_link > num)
      743: 6400:	warn (_("Section %u has an out of range sh_link value of %u\n"), i, internal->sh_link);
     4475: 6401:      if (!probe && internal->sh_flags & SHF_INFO_LINK && internal->sh_info > num)
       88: 6402:	warn (_("Section %u has an out of range sh_info value of %u\n"), i, internal->sh_info);
        -: 6403:    }
        -: 6404:
     1850: 6405:  free (shdrs);
     1850: 6406:  return true;
        -: 6407:}
        -: 6408:
        -: 6409:/* Like get_32bit_section_headers, except that it fetches 64-bit headers.  */
        -: 6410:
        -: 6411:static bool
       20: 6412:get_64bit_section_headers (Filedata * filedata, bool probe)
        -: 6413:{
        -: 6414:  Elf64_External_Shdr *  shdrs;
        -: 6415:  Elf_Internal_Shdr *    internal;
        -: 6416:  unsigned int           i;
       20: 6417:  unsigned int           size = filedata->file_header.e_shentsize;
       20: 6418:  unsigned int           num = probe ? 1 : filedata->file_header.e_shnum;
        -: 6419:
        -: 6420:  /* PR binutils/17531: Cope with unexpected section header sizes.  */
       20: 6421:  if (size == 0 || num == 0)
       10: 6422:    return false;
        -: 6423:
       10: 6424:  if (size < sizeof * shdrs)
        -: 6425:    {
        2: 6426:      if (! probe)
        1: 6427:	error (_("The e_shentsize field in the ELF header is less than the size of an ELF section header\n"));
        2: 6428:      return false;
        -: 6429:    }
        -: 6430:
        8: 6431:  if (! probe && size > sizeof * shdrs)
        2: 6432:    warn (_("The e_shentsize field in the ELF header is larger than the size of an ELF section header\n"));
        -: 6433:
       11: 6434:  shdrs = (Elf64_External_Shdr *) get_data (NULL, filedata,
        -: 6435:					    filedata->file_header.e_shoff,
        -: 6436:                                            size, num,
        3: 6437:					    probe ? NULL : _("section headers"));
        8: 6438:  if (shdrs == NULL)
        7: 6439:    return false;
        -: 6440:
        1: 6441:  filedata->section_headers = (Elf_Internal_Shdr *)
        1: 6442:    cmalloc (num, sizeof (Elf_Internal_Shdr));
        1: 6443:  if (filedata->section_headers == NULL)
        -: 6444:    {
    #####: 6445:      if (! probe)
    #####: 6446:	error (_("Out of memory reading %u section headers\n"), num);
    #####: 6447:      free (shdrs);
    #####: 6448:      return false;
        -: 6449:    }
        -: 6450:
        2: 6451:  for (i = 0, internal = filedata->section_headers;
        -: 6452:       i < num;
        1: 6453:       i++, internal++)
        -: 6454:    {
        1: 6455:      internal->sh_name      = BYTE_GET (shdrs[i].sh_name);
        1: 6456:      internal->sh_type      = BYTE_GET (shdrs[i].sh_type);
        1: 6457:      internal->sh_flags     = BYTE_GET (shdrs[i].sh_flags);
        1: 6458:      internal->sh_addr      = BYTE_GET (shdrs[i].sh_addr);
        1: 6459:      internal->sh_size      = BYTE_GET (shdrs[i].sh_size);
        1: 6460:      internal->sh_entsize   = BYTE_GET (shdrs[i].sh_entsize);
        1: 6461:      internal->sh_link      = BYTE_GET (shdrs[i].sh_link);
        1: 6462:      internal->sh_info      = BYTE_GET (shdrs[i].sh_info);
        1: 6463:      internal->sh_offset    = BYTE_GET (shdrs[i].sh_offset);
        1: 6464:      internal->sh_addralign = BYTE_GET (shdrs[i].sh_addralign);
       1*: 6465:      if (!probe && internal->sh_link > num)
    #####: 6466:	warn (_("Section %u has an out of range sh_link value of %u\n"), i, internal->sh_link);
       1*: 6467:      if (!probe && internal->sh_flags & SHF_INFO_LINK && internal->sh_info > num)
    #####: 6468:	warn (_("Section %u has an out of range sh_info value of %u\n"), i, internal->sh_info);
        -: 6469:    }
        -: 6470:
        1: 6471:  free (shdrs);
        1: 6472:  return true;
        -: 6473:}
        -: 6474:
        -: 6475:static bool
     2667: 6476:get_section_headers (Filedata *filedata, bool probe)
        -: 6477:{
     2667: 6478:  if (filedata->section_headers != NULL)
    #####: 6479:    return true;
        -: 6480:
     2667: 6481:  if (is_32bit_elf)
     2647: 6482:    return get_32bit_section_headers (filedata, probe);
        -: 6483:  else
       20: 6484:    return get_64bit_section_headers (filedata, probe);
        -: 6485:}
        -: 6486:
        -: 6487:static Elf_Internal_Sym *
      109: 6488:get_32bit_elf_symbols (Filedata *           filedata,
        -: 6489:		       Elf_Internal_Shdr *  section,
        -: 6490:		       unsigned long *      num_syms_return)
        -: 6491:{
      109: 6492:  unsigned long number = 0;
      109: 6493:  Elf32_External_Sym * esyms = NULL;
      109: 6494:  Elf_External_Sym_Shndx * shndx = NULL;
      109: 6495:  Elf_Internal_Sym * isyms = NULL;
        -: 6496:  Elf_Internal_Sym * psym;
        -: 6497:  unsigned int j;
        -: 6498:  elf_section_list * entry;
        -: 6499:
      109: 6500:  if (section->sh_size == 0)
        -: 6501:    {
       12: 6502:      if (num_syms_return != NULL)
       12: 6503:	* num_syms_return = 0;
       12: 6504:      return NULL;
        -: 6505:    }
        -: 6506:
        -: 6507:  /* Run some sanity checks first.  */
       97: 6508:  if (section->sh_entsize == 0 || section->sh_entsize > section->sh_size)
        -: 6509:    {
        9: 6510:      error (_("Section %s has an invalid sh_entsize of 0x%lx\n"),
        -: 6511:	     printable_section_name (filedata, section),
        9: 6512:	     (unsigned long) section->sh_entsize);
        9: 6513:      goto exit_point;
        -: 6514:    }
        -: 6515:
       88: 6516:  if (section->sh_size > filedata->file_size)
        -: 6517:    {
        6: 6518:      error (_("Section %s has an invalid sh_size of 0x%lx\n"),
        -: 6519:	     printable_section_name (filedata, section),
        6: 6520:	     (unsigned long) section->sh_size);
        6: 6521:      goto exit_point;
        -: 6522:    }
        -: 6523:
       82: 6524:  number = section->sh_size / section->sh_entsize;
        -: 6525:
       82: 6526:  if (number * sizeof (Elf32_External_Sym) > section->sh_size + 1)
        -: 6527:    {
    #####: 6528:      error (_("Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n"),
    #####: 6529:	     (unsigned long) section->sh_size,
        -: 6530:	     printable_section_name (filedata, section),
    #####: 6531:	     (unsigned long) section->sh_entsize);
    #####: 6532:      goto exit_point;
        -: 6533:    }
        -: 6534:
       82: 6535:  esyms = (Elf32_External_Sym *) get_data (NULL, filedata, section->sh_offset, 1,
       82: 6536:                                           section->sh_size, _("symbols"));
       82: 6537:  if (esyms == NULL)
       48: 6538:    goto exit_point;
        -: 6539:
       34: 6540:  shndx = NULL;
      34*: 6541:  for (entry = filedata->symtab_shndx_list; entry != NULL; entry = entry->next)
        -: 6542:    {
    #####: 6543:      if (entry->hdr->sh_link != (unsigned long) (section - filedata->section_headers))
    #####: 6544:	continue;
        -: 6545:
    #####: 6546:      if (shndx != NULL)
        -: 6547:	{
    #####: 6548:	  error (_("Multiple symbol table index sections associated with the same symbol section\n"));
    #####: 6549:	  free (shndx);
        -: 6550:	}
        -: 6551:
    #####: 6552:      shndx = (Elf_External_Sym_Shndx *) get_data (NULL, filedata,
    #####: 6553:						   entry->hdr->sh_offset,
    #####: 6554:						   1, entry->hdr->sh_size,
    #####: 6555:						   _("symbol table section indices"));
    #####: 6556:      if (shndx == NULL)
    #####: 6557:	goto exit_point;
        -: 6558:
        -: 6559:      /* PR17531: file: heap-buffer-overflow */
    #####: 6560:      if (entry->hdr->sh_size / sizeof (Elf_External_Sym_Shndx) < number)
        -: 6561:	{
    #####: 6562:	  error (_("Index section %s has an sh_size of 0x%lx - expected 0x%lx\n"),
    #####: 6563:		 printable_section_name (filedata, entry->hdr),
    #####: 6564:		 (unsigned long) entry->hdr->sh_size,
    #####: 6565:		 (unsigned long) section->sh_size);
    #####: 6566:	  goto exit_point;
        -: 6567:	}
        -: 6568:    }
        -: 6569:
       34: 6570:  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));
        -: 6571:
       34: 6572:  if (isyms == NULL)
        -: 6573:    {
    #####: 6574:      error (_("Out of memory reading %lu symbols\n"),
        -: 6575:	     (unsigned long) number);
    #####: 6576:      goto exit_point;
        -: 6577:    }
        -: 6578:
      243: 6579:  for (j = 0, psym = isyms; j < number; j++, psym++)
        -: 6580:    {
      209: 6581:      psym->st_name  = BYTE_GET (esyms[j].st_name);
      209: 6582:      psym->st_value = BYTE_GET (esyms[j].st_value);
      209: 6583:      psym->st_size  = BYTE_GET (esyms[j].st_size);
      209: 6584:      psym->st_shndx = BYTE_GET (esyms[j].st_shndx);
     209*: 6585:      if (psym->st_shndx == (SHN_XINDEX & 0xffff) && shndx != NULL)
        -: 6586:	psym->st_shndx
    #####: 6587:	  = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
      209: 6588:      else if (psym->st_shndx >= (SHN_LORESERVE & 0xffff))
    #####: 6589:	psym->st_shndx += SHN_LORESERVE - (SHN_LORESERVE & 0xffff);
      209: 6590:      psym->st_info  = BYTE_GET (esyms[j].st_info);
      209: 6591:      psym->st_other = BYTE_GET (esyms[j].st_other);
        -: 6592:    }
        -: 6593:
       34: 6594: exit_point:
       97: 6595:  free (shndx);
       97: 6596:  free (esyms);
        -: 6597:
       97: 6598:  if (num_syms_return != NULL)
       97: 6599:    * num_syms_return = isyms == NULL ? 0 : number;
        -: 6600:
       97: 6601:  return isyms;
        -: 6602:}
        -: 6603:
        -: 6604:static Elf_Internal_Sym *
    #####: 6605:get_64bit_elf_symbols (Filedata *           filedata,
        -: 6606:		       Elf_Internal_Shdr *  section,
        -: 6607:		       unsigned long *      num_syms_return)
        -: 6608:{
    #####: 6609:  unsigned long number = 0;
    #####: 6610:  Elf64_External_Sym * esyms = NULL;
    #####: 6611:  Elf_External_Sym_Shndx * shndx = NULL;
    #####: 6612:  Elf_Internal_Sym * isyms = NULL;
        -: 6613:  Elf_Internal_Sym * psym;
        -: 6614:  unsigned int j;
        -: 6615:  elf_section_list * entry;
        -: 6616:
    #####: 6617:  if (section->sh_size == 0)
        -: 6618:    {
    #####: 6619:      if (num_syms_return != NULL)
    #####: 6620:	* num_syms_return = 0;
    #####: 6621:      return NULL;
        -: 6622:    }
        -: 6623:
        -: 6624:  /* Run some sanity checks first.  */
    #####: 6625:  if (section->sh_entsize == 0 || section->sh_entsize > section->sh_size)
        -: 6626:    {
    #####: 6627:      error (_("Section %s has an invalid sh_entsize of 0x%lx\n"),
        -: 6628:	     printable_section_name (filedata, section),
    #####: 6629:	     (unsigned long) section->sh_entsize);
    #####: 6630:      goto exit_point;
        -: 6631:    }
        -: 6632:
    #####: 6633:  if (section->sh_size > filedata->file_size)
        -: 6634:    {
    #####: 6635:      error (_("Section %s has an invalid sh_size of 0x%lx\n"),
        -: 6636:	     printable_section_name (filedata, section),
    #####: 6637:	     (unsigned long) section->sh_size);
    #####: 6638:      goto exit_point;
        -: 6639:    }
        -: 6640:
    #####: 6641:  number = section->sh_size / section->sh_entsize;
        -: 6642:
    #####: 6643:  if (number * sizeof (Elf64_External_Sym) > section->sh_size + 1)
        -: 6644:    {
    #####: 6645:      error (_("Size (0x%lx) of section %s is not a multiple of its sh_entsize (0x%lx)\n"),
    #####: 6646:	     (unsigned long) section->sh_size,
        -: 6647:	     printable_section_name (filedata, section),
    #####: 6648:	     (unsigned long) section->sh_entsize);
    #####: 6649:      goto exit_point;
        -: 6650:    }
        -: 6651:
    #####: 6652:  esyms = (Elf64_External_Sym *) get_data (NULL, filedata, section->sh_offset, 1,
    #####: 6653:                                           section->sh_size, _("symbols"));
    #####: 6654:  if (!esyms)
    #####: 6655:    goto exit_point;
        -: 6656:
    #####: 6657:  shndx = NULL;
    #####: 6658:  for (entry = filedata->symtab_shndx_list; entry != NULL; entry = entry->next)
        -: 6659:    {
    #####: 6660:      if (entry->hdr->sh_link != (unsigned long) (section - filedata->section_headers))
    #####: 6661:	continue;
        -: 6662:
    #####: 6663:      if (shndx != NULL)
        -: 6664:	{
    #####: 6665:	  error (_("Multiple symbol table index sections associated with the same symbol section\n"));
    #####: 6666:	  free (shndx);
        -: 6667:	}
        -: 6668:
    #####: 6669:      shndx = (Elf_External_Sym_Shndx *) get_data (NULL, filedata,
    #####: 6670:						   entry->hdr->sh_offset,
    #####: 6671:						   1, entry->hdr->sh_size,
    #####: 6672:						   _("symbol table section indices"));
    #####: 6673:      if (shndx == NULL)
    #####: 6674:	goto exit_point;
        -: 6675:
        -: 6676:      /* PR17531: file: heap-buffer-overflow */
    #####: 6677:      if (entry->hdr->sh_size / sizeof (Elf_External_Sym_Shndx) < number)
        -: 6678:	{
    #####: 6679:	  error (_("Index section %s has an sh_size of 0x%lx - expected 0x%lx\n"),
    #####: 6680:		 printable_section_name (filedata, entry->hdr),
    #####: 6681:		 (unsigned long) entry->hdr->sh_size,
    #####: 6682:		 (unsigned long) section->sh_size);
    #####: 6683:	  goto exit_point;
        -: 6684:	}
        -: 6685:    }
        -: 6686:
    #####: 6687:  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));
        -: 6688:
    #####: 6689:  if (isyms == NULL)
        -: 6690:    {
    #####: 6691:      error (_("Out of memory reading %lu symbols\n"),
        -: 6692:	     (unsigned long) number);
    #####: 6693:      goto exit_point;
        -: 6694:    }
        -: 6695:
    #####: 6696:  for (j = 0, psym = isyms; j < number; j++, psym++)
        -: 6697:    {
    #####: 6698:      psym->st_name  = BYTE_GET (esyms[j].st_name);
    #####: 6699:      psym->st_info  = BYTE_GET (esyms[j].st_info);
    #####: 6700:      psym->st_other = BYTE_GET (esyms[j].st_other);
    #####: 6701:      psym->st_shndx = BYTE_GET (esyms[j].st_shndx);
        -: 6702:
    #####: 6703:      if (psym->st_shndx == (SHN_XINDEX & 0xffff) && shndx != NULL)
        -: 6704:	psym->st_shndx
    #####: 6705:	  = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
    #####: 6706:      else if (psym->st_shndx >= (SHN_LORESERVE & 0xffff))
    #####: 6707:	psym->st_shndx += SHN_LORESERVE - (SHN_LORESERVE & 0xffff);
        -: 6708:
    #####: 6709:      psym->st_value = BYTE_GET (esyms[j].st_value);
    #####: 6710:      psym->st_size  = BYTE_GET (esyms[j].st_size);
        -: 6711:    }
        -: 6712:
    #####: 6713: exit_point:
    #####: 6714:  free (shndx);
    #####: 6715:  free (esyms);
        -: 6716:
    #####: 6717:  if (num_syms_return != NULL)
    #####: 6718:    * num_syms_return = isyms == NULL ? 0 : number;
        -: 6719:
    #####: 6720:  return isyms;
        -: 6721:}
        -: 6722:
        -: 6723:static Elf_Internal_Sym *
      109: 6724:get_elf_symbols (Filedata *filedata,
        -: 6725:		 Elf_Internal_Shdr *section,
        -: 6726:		 unsigned long *num_syms_return)
        -: 6727:{
      109: 6728:  if (is_32bit_elf)
      109: 6729:    return get_32bit_elf_symbols (filedata, section, num_syms_return);
        -: 6730:  else
    #####: 6731:    return get_64bit_elf_symbols (filedata, section, num_syms_return);
        -: 6732:}
        -: 6733:
        -: 6734:static const char *
     3507: 6735:get_elf_section_flags (Filedata * filedata, bfd_vma sh_flags)
        -: 6736:{
        -: 6737:  static char buff[1024];
     3507: 6738:  char * p = buff;
    3507*: 6739:  unsigned int field_size = is_32bit_elf ? 8 : 16;
        -: 6740:  signed int sindex;
     3507: 6741:  unsigned int size = sizeof (buff) - (field_size + 4 + 1);
     3507: 6742:  bfd_vma os_flags = 0;
     3507: 6743:  bfd_vma proc_flags = 0;
     3507: 6744:  bfd_vma unknown_flags = 0;
        -: 6745:  static const struct
        -: 6746:    {
        -: 6747:      const char * str;
        -: 6748:      unsigned int len;
        -: 6749:    }
        -: 6750:  flags [] =
        -: 6751:    {
        -: 6752:      /*  0 */ { STRING_COMMA_LEN ("WRITE") },
        -: 6753:      /*  1 */ { STRING_COMMA_LEN ("ALLOC") },
        -: 6754:      /*  2 */ { STRING_COMMA_LEN ("EXEC") },
        -: 6755:      /*  3 */ { STRING_COMMA_LEN ("MERGE") },
        -: 6756:      /*  4 */ { STRING_COMMA_LEN ("STRINGS") },
        -: 6757:      /*  5 */ { STRING_COMMA_LEN ("INFO LINK") },
        -: 6758:      /*  6 */ { STRING_COMMA_LEN ("LINK ORDER") },
        -: 6759:      /*  7 */ { STRING_COMMA_LEN ("OS NONCONF") },
        -: 6760:      /*  8 */ { STRING_COMMA_LEN ("GROUP") },
        -: 6761:      /*  9 */ { STRING_COMMA_LEN ("TLS") },
        -: 6762:      /* IA-64 specific.  */
        -: 6763:      /* 10 */ { STRING_COMMA_LEN ("SHORT") },
        -: 6764:      /* 11 */ { STRING_COMMA_LEN ("NORECOV") },
        -: 6765:      /* IA-64 OpenVMS specific.  */
        -: 6766:      /* 12 */ { STRING_COMMA_LEN ("VMS_GLOBAL") },
        -: 6767:      /* 13 */ { STRING_COMMA_LEN ("VMS_OVERLAID") },
        -: 6768:      /* 14 */ { STRING_COMMA_LEN ("VMS_SHARED") },
        -: 6769:      /* 15 */ { STRING_COMMA_LEN ("VMS_VECTOR") },
        -: 6770:      /* 16 */ { STRING_COMMA_LEN ("VMS_ALLOC_64BIT") },
        -: 6771:      /* 17 */ { STRING_COMMA_LEN ("VMS_PROTECTED") },
        -: 6772:      /* Generic.  */
        -: 6773:      /* 18 */ { STRING_COMMA_LEN ("EXCLUDE") },
        -: 6774:      /* SPARC specific.  */
        -: 6775:      /* 19 */ { STRING_COMMA_LEN ("ORDERED") },
        -: 6776:      /* 20 */ { STRING_COMMA_LEN ("COMPRESSED") },
        -: 6777:      /* ARM specific.  */
        -: 6778:      /* 21 */ { STRING_COMMA_LEN ("ENTRYSECT") },
        -: 6779:      /* 22 */ { STRING_COMMA_LEN ("ARM_PURECODE") },
        -: 6780:      /* 23 */ { STRING_COMMA_LEN ("COMDEF") },
        -: 6781:      /* GNU specific.  */
        -: 6782:      /* 24 */ { STRING_COMMA_LEN ("GNU_MBIND") },
        -: 6783:      /* VLE specific.  */
        -: 6784:      /* 25 */ { STRING_COMMA_LEN ("VLE") },
        -: 6785:      /* GNU specific.  */
        -: 6786:      /* 26 */ { STRING_COMMA_LEN ("GNU_RETAIN") },
        -: 6787:    };
        -: 6788:
     3507: 6789:  if (do_section_details)
        -: 6790:    {
    #####: 6791:      sprintf (buff, "[%*.*lx]: ",
        -: 6792:	       field_size, field_size, (unsigned long) sh_flags);
    #####: 6793:      p += field_size + 4;
        -: 6794:    }
        -: 6795:
     9771: 6796:  while (sh_flags)
        -: 6797:    {
        -: 6798:      bfd_vma flag;
        -: 6799:
     6264: 6800:      flag = sh_flags & - sh_flags;
     6264: 6801:      sh_flags &= ~ flag;
        -: 6802:
     6264: 6803:      if (do_section_details)
        -: 6804:	{
    #####: 6805:	  switch (flag)
        -: 6806:	    {
    #####: 6807:	    case SHF_WRITE:		sindex = 0; break;
    #####: 6808:	    case SHF_ALLOC:		sindex = 1; break;
    #####: 6809:	    case SHF_EXECINSTR:		sindex = 2; break;
    #####: 6810:	    case SHF_MERGE:		sindex = 3; break;
    #####: 6811:	    case SHF_STRINGS:		sindex = 4; break;
    #####: 6812:	    case SHF_INFO_LINK:		sindex = 5; break;
    #####: 6813:	    case SHF_LINK_ORDER:	sindex = 6; break;
    #####: 6814:	    case SHF_OS_NONCONFORMING:	sindex = 7; break;
    #####: 6815:	    case SHF_GROUP:		sindex = 8; break;
    #####: 6816:	    case SHF_TLS:		sindex = 9; break;
    #####: 6817:	    case SHF_EXCLUDE:		sindex = 18; break;
    #####: 6818:	    case SHF_COMPRESSED:	sindex = 20; break;
        -: 6819:
    #####: 6820:	    default:
    #####: 6821:	      sindex = -1;
    #####: 6822:	      switch (filedata->file_header.e_machine)
        -: 6823:		{
    #####: 6824:		case EM_IA_64:
    #####: 6825:		  if (flag == SHF_IA_64_SHORT)
    #####: 6826:		    sindex = 10;
    #####: 6827:		  else if (flag == SHF_IA_64_NORECOV)
    #####: 6828:		    sindex = 11;
        -: 6829:#ifdef BFD64
    #####: 6830:		  else if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_OPENVMS)
        -: 6831:		    switch (flag)
        -: 6832:		      {
    #####: 6833:		      case SHF_IA_64_VMS_GLOBAL:      sindex = 12; break;
    #####: 6834:		      case SHF_IA_64_VMS_OVERLAID:    sindex = 13; break;
    #####: 6835:		      case SHF_IA_64_VMS_SHARED:      sindex = 14; break;
    #####: 6836:		      case SHF_IA_64_VMS_VECTOR:      sindex = 15; break;
    #####: 6837:		      case SHF_IA_64_VMS_ALLOC_64BIT: sindex = 16; break;
    #####: 6838:		      case SHF_IA_64_VMS_PROTECTED:   sindex = 17; break;
    #####: 6839:		      default:                        break;
        -: 6840:		      }
        -: 6841:#endif
    #####: 6842:		  break;
        -: 6843:
    #####: 6844:		case EM_386:
        -: 6845:		case EM_IAMCU:
        -: 6846:		case EM_X86_64:
        -: 6847:		case EM_L1OM:
        -: 6848:		case EM_K1OM:
        -: 6849:		case EM_OLD_SPARCV9:
        -: 6850:		case EM_SPARC32PLUS:
        -: 6851:		case EM_SPARCV9:
        -: 6852:		case EM_SPARC:
    #####: 6853:		  if (flag == SHF_ORDERED)
    #####: 6854:		    sindex = 19;
    #####: 6855:		  break;
        -: 6856:
    #####: 6857:		case EM_ARM:
        -: 6858:		  switch (flag)
        -: 6859:		    {
    #####: 6860:		    case SHF_ENTRYSECT: sindex = 21; break;
    #####: 6861:		    case SHF_ARM_PURECODE: sindex = 22; break;
    #####: 6862:		    case SHF_COMDEF: sindex = 23; break;
    #####: 6863:		    default: break;
        -: 6864:		    }
    #####: 6865:		  break;
    #####: 6866:		case EM_PPC:
    #####: 6867:		  if (flag == SHF_PPC_VLE)
    #####: 6868:		    sindex = 25;
    #####: 6869:		  break;
    #####: 6870:		default:
    #####: 6871:		  break;
        -: 6872:		}
        -: 6873:
    #####: 6874:	      switch (filedata->file_header.e_ident[EI_OSABI])
        -: 6875:		{
    #####: 6876:		case ELFOSABI_GNU:
        -: 6877:		case ELFOSABI_FREEBSD:
    #####: 6878:		  if (flag == SHF_GNU_RETAIN)
    #####: 6879:		    sindex = 26;
        -: 6880:		  /* Fall through */
        -: 6881:		case ELFOSABI_NONE:
    #####: 6882:		  if (flag == SHF_GNU_MBIND)
        -: 6883:		    /* We should not recognize SHF_GNU_MBIND for
        -: 6884:		       ELFOSABI_NONE, but binutils as of 2019-07-23 did
        -: 6885:		       not set the EI_OSABI header byte.  */
    #####: 6886:		    sindex = 24;
    #####: 6887:		  break;
    #####: 6888:		default:
    #####: 6889:		  break;
        -: 6890:		}
    #####: 6891:	      break;
        -: 6892:	    }
        -: 6893:
    #####: 6894:	  if (sindex != -1)
        -: 6895:	    {
    #####: 6896:	      if (p != buff + field_size + 4)
        -: 6897:		{
    #####: 6898:		  if (size < (10 + 2))
        -: 6899:		    {
    #####: 6900:		      warn (_("Internal error: not enough buffer room for section flag info"));
    #####: 6901:		      return _("<unknown>");
        -: 6902:		    }
    #####: 6903:		  size -= 2;
    #####: 6904:		  *p++ = ',';
    #####: 6905:		  *p++ = ' ';
        -: 6906:		}
        -: 6907:
    #####: 6908:	      size -= flags [sindex].len;
    #####: 6909:	      p = stpcpy (p, flags [sindex].str);
        -: 6910:	    }
    #####: 6911:	  else if (flag & SHF_MASKOS)
    #####: 6912:	    os_flags |= flag;
    #####: 6913:	  else if (flag & SHF_MASKPROC)
    #####: 6914:	    proc_flags |= flag;
        -: 6915:	  else
    #####: 6916:	    unknown_flags |= flag;
        -: 6917:	}
        -: 6918:      else
        -: 6919:	{
     6264: 6920:	  switch (flag)
        -: 6921:	    {
      864: 6922:	    case SHF_WRITE:		*p = 'W'; break;
     1340: 6923:	    case SHF_ALLOC:		*p = 'A'; break;
      802: 6924:	    case SHF_EXECINSTR:		*p = 'X'; break;
      161: 6925:	    case SHF_MERGE:		*p = 'M'; break;
      209: 6926:	    case SHF_STRINGS:		*p = 'S'; break;
      191: 6927:	    case SHF_INFO_LINK:		*p = 'I'; break;
      105: 6928:	    case SHF_LINK_ORDER:	*p = 'L'; break;
      156: 6929:	    case SHF_OS_NONCONFORMING:	*p = 'O'; break;
      139: 6930:	    case SHF_GROUP:		*p = 'G'; break;
      204: 6931:	    case SHF_TLS:		*p = 'T'; break;
       30: 6932:	    case SHF_EXCLUDE:		*p = 'E'; break;
      130: 6933:	    case SHF_COMPRESSED:	*p = 'C'; break;
        -: 6934:
     1933: 6935:	    default:
     1933: 6936:	      if ((filedata->file_header.e_machine == EM_X86_64
     1921: 6937:		   || filedata->file_header.e_machine == EM_L1OM
     1909: 6938:		   || filedata->file_header.e_machine == EM_K1OM)
       24: 6939:		  && flag == SHF_X86_64_LARGE)
        2: 6940:		*p = 'l';
     1931: 6941:	      else if (filedata->file_header.e_machine == EM_ARM
        3: 6942:		       && flag == SHF_ARM_PURECODE)
    #####: 6943:		*p = 'y';
     1931: 6944:	      else if (filedata->file_header.e_machine == EM_PPC
        6: 6945:		       && flag == SHF_PPC_VLE)
        1: 6946:		*p = 'v';
     1930: 6947:	      else if (flag & SHF_MASKOS)
        -: 6948:		{
      467: 6949:		  switch (filedata->file_header.e_ident[EI_OSABI])
        -: 6950:		    {
       27: 6951:		    case ELFOSABI_GNU:
        -: 6952:		    case ELFOSABI_FREEBSD:
       27: 6953:		      if (flag == SHF_GNU_RETAIN)
        -: 6954:			{
        5: 6955:			  *p = 'R';
        5: 6956:			  break;
        -: 6957:			}
        -: 6958:		      /* Fall through */
        -: 6959:		    case ELFOSABI_NONE:
      429: 6960:		      if (flag == SHF_GNU_MBIND)
        -: 6961:			{
        -: 6962:			  /* We should not recognize SHF_GNU_MBIND for
        -: 6963:			     ELFOSABI_NONE, but binutils as of 2019-07-23 did
        -: 6964:			     not set the EI_OSABI header byte.  */
       75: 6965:			  *p = 'D';
       75: 6966:			  break;
        -: 6967:			}
        -: 6968:		      /* Fall through */
        -: 6969:		    default:
      387: 6970:		      *p = 'o';
      387: 6971:		      sh_flags &= ~SHF_MASKOS;
      387: 6972:		      break;
        -: 6973:		    }
        -: 6974:		}
     1463: 6975:	      else if (flag & SHF_MASKPROC)
        -: 6976:		{
      216: 6977:		  *p = 'p';
      216: 6978:		  sh_flags &= ~ SHF_MASKPROC;
        -: 6979:		}
        -: 6980:	      else
     1247: 6981:		*p = 'x';
     1933: 6982:	      break;
        -: 6983:	    }
     6264: 6984:	  p++;
        -: 6985:	}
        -: 6986:    }
        -: 6987:
     3507: 6988:  if (do_section_details)
        -: 6989:    {
    #####: 6990:      if (os_flags)
        -: 6991:	{
    #####: 6992:	  size -= 5 + field_size;
    #####: 6993:	  if (p != buff + field_size + 4)
        -: 6994:	    {
    #####: 6995:	      if (size < (2 + 1))
        -: 6996:		{
    #####: 6997:		  warn (_("Internal error: not enough buffer room for section flag info"));
    #####: 6998:		  return _("<unknown>");
        -: 6999:		}
    #####: 7000:	      size -= 2;
    #####: 7001:	      *p++ = ',';
    #####: 7002:	      *p++ = ' ';
        -: 7003:	    }
    #####: 7004:	  sprintf (p, "OS (%*.*lx)", field_size, field_size,
        -: 7005:		   (unsigned long) os_flags);
    #####: 7006:	  p += 5 + field_size;
        -: 7007:	}
    #####: 7008:      if (proc_flags)
        -: 7009:	{
    #####: 7010:	  size -= 7 + field_size;
    #####: 7011:	  if (p != buff + field_size + 4)
        -: 7012:	    {
    #####: 7013:	      if (size < (2 + 1))
        -: 7014:		{
    #####: 7015:		  warn (_("Internal error: not enough buffer room for section flag info"));
    #####: 7016:		  return _("<unknown>");
        -: 7017:		}
    #####: 7018:	      size -= 2;
    #####: 7019:	      *p++ = ',';
    #####: 7020:	      *p++ = ' ';
        -: 7021:	    }
    #####: 7022:	  sprintf (p, "PROC (%*.*lx)", field_size, field_size,
        -: 7023:		   (unsigned long) proc_flags);
    #####: 7024:	  p += 7 + field_size;
        -: 7025:	}
    #####: 7026:      if (unknown_flags)
        -: 7027:	{
    #####: 7028:	  size -= 10 + field_size;
    #####: 7029:	  if (p != buff + field_size + 4)
        -: 7030:	    {
    #####: 7031:	      if (size < (2 + 1))
        -: 7032:		{
    #####: 7033:		  warn (_("Internal error: not enough buffer room for section flag info"));
    #####: 7034:		  return _("<unknown>");
        -: 7035:		}
    #####: 7036:	      size -= 2;
    #####: 7037:	      *p++ = ',';
    #####: 7038:	      *p++ = ' ';
        -: 7039:	    }
    #####: 7040:	  sprintf (p, _("UNKNOWN (%*.*lx)"), field_size, field_size,
        -: 7041:		   (unsigned long) unknown_flags);
    #####: 7042:	  p += 10 + field_size;
        -: 7043:	}
        -: 7044:    }
        -: 7045:
     3507: 7046:  *p = '\0';
     3507: 7047:  return buff;
        -: 7048:}
        -: 7049:
        -: 7050:static unsigned int ATTRIBUTE_WARN_UNUSED_RESULT
    #####: 7051:get_compression_header (Elf_Internal_Chdr *chdr, unsigned char *buf, bfd_size_type size)
        -: 7052:{
    #####: 7053:  if (is_32bit_elf)
        -: 7054:    {
    #####: 7055:      Elf32_External_Chdr *echdr = (Elf32_External_Chdr *) buf;
        -: 7056:
    #####: 7057:      if (size < sizeof (* echdr))
        -: 7058:	{
    #####: 7059:	  error (_("Compressed section is too small even for a compression header\n"));
    #####: 7060:	  return 0;
        -: 7061:	}
        -: 7062:
    #####: 7063:      chdr->ch_type = BYTE_GET (echdr->ch_type);
    #####: 7064:      chdr->ch_size = BYTE_GET (echdr->ch_size);
    #####: 7065:      chdr->ch_addralign = BYTE_GET (echdr->ch_addralign);
    #####: 7066:      return sizeof (*echdr);
        -: 7067:    }
        -: 7068:  else
        -: 7069:    {
    #####: 7070:      Elf64_External_Chdr *echdr = (Elf64_External_Chdr *) buf;
        -: 7071:
    #####: 7072:      if (size < sizeof (* echdr))
        -: 7073:	{
    #####: 7074:	  error (_("Compressed section is too small even for a compression header\n"));
    #####: 7075:	  return 0;
        -: 7076:	}
        -: 7077:
    #####: 7078:      chdr->ch_type = BYTE_GET (echdr->ch_type);
    #####: 7079:      chdr->ch_size = BYTE_GET (echdr->ch_size);
    #####: 7080:      chdr->ch_addralign = BYTE_GET (echdr->ch_addralign);
    #####: 7081:      return sizeof (*echdr);
        -: 7082:    }
        -: 7083:}
        -: 7084:
        -: 7085:static bool
     1391: 7086:process_section_headers (Filedata * filedata)
        -: 7087:{
        -: 7088:  Elf_Internal_Shdr * section;
        -: 7089:  unsigned int i;
        -: 7090:
     1391: 7091:  if (filedata->file_header.e_shnum == 0)
        -: 7092:    {
        -: 7093:      /* PR binutils/12467.  */
      121: 7094:      if (filedata->file_header.e_shoff != 0)
        -: 7095:	{
      102: 7096:	  warn (_("possibly corrupt ELF file header - it has a non-zero"
        -: 7097:		  " section header offset, but no section headers\n"));
      102: 7098:	  return false;
        -: 7099:	}
       19: 7100:      else if (do_sections)
       19: 7101:	printf (_("\nThere are no sections in this file.\n"));
        -: 7102:
       19: 7103:      return true;
        -: 7104:    }
        -: 7105:
     1270: 7106:  if (do_sections && !do_header)
        -: 7107:    {
    #####: 7108:      if (filedata->is_separate && process_links)
    #####: 7109:	printf (_("In linked file '%s': "), filedata->file_name);
    #####: 7110:      if (! filedata->is_separate || process_links)
    #####: 7111:	printf (ngettext ("There is %d section header, "
        -: 7112:			  "starting at offset 0x%lx:\n",
        -: 7113:			  "There are %d section headers, "
        -: 7114:			  "starting at offset 0x%lx:\n",
    #####: 7115:			  filedata->file_header.e_shnum),
        -: 7116:		filedata->file_header.e_shnum,
    #####: 7117:		(unsigned long) filedata->file_header.e_shoff);
        -: 7118:    }
        -: 7119:
     1270: 7120:  if (!get_section_headers (filedata, false))
      388: 7121:    return false;
        -: 7122:
        -: 7123:  /* Read in the string table, so that we have names to display.  */
      882: 7124:  if (filedata->file_header.e_shstrndx != SHN_UNDEF
      839: 7125:       && filedata->file_header.e_shstrndx < filedata->file_header.e_shnum)
        -: 7126:    {
      839: 7127:      section = filedata->section_headers + filedata->file_header.e_shstrndx;
        -: 7128:
      839: 7129:      if (section->sh_size != 0)
        -: 7130:	{
     1524: 7131:	  filedata->string_table = (char *) get_data (NULL, filedata, section->sh_offset,
        -: 7132:						      1, section->sh_size,
      762: 7133:						      _("string table"));
        -: 7134:
      762: 7135:	  filedata->string_table_length = filedata->string_table != NULL ? section->sh_size : 0;
        -: 7136:	}
        -: 7137:    }
        -: 7138:
        -: 7139:  /* Scan the sections for the dynamic symbol table
        -: 7140:     and dynamic string table and debug sections.  */
     882*: 7141:  eh_addr_size = is_32bit_elf ? 4 : 8;
      882: 7142:  switch (filedata->file_header.e_machine)
        -: 7143:    {
       21: 7144:    case EM_MIPS:
        -: 7145:    case EM_MIPS_RS3_LE:
        -: 7146:      /* The 64-bit MIPS EABI uses a combination of 32-bit ELF and 64-bit
        -: 7147:	 FDE addresses.  However, the ABI also has a semi-official ILP32
        -: 7148:	 variant for which the normal FDE address size rules apply.
        -: 7149:
        -: 7150:	 GCC 4.0 marks EABI64 objects with a dummy .gcc_compiled_longXX
        -: 7151:	 section, where XX is the size of longs in bits.  Unfortunately,
        -: 7152:	 earlier compilers provided no way of distinguishing ILP32 objects
        -: 7153:	 from LP64 objects, so if there's any doubt, we should assume that
        -: 7154:	 the official LP64 form is being used.  */
       21: 7155:      if ((filedata->file_header.e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI64
        2: 7156:	  && find_section (filedata, ".gcc_compiled_long32") == NULL)
        2: 7157:	eh_addr_size = 8;
       21: 7158:      break;
        -: 7159:
        2: 7160:    case EM_H8_300:
        -: 7161:    case EM_H8_300H:
        2: 7162:      switch (filedata->file_header.e_flags & EF_H8_MACH)
        -: 7163:	{
    #####: 7164:	case E_H8_MACH_H8300:
        -: 7165:	case E_H8_MACH_H8300HN:
        -: 7166:	case E_H8_MACH_H8300SN:
        -: 7167:	case E_H8_MACH_H8300SXN:
    #####: 7168:	  eh_addr_size = 2;
    #####: 7169:	  break;
    #####: 7170:	case E_H8_MACH_H8300H:
        -: 7171:	case E_H8_MACH_H8300S:
        -: 7172:	case E_H8_MACH_H8300SX:
    #####: 7173:	  eh_addr_size = 4;
    #####: 7174:	  break;
        -: 7175:	}
        2: 7176:      break;
        -: 7177:
        1: 7178:    case EM_M32C_OLD:
        -: 7179:    case EM_M32C:
        1: 7180:      switch (filedata->file_header.e_flags & EF_M32C_CPU_MASK)
        -: 7181:	{
    #####: 7182:	case EF_M32C_CPU_M16C:
    #####: 7183:	  eh_addr_size = 2;
    #####: 7184:	  break;
        -: 7185:	}
        1: 7186:      break;
        -: 7187:    }
        -: 7188:
        -: 7189:#define CHECK_ENTSIZE_VALUES(section, i, size32, size64)		\
        -: 7190:  do									\
        -: 7191:    {									\
        -: 7192:      bfd_size_type expected_entsize = is_32bit_elf ? size32 : size64;	\
        -: 7193:      if (section->sh_entsize != expected_entsize)			\
        -: 7194:	{								\
        -: 7195:	  char buf[40];							\
        -: 7196:	  sprintf_vma (buf, section->sh_entsize);			\
        -: 7197:	  /* Note: coded this way so that there is a single string for  \
        -: 7198:	     translation.  */ \
        -: 7199:	  error (_("Section %d has invalid sh_entsize of %s\n"), i, buf); \
        -: 7200:	  error (_("(Using the expected size of %u for the rest of this dump)\n"), \
        -: 7201:		   (unsigned) expected_entsize);			\
        -: 7202:	  section->sh_entsize = expected_entsize;			\
        -: 7203:	}								\
        -: 7204:    }									\
        -: 7205:  while (0)
        -: 7206:
        -: 7207:#define CHECK_ENTSIZE(section, i, type)					\
        -: 7208:  CHECK_ENTSIZE_VALUES (section, i, sizeof (Elf32_External_##type),	\
        -: 7209:			sizeof (Elf64_External_##type))
        -: 7210:
      882: 7211:  for (i = 0, section = filedata->section_headers;
     4389: 7212:       i < filedata->file_header.e_shnum;
     3507: 7213:       i++, section++)
        -: 7214:    {
     3507: 7215:      const char *name = section_name_print (filedata, section);
        -: 7216:
        -: 7217:      /* Run some sanity checks on the headers and
        -: 7218:	 possibly fill in some file data as well.  */
     3507: 7219:      switch (section->sh_type)
        -: 7220:	{
       65: 7221:	case SHT_DYNSYM:
       65: 7222:	  if (filedata->dynamic_symbols != NULL)
        -: 7223:	    {
    #####: 7224:	      error (_("File contains multiple dynamic symbol tables\n"));
    #####: 7225:	      continue;
        -: 7226:	    }
        -: 7227:
      65*: 7228:	  CHECK_ENTSIZE (section, i, Sym);
        -: 7229:	  filedata->dynamic_symbols
       65: 7230:	    = get_elf_symbols (filedata, section, &filedata->num_dynamic_syms);
       65: 7231:	  filedata->dynamic_symtab_section = section;
       65: 7232:	  break;
        -: 7233:
      531: 7234:	case SHT_STRTAB:
      531: 7235:	  if (streq (name, ".dynstr"))
        -: 7236:	    {
    #####: 7237:	      if (filedata->dynamic_strings != NULL)
        -: 7238:		{
    #####: 7239:		  error (_("File contains multiple dynamic string tables\n"));
    #####: 7240:		  continue;
        -: 7241:		}
        -: 7242:
        -: 7243:	      filedata->dynamic_strings
    #####: 7244:		= (char *) get_data (NULL, filedata, section->sh_offset,
    #####: 7245:				     1, section->sh_size, _("dynamic strings"));
        -: 7246:	      filedata->dynamic_strings_length
    #####: 7247:		= filedata->dynamic_strings == NULL ? 0 : section->sh_size;
    #####: 7248:	      filedata->dynamic_strtab_section = section;
        -: 7249:	    }
      531: 7250:	  break;
        -: 7251:
        1: 7252:	case SHT_SYMTAB_SHNDX:
        -: 7253:	  {
        1: 7254:	    elf_section_list * entry = xmalloc (sizeof * entry);
        -: 7255:
        1: 7256:	    entry->hdr = section;
        1: 7257:	    entry->next = filedata->symtab_shndx_list;
        1: 7258:	    filedata->symtab_shndx_list = entry;
        -: 7259:	  }
        1: 7260:	  break;
        -: 7261:
       53: 7262:	case SHT_SYMTAB:
      53*: 7263:	  CHECK_ENTSIZE (section, i, Sym);
       53: 7264:	  break;
        -: 7265:
       57: 7266:	case SHT_GROUP:
       57: 7267:	  CHECK_ENTSIZE_VALUES (section, i, GRP_ENTRY_SIZE, GRP_ENTRY_SIZE);
       57: 7268:	  break;
        -: 7269:
       94: 7270:	case SHT_REL:
      94*: 7271:	  CHECK_ENTSIZE (section, i, Rel);
      94*: 7272:	  if (do_checks && section->sh_size == 0)
    #####: 7273:	    warn (_("Section '%s': zero-sized relocation section\n"), name);
       94: 7274:	  break;
        -: 7275:
       63: 7276:	case SHT_RELA:
      63*: 7277:	  CHECK_ENTSIZE (section, i, Rela);
      63*: 7278:	  if (do_checks && section->sh_size == 0)
    #####: 7279:	    warn (_("Section '%s': zero-sized relocation section\n"), name);
       63: 7280:	  break;
        -: 7281:
        8: 7282:	case SHT_RELR:
       8*: 7283:	  CHECK_ENTSIZE (section, i, Relr);
        8: 7284:	  break;
        -: 7285:
     1125: 7286:	case SHT_NOTE:
        -: 7287:	case SHT_PROGBITS:
        -: 7288:	  /* Having a zero sized section is not illegal according to the
        -: 7289:	     ELF standard, but it might be an indication that something
        -: 7290:	     is wrong.  So issue a warning if we are running in lint mode.  */
    1125*: 7291:	  if (do_checks && section->sh_size == 0)
    #####: 7292:	    warn (_("Section '%s': has a size of zero - is this intended ?\n"), name);
     1125: 7293:	  break;
        -: 7294:
     1510: 7295:	default:
     1510: 7296:	  break;
        -: 7297:	}
        -: 7298:
     3507: 7299:      if ((do_debugging || do_debug_info || do_debug_abbrevs
     3507: 7300:	   || do_debug_lines || do_debug_pubnames || do_debug_pubtypes
     3507: 7301:	   || do_debug_aranges || do_debug_frames || do_debug_macinfo
     3507: 7302:	   || do_debug_str || do_debug_str_offsets || do_debug_loc
     3507: 7303:	   || do_debug_ranges
     3507: 7304:	   || do_debug_addr || do_debug_cu_index || do_debug_links)
    #####: 7305:	  && (startswith (name, ".debug_")
    #####: 7306:	      || startswith (name, ".zdebug_")))
        -: 7307:	{
    #####: 7308:          if (name[1] == 'z')
    #####: 7309:            name += sizeof (".zdebug_") - 1;
        -: 7310:          else
    #####: 7311:            name += sizeof (".debug_") - 1;
        -: 7312:
    #####: 7313:	  if (do_debugging
    #####: 7314:	      || (do_debug_info     && startswith (name, "info"))
    #####: 7315:	      || (do_debug_info     && startswith (name, "types"))
    #####: 7316:	      || (do_debug_abbrevs  && startswith (name, "abbrev"))
    #####: 7317:	      || (do_debug_lines    && strcmp (name, "line") == 0)
    #####: 7318:	      || (do_debug_lines    && startswith (name, "line."))
    #####: 7319:	      || (do_debug_pubnames && startswith (name, "pubnames"))
    #####: 7320:	      || (do_debug_pubtypes && startswith (name, "pubtypes"))
    #####: 7321:	      || (do_debug_pubnames && startswith (name, "gnu_pubnames"))
    #####: 7322:	      || (do_debug_pubtypes && startswith (name, "gnu_pubtypes"))
    #####: 7323:	      || (do_debug_aranges  && startswith (name, "aranges"))
    #####: 7324:	      || (do_debug_ranges   && startswith (name, "ranges"))
    #####: 7325:	      || (do_debug_ranges   && startswith (name, "rnglists"))
    #####: 7326:	      || (do_debug_frames   && startswith (name, "frame"))
    #####: 7327:	      || (do_debug_macinfo  && startswith (name, "macinfo"))
    #####: 7328:	      || (do_debug_macinfo  && startswith (name, "macro"))
    #####: 7329:	      || (do_debug_str      && startswith (name, "str"))
    #####: 7330:	      || (do_debug_links    && startswith (name, "sup"))
    #####: 7331:	      || (do_debug_str_offsets && startswith (name, "str_offsets"))
    #####: 7332:	      || (do_debug_loc      && startswith (name, "loc"))
    #####: 7333:	      || (do_debug_loc      && startswith (name, "loclists"))
    #####: 7334:	      || (do_debug_addr     && startswith (name, "addr"))
    #####: 7335:	      || (do_debug_cu_index && startswith (name, "cu_index"))
    #####: 7336:	      || (do_debug_cu_index && startswith (name, "tu_index"))
        -: 7337:	      )
    #####: 7338:	    request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
        -: 7339:	}
        -: 7340:      /* Linkonce section to be combined with .debug_info at link time.  */
     3507: 7341:      else if ((do_debugging || do_debug_info)
    #####: 7342:	       && startswith (name, ".gnu.linkonce.wi."))
    #####: 7343:	request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
    3507*: 7344:      else if (do_debug_frames && streq (name, ".eh_frame"))
    #####: 7345:	request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
    3507*: 7346:      else if (do_gdb_index && (streq (name, ".gdb_index")
    #####: 7347:				|| streq (name, ".debug_names")))
    #####: 7348:	request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
        -: 7349:      /* Trace sections for Itanium VMS.  */
     3507: 7350:      else if ((do_debugging || do_trace_info || do_trace_abbrevs
     3507: 7351:                || do_trace_aranges)
    #####: 7352:	       && startswith (name, ".trace_"))
        -: 7353:	{
    #####: 7354:          name += sizeof (".trace_") - 1;
        -: 7355:
    #####: 7356:	  if (do_debugging
    #####: 7357:	      || (do_trace_info     && streq (name, "info"))
    #####: 7358:	      || (do_trace_abbrevs  && streq (name, "abbrev"))
    #####: 7359:	      || (do_trace_aranges  && streq (name, "aranges"))
        -: 7360:	      )
    #####: 7361:	    request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
        -: 7362:	}
     3507: 7363:      else if ((do_debugging || do_debug_links)
    #####: 7364:	       && (startswith (name, ".gnu_debuglink")
    #####: 7365:		   || startswith (name, ".gnu_debugaltlink")))
    #####: 7366:	request_dump_bynumber (&filedata->dump, i, DEBUG_DUMP);
        -: 7367:    }
        -: 7368:
      882: 7369:  if (! do_sections)
    #####: 7370:    return true;
        -: 7371:
     882*: 7372:  if (filedata->is_separate && ! process_links)
    #####: 7373:    return true;
        -: 7374:
      882: 7375:  if (filedata->is_separate)
    #####: 7376:    printf (_("\nSection Headers in linked file '%s':\n"), filedata->file_name);
      882: 7377:  else if (filedata->file_header.e_shnum > 1)
      878: 7378:    printf (_("\nSection Headers:\n"));
        -: 7379:  else
        4: 7380:    printf (_("\nSection Header:\n"));
        -: 7381:
      882: 7382:  if (is_32bit_elf)
        -: 7383:    {
      882: 7384:      if (do_section_details)
        -: 7385:	{
    #####: 7386:	  printf (_("  [Nr] Name\n"));
    #####: 7387:	  printf (_("       Type            Addr     Off    Size   ES   Lk Inf Al\n"));
        -: 7388:	}
        -: 7389:      else
      882: 7390:	printf
      882: 7391:	  (_("  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"));
        -: 7392:    }
    #####: 7393:  else if (do_wide)
        -: 7394:    {
    #####: 7395:      if (do_section_details)
        -: 7396:	{
    #####: 7397:	  printf (_("  [Nr] Name\n"));
    #####: 7398:	  printf (_("       Type            Address          Off    Size   ES   Lk Inf Al\n"));
        -: 7399:	}
        -: 7400:      else
    #####: 7401:	printf
    #####: 7402:	  (_("  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n"));
        -: 7403:    }
        -: 7404:  else
        -: 7405:    {
    #####: 7406:      if (do_section_details)
        -: 7407:	{
    #####: 7408:	  printf (_("  [Nr] Name\n"));
    #####: 7409:	  printf (_("       Type              Address          Offset            Link\n"));
    #####: 7410:	  printf (_("       Size              EntSize          Info              Align\n"));
        -: 7411:	}
        -: 7412:      else
        -: 7413:	{
    #####: 7414:	  printf (_("  [Nr] Name              Type             Address           Offset\n"));
    #####: 7415:	  printf (_("       Size              EntSize          Flags  Link  Info  Align\n"));
        -: 7416:	}
        -: 7417:    }
        -: 7418:
      882: 7419:  if (do_section_details)
    #####: 7420:    printf (_("       Flags\n"));
        -: 7421:
      882: 7422:  for (i = 0, section = filedata->section_headers;
     4389: 7423:       i < filedata->file_header.e_shnum;
     3507: 7424:       i++, section++)
        -: 7425:    {
        -: 7426:      /* Run some sanity checks on the section header.  */
        -: 7427:
        -: 7428:      /* Check the sh_link field.  */
     3507: 7429:      switch (section->sh_type)
        -: 7430:	{
      157: 7431:	case SHT_REL:
        -: 7432:	case SHT_RELA:
      157: 7433:	  if (section->sh_link == 0
      120: 7434:	      && (filedata->file_header.e_type == ET_EXEC
        8: 7435:		  || filedata->file_header.e_type == ET_DYN))
        -: 7436:	    /* A dynamic relocation section where all entries use a
        -: 7437:	       zero symbol index need not specify a symtab section.  */
        -: 7438:	    break;
        -: 7439:	  /* Fall through.  */
        -: 7440:	case SHT_SYMTAB_SHNDX:
        -: 7441:	case SHT_GROUP:
        -: 7442:	case SHT_HASH:
        -: 7443:	case SHT_GNU_HASH:
        -: 7444:	case SHT_GNU_versym:
      108: 7445:	  if (section->sh_link == 0
       90: 7446:	      || section->sh_link >= filedata->file_header.e_shnum
        4: 7447:	      || (filedata->section_headers[section->sh_link].sh_type != SHT_SYMTAB
        4: 7448:		  && filedata->section_headers[section->sh_link].sh_type != SHT_DYNSYM))
      107: 7449:	    warn (_("[%2u]: Link field (%u) should index a symtab section.\n"),
        -: 7450:		  i, section->sh_link);
      108: 7451:	  break;
        -: 7452:
      126: 7453:	case SHT_DYNAMIC:
        -: 7454:	case SHT_SYMTAB:
        -: 7455:	case SHT_DYNSYM:
        -: 7456:	case SHT_GNU_verneed:
        -: 7457:	case SHT_GNU_verdef:
        -: 7458:	case SHT_GNU_LIBLIST:
      126: 7459:	  if (section->sh_link == 0
       67: 7460:	      || section->sh_link >= filedata->file_header.e_shnum
        5: 7461:	      || filedata->section_headers[section->sh_link].sh_type != SHT_STRTAB)
      125: 7462:	    warn (_("[%2u]: Link field (%u) should index a string section.\n"),
        -: 7463:		  i, section->sh_link);
      126: 7464:	  break;
        -: 7465:
       16: 7466:	case SHT_INIT_ARRAY:
        -: 7467:	case SHT_FINI_ARRAY:
        -: 7468:	case SHT_PREINIT_ARRAY:
       16: 7469:	  if (section->sh_type < SHT_LOOS && section->sh_link != 0)
        6: 7470:	    warn (_("[%2u]: Unexpected value (%u) in link field.\n"),
        -: 7471:		  i, section->sh_link);
       16: 7472:	  break;
        -: 7473:
     3142: 7474:	default:
        -: 7475:	  /* FIXME: Add support for target specific section types.  */
        -: 7476:#if 0 	  /* Currently we do not check other section types as there are too
        -: 7477:	     many special cases.  Stab sections for example have a type
        -: 7478:	     of SHT_PROGBITS but an sh_link field that links to the .stabstr
        -: 7479:	     section.  */
        -: 7480:	  if (section->sh_type < SHT_LOOS && section->sh_link != 0)
        -: 7481:	    warn (_("[%2u]: Unexpected value (%u) in link field.\n"),
        -: 7482:		  i, section->sh_link);
        -: 7483:#endif
     3142: 7484:	  break;
        -: 7485:	}
        -: 7486:
        -: 7487:      /* Check the sh_info field.  */
     3507: 7488:      switch (section->sh_type)
        -: 7489:	{
      157: 7490:	case SHT_REL:
        -: 7491:	case SHT_RELA:
      157: 7492:	  if (section->sh_info == 0
      113: 7493:	      && (filedata->file_header.e_type == ET_EXEC
        8: 7494:		  || filedata->file_header.e_type == ET_DYN))
        -: 7495:	    /* Dynamic relocations apply to segments, so they do not
        -: 7496:	       need to specify the section they relocate.  */
        -: 7497:	    break;
       50: 7498:	  if (section->sh_info == 0
       44: 7499:	      || section->sh_info >= filedata->file_header.e_shnum
        4: 7500:	      || (filedata->section_headers[section->sh_info].sh_type != SHT_PROGBITS
        3: 7501:		  && filedata->section_headers[section->sh_info].sh_type != SHT_NOBITS
        3: 7502:		  && filedata->section_headers[section->sh_info].sh_type != SHT_NOTE
        3: 7503:		  && filedata->section_headers[section->sh_info].sh_type != SHT_INIT_ARRAY
        3: 7504:		  && filedata->section_headers[section->sh_info].sh_type != SHT_FINI_ARRAY
        3: 7505:		  && filedata->section_headers[section->sh_info].sh_type != SHT_PREINIT_ARRAY
        -: 7506:		  /* FIXME: Are other section types valid ?  */
        3: 7507:		  && filedata->section_headers[section->sh_info].sh_type < SHT_LOOS))
       48: 7508:	    warn (_("[%2u]: Info field (%u) should index a relocatable section.\n"),
        -: 7509:		  i, section->sh_info);
       50: 7510:	  break;
        -: 7511:
       33: 7512:	case SHT_DYNAMIC:
        -: 7513:	case SHT_HASH:
        -: 7514:	case SHT_SYMTAB_SHNDX:
        -: 7515:	case SHT_INIT_ARRAY:
        -: 7516:	case SHT_FINI_ARRAY:
        -: 7517:	case SHT_PREINIT_ARRAY:
       33: 7518:	  if (section->sh_info != 0)
       11: 7519:	    warn (_("[%2u]: Unexpected value (%u) in info field.\n"),
        -: 7520:		  i, section->sh_info);
       33: 7521:	  break;
        -: 7522:
      175: 7523:	case SHT_GROUP:
        -: 7524:	case SHT_SYMTAB:
        -: 7525:	case SHT_DYNSYM:
        -: 7526:	  /* A symbol index - we assume that it is valid.  */
      175: 7527:	  break;
        -: 7528:
     3142: 7529:	default:
        -: 7530:	  /* FIXME: Add support for target specific section types.  */
     3142: 7531:	  if (section->sh_type == SHT_NOBITS)
        -: 7532:	    /* NOBITS section headers with non-zero sh_info fields can be
        -: 7533:	       created when a binary is stripped of everything but its debug
        -: 7534:	       information.  The stripped sections have their headers
        -: 7535:	       preserved but their types set to SHT_NOBITS.  So do not check
        -: 7536:	       this type of section.  */
        -: 7537:	    ;
     3128: 7538:	  else if (section->sh_flags & SHF_INFO_LINK)
        -: 7539:	    {
      186: 7540:	      if (section->sh_info < 1 || section->sh_info >= filedata->file_header.e_shnum)
      185: 7541:		warn (_("[%2u]: Expected link to another section in info field"), i);
        -: 7542:	    }
     2942: 7543:	  else if (section->sh_type < SHT_LOOS
     2838: 7544:		   && (section->sh_flags & SHF_GNU_MBIND) == 0
     2749: 7545:		   && section->sh_info != 0)
      365: 7546:	    warn (_("[%2u]: Unexpected value (%u) in info field.\n"),
        -: 7547:		  i, section->sh_info);
     3142: 7548:	  break;
        -: 7549:	}
        -: 7550:
        -: 7551:      /* Check the sh_size field.  */
     3507: 7552:      if (section->sh_size > filedata->file_size
      498: 7553:	  && section->sh_type != SHT_NOBITS
      496: 7554:	  && section->sh_type != SHT_NULL
      395: 7555:	  && section->sh_type < SHT_LOOS)
      266: 7556:	warn (_("Size of section %u is larger than the entire file!\n"), i);
        -: 7557:
     3507: 7558:      printf ("  [%2u] ", i);
     3507: 7559:      if (do_section_details)
    #####: 7560:	printf ("%s\n      ", printable_section_name (filedata, section));
        -: 7561:      else
     3507: 7562:	print_symbol (-17, section_name_print (filedata, section));
        -: 7563:
    3507*: 7564:      printf (do_wide ? " %-15s " : " %-15.15s ",
        -: 7565:	      get_section_type_name (filedata, section->sh_type));
        -: 7566:
     3507: 7567:      if (is_32bit_elf)
        -: 7568:	{
     3507: 7569:	  const char * link_too_big = NULL;
        -: 7570:
     3507: 7571:	  print_vma (section->sh_addr, LONG_HEX);
        -: 7572:
     3507: 7573:	  printf ( " %6.6lx %6.6lx %2.2lx",
     3507: 7574:		   (unsigned long) section->sh_offset,
     3507: 7575:		   (unsigned long) section->sh_size,
     3507: 7576:		   (unsigned long) section->sh_entsize);
        -: 7577:
     3507: 7578:	  if (do_section_details)
    #####: 7579:	    fputs ("  ", stdout);
        -: 7580:	  else
     3507: 7581:	    printf (" %3s ", get_elf_section_flags (filedata, section->sh_flags));
        -: 7582:
     3507: 7583:	  if (section->sh_link >= filedata->file_header.e_shnum)
        -: 7584:	    {
      748: 7585:	      link_too_big = "";
        -: 7586:	      /* The sh_link value is out of range.  Normally this indicates
        -: 7587:		 an error but it can have special values in Solaris binaries.  */
      748: 7588:	      switch (filedata->file_header.e_machine)
        -: 7589:		{
      430: 7590:		case EM_386:
        -: 7591:		case EM_IAMCU:
        -: 7592:		case EM_X86_64:
        -: 7593:		case EM_L1OM:
        -: 7594:		case EM_K1OM:
        -: 7595:		case EM_OLD_SPARCV9:
        -: 7596:		case EM_SPARC32PLUS:
        -: 7597:		case EM_SPARCV9:
        -: 7598:		case EM_SPARC:
      430: 7599:		  if (section->sh_link == (SHN_BEFORE & 0xffff))
        3: 7600:		    link_too_big = "BEFORE";
      427: 7601:		  else if (section->sh_link == (SHN_AFTER & 0xffff))
        1: 7602:		    link_too_big = "AFTER";
      430: 7603:		  break;
      318: 7604:		default:
      318: 7605:		  break;
        -: 7606:		}
     2759: 7607:	    }
        -: 7608:
     3507: 7609:	  if (do_section_details)
        -: 7610:	    {
    #####: 7611:	      if (link_too_big != NULL && * link_too_big)
    #####: 7612:		printf ("<%s> ", link_too_big);
        -: 7613:	      else
    #####: 7614:		printf ("%2u ", section->sh_link);
    #####: 7615:	      printf ("%3u %2lu\n", section->sh_info,
    #####: 7616:		      (unsigned long) section->sh_addralign);
        -: 7617:	    }
        -: 7618:	  else
     3507: 7619:	    printf ("%2u %3u %2lu\n",
        -: 7620:		    section->sh_link,
        -: 7621:		    section->sh_info,
     3507: 7622:		    (unsigned long) section->sh_addralign);
        -: 7623:
     3507: 7624:	  if (link_too_big && ! * link_too_big)
      744: 7625:	    warn (_("section %u: sh_link value of %u is larger than the number of sections\n"),
        -: 7626:		  i, section->sh_link);
        -: 7627:	}
    #####: 7628:      else if (do_wide)
        -: 7629:	{
    #####: 7630:	  print_vma (section->sh_addr, LONG_HEX);
        -: 7631:
        -: 7632:	  if ((long) section->sh_offset == section->sh_offset)
    #####: 7633:	    printf (" %6.6lx", (unsigned long) section->sh_offset);
        -: 7634:	  else
        -: 7635:	    {
        -: 7636:	      putchar (' ');
        -: 7637:	      print_vma (section->sh_offset, LONG_HEX);
        -: 7638:	    }
        -: 7639:
        -: 7640:	  if ((unsigned long) section->sh_size == section->sh_size)
    #####: 7641:	    printf (" %6.6lx", (unsigned long) section->sh_size);
        -: 7642:	  else
        -: 7643:	    {
        -: 7644:	      putchar (' ');
        -: 7645:	      print_vma (section->sh_size, LONG_HEX);
        -: 7646:	    }
        -: 7647:
        -: 7648:	  if ((unsigned long) section->sh_entsize == section->sh_entsize)
    #####: 7649:	    printf (" %2.2lx", (unsigned long) section->sh_entsize);
        -: 7650:	  else
        -: 7651:	    {
        -: 7652:	      putchar (' ');
        -: 7653:	      print_vma (section->sh_entsize, LONG_HEX);
        -: 7654:	    }
        -: 7655:
    #####: 7656:	  if (do_section_details)
    #####: 7657:	    fputs ("  ", stdout);
        -: 7658:	  else
    #####: 7659:	    printf (" %3s ", get_elf_section_flags (filedata, section->sh_flags));
        -: 7660:
    #####: 7661:	  printf ("%2u %3u ", section->sh_link, section->sh_info);
        -: 7662:
        -: 7663:	  if ((unsigned long) section->sh_addralign == section->sh_addralign)
    #####: 7664:	    printf ("%2lu\n", (unsigned long) section->sh_addralign);
        -: 7665:	  else
        -: 7666:	    {
        -: 7667:	      print_vma (section->sh_addralign, DEC);
        -: 7668:	      putchar ('\n');
        -: 7669:	    }
        -: 7670:	}
    #####: 7671:      else if (do_section_details)
        -: 7672:	{
    #####: 7673:	  putchar (' ');
    #####: 7674:	  print_vma (section->sh_addr, LONG_HEX);
        -: 7675:	  if ((long) section->sh_offset == section->sh_offset)
    #####: 7676:	    printf ("  %16.16lx", (unsigned long) section->sh_offset);
        -: 7677:	  else
        -: 7678:	    {
        -: 7679:	      printf ("  ");
        -: 7680:	      print_vma (section->sh_offset, LONG_HEX);
        -: 7681:	    }
    #####: 7682:	  printf ("  %u\n       ", section->sh_link);
    #####: 7683:	  print_vma (section->sh_size, LONG_HEX);
    #####: 7684:	  putchar (' ');
    #####: 7685:	  print_vma (section->sh_entsize, LONG_HEX);
        -: 7686:
    #####: 7687:	  printf ("  %-16u  %lu\n",
        -: 7688:		  section->sh_info,
    #####: 7689:		  (unsigned long) section->sh_addralign);
        -: 7690:	}
        -: 7691:      else
        -: 7692:	{
    #####: 7693:	  putchar (' ');
    #####: 7694:	  print_vma (section->sh_addr, LONG_HEX);
        -: 7695:	  if ((long) section->sh_offset == section->sh_offset)
    #####: 7696:	    printf ("  %8.8lx", (unsigned long) section->sh_offset);
        -: 7697:	  else
        -: 7698:	    {
        -: 7699:	      printf ("  ");
        -: 7700:	      print_vma (section->sh_offset, LONG_HEX);
        -: 7701:	    }
    #####: 7702:	  printf ("\n       ");
    #####: 7703:	  print_vma (section->sh_size, LONG_HEX);
    #####: 7704:	  printf ("  ");
    #####: 7705:	  print_vma (section->sh_entsize, LONG_HEX);
        -: 7706:
    #####: 7707:	  printf (" %3s ", get_elf_section_flags (filedata, section->sh_flags));
        -: 7708:
    #####: 7709:	  printf ("     %2u   %3u     %lu\n",
        -: 7710:		  section->sh_link,
        -: 7711:		  section->sh_info,
    #####: 7712:		  (unsigned long) section->sh_addralign);
        -: 7713:	}
        -: 7714:
     3507: 7715:      if (do_section_details)
        -: 7716:	{
    #####: 7717:	  printf ("       %s\n", get_elf_section_flags (filedata, section->sh_flags));
    #####: 7718:	  if ((section->sh_flags & SHF_COMPRESSED) != 0)
        -: 7719:	    {
        -: 7720:	      /* Minimum section size is 12 bytes for 32-bit compression
        -: 7721:		 header + 12 bytes for compressed data header.  */
        -: 7722:	      unsigned char buf[24];
        -: 7723:
        -: 7724:	      assert (sizeof (buf) >= sizeof (Elf64_External_Chdr));
    #####: 7725:	      if (get_data (&buf, filedata, section->sh_offset, 1,
    #####: 7726:			    sizeof (buf), _("compression header")))
        -: 7727:		{
        -: 7728:		  Elf_Internal_Chdr chdr;
        -: 7729:
    #####: 7730:		  if (get_compression_header (&chdr, buf, sizeof (buf)) == 0)
    #####: 7731:		    printf (_("       [<corrupt>]\n"));
        -: 7732:		  else
        -: 7733:		    {
    #####: 7734:		      if (chdr.ch_type == ELFCOMPRESS_ZLIB)
    #####: 7735:			printf ("       ZLIB, ");
        -: 7736:		      else
    #####: 7737:			printf (_("       [<unknown>: 0x%x], "),
        -: 7738:				chdr.ch_type);
    #####: 7739:		      print_vma (chdr.ch_size, LONG_HEX);
    #####: 7740:		      printf (", %lu\n", (unsigned long) chdr.ch_addralign);
        -: 7741:		    }
        -: 7742:		}
        -: 7743:	    }
        -: 7744:	}
        -: 7745:    }
        -: 7746:
      882: 7747:  if (!do_section_details)
        -: 7748:    {
        -: 7749:      /* The ordering of the letters shown here matches the ordering of the
        -: 7750:	 corresponding SHF_xxx values, and hence the order in which these
        -: 7751:	 letters will be displayed to the user.  */
      882: 7752:      printf (_("Key to Flags:\n\
        -: 7753:  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),\n\
        -: 7754:  L (link order), O (extra OS processing required), G (group), T (TLS),\n\
        -: 7755:  C (compressed), x (unknown), o (OS specific), E (exclude),\n  "));
      882: 7756:      switch (filedata->file_header.e_ident[EI_OSABI])
        -: 7757:	{
       12: 7758:	case ELFOSABI_GNU:
        -: 7759:	case ELFOSABI_FREEBSD:
       12: 7760:	  printf (_("R (retain), "));
        -: 7761:	  /* Fall through */
      854: 7762:	case ELFOSABI_NONE:
      854: 7763:	  printf (_("D (mbind), "));
      854: 7764:	  break;
       28: 7765:	default:
       28: 7766:	  break;
        -: 7767:	}
      882: 7768:      if (filedata->file_header.e_machine == EM_X86_64
      880: 7769:	  || filedata->file_header.e_machine == EM_L1OM
      877: 7770:	  || filedata->file_header.e_machine == EM_K1OM)
        6: 7771:	printf (_("l (large), "));
      876: 7772:      else if (filedata->file_header.e_machine == EM_ARM)
        3: 7773:	printf (_("y (purecode), "));
      873: 7774:      else if (filedata->file_header.e_machine == EM_PPC)
        3: 7775:	printf (_("v (VLE), "));
      882: 7776:      printf ("p (processor specific)\n");
        -: 7777:    }
        -: 7778:
      882: 7779:  return true;
        -: 7780:}
        -: 7781:
        -: 7782:static bool
        4: 7783:get_symtab (Filedata *filedata, Elf_Internal_Shdr *symsec,
        -: 7784:	    Elf_Internal_Sym **symtab, unsigned long *nsyms,
        -: 7785:	    char **strtab, unsigned long *strtablen)
        -: 7786:{
        4: 7787:  *strtab = NULL;
        4: 7788:  *strtablen = 0;
        4: 7789:  *symtab = get_elf_symbols (filedata, symsec, nsyms);
        -: 7790:
        4: 7791:  if (*symtab == NULL)
        3: 7792:    return false;
        -: 7793:
        1: 7794:  if (symsec->sh_link != 0)
        -: 7795:    {
        -: 7796:      Elf_Internal_Shdr *strsec;
        -: 7797:
    #####: 7798:      if (symsec->sh_link >= filedata->file_header.e_shnum)
        -: 7799:	{
    #####: 7800:	  error (_("Bad sh_link in symbol table section\n"));
    #####: 7801:	  free (*symtab);
    #####: 7802:	  *symtab = NULL;
    #####: 7803:	  *nsyms = 0;
    #####: 7804:	  return false;
        -: 7805:	}
        -: 7806:
    #####: 7807:      strsec = filedata->section_headers + symsec->sh_link;
        -: 7808:
    #####: 7809:      *strtab = (char *) get_data (NULL, filedata, strsec->sh_offset,
    #####: 7810:				   1, strsec->sh_size, _("string table"));
    #####: 7811:      if (*strtab == NULL)
        -: 7812:	{
    #####: 7813:	  free (*symtab);
    #####: 7814:	  *symtab = NULL;
    #####: 7815:	  *nsyms = 0;
    #####: 7816:	  return false;
        -: 7817:	}
    #####: 7818:      *strtablen = strsec->sh_size;
        -: 7819:    }
        1: 7820:  return true;
        -: 7821:}
        -: 7822:
        -: 7823:static const char *
    #####: 7824:get_group_flags (unsigned int flags)
        -: 7825:{
        -: 7826:  static char buff[128];
        -: 7827:
    #####: 7828:  if (flags == 0)
    #####: 7829:    return "";
    #####: 7830:  else if (flags == GRP_COMDAT)
    #####: 7831:    return "COMDAT ";
        -: 7832:
    #####: 7833:  snprintf (buff, sizeof buff, "[0x%x: %s%s%s]",
        -: 7834:	    flags,
    #####: 7835:	    flags & GRP_MASKOS ? _("<OS specific>") : "",
    #####: 7836:	    flags & GRP_MASKPROC ? _("<PROC specific>") : "",
    #####: 7837:	    (flags & ~(GRP_COMDAT | GRP_MASKOS | GRP_MASKPROC)
    #####: 7838:	     ? _("<unknown>") : ""));
        -: 7839:
    #####: 7840:  return buff;
        -: 7841:}
        -: 7842:
        -: 7843:static bool
     1391: 7844:process_section_groups (Filedata * filedata)
        -: 7845:{
        -: 7846:  Elf_Internal_Shdr * section;
        -: 7847:  unsigned int i;
        -: 7848:  struct group * group;
        -: 7849:  Elf_Internal_Shdr * symtab_sec;
        -: 7850:  Elf_Internal_Shdr * strtab_sec;
        -: 7851:  Elf_Internal_Sym * symtab;
        -: 7852:  unsigned long num_syms;
        -: 7853:  char * strtab;
        -: 7854:  size_t strtab_size;
        -: 7855:
        -: 7856:  /* Don't process section groups unless needed.  */
     1391: 7857:  if (!do_unwind && !do_section_groups)
    #####: 7858:    return true;
        -: 7859:
     1391: 7860:  if (filedata->file_header.e_shnum == 0)
        -: 7861:    {
      121: 7862:      if (do_section_groups)
        -: 7863:	{
      121: 7864:	  if (filedata->is_separate)
    #####: 7865:	    printf (_("\nThere are no sections group in linked file '%s'.\n"),
        -: 7866:		    filedata->file_name);
        -: 7867:	  else
      121: 7868:	    printf (_("\nThere are no section groups in this file.\n"));
        -: 7869:	}
      121: 7870:      return true;
        -: 7871:    }
        -: 7872:
     1270: 7873:  if (filedata->section_headers == NULL)
        -: 7874:    {
      388: 7875:      error (_("Section headers are not available!\n"));
        -: 7876:      /* PR 13622: This can happen with a corrupt ELF header.  */
      388: 7877:      return false;
        -: 7878:    }
        -: 7879:
        -: 7880:  filedata->section_headers_groups
      882: 7881:    = (struct group **) calloc (filedata->file_header.e_shnum,
        -: 7882:				sizeof (struct group *));
        -: 7883:
      882: 7884:  if (filedata->section_headers_groups == NULL)
        -: 7885:    {
    #####: 7886:      error (_("Out of memory reading %u section group headers\n"),
        -: 7887:	     filedata->file_header.e_shnum);
    #####: 7888:      return false;
        -: 7889:    }
        -: 7890:
        -: 7891:  /* Scan the sections for the group section.  */
      882: 7892:  filedata->group_count = 0;
      882: 7893:  for (i = 0, section = filedata->section_headers;
     4389: 7894:       i < filedata->file_header.e_shnum;
     3507: 7895:       i++, section++)
     3507: 7896:    if (section->sh_type == SHT_GROUP)
       57: 7897:      filedata->group_count++;
        -: 7898:
      882: 7899:  if (filedata->group_count == 0)
        -: 7900:    {
      827: 7901:      if (do_section_groups)
        -: 7902:	{
      827: 7903:	  if (filedata->is_separate)
    #####: 7904:	    printf (_("\nThere are no section groups in linked file '%s'.\n"),
        -: 7905:		    filedata->file_name);
        -: 7906:	  else
      827: 7907:	    printf (_("\nThere are no section groups in this file.\n"));
        -: 7908:	}
        -: 7909:
      827: 7910:      return true;
        -: 7911:    }
        -: 7912:
       55: 7913:  filedata->section_groups = (struct group *) calloc (filedata->group_count,
        -: 7914:						      sizeof (struct group));
        -: 7915:
       55: 7916:  if (filedata->section_groups == NULL)
        -: 7917:    {
    #####: 7918:      error (_("Out of memory reading %lu groups\n"),
    #####: 7919:	     (unsigned long) filedata->group_count);
    #####: 7920:      return false;
        -: 7921:    }
        -: 7922:
       55: 7923:  symtab_sec = NULL;
       55: 7924:  strtab_sec = NULL;
       55: 7925:  symtab = NULL;
       55: 7926:  num_syms = 0;
       55: 7927:  strtab = NULL;
       55: 7928:  strtab_size = 0;
        -: 7929:
       55: 7930:  if (filedata->is_separate)
    #####: 7931:    printf (_("Section groups in linked file '%s'\n"), filedata->file_name);
        -: 7932:
       55: 7933:  for (i = 0, section = filedata->section_headers, group = filedata->section_groups;
      275: 7934:       i < filedata->file_header.e_shnum;
      220: 7935:       i++, section++)
        -: 7936:    {
      220: 7937:      if (section->sh_type == SHT_GROUP)
        -: 7938:	{
       57: 7939:	  const char * name = printable_section_name (filedata, section);
        -: 7940:	  const char * group_name;
        -: 7941:	  unsigned char * start;
        -: 7942:	  unsigned char * indices;
        -: 7943:	  unsigned int entry, j, size;
        -: 7944:	  Elf_Internal_Shdr * sec;
        -: 7945:	  Elf_Internal_Sym * sym;
        -: 7946:
        -: 7947:	  /* Get the symbol table.  */
       57: 7948:	  if (section->sh_link >= filedata->file_header.e_shnum
       10: 7949:	      || ((sec = filedata->section_headers + section->sh_link)->sh_type
        -: 7950:		  != SHT_SYMTAB))
        -: 7951:	    {
       55: 7952:	      error (_("Bad sh_link in group section `%s'\n"), name);
       55: 7953:	      continue;
        -: 7954:	    }
        -: 7955:
        2: 7956:	  if (symtab_sec != sec)
        -: 7957:	    {
        2: 7958:	      symtab_sec = sec;
        2: 7959:	      free (symtab);
        2: 7960:	      symtab = get_elf_symbols (filedata, symtab_sec, & num_syms);
        -: 7961:	    }
        -: 7962:
        2: 7963:	  if (symtab == NULL)
        -: 7964:	    {
        2: 7965:	      error (_("Corrupt header in group section `%s'\n"), name);
        2: 7966:	      continue;
        -: 7967:	    }
        -: 7968:
    #####: 7969:	  if (section->sh_info >= num_syms)
        -: 7970:	    {
    #####: 7971:	      error (_("Bad sh_info in group section `%s'\n"), name);
    #####: 7972:	      continue;
        -: 7973:	    }
        -: 7974:
    #####: 7975:	  sym = symtab + section->sh_info;
        -: 7976:
    #####: 7977:	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
        -: 7978:	    {
    #####: 7979:	      if (sym->st_shndx == 0
    #####: 7980:		  || sym->st_shndx >= filedata->file_header.e_shnum)
        -: 7981:		{
    #####: 7982:		  error (_("Bad sh_info in group section `%s'\n"), name);
    #####: 7983:		  continue;
        -: 7984:		}
        -: 7985:
    #####: 7986:	      group_name = section_name_print (filedata,
    #####: 7987:					       filedata->section_headers
    #####: 7988:					       + sym->st_shndx);
    #####: 7989:	      strtab_sec = NULL;
    #####: 7990:	      free (strtab);
    #####: 7991:	      strtab = NULL;
    #####: 7992:	      strtab_size = 0;
        -: 7993:	    }
        -: 7994:	  else
        -: 7995:	    {
        -: 7996:	      /* Get the string table.  */
    #####: 7997:	      if (symtab_sec->sh_link >= filedata->file_header.e_shnum)
        -: 7998:		{
    #####: 7999:		  strtab_sec = NULL;
    #####: 8000:		  free (strtab);
    #####: 8001:		  strtab = NULL;
    #####: 8002:		  strtab_size = 0;
        -: 8003:		}
    #####: 8004:	      else if (strtab_sec
    #####: 8005:		       != (sec = filedata->section_headers + symtab_sec->sh_link))
        -: 8006:		{
    #####: 8007:		  strtab_sec = sec;
    #####: 8008:		  free (strtab);
        -: 8009:
    #####: 8010:		  strtab = (char *) get_data (NULL, filedata, strtab_sec->sh_offset,
        -: 8011:					      1, strtab_sec->sh_size,
    #####: 8012:					      _("string table"));
    #####: 8013:		  strtab_size = strtab != NULL ? strtab_sec->sh_size : 0;
        -: 8014:		}
    #####: 8015:	      group_name = sym->st_name < strtab_size
    #####: 8016:		? strtab + sym->st_name : _("<corrupt>");
        -: 8017:	    }
        -: 8018:
        -: 8019:	  /* PR 17531: file: loop.  */
    #####: 8020:	  if (section->sh_entsize > section->sh_size)
        -: 8021:	    {
    #####: 8022:	      error (_("Section %s has sh_entsize (0x%lx) which is larger than its size (0x%lx)\n"),
        -: 8023:		     printable_section_name (filedata, section),
    #####: 8024:		     (unsigned long) section->sh_entsize,
    #####: 8025:		     (unsigned long) section->sh_size);
    #####: 8026:	      continue;
        -: 8027:	    }
        -: 8028:
    #####: 8029:	  start = (unsigned char *) get_data (NULL, filedata, section->sh_offset,
        -: 8030:                                              1, section->sh_size,
    #####: 8031:                                              _("section data"));
    #####: 8032:	  if (start == NULL)
    #####: 8033:	    continue;
        -: 8034:
    #####: 8035:	  indices = start;
    #####: 8036:	  size = (section->sh_size / section->sh_entsize) - 1;
    #####: 8037:	  entry = byte_get (indices, 4);
    #####: 8038:	  indices += 4;
        -: 8039:
    #####: 8040:	  if (do_section_groups)
        -: 8041:	    {
    #####: 8042:	      printf (_("\n%sgroup section [%5u] `%s' [%s] contains %u sections:\n"),
        -: 8043:		      get_group_flags (entry), i, name, group_name, size);
        -: 8044:
    #####: 8045:	      printf (_("   [Index]    Name\n"));
        -: 8046:	    }
        -: 8047:
    #####: 8048:	  group->group_index = i;
        -: 8049:
    #####: 8050:	  for (j = 0; j < size; j++)
        -: 8051:	    {
        -: 8052:	      struct group_list * g;
        -: 8053:
    #####: 8054:	      entry = byte_get (indices, 4);
    #####: 8055:	      indices += 4;
        -: 8056:
    #####: 8057:	      if (entry >= filedata->file_header.e_shnum)
        -: 8058:		{
        -: 8059:		  static unsigned num_group_errors = 0;
        -: 8060:
    #####: 8061:		  if (num_group_errors ++ < 10)
        -: 8062:		    {
    #####: 8063:		      error (_("section [%5u] in group section [%5u] > maximum section [%5u]\n"),
    #####: 8064:			     entry, i, filedata->file_header.e_shnum - 1);
    #####: 8065:		      if (num_group_errors == 10)
    #####: 8066:			warn (_("Further error messages about overlarge group section indices suppressed\n"));
        -: 8067:		    }
    #####: 8068:		  continue;
        -: 8069:		}
        -: 8070:
    #####: 8071:	      if (filedata->section_headers_groups [entry] != NULL)
        -: 8072:		{
    #####: 8073:		  if (entry)
        -: 8074:		    {
        -: 8075:		      static unsigned num_errs = 0;
        -: 8076:
    #####: 8077:		      if (num_errs ++ < 10)
        -: 8078:			{
    #####: 8079:			  error (_("section [%5u] in group section [%5u] already in group section [%5u]\n"),
        -: 8080:				 entry, i,
    #####: 8081:				 filedata->section_headers_groups [entry]->group_index);
    #####: 8082:			  if (num_errs == 10)
    #####: 8083:			    warn (_("Further error messages about already contained group sections suppressed\n"));
        -: 8084:			}
    #####: 8085:		      continue;
        -: 8086:		    }
        -: 8087:		  else
        -: 8088:		    {
        -: 8089:		      /* Intel C/C++ compiler may put section 0 in a
        -: 8090:			 section group.  We just warn it the first time
        -: 8091:			 and ignore it afterwards.  */
        -: 8092:		      static bool warned = false;
    #####: 8093:		      if (!warned)
        -: 8094:			{
    #####: 8095:			  error (_("section 0 in group section [%5u]\n"),
    #####: 8096:				 filedata->section_headers_groups [entry]->group_index);
    #####: 8097:			  warned = true;
        -: 8098:			}
        -: 8099:		    }
        -: 8100:		}
        -: 8101:
    #####: 8102:	      filedata->section_headers_groups [entry] = group;
        -: 8103:
    #####: 8104:	      if (do_section_groups)
        -: 8105:		{
    #####: 8106:		  sec = filedata->section_headers + entry;
    #####: 8107:		  printf ("   [%5u]   %s\n", entry, printable_section_name (filedata, sec));
        -: 8108:		}
        -: 8109:
    #####: 8110:	      g = (struct group_list *) xmalloc (sizeof (struct group_list));
    #####: 8111:	      g->section_index = entry;
    #####: 8112:	      g->next = group->root;
    #####: 8113:	      group->root = g;
        -: 8114:	    }
        -: 8115:
    #####: 8116:	  free (start);
        -: 8117:
    #####: 8118:	  group++;
        -: 8119:	}
        -: 8120:    }
        -: 8121:
       55: 8122:  free (symtab);
       55: 8123:  free (strtab);
       55: 8124:  return true;
        -: 8125:}
        -: 8126:
        -: 8127:/* Data used to display dynamic fixups.  */
        -: 8128:
        -: 8129:struct ia64_vms_dynfixup
        -: 8130:{
        -: 8131:  bfd_vma needed_ident;		/* Library ident number.  */
        -: 8132:  bfd_vma needed;		/* Index in the dstrtab of the library name.  */
        -: 8133:  bfd_vma fixup_needed;		/* Index of the library.  */
        -: 8134:  bfd_vma fixup_rela_cnt;	/* Number of fixups.  */
        -: 8135:  bfd_vma fixup_rela_off;	/* Fixups offset in the dynamic segment.  */
        -: 8136:};
        -: 8137:
        -: 8138:/* Data used to display dynamic relocations.  */
        -: 8139:
        -: 8140:struct ia64_vms_dynimgrela
        -: 8141:{
        -: 8142:  bfd_vma img_rela_cnt;		/* Number of relocations.  */
        -: 8143:  bfd_vma img_rela_off;		/* Reloc offset in the dynamic segment.  */
        -: 8144:};
        -: 8145:
        -: 8146:/* Display IA-64 OpenVMS dynamic fixups (used to dynamically link a shared
        -: 8147:   library).  */
        -: 8148:
        -: 8149:static bool
    #####: 8150:dump_ia64_vms_dynamic_fixups (Filedata *                  filedata,
        -: 8151:			      struct ia64_vms_dynfixup *  fixup,
        -: 8152:                              const char *                strtab,
        -: 8153:			      unsigned int                strtab_sz)
        -: 8154:{
        -: 8155:  Elf64_External_VMS_IMAGE_FIXUP * imfs;
        -: 8156:  long i;
        -: 8157:  const char * lib_name;
        -: 8158:
    #####: 8159:  imfs = get_data (NULL, filedata,
    #####: 8160:		   filedata->dynamic_addr + fixup->fixup_rela_off,
        -: 8161:		   sizeof (*imfs), fixup->fixup_rela_cnt,
    #####: 8162:		   _("dynamic section image fixups"));
    #####: 8163:  if (!imfs)
    #####: 8164:    return false;
        -: 8165:
    #####: 8166:  if (fixup->needed < strtab_sz)
    #####: 8167:    lib_name = strtab + fixup->needed;
        -: 8168:  else
        -: 8169:    {
    #####: 8170:      warn (_("corrupt library name index of 0x%lx found in dynamic entry"),
    #####: 8171:            (unsigned long) fixup->needed);
    #####: 8172:      lib_name = "???";
        -: 8173:    }
        -: 8174:
    #####: 8175:  printf (_("\nImage fixups for needed library #%d: %s - ident: %lx\n"),
    #####: 8176:	  (int) fixup->fixup_needed, lib_name, (long) fixup->needed_ident);
    #####: 8177:  printf
    #####: 8178:    (_("Seg Offset           Type                             SymVec DataType\n"));
        -: 8179:
    #####: 8180:  for (i = 0; i < (long) fixup->fixup_rela_cnt; i++)
        -: 8181:    {
        -: 8182:      unsigned int type;
        -: 8183:      const char *rtype;
        -: 8184:
    #####: 8185:      printf ("%3u ", (unsigned) BYTE_GET (imfs [i].fixup_seg));
    #####: 8186:      printf_vma ((bfd_vma) BYTE_GET (imfs [i].fixup_offset));
    #####: 8187:      type = BYTE_GET (imfs [i].type);
    #####: 8188:      rtype = elf_ia64_reloc_type (type);
    #####: 8189:      if (rtype == NULL)
    #####: 8190:        printf (" 0x%08x                       ", type);
        -: 8191:      else
    #####: 8192:        printf (" %-32s ", rtype);
    #####: 8193:      printf ("%6u ", (unsigned) BYTE_GET (imfs [i].symvec_index));
    #####: 8194:      printf ("0x%08x\n", (unsigned) BYTE_GET (imfs [i].data_type));
        -: 8195:    }
        -: 8196:
    #####: 8197:  free (imfs);
    #####: 8198:  return true;
        -: 8199:}
        -: 8200:
        -: 8201:/* Display IA-64 OpenVMS dynamic relocations (used to relocate an image).  */
        -: 8202:
        -: 8203:static bool
    #####: 8204:dump_ia64_vms_dynamic_relocs (Filedata * filedata, struct ia64_vms_dynimgrela *imgrela)
        -: 8205:{
        -: 8206:  Elf64_External_VMS_IMAGE_RELA *imrs;
        -: 8207:  long i;
        -: 8208:
    #####: 8209:  imrs = get_data (NULL, filedata,
    #####: 8210:		   filedata->dynamic_addr + imgrela->img_rela_off,
        -: 8211:		   sizeof (*imrs), imgrela->img_rela_cnt,
    #####: 8212:		   _("dynamic section image relocations"));
    #####: 8213:  if (!imrs)
    #####: 8214:    return false;
        -: 8215:
    #####: 8216:  printf (_("\nImage relocs\n"));
    #####: 8217:  printf
    #####: 8218:    (_("Seg Offset   Type                            Addend            Seg Sym Off\n"));
        -: 8219:
    #####: 8220:  for (i = 0; i < (long) imgrela->img_rela_cnt; i++)
        -: 8221:    {
        -: 8222:      unsigned int type;
        -: 8223:      const char *rtype;
        -: 8224:
    #####: 8225:      printf ("%3u ", (unsigned) BYTE_GET (imrs [i].rela_seg));
    #####: 8226:      printf ("%08" BFD_VMA_FMT "x ",
    #####: 8227:              (bfd_vma) BYTE_GET (imrs [i].rela_offset));
    #####: 8228:      type = BYTE_GET (imrs [i].type);
    #####: 8229:      rtype = elf_ia64_reloc_type (type);
    #####: 8230:      if (rtype == NULL)
    #####: 8231:        printf ("0x%08x                      ", type);
        -: 8232:      else
    #####: 8233:        printf ("%-31s ", rtype);
    #####: 8234:      print_vma (BYTE_GET (imrs [i].addend), FULL_HEX);
    #####: 8235:      printf ("%3u ", (unsigned) BYTE_GET (imrs [i].sym_seg));
    #####: 8236:      printf ("%08" BFD_VMA_FMT "x\n",
    #####: 8237:              (bfd_vma) BYTE_GET (imrs [i].sym_offset));
        -: 8238:    }
        -: 8239:
    #####: 8240:  free (imrs);
    #####: 8241:  return true;
        -: 8242:}
        -: 8243:
        -: 8244:/* Display IA-64 OpenVMS dynamic relocations and fixups.  */
        -: 8245:
        -: 8246:static bool
    #####: 8247:process_ia64_vms_dynamic_relocs (Filedata * filedata)
        -: 8248:{
        -: 8249:  struct ia64_vms_dynfixup fixup;
        -: 8250:  struct ia64_vms_dynimgrela imgrela;
        -: 8251:  Elf_Internal_Dyn *entry;
    #####: 8252:  bfd_vma strtab_off = 0;
    #####: 8253:  bfd_vma strtab_sz = 0;
    #####: 8254:  char *strtab = NULL;
    #####: 8255:  bool res = true;
        -: 8256:
    #####: 8257:  memset (&fixup, 0, sizeof (fixup));
    #####: 8258:  memset (&imgrela, 0, sizeof (imgrela));
        -: 8259:
        -: 8260:  /* Note: the order of the entries is specified by the OpenVMS specs.  */
    #####: 8261:  for (entry = filedata->dynamic_section;
    #####: 8262:       entry < filedata->dynamic_section + filedata->dynamic_nent;
    #####: 8263:       entry++)
        -: 8264:    {
    #####: 8265:      switch (entry->d_tag)
        -: 8266:        {
    #####: 8267:        case DT_IA_64_VMS_STRTAB_OFFSET:
    #####: 8268:          strtab_off = entry->d_un.d_val;
    #####: 8269:          break;
    #####: 8270:        case DT_STRSZ:
    #####: 8271:          strtab_sz = entry->d_un.d_val;
    #####: 8272:          if (strtab == NULL)
    #####: 8273:	    strtab = get_data (NULL, filedata,
    #####: 8274:			       filedata->dynamic_addr + strtab_off,
    #####: 8275:                               1, strtab_sz, _("dynamic string section"));
    #####: 8276:	  if (strtab == NULL)
    #####: 8277:	    strtab_sz = 0;
    #####: 8278:          break;
        -: 8279:
    #####: 8280:        case DT_IA_64_VMS_NEEDED_IDENT:
    #####: 8281:          fixup.needed_ident = entry->d_un.d_val;
    #####: 8282:          break;
    #####: 8283:        case DT_NEEDED:
    #####: 8284:          fixup.needed = entry->d_un.d_val;
    #####: 8285:          break;
    #####: 8286:        case DT_IA_64_VMS_FIXUP_NEEDED:
    #####: 8287:          fixup.fixup_needed = entry->d_un.d_val;
    #####: 8288:          break;
    #####: 8289:        case DT_IA_64_VMS_FIXUP_RELA_CNT:
    #####: 8290:          fixup.fixup_rela_cnt = entry->d_un.d_val;
    #####: 8291:          break;
    #####: 8292:        case DT_IA_64_VMS_FIXUP_RELA_OFF:
    #####: 8293:          fixup.fixup_rela_off = entry->d_un.d_val;
    #####: 8294:          if (! dump_ia64_vms_dynamic_fixups (filedata, &fixup, strtab, strtab_sz))
    #####: 8295:	    res = false;
    #####: 8296:          break;
    #####: 8297:        case DT_IA_64_VMS_IMG_RELA_CNT:
    #####: 8298:	  imgrela.img_rela_cnt = entry->d_un.d_val;
    #####: 8299:          break;
    #####: 8300:        case DT_IA_64_VMS_IMG_RELA_OFF:
    #####: 8301:	  imgrela.img_rela_off = entry->d_un.d_val;
    #####: 8302:          if (! dump_ia64_vms_dynamic_relocs (filedata, &imgrela))
    #####: 8303:	    res = false;
    #####: 8304:          break;
        -: 8305:
    #####: 8306:        default:
    #####: 8307:          break;
        -: 8308:	}
        -: 8309:    }
        -: 8310:
    #####: 8311:  free (strtab);
        -: 8312:
    #####: 8313:  return res;
        -: 8314:}
        -: 8315:
        -: 8316:static struct
        -: 8317:{
        -: 8318:  const char * name;
        -: 8319:  int reloc;
        -: 8320:  int size;
        -: 8321:  relocation_type rel_type;
        -: 8322:}
        -: 8323:  dynamic_relocations [] =
        -: 8324:{
        -: 8325:  { "REL", DT_REL, DT_RELSZ, reltype_rel },
        -: 8326:  { "RELA", DT_RELA, DT_RELASZ, reltype_rela },
        -: 8327:  { "RELR", DT_RELR, DT_RELRSZ, reltype_relr },
        -: 8328:  { "PLT", DT_JMPREL, DT_PLTRELSZ, reltype_unknown }
        -: 8329:};
        -: 8330:
        -: 8331:/* Process the reloc section.  */
        -: 8332:
        -: 8333:static bool
     1391: 8334:process_relocs (Filedata * filedata)
        -: 8335:{
        -: 8336:  unsigned long rel_size;
        -: 8337:  unsigned long rel_offset;
        -: 8338:
     1391: 8339:  if (!do_reloc)
     1228: 8340:    return true;
        -: 8341:
      163: 8342:  if (do_using_dynamic)
        -: 8343:    {
        -: 8344:      relocation_type rel_type;
        -: 8345:      const char * name;
        -: 8346:      bool  has_dynamic_reloc;
        -: 8347:      unsigned int i;
        -: 8348:
    #####: 8349:      has_dynamic_reloc = false;
        -: 8350:
    #####: 8351:      for (i = 0; i < ARRAY_SIZE (dynamic_relocations); i++)
        -: 8352:	{
    #####: 8353:	  rel_type = dynamic_relocations [i].rel_type;
    #####: 8354:	  name = dynamic_relocations [i].name;
    #####: 8355:	  rel_size = filedata->dynamic_info[dynamic_relocations [i].size];
    #####: 8356:	  rel_offset = filedata->dynamic_info[dynamic_relocations [i].reloc];
        -: 8357:
    #####: 8358:	  if (rel_size)
    #####: 8359:	    has_dynamic_reloc = true;
        -: 8360:
    #####: 8361:	  if (rel_type == reltype_unknown)
        -: 8362:	    {
    #####: 8363:	      if (dynamic_relocations [i].reloc == DT_JMPREL)
    #####: 8364:		switch (filedata->dynamic_info[DT_PLTREL])
        -: 8365:		  {
    #####: 8366:		  case DT_REL:
    #####: 8367:		    rel_type = reltype_rel;
    #####: 8368:		    break;
    #####: 8369:		  case DT_RELA:
    #####: 8370:		    rel_type = reltype_rela;
    #####: 8371:		    break;
        -: 8372:		  }
    #####: 8373:	    }
        -: 8374:
    #####: 8375:	  if (rel_size)
        -: 8376:	    {
    #####: 8377:	      if (filedata->is_separate)
    #####: 8378:		printf
    #####: 8379:		  (_("\nIn linked file '%s' section '%s' at offset 0x%lx contains %ld bytes:\n"),
        -: 8380:		   filedata->file_name, name, rel_offset, rel_size);
        -: 8381:	      else
    #####: 8382:		printf
    #####: 8383:		  (_("\n'%s' relocation section at offset 0x%lx contains %ld bytes:\n"),
        -: 8384:		   name, rel_offset, rel_size);
        -: 8385:
    #####: 8386:	      dump_relocations (filedata,
    #####: 8387:				offset_from_vma (filedata, rel_offset, rel_size),
        -: 8388:				rel_size,
        -: 8389:				filedata->dynamic_symbols,
        -: 8390:				filedata->num_dynamic_syms,
        -: 8391:				filedata->dynamic_strings,
        -: 8392:				filedata->dynamic_strings_length,
        -: 8393:				rel_type, true /* is_dynamic */);
        -: 8394:	    }
        -: 8395:	}
        -: 8396:
    #####: 8397:      if (is_ia64_vms (filedata))
    #####: 8398:        if (process_ia64_vms_dynamic_relocs (filedata))
    #####: 8399:	  has_dynamic_reloc = true;
        -: 8400:
    #####: 8401:      if (! has_dynamic_reloc)
        -: 8402:	{
    #####: 8403:	  if (filedata->is_separate)
    #####: 8404:	    printf (_("\nThere are no dynamic relocations in linked file '%s'.\n"),
        -: 8405:		    filedata->file_name);
        -: 8406:	  else
    #####: 8407:	    printf (_("\nThere are no dynamic relocations in this file.\n"));
        -: 8408:	}
        -: 8409:    }
        -: 8410:  else
        -: 8411:    {
        -: 8412:      Elf_Internal_Shdr * section;
        -: 8413:      unsigned long i;
      163: 8414:      bool found = false;
        -: 8415:
      163: 8416:      for (i = 0, section = filedata->section_headers;
      807: 8417:	   i < filedata->file_header.e_shnum;
      644: 8418:	   i++, section++)
        -: 8419:	{
      644: 8420:	  if (   section->sh_type != SHT_RELA
      639: 8421:	      && section->sh_type != SHT_REL
      625: 8422:	      && section->sh_type != SHT_RELR)
      622: 8423:	    continue;
        -: 8424:
       22: 8425:	  rel_offset = section->sh_offset;
       22: 8426:	  rel_size   = section->sh_size;
        -: 8427:
       22: 8428:	  if (rel_size)
        -: 8429:	    {
        -: 8430:	      relocation_type rel_type;
        -: 8431:	      unsigned long num_rela;
        -: 8432:
       20: 8433:	      if (filedata->is_separate)
    #####: 8434:		printf (_("\nIn linked file '%s' relocation section "),
        -: 8435:			filedata->file_name);
        -: 8436:	      else
       20: 8437:		printf (_("\nRelocation section "));
        -: 8438:
       20: 8439:	      if (filedata->string_table == NULL)
        2: 8440:		printf ("%d", section->sh_name);
        -: 8441:	      else
       18: 8442:		printf ("'%s'", printable_section_name (filedata, section));
        -: 8443:
       20: 8444:	      num_rela = rel_size / section->sh_entsize;
       20: 8445:	      printf (ngettext (" at offset 0x%lx contains %lu entry:\n",
        -: 8446:				" at offset 0x%lx contains %lu entries:\n",
        -: 8447:				num_rela),
        -: 8448:		      rel_offset, num_rela);
        -: 8449:
       37: 8450:	      rel_type = section->sh_type == SHT_RELA ? reltype_rela :
       17: 8451:		section->sh_type == SHT_REL ? reltype_rel : reltype_relr;
        -: 8452:
       20: 8453:	      if (section->sh_link != 0
        3: 8454:		  && section->sh_link < filedata->file_header.e_shnum)
    #####: 8455:		{
        -: 8456:		  Elf_Internal_Shdr * symsec;
        -: 8457:		  Elf_Internal_Sym *  symtab;
        -: 8458:		  unsigned long nsyms;
    #####: 8459:		  unsigned long strtablen = 0;
    #####: 8460:		  char * strtab = NULL;
        -: 8461:
    #####: 8462:		  symsec = filedata->section_headers + section->sh_link;
    #####: 8463:		  if (symsec->sh_type != SHT_SYMTAB
    #####: 8464:		      && symsec->sh_type != SHT_DYNSYM)
    #####: 8465:                    continue;
        -: 8466:
    #####: 8467:		  if (!get_symtab (filedata, symsec,
        -: 8468:				   &symtab, &nsyms, &strtab, &strtablen))
    #####: 8469:		    continue;
        -: 8470:
    #####: 8471:		  dump_relocations (filedata, rel_offset, rel_size,
        -: 8472:				    symtab, nsyms, strtab, strtablen,
        -: 8473:				    rel_type,
    #####: 8474:				    symsec->sh_type == SHT_DYNSYM);
    #####: 8475:		  free (strtab);
    #####: 8476:		  free (symtab);
        -: 8477:		}
        -: 8478:	      else
       20: 8479:		dump_relocations (filedata, rel_offset, rel_size,
        -: 8480:				  NULL, 0, NULL, 0, rel_type, false /* is_dynamic */);
        -: 8481:
       20: 8482:	      found = true;
        -: 8483:	    }
        -: 8484:	}
        -: 8485:
      163: 8486:      if (! found)
        -: 8487:	{
        -: 8488:	  /* Users sometimes forget the -D option, so try to be helpful.  */
      715: 8489:	  for (i = 0; i < ARRAY_SIZE (dynamic_relocations); i++)
        -: 8490:	    {
      572: 8491:	      if (filedata->dynamic_info[dynamic_relocations [i].size])
        -: 8492:		{
    #####: 8493:		  if (filedata->is_separate)
    #####: 8494:		    printf (_("\nThere are no static relocations in linked file '%s'."),
        -: 8495:			    filedata->file_name);
        -: 8496:		  else
    #####: 8497:		    printf (_("\nThere are no static relocations in this file."));
    #####: 8498:		  printf (_("\nTo see the dynamic relocations add --use-dynamic to the command line.\n"));
        -: 8499:
    #####: 8500:		  break;
        -: 8501:		}
        -: 8502:	    }
      143: 8503:	  if (i == ARRAY_SIZE (dynamic_relocations))
        -: 8504:	    {
      143: 8505:	      if (filedata->is_separate)
    #####: 8506:		printf (_("\nThere are no relocations in linked file '%s'.\n"),
        -: 8507:			filedata->file_name);
        -: 8508:	      else
      143: 8509:		printf (_("\nThere are no relocations in this file.\n"));
        -: 8510:	    }
        -: 8511:	}
        -: 8512:    }
        -: 8513:
      163: 8514:  return true;
        -: 8515:}
        -: 8516:
        -: 8517:/* An absolute address consists of a section and an offset.  If the
        -: 8518:   section is NULL, the offset itself is the address, otherwise, the
        -: 8519:   address equals to LOAD_ADDRESS(section) + offset.  */
        -: 8520:
        -: 8521:struct absaddr
        -: 8522:{
        -: 8523:  unsigned short section;
        -: 8524:  bfd_vma offset;
        -: 8525:};
        -: 8526:
        -: 8527:/* Find the nearest symbol at or below ADDR.  Returns the symbol
        -: 8528:   name, if found, and the offset from the symbol to ADDR.  */
        -: 8529:
        -: 8530:static void
    #####: 8531:find_symbol_for_address (Filedata *          filedata,
        -: 8532:			 Elf_Internal_Sym *  symtab,
        -: 8533:			 unsigned long       nsyms,
        -: 8534:			 const char *        strtab,
        -: 8535:			 unsigned long       strtab_size,
        -: 8536:			 struct absaddr      addr,
        -: 8537:			 const char **       symname,
        -: 8538:			 bfd_vma *           offset)
        -: 8539:{
    #####: 8540:  bfd_vma dist = 0x100000;
        -: 8541:  Elf_Internal_Sym * sym;
        -: 8542:  Elf_Internal_Sym * beg;
        -: 8543:  Elf_Internal_Sym * end;
    #####: 8544:  Elf_Internal_Sym * best = NULL;
        -: 8545:
    #####: 8546:  REMOVE_ARCH_BITS (addr.offset);
    #####: 8547:  beg = symtab;
    #####: 8548:  end = symtab + nsyms;
        -: 8549:
    #####: 8550:  while (beg < end)
        -: 8551:    {
        -: 8552:      bfd_vma value;
        -: 8553:
    #####: 8554:      sym = beg + (end - beg) / 2;
        -: 8555:
    #####: 8556:      value = sym->st_value;
    #####: 8557:      REMOVE_ARCH_BITS (value);
        -: 8558:
    #####: 8559:      if (sym->st_name != 0
    #####: 8560:	  && (addr.section == SHN_UNDEF || addr.section == sym->st_shndx)
    #####: 8561:	  && addr.offset >= value
    #####: 8562:	  && addr.offset - value < dist)
        -: 8563:	{
    #####: 8564:	  best = sym;
    #####: 8565:	  dist = addr.offset - value;
    #####: 8566:	  if (!dist)
    #####: 8567:	    break;
        -: 8568:	}
        -: 8569:
    #####: 8570:      if (addr.offset < value)
    #####: 8571:	end = sym;
        -: 8572:      else
    #####: 8573:	beg = sym + 1;
        -: 8574:    }
        -: 8575:
    #####: 8576:  if (best)
        -: 8577:    {
    #####: 8578:      *symname = (best->st_name >= strtab_size
    #####: 8579:		  ? _("<corrupt>") : strtab + best->st_name);
    #####: 8580:      *offset = dist;
    #####: 8581:      return;
        -: 8582:    }
        -: 8583:
    #####: 8584:  *symname = NULL;
    #####: 8585:  *offset = addr.offset;
        -: 8586:}
        -: 8587:
        -: 8588:static /* signed */ int
    #####: 8589:symcmp (const void *p, const void *q)
        -: 8590:{
    #####: 8591:  Elf_Internal_Sym *sp = (Elf_Internal_Sym *) p;
    #####: 8592:  Elf_Internal_Sym *sq = (Elf_Internal_Sym *) q;
        -: 8593:
    #####: 8594:  return sp->st_value > sq->st_value ? 1 : (sp->st_value < sq->st_value ? -1 : 0);
        -: 8595:}
        -: 8596:
        -: 8597:/* Process the unwind section.  */
        -: 8598:
        -: 8599:#include "unwind-ia64.h"
        -: 8600:
        -: 8601:struct ia64_unw_table_entry
        -: 8602:{
        -: 8603:  struct absaddr start;
        -: 8604:  struct absaddr end;
        -: 8605:  struct absaddr info;
        -: 8606:};
        -: 8607:
        -: 8608:struct ia64_unw_aux_info
        -: 8609:{
        -: 8610:  struct ia64_unw_table_entry * table;		/* Unwind table.  */
        -: 8611:  unsigned long                 table_len;	/* Length of unwind table.  */
        -: 8612:  unsigned char *               info;		/* Unwind info.  */
        -: 8613:  unsigned long                 info_size;	/* Size of unwind info.  */
        -: 8614:  bfd_vma                       info_addr;	/* Starting address of unwind info.  */
        -: 8615:  bfd_vma                       seg_base;	/* Starting address of segment.  */
        -: 8616:  Elf_Internal_Sym *            symtab;		/* The symbol table.  */
        -: 8617:  unsigned long                 nsyms;		/* Number of symbols.  */
        -: 8618:  Elf_Internal_Sym *            funtab;		/* Sorted table of STT_FUNC symbols.  */
        -: 8619:  unsigned long                 nfuns;		/* Number of entries in funtab.  */
        -: 8620:  char *                        strtab;		/* The string table.  */
        -: 8621:  unsigned long                 strtab_size;	/* Size of string table.  */
        -: 8622:};
        -: 8623:
        -: 8624:static bool
    #####: 8625:dump_ia64_unwind (Filedata * filedata, struct ia64_unw_aux_info * aux)
        -: 8626:{
        -: 8627:  struct ia64_unw_table_entry * tp;
        -: 8628:  unsigned long j, nfuns;
        -: 8629:  int in_body;
    #####: 8630:  bool res = true;
        -: 8631:
    #####: 8632:  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
    #####: 8633:  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
    #####: 8634:    if (aux->symtab[j].st_value && ELF_ST_TYPE (aux->symtab[j].st_info) == STT_FUNC)
    #####: 8635:      aux->funtab[nfuns++] = aux->symtab[j];
    #####: 8636:  aux->nfuns = nfuns;
    #####: 8637:  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);
        -: 8638:
    #####: 8639:  for (tp = aux->table; tp < aux->table + aux->table_len; ++tp)
        -: 8640:    {
        -: 8641:      bfd_vma stamp;
        -: 8642:      bfd_vma offset;
        -: 8643:      const unsigned char * dp;
        -: 8644:      const unsigned char * head;
        -: 8645:      const unsigned char * end;
        -: 8646:      const char * procname;
        -: 8647:
    #####: 8648:      find_symbol_for_address (filedata, aux->funtab, aux->nfuns, aux->strtab,
        -: 8649:			       aux->strtab_size, tp->start, &procname, &offset);
        -: 8650:
    #####: 8651:      fputs ("\n<", stdout);
        -: 8652:
    #####: 8653:      if (procname)
        -: 8654:	{
    #####: 8655:	  fputs (procname, stdout);
        -: 8656:
    #####: 8657:	  if (offset)
    #####: 8658:	    printf ("+%lx", (unsigned long) offset);
        -: 8659:	}
        -: 8660:
    #####: 8661:      fputs (">: [", stdout);
    #####: 8662:      print_vma (tp->start.offset, PREFIX_HEX);
    #####: 8663:      fputc ('-', stdout);
    #####: 8664:      print_vma (tp->end.offset, PREFIX_HEX);
    #####: 8665:      printf ("], info at +0x%lx\n",
    #####: 8666:	      (unsigned long) (tp->info.offset - aux->seg_base));
        -: 8667:
        -: 8668:      /* PR 17531: file: 86232b32.  */
    #####: 8669:      if (aux->info == NULL)
    #####: 8670:	continue;
        -: 8671:
    #####: 8672:      offset = tp->info.offset;
    #####: 8673:      if (tp->info.section)
        -: 8674:	{
    #####: 8675:	  if (tp->info.section >= filedata->file_header.e_shnum)
        -: 8676:	    {
    #####: 8677:	      warn (_("Invalid section %u in table entry %ld\n"),
    #####: 8678:		    tp->info.section, (long) (tp - aux->table));
    #####: 8679:	      res = false;
    #####: 8680:	      continue;
        -: 8681:	    }
    #####: 8682:	  offset += filedata->section_headers[tp->info.section].sh_addr;
        -: 8683:	}
    #####: 8684:      offset -= aux->info_addr;
        -: 8685:      /* PR 17531: file: 0997b4d1.  */
    #####: 8686:      if (offset >= aux->info_size
    #####: 8687:	  || aux->info_size - offset < 8)
        -: 8688:	{
    #####: 8689:	  warn (_("Invalid offset %lx in table entry %ld\n"),
    #####: 8690:		(long) tp->info.offset, (long) (tp - aux->table));
    #####: 8691:	  res = false;
    #####: 8692:	  continue;
        -: 8693:	}
        -: 8694:
    #####: 8695:      head = aux->info + offset;
    #####: 8696:      stamp = byte_get ((unsigned char *) head, sizeof (stamp));
        -: 8697:
    #####: 8698:      printf ("  v%u, flags=0x%lx (%s%s), len=%lu bytes\n",
    #####: 8699:	      (unsigned) UNW_VER (stamp),
    #####: 8700:	      (unsigned long) ((stamp & UNW_FLAG_MASK) >> 32),
    #####: 8701:	      UNW_FLAG_EHANDLER (stamp) ? " ehandler" : "",
    #####: 8702:	      UNW_FLAG_UHANDLER (stamp) ? " uhandler" : "",
    #####: 8703:	      (unsigned long) (eh_addr_size * UNW_LENGTH (stamp)));
        -: 8704:
    #####: 8705:      if (UNW_VER (stamp) != 1)
        -: 8706:	{
    #####: 8707:	  printf (_("\tUnknown version.\n"));
    #####: 8708:	  continue;
        -: 8709:	}
        -: 8710:
    #####: 8711:      in_body = 0;
    #####: 8712:      end = head + 8 + eh_addr_size * UNW_LENGTH (stamp);
        -: 8713:      /* PR 17531: file: 16ceda89.  */
    #####: 8714:      if (end > aux->info + aux->info_size)
    #####: 8715:	end = aux->info + aux->info_size;
    #####: 8716:      for (dp = head + 8; dp < end;)
    #####: 8717:	dp = unw_decode (dp, in_body, & in_body, end);
        -: 8718:    }
        -: 8719:
    #####: 8720:  free (aux->funtab);
        -: 8721:
    #####: 8722:  return res;
        -: 8723:}
        -: 8724:
        -: 8725:static bool
    #####: 8726:slurp_ia64_unwind_table (Filedata *                  filedata,
        -: 8727:			 struct ia64_unw_aux_info *  aux,
        -: 8728:			 Elf_Internal_Shdr *         sec)
        -: 8729:{
        -: 8730:  unsigned long size, nrelas, i;
        -: 8731:  Elf_Internal_Phdr * seg;
        -: 8732:  struct ia64_unw_table_entry * tep;
        -: 8733:  Elf_Internal_Shdr * relsec;
        -: 8734:  Elf_Internal_Rela * rela;
        -: 8735:  Elf_Internal_Rela * rp;
        -: 8736:  unsigned char * table;
        -: 8737:  unsigned char * tp;
        -: 8738:  Elf_Internal_Sym * sym;
        -: 8739:  const char * relname;
        -: 8740:
    #####: 8741:  aux->table_len = 0;
        -: 8742:
        -: 8743:  /* First, find the starting address of the segment that includes
        -: 8744:     this section: */
        -: 8745:
    #####: 8746:  if (filedata->file_header.e_phnum)
        -: 8747:    {
    #####: 8748:      if (! get_program_headers (filedata))
    #####: 8749:	  return false;
        -: 8750:
    #####: 8751:      for (seg = filedata->program_headers;
    #####: 8752:	   seg < filedata->program_headers + filedata->file_header.e_phnum;
    #####: 8753:	   ++seg)
        -: 8754:	{
    #####: 8755:	  if (seg->p_type != PT_LOAD)
    #####: 8756:	    continue;
        -: 8757:
    #####: 8758:	  if (sec->sh_addr >= seg->p_vaddr
    #####: 8759:	      && (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz))
        -: 8760:	    {
    #####: 8761:	      aux->seg_base = seg->p_vaddr;
    #####: 8762:	      break;
        -: 8763:	    }
        -: 8764:	}
        -: 8765:    }
        -: 8766:
        -: 8767:  /* Second, build the unwind table from the contents of the unwind section:  */
    #####: 8768:  size = sec->sh_size;
    #####: 8769:  table = (unsigned char *) get_data (NULL, filedata, sec->sh_offset, 1, size,
    #####: 8770:                                      _("unwind table"));
    #####: 8771:  if (!table)
    #####: 8772:    return false;
        -: 8773:
    #####: 8774:  aux->table_len = size / (3 * eh_addr_size);
    #####: 8775:  aux->table = (struct ia64_unw_table_entry *)
    #####: 8776:    xcmalloc (aux->table_len, sizeof (aux->table[0]));
    #####: 8777:  tep = aux->table;
        -: 8778:
    #####: 8779:  for (tp = table; tp <= table + size - (3 * eh_addr_size); ++tep)
        -: 8780:    {
    #####: 8781:      tep->start.section = SHN_UNDEF;
    #####: 8782:      tep->end.section   = SHN_UNDEF;
    #####: 8783:      tep->info.section  = SHN_UNDEF;
    #####: 8784:      tep->start.offset = byte_get (tp, eh_addr_size); tp += eh_addr_size;
    #####: 8785:      tep->end.offset   = byte_get (tp, eh_addr_size); tp += eh_addr_size;
    #####: 8786:      tep->info.offset  = byte_get (tp, eh_addr_size); tp += eh_addr_size;
    #####: 8787:      tep->start.offset += aux->seg_base;
    #####: 8788:      tep->end.offset   += aux->seg_base;
    #####: 8789:      tep->info.offset  += aux->seg_base;
        -: 8790:    }
    #####: 8791:  free (table);
        -: 8792:
        -: 8793:  /* Third, apply any relocations to the unwind table:  */
    #####: 8794:  for (relsec = filedata->section_headers;
    #####: 8795:       relsec < filedata->section_headers + filedata->file_header.e_shnum;
    #####: 8796:       ++relsec)
        -: 8797:    {
    #####: 8798:      if (relsec->sh_type != SHT_RELA
    #####: 8799:	  || relsec->sh_info >= filedata->file_header.e_shnum
    #####: 8800:	  || filedata->section_headers + relsec->sh_info != sec)
    #####: 8801:	continue;
        -: 8802:
    #####: 8803:      if (!slurp_rela_relocs (filedata, relsec->sh_offset, relsec->sh_size,
        -: 8804:			      & rela, & nrelas))
        -: 8805:	{
    #####: 8806:	  free (aux->table);
    #####: 8807:	  aux->table = NULL;
    #####: 8808:	  aux->table_len = 0;
    #####: 8809:	  return false;
        -: 8810:	}
        -: 8811:
    #####: 8812:      for (rp = rela; rp < rela + nrelas; ++rp)
        -: 8813:	{
        -: 8814:	  unsigned int sym_ndx;
    #####: 8815:	  unsigned int r_type = get_reloc_type (filedata, rp->r_info);
    #####: 8816:	  relname = elf_ia64_reloc_type (r_type);
        -: 8817:
        -: 8818:	  /* PR 17531: file: 9fa67536.  */
    #####: 8819:	  if (relname == NULL)
        -: 8820:	    {
    #####: 8821:	      warn (_("Skipping unknown relocation type: %u\n"), r_type);
    #####: 8822:	      continue;
        -: 8823:	    }
        -: 8824:
    #####: 8825:	  if (! startswith (relname, "R_IA64_SEGREL"))
        -: 8826:	    {
    #####: 8827:	      warn (_("Skipping unexpected relocation type: %s\n"), relname);
    #####: 8828:	      continue;
        -: 8829:	    }
        -: 8830:
    #####: 8831:	  i = rp->r_offset / (3 * eh_addr_size);
        -: 8832:
        -: 8833:	  /* PR 17531: file: 5bc8d9bf.  */
    #####: 8834:	  if (i >= aux->table_len)
        -: 8835:	    {
    #####: 8836:	      warn (_("Skipping reloc with overlarge offset: %lx\n"), i);
    #####: 8837:	      continue;
        -: 8838:	    }
        -: 8839:
    #####: 8840:	  sym_ndx = get_reloc_symindex (rp->r_info);
    #####: 8841:	  if (sym_ndx >= aux->nsyms)
        -: 8842:	    {
    #####: 8843:	      warn (_("Skipping reloc with invalid symbol index: %u\n"),
        -: 8844:		    sym_ndx);
    #####: 8845:	      continue;
        -: 8846:	    }
    #####: 8847:	  sym = aux->symtab + sym_ndx;
        -: 8848:
    #####: 8849:	  switch (rp->r_offset / eh_addr_size % 3)
        -: 8850:	    {
    #####: 8851:	    case 0:
    #####: 8852:	      aux->table[i].start.section = sym->st_shndx;
    #####: 8853:	      aux->table[i].start.offset  = rp->r_addend + sym->st_value;
    #####: 8854:	      break;
    #####: 8855:	    case 1:
    #####: 8856:	      aux->table[i].end.section   = sym->st_shndx;
    #####: 8857:	      aux->table[i].end.offset    = rp->r_addend + sym->st_value;
    #####: 8858:	      break;
    #####: 8859:	    case 2:
    #####: 8860:	      aux->table[i].info.section  = sym->st_shndx;
    #####: 8861:	      aux->table[i].info.offset   = rp->r_addend + sym->st_value;
    #####: 8862:	      break;
    #####: 8863:	    default:
    #####: 8864:	      break;
        -: 8865:	    }
        -: 8866:	}
        -: 8867:
    #####: 8868:      free (rela);
        -: 8869:    }
        -: 8870:
    #####: 8871:  return true;
        -: 8872:}
        -: 8873:
        -: 8874:static bool
    #####: 8875:ia64_process_unwind (Filedata * filedata)
        -: 8876:{
        -: 8877:  Elf_Internal_Shdr * sec;
    #####: 8878:  Elf_Internal_Shdr * unwsec = NULL;
    #####: 8879:  unsigned long i, unwcount = 0, unwstart = 0;
        -: 8880:  struct ia64_unw_aux_info aux;
    #####: 8881:  bool res = true;
        -: 8882:
    #####: 8883:  memset (& aux, 0, sizeof (aux));
        -: 8884:
    #####: 8885:  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
        -: 8886:    {
    #####: 8887:      if (sec->sh_type == SHT_SYMTAB)
        -: 8888:	{
    #####: 8889:	  if (aux.symtab)
        -: 8890:	    {
    #####: 8891:	      error (_("Multiple symbol tables encountered\n"));
    #####: 8892:	      free (aux.symtab);
    #####: 8893:	      aux.symtab = NULL;
    #####: 8894:	      free (aux.strtab);
    #####: 8895:	      aux.strtab = NULL;
        -: 8896:	    }
    #####: 8897:	  if (!get_symtab (filedata, sec, &aux.symtab, &aux.nsyms,
        -: 8898:			   &aux.strtab, &aux.strtab_size))
    #####: 8899:	    return false;
        -: 8900:	}
    #####: 8901:      else if (sec->sh_type == SHT_IA_64_UNWIND)
    #####: 8902:	unwcount++;
        -: 8903:    }
        -: 8904:
    #####: 8905:  if (!unwcount)
    #####: 8906:    printf (_("\nThere are no unwind sections in this file.\n"));
        -: 8907:
    #####: 8908:  while (unwcount-- > 0)
        -: 8909:    {
        -: 8910:      const char *suffix;
        -: 8911:      size_t len, len2;
        -: 8912:
    #####: 8913:      for (i = unwstart, sec = filedata->section_headers + unwstart, unwsec = NULL;
    #####: 8914:	   i < filedata->file_header.e_shnum; ++i, ++sec)
    #####: 8915:	if (sec->sh_type == SHT_IA_64_UNWIND)
        -: 8916:	  {
    #####: 8917:	    unwsec = sec;
    #####: 8918:	    break;
        -: 8919:	  }
        -: 8920:      /* We have already counted the number of SHT_IA64_UNWIND
        -: 8921:	 sections so the loop above should never fail.  */
    #####: 8922:      assert (unwsec != NULL);
        -: 8923:
    #####: 8924:      unwstart = i + 1;
    #####: 8925:      len = sizeof (ELF_STRING_ia64_unwind_once) - 1;
        -: 8926:
    #####: 8927:      if ((unwsec->sh_flags & SHF_GROUP) != 0)
        -: 8928:	{
        -: 8929:	  /* We need to find which section group it is in.  */
        -: 8930:	  struct group_list * g;
        -: 8931:
    #####: 8932:	  if (filedata->section_headers_groups == NULL
    #####: 8933:	      || filedata->section_headers_groups[i] == NULL)
    #####: 8934:	    i = filedata->file_header.e_shnum;
        -: 8935:	  else
        -: 8936:	    {
    #####: 8937:	      g = filedata->section_headers_groups[i]->root;
        -: 8938:
    #####: 8939:	      for (; g != NULL; g = g->next)
        -: 8940:		{
    #####: 8941:		  sec = filedata->section_headers + g->section_index;
        -: 8942:
    #####: 8943:		  if (section_name_valid (filedata, sec)
    #####: 8944:		      && streq (section_name (filedata, sec),
        -: 8945:				ELF_STRING_ia64_unwind_info))
    #####: 8946:		    break;
        -: 8947:		}
        -: 8948:
    #####: 8949:	      if (g == NULL)
    #####: 8950:		i = filedata->file_header.e_shnum;
        -: 8951:	    }
        -: 8952:	}
    #####: 8953:      else if (section_name_valid (filedata, unwsec)
    #####: 8954:	       && startswith (section_name (filedata, unwsec),
        -: 8955:			      ELF_STRING_ia64_unwind_once))
        -: 8956:	{
        -: 8957:	  /* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.ia64unwi.FOO.  */
    #####: 8958:	  len2 = sizeof (ELF_STRING_ia64_unwind_info_once) - 1;
    #####: 8959:	  suffix = section_name (filedata, unwsec) + len;
    #####: 8960:	  for (i = 0, sec = filedata->section_headers;
    #####: 8961:	       i < filedata->file_header.e_shnum;
    #####: 8962:	       ++i, ++sec)
    #####: 8963:	    if (section_name_valid (filedata, sec)
    #####: 8964:		&& startswith (section_name (filedata, sec),
        -: 8965:			       ELF_STRING_ia64_unwind_info_once)
    #####: 8966:		&& streq (section_name (filedata, sec) + len2, suffix))
    #####: 8967:	      break;
        -: 8968:	}
        -: 8969:      else
        -: 8970:	{
        -: 8971:	  /* .IA_64.unwindFOO -> .IA_64.unwind_infoFOO
        -: 8972:	     .IA_64.unwind or BAR -> .IA_64.unwind_info.  */
    #####: 8973:	  len = sizeof (ELF_STRING_ia64_unwind) - 1;
    #####: 8974:	  len2 = sizeof (ELF_STRING_ia64_unwind_info) - 1;
    #####: 8975:	  suffix = "";
    #####: 8976:	  if (section_name_valid (filedata, unwsec)
    #####: 8977:	      && startswith (section_name (filedata, unwsec),
        -: 8978:			     ELF_STRING_ia64_unwind))
    #####: 8979:	    suffix = section_name (filedata, unwsec) + len;
    #####: 8980:	  for (i = 0, sec = filedata->section_headers;
    #####: 8981:	       i < filedata->file_header.e_shnum;
    #####: 8982:	       ++i, ++sec)
    #####: 8983:	    if (section_name_valid (filedata, sec)
    #####: 8984:		&& startswith (section_name (filedata, sec),
        -: 8985:			       ELF_STRING_ia64_unwind_info)
    #####: 8986:		&& streq (section_name (filedata, sec) + len2, suffix))
    #####: 8987:	      break;
        -: 8988:	}
        -: 8989:
    #####: 8990:      if (i == filedata->file_header.e_shnum)
        -: 8991:	{
    #####: 8992:	  printf (_("\nCould not find unwind info section for "));
        -: 8993:
    #####: 8994:	  if (filedata->string_table == NULL)
    #####: 8995:	    printf ("%d", unwsec->sh_name);
        -: 8996:	  else
    #####: 8997:	    printf ("'%s'", printable_section_name (filedata, unwsec));
        -: 8998:	}
        -: 8999:      else
        -: 9000:	{
    #####: 9001:	  aux.info_addr = sec->sh_addr;
    #####: 9002:	  aux.info = (unsigned char *) get_data (NULL, filedata, sec->sh_offset, 1,
        -: 9003:						 sec->sh_size,
    #####: 9004:						 _("unwind info"));
    #####: 9005:	  aux.info_size = aux.info == NULL ? 0 : sec->sh_size;
        -: 9006:
    #####: 9007:	  printf (_("\nUnwind section "));
        -: 9008:
    #####: 9009:	  if (filedata->string_table == NULL)
    #####: 9010:	    printf ("%d", unwsec->sh_name);
        -: 9011:	  else
    #####: 9012:	    printf ("'%s'", printable_section_name (filedata, unwsec));
        -: 9013:
    #####: 9014:	  printf (_(" at offset 0x%lx contains %lu entries:\n"),
    #####: 9015:		  (unsigned long) unwsec->sh_offset,
    #####: 9016:		  (unsigned long) (unwsec->sh_size / (3 * eh_addr_size)));
        -: 9017:
    #####: 9018:	  if (slurp_ia64_unwind_table (filedata, & aux, unwsec)
    #####: 9019:	      && aux.table_len > 0)
    #####: 9020:	    dump_ia64_unwind (filedata, & aux);
        -: 9021:
    #####: 9022:	  free ((char *) aux.table);
    #####: 9023:	  free ((char *) aux.info);
    #####: 9024:	  aux.table = NULL;
    #####: 9025:	  aux.info = NULL;
        -: 9026:	}
        -: 9027:    }
        -: 9028:
    #####: 9029:  free (aux.symtab);
    #####: 9030:  free ((char *) aux.strtab);
        -: 9031:
    #####: 9032:  return res;
        -: 9033:}
        -: 9034:
        -: 9035:struct hppa_unw_table_entry
        -: 9036:{
        -: 9037:  struct absaddr start;
        -: 9038:  struct absaddr end;
        -: 9039:  unsigned int Cannot_unwind:1;			/* 0 */
        -: 9040:  unsigned int Millicode:1;			/* 1 */
        -: 9041:  unsigned int Millicode_save_sr0:1;		/* 2 */
        -: 9042:  unsigned int Region_description:2;		/* 3..4 */
        -: 9043:  unsigned int reserved1:1;			/* 5 */
        -: 9044:  unsigned int Entry_SR:1;			/* 6 */
        -: 9045:  unsigned int Entry_FR:4;     /* Number saved     7..10 */
        -: 9046:  unsigned int Entry_GR:5;     /* Number saved     11..15 */
        -: 9047:  unsigned int Args_stored:1;			/* 16 */
        -: 9048:  unsigned int Variable_Frame:1;		/* 17 */
        -: 9049:  unsigned int Separate_Package_Body:1;		/* 18 */
        -: 9050:  unsigned int Frame_Extension_Millicode:1;	/* 19 */
        -: 9051:  unsigned int Stack_Overflow_Check:1;		/* 20 */
        -: 9052:  unsigned int Two_Instruction_SP_Increment:1;	/* 21 */
        -: 9053:  unsigned int Ada_Region:1;			/* 22 */
        -: 9054:  unsigned int cxx_info:1;			/* 23 */
        -: 9055:  unsigned int cxx_try_catch:1;			/* 24 */
        -: 9056:  unsigned int sched_entry_seq:1;		/* 25 */
        -: 9057:  unsigned int reserved2:1;			/* 26 */
        -: 9058:  unsigned int Save_SP:1;			/* 27 */
        -: 9059:  unsigned int Save_RP:1;			/* 28 */
        -: 9060:  unsigned int Save_MRP_in_frame:1;		/* 29 */
        -: 9061:  unsigned int extn_ptr_defined:1;		/* 30 */
        -: 9062:  unsigned int Cleanup_defined:1;		/* 31 */
        -: 9063:
        -: 9064:  unsigned int MPE_XL_interrupt_marker:1;	/* 0 */
        -: 9065:  unsigned int HP_UX_interrupt_marker:1;	/* 1 */
        -: 9066:  unsigned int Large_frame:1;			/* 2 */
        -: 9067:  unsigned int Pseudo_SP_Set:1;			/* 3 */
        -: 9068:  unsigned int reserved4:1;			/* 4 */
        -: 9069:  unsigned int Total_frame_size:27;		/* 5..31 */
        -: 9070:};
        -: 9071:
        -: 9072:struct hppa_unw_aux_info
        -: 9073:{
        -: 9074:  struct hppa_unw_table_entry *  table;		/* Unwind table.  */
        -: 9075:  unsigned long                  table_len;	/* Length of unwind table.  */
        -: 9076:  bfd_vma                        seg_base;	/* Starting address of segment.  */
        -: 9077:  Elf_Internal_Sym *             symtab;	/* The symbol table.  */
        -: 9078:  unsigned long                  nsyms;		/* Number of symbols.  */
        -: 9079:  Elf_Internal_Sym *             funtab;	/* Sorted table of STT_FUNC symbols.  */
        -: 9080:  unsigned long                  nfuns;		/* Number of entries in funtab.  */
        -: 9081:  char *                         strtab;	/* The string table.  */
        -: 9082:  unsigned long                  strtab_size;	/* Size of string table.  */
        -: 9083:};
        -: 9084:
        -: 9085:static bool
    #####: 9086:dump_hppa_unwind (Filedata * filedata, struct hppa_unw_aux_info * aux)
        -: 9087:{
        -: 9088:  struct hppa_unw_table_entry * tp;
        -: 9089:  unsigned long j, nfuns;
    #####: 9090:  bool res = true;
        -: 9091:
    #####: 9092:  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
    #####: 9093:  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
    #####: 9094:    if (aux->symtab[j].st_value && ELF_ST_TYPE (aux->symtab[j].st_info) == STT_FUNC)
    #####: 9095:      aux->funtab[nfuns++] = aux->symtab[j];
    #####: 9096:  aux->nfuns = nfuns;
    #####: 9097:  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);
        -: 9098:
    #####: 9099:  for (tp = aux->table; tp < aux->table + aux->table_len; ++tp)
        -: 9100:    {
        -: 9101:      bfd_vma offset;
        -: 9102:      const char * procname;
        -: 9103:
    #####: 9104:      find_symbol_for_address (filedata, aux->funtab, aux->nfuns, aux->strtab,
        -: 9105:			       aux->strtab_size, tp->start, &procname,
        -: 9106:			       &offset);
        -: 9107:
    #####: 9108:      fputs ("\n<", stdout);
        -: 9109:
    #####: 9110:      if (procname)
        -: 9111:	{
    #####: 9112:	  fputs (procname, stdout);
        -: 9113:
    #####: 9114:	  if (offset)
    #####: 9115:	    printf ("+%lx", (unsigned long) offset);
        -: 9116:	}
        -: 9117:
    #####: 9118:      fputs (">: [", stdout);
    #####: 9119:      print_vma (tp->start.offset, PREFIX_HEX);
    #####: 9120:      fputc ('-', stdout);
    #####: 9121:      print_vma (tp->end.offset, PREFIX_HEX);
    #####: 9122:      printf ("]\n\t");
        -: 9123:
        -: 9124:#define PF(_m) if (tp->_m) printf (#_m " ");
        -: 9125:#define PV(_m) if (tp->_m) printf (#_m "=%d ", tp->_m);
    #####: 9126:      PF(Cannot_unwind);
    #####: 9127:      PF(Millicode);
    #####: 9128:      PF(Millicode_save_sr0);
        -: 9129:      /* PV(Region_description);  */
    #####: 9130:      PF(Entry_SR);
    #####: 9131:      PV(Entry_FR);
    #####: 9132:      PV(Entry_GR);
    #####: 9133:      PF(Args_stored);
    #####: 9134:      PF(Variable_Frame);
    #####: 9135:      PF(Separate_Package_Body);
    #####: 9136:      PF(Frame_Extension_Millicode);
    #####: 9137:      PF(Stack_Overflow_Check);
    #####: 9138:      PF(Two_Instruction_SP_Increment);
    #####: 9139:      PF(Ada_Region);
    #####: 9140:      PF(cxx_info);
    #####: 9141:      PF(cxx_try_catch);
    #####: 9142:      PF(sched_entry_seq);
    #####: 9143:      PF(Save_SP);
    #####: 9144:      PF(Save_RP);
    #####: 9145:      PF(Save_MRP_in_frame);
    #####: 9146:      PF(extn_ptr_defined);
    #####: 9147:      PF(Cleanup_defined);
    #####: 9148:      PF(MPE_XL_interrupt_marker);
    #####: 9149:      PF(HP_UX_interrupt_marker);
    #####: 9150:      PF(Large_frame);
    #####: 9151:      PF(Pseudo_SP_Set);
    #####: 9152:      PV(Total_frame_size);
        -: 9153:#undef PF
        -: 9154:#undef PV
        -: 9155:    }
        -: 9156:
    #####: 9157:  printf ("\n");
        -: 9158:
    #####: 9159:  free (aux->funtab);
        -: 9160:
    #####: 9161:  return res;
        -: 9162:}
        -: 9163:
        -: 9164:static bool
    #####: 9165:slurp_hppa_unwind_table (Filedata *                  filedata,
        -: 9166:			 struct hppa_unw_aux_info *  aux,
        -: 9167:			 Elf_Internal_Shdr *         sec)
        -: 9168:{
        -: 9169:  unsigned long size, unw_ent_size, nentries, nrelas, i;
        -: 9170:  Elf_Internal_Phdr * seg;
        -: 9171:  struct hppa_unw_table_entry * tep;
        -: 9172:  Elf_Internal_Shdr * relsec;
        -: 9173:  Elf_Internal_Rela * rela;
        -: 9174:  Elf_Internal_Rela * rp;
        -: 9175:  unsigned char * table;
        -: 9176:  unsigned char * tp;
        -: 9177:  Elf_Internal_Sym * sym;
        -: 9178:  const char * relname;
        -: 9179:
        -: 9180:  /* First, find the starting address of the segment that includes
        -: 9181:     this section.  */
    #####: 9182:  if (filedata->file_header.e_phnum)
        -: 9183:    {
    #####: 9184:      if (! get_program_headers (filedata))
    #####: 9185:	return false;
        -: 9186:
    #####: 9187:      for (seg = filedata->program_headers;
    #####: 9188:	   seg < filedata->program_headers + filedata->file_header.e_phnum;
    #####: 9189:	   ++seg)
        -: 9190:	{
    #####: 9191:	  if (seg->p_type != PT_LOAD)
    #####: 9192:	    continue;
        -: 9193:
    #####: 9194:	  if (sec->sh_addr >= seg->p_vaddr
    #####: 9195:	      && (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz))
        -: 9196:	    {
    #####: 9197:	      aux->seg_base = seg->p_vaddr;
    #####: 9198:	      break;
        -: 9199:	    }
        -: 9200:	}
        -: 9201:    }
        -: 9202:
        -: 9203:  /* Second, build the unwind table from the contents of the unwind
        -: 9204:     section.  */
    #####: 9205:  size = sec->sh_size;
    #####: 9206:  table = (unsigned char *) get_data (NULL, filedata, sec->sh_offset, 1, size,
    #####: 9207:                                      _("unwind table"));
    #####: 9208:  if (!table)
    #####: 9209:    return false;
        -: 9210:
    #####: 9211:  unw_ent_size = 16;
    #####: 9212:  nentries = size / unw_ent_size;
    #####: 9213:  size = unw_ent_size * nentries;
        -: 9214:
    #####: 9215:  aux->table_len = nentries;
    #####: 9216:  tep = aux->table = (struct hppa_unw_table_entry *)
    #####: 9217:      xcmalloc (nentries, sizeof (aux->table[0]));
        -: 9218:
    #####: 9219:  for (tp = table; tp < table + size; tp += unw_ent_size, ++tep)
        -: 9220:    {
        -: 9221:      unsigned int tmp1, tmp2;
        -: 9222:
    #####: 9223:      tep->start.section = SHN_UNDEF;
    #####: 9224:      tep->end.section   = SHN_UNDEF;
        -: 9225:
    #####: 9226:      tep->start.offset = byte_get ((unsigned char *) tp + 0, 4);
    #####: 9227:      tep->end.offset = byte_get ((unsigned char *) tp + 4, 4);
    #####: 9228:      tmp1 = byte_get ((unsigned char *) tp + 8, 4);
    #####: 9229:      tmp2 = byte_get ((unsigned char *) tp + 12, 4);
        -: 9230:
    #####: 9231:      tep->start.offset += aux->seg_base;
    #####: 9232:      tep->end.offset   += aux->seg_base;
        -: 9233:
    #####: 9234:      tep->Cannot_unwind = (tmp1 >> 31) & 0x1;
    #####: 9235:      tep->Millicode = (tmp1 >> 30) & 0x1;
    #####: 9236:      tep->Millicode_save_sr0 = (tmp1 >> 29) & 0x1;
    #####: 9237:      tep->Region_description = (tmp1 >> 27) & 0x3;
    #####: 9238:      tep->reserved1 = (tmp1 >> 26) & 0x1;
    #####: 9239:      tep->Entry_SR = (tmp1 >> 25) & 0x1;
    #####: 9240:      tep->Entry_FR = (tmp1 >> 21) & 0xf;
    #####: 9241:      tep->Entry_GR = (tmp1 >> 16) & 0x1f;
    #####: 9242:      tep->Args_stored = (tmp1 >> 15) & 0x1;
    #####: 9243:      tep->Variable_Frame = (tmp1 >> 14) & 0x1;
    #####: 9244:      tep->Separate_Package_Body = (tmp1 >> 13) & 0x1;
    #####: 9245:      tep->Frame_Extension_Millicode = (tmp1 >> 12) & 0x1;
    #####: 9246:      tep->Stack_Overflow_Check = (tmp1 >> 11) & 0x1;
    #####: 9247:      tep->Two_Instruction_SP_Increment = (tmp1 >> 10) & 0x1;
    #####: 9248:      tep->Ada_Region = (tmp1 >> 9) & 0x1;
    #####: 9249:      tep->cxx_info = (tmp1 >> 8) & 0x1;
    #####: 9250:      tep->cxx_try_catch = (tmp1 >> 7) & 0x1;
    #####: 9251:      tep->sched_entry_seq = (tmp1 >> 6) & 0x1;
    #####: 9252:      tep->reserved2 = (tmp1 >> 5) & 0x1;
    #####: 9253:      tep->Save_SP = (tmp1 >> 4) & 0x1;
    #####: 9254:      tep->Save_RP = (tmp1 >> 3) & 0x1;
    #####: 9255:      tep->Save_MRP_in_frame = (tmp1 >> 2) & 0x1;
    #####: 9256:      tep->extn_ptr_defined = (tmp1 >> 1) & 0x1;
    #####: 9257:      tep->Cleanup_defined = tmp1 & 0x1;
        -: 9258:
    #####: 9259:      tep->MPE_XL_interrupt_marker = (tmp2 >> 31) & 0x1;
    #####: 9260:      tep->HP_UX_interrupt_marker = (tmp2 >> 30) & 0x1;
    #####: 9261:      tep->Large_frame = (tmp2 >> 29) & 0x1;
    #####: 9262:      tep->Pseudo_SP_Set = (tmp2 >> 28) & 0x1;
    #####: 9263:      tep->reserved4 = (tmp2 >> 27) & 0x1;
    #####: 9264:      tep->Total_frame_size = tmp2 & 0x7ffffff;
        -: 9265:    }
    #####: 9266:  free (table);
        -: 9267:
        -: 9268:  /* Third, apply any relocations to the unwind table.  */
    #####: 9269:  for (relsec = filedata->section_headers;
    #####: 9270:       relsec < filedata->section_headers + filedata->file_header.e_shnum;
    #####: 9271:       ++relsec)
        -: 9272:    {
    #####: 9273:      if (relsec->sh_type != SHT_RELA
    #####: 9274:	  || relsec->sh_info >= filedata->file_header.e_shnum
    #####: 9275:	  || filedata->section_headers + relsec->sh_info != sec)
    #####: 9276:	continue;
        -: 9277:
    #####: 9278:      if (!slurp_rela_relocs (filedata, relsec->sh_offset, relsec->sh_size,
        -: 9279:			      & rela, & nrelas))
    #####: 9280:	return false;
        -: 9281:
    #####: 9282:      for (rp = rela; rp < rela + nrelas; ++rp)
        -: 9283:	{
        -: 9284:	  unsigned int sym_ndx;
    #####: 9285:	  unsigned int r_type = get_reloc_type (filedata, rp->r_info);
    #####: 9286:	  relname = elf_hppa_reloc_type (r_type);
        -: 9287:
    #####: 9288:	  if (relname == NULL)
        -: 9289:	    {
    #####: 9290:	      warn (_("Skipping unknown relocation type: %u\n"), r_type);
    #####: 9291:	      continue;
        -: 9292:	    }
        -: 9293:
        -: 9294:	  /* R_PARISC_SEGREL32 or R_PARISC_SEGREL64.  */
    #####: 9295:	  if (! startswith (relname, "R_PARISC_SEGREL"))
        -: 9296:	    {
    #####: 9297:	      warn (_("Skipping unexpected relocation type: %s\n"), relname);
    #####: 9298:	      continue;
        -: 9299:	    }
        -: 9300:
    #####: 9301:	  i = rp->r_offset / unw_ent_size;
    #####: 9302:	  if (i >= aux->table_len)
        -: 9303:	    {
    #####: 9304:	      warn (_("Skipping reloc with overlarge offset: %lx\n"), i);
    #####: 9305:	      continue;
        -: 9306:	    }
        -: 9307:
    #####: 9308:	  sym_ndx = get_reloc_symindex (rp->r_info);
    #####: 9309:	  if (sym_ndx >= aux->nsyms)
        -: 9310:	    {
    #####: 9311:	      warn (_("Skipping reloc with invalid symbol index: %u\n"),
        -: 9312:		    sym_ndx);
    #####: 9313:	      continue;
        -: 9314:	    }
    #####: 9315:	  sym = aux->symtab + sym_ndx;
        -: 9316:
    #####: 9317:	  switch ((rp->r_offset % unw_ent_size) / 4)
        -: 9318:	    {
    #####: 9319:	    case 0:
    #####: 9320:	      aux->table[i].start.section = sym->st_shndx;
    #####: 9321:	      aux->table[i].start.offset  = sym->st_value + rp->r_addend;
    #####: 9322:	      break;
    #####: 9323:	    case 1:
    #####: 9324:	      aux->table[i].end.section   = sym->st_shndx;
    #####: 9325:	      aux->table[i].end.offset    = sym->st_value + rp->r_addend;
    #####: 9326:	      break;
    #####: 9327:	    default:
    #####: 9328:	      break;
        -: 9329:	    }
        -: 9330:	}
        -: 9331:
    #####: 9332:      free (rela);
        -: 9333:    }
        -: 9334:
    #####: 9335:  return true;
        -: 9336:}
        -: 9337:
        -: 9338:static bool
       14: 9339:hppa_process_unwind (Filedata * filedata)
        -: 9340:{
        -: 9341:  struct hppa_unw_aux_info aux;
       14: 9342:  Elf_Internal_Shdr * unwsec = NULL;
        -: 9343:  Elf_Internal_Shdr * sec;
        -: 9344:  unsigned long i;
       14: 9345:  bool res = true;
        -: 9346:
       14: 9347:  if (filedata->string_table == NULL)
        1: 9348:    return false;
        -: 9349:
       13: 9350:  memset (& aux, 0, sizeof (aux));
        -: 9351:
       56: 9352:  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
        -: 9353:    {
       46: 9354:      if (sec->sh_type == SHT_SYMTAB)
        -: 9355:	{
        4: 9356:	  if (aux.symtab)
        -: 9357:	    {
    #####: 9358:	      error (_("Multiple symbol tables encountered\n"));
    #####: 9359:	      free (aux.symtab);
    #####: 9360:	      aux.symtab = NULL;
    #####: 9361:	      free (aux.strtab);
    #####: 9362:	      aux.strtab = NULL;
        -: 9363:	    }
        4: 9364:	  if (!get_symtab (filedata, sec, &aux.symtab, &aux.nsyms,
        -: 9365:			   &aux.strtab, &aux.strtab_size))
        3: 9366:	    return false;
        -: 9367:	}
       42: 9368:      else if (section_name_valid (filedata, sec)
       36: 9369:	       && streq (section_name (filedata, sec), ".PARISC.unwind"))
    #####: 9370:	unwsec = sec;
        -: 9371:    }
        -: 9372:
       10: 9373:  if (!unwsec)
       10: 9374:    printf (_("\nThere are no unwind sections in this file.\n"));
        -: 9375:
       50: 9376:  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
        -: 9377:    {
       40: 9378:      if (section_name_valid (filedata, sec)
       34: 9379:	  && streq (section_name (filedata, sec), ".PARISC.unwind"))
        -: 9380:	{
    #####: 9381:	  unsigned long num_unwind = sec->sh_size / 16;
        -: 9382:
    #####: 9383:	  printf (ngettext ("\nUnwind section '%s' at offset 0x%lx "
        -: 9384:			    "contains %lu entry:\n",
        -: 9385:			    "\nUnwind section '%s' at offset 0x%lx "
        -: 9386:			    "contains %lu entries:\n",
        -: 9387:			    num_unwind),
        -: 9388:		  printable_section_name (filedata, sec),
    #####: 9389:		  (unsigned long) sec->sh_offset,
        -: 9390:		  num_unwind);
        -: 9391:
    #####: 9392:          if (! slurp_hppa_unwind_table (filedata, &aux, sec))
    #####: 9393:	    res = false;
        -: 9394:
    #####: 9395:	  if (res && aux.table_len > 0)
        -: 9396:	    {
    #####: 9397:	      if (! dump_hppa_unwind (filedata, &aux))
    #####: 9398:		res = false;
        -: 9399:	    }
        -: 9400:
    #####: 9401:	  free ((char *) aux.table);
    #####: 9402:	  aux.table = NULL;
        -: 9403:	}
        -: 9404:    }
        -: 9405:
       10: 9406:  free (aux.symtab);
       10: 9407:  free ((char *) aux.strtab);
        -: 9408:
       10: 9409:  return res;
        -: 9410:}
        -: 9411:
        -: 9412:struct arm_section
        -: 9413:{
        -: 9414:  unsigned char *      data;		/* The unwind data.  */
        -: 9415:  Elf_Internal_Shdr *  sec;		/* The cached unwind section header.  */
        -: 9416:  Elf_Internal_Rela *  rela;		/* The cached relocations for this section.  */
        -: 9417:  unsigned long        nrelas;		/* The number of relocations.  */
        -: 9418:  unsigned int         rel_type;	/* REL or RELA ?  */
        -: 9419:  Elf_Internal_Rela *  next_rela;	/* Cyclic pointer to the next reloc to process.  */
        -: 9420:};
        -: 9421:
        -: 9422:struct arm_unw_aux_info
        -: 9423:{
        -: 9424:  Filedata *          filedata;		/* The file containing the unwind sections.  */
        -: 9425:  Elf_Internal_Sym *  symtab;		/* The file's symbol table.  */
        -: 9426:  unsigned long       nsyms;		/* Number of symbols.  */
        -: 9427:  Elf_Internal_Sym *  funtab;		/* Sorted table of STT_FUNC symbols.  */
        -: 9428:  unsigned long       nfuns;		/* Number of these symbols.  */
        -: 9429:  char *              strtab;		/* The file's string table.  */
        -: 9430:  unsigned long       strtab_size;	/* Size of string table.  */
        -: 9431:};
        -: 9432:
        -: 9433:static const char *
    #####: 9434:arm_print_vma_and_name (Filedata *                 filedata,
        -: 9435:			struct arm_unw_aux_info *  aux,
        -: 9436:			bfd_vma                    fn,
        -: 9437:			struct absaddr             addr)
        -: 9438:{
        -: 9439:  const char *procname;
        -: 9440:  bfd_vma sym_offset;
        -: 9441:
    #####: 9442:  if (addr.section == SHN_UNDEF)
    #####: 9443:    addr.offset = fn;
        -: 9444:
    #####: 9445:  find_symbol_for_address (filedata, aux->funtab, aux->nfuns, aux->strtab,
        -: 9446:			   aux->strtab_size, addr, &procname,
        -: 9447:			   &sym_offset);
        -: 9448:
    #####: 9449:  print_vma (fn, PREFIX_HEX);
        -: 9450:
    #####: 9451:  if (procname)
        -: 9452:    {
    #####: 9453:      fputs (" <", stdout);
    #####: 9454:      fputs (procname, stdout);
        -: 9455:
    #####: 9456:      if (sym_offset)
    #####: 9457:	printf ("+0x%lx", (unsigned long) sym_offset);
    #####: 9458:      fputc ('>', stdout);
        -: 9459:    }
        -: 9460:
    #####: 9461:  return procname;
        -: 9462:}
        -: 9463:
        -: 9464:static void
    #####: 9465:arm_free_section (struct arm_section *arm_sec)
        -: 9466:{
    #####: 9467:  free (arm_sec->data);
    #####: 9468:  free (arm_sec->rela);
    #####: 9469:}
        -: 9470:
        -: 9471:/* 1) If SEC does not match the one cached in ARM_SEC, then free the current
        -: 9472:      cached section and install SEC instead.
        -: 9473:   2) Locate the 32-bit word at WORD_OFFSET in unwind section SEC
        -: 9474:      and return its valued in * WORDP, relocating if necessary.
        -: 9475:   3) Update the NEXT_RELA field in ARM_SEC and store the section index and
        -: 9476:      relocation's offset in ADDR.
        -: 9477:   4) If SYM_NAME is non-NULL and a relocation was applied, record the offset
        -: 9478:      into the string table of the symbol associated with the reloc.  If no
        -: 9479:      reloc was applied store -1 there.
        -: 9480:   5) Return TRUE upon success, FALSE otherwise.  */
        -: 9481:
        -: 9482:static bool
    #####: 9483:get_unwind_section_word (Filedata *                 filedata,
        -: 9484:			 struct arm_unw_aux_info *  aux,
        -: 9485:			 struct arm_section *       arm_sec,
        -: 9486:			 Elf_Internal_Shdr *        sec,
        -: 9487:			 bfd_vma 		    word_offset,
        -: 9488:			 unsigned int *             wordp,
        -: 9489:			 struct absaddr *           addr,
        -: 9490:			 bfd_vma *		    sym_name)
        -: 9491:{
        -: 9492:  Elf_Internal_Rela *rp;
        -: 9493:  Elf_Internal_Sym *sym;
        -: 9494:  const char * relname;
        -: 9495:  unsigned int word;
        -: 9496:  bool wrapped;
        -: 9497:
    #####: 9498:  if (sec == NULL || arm_sec == NULL)
    #####: 9499:    return false;
        -: 9500:
    #####: 9501:  addr->section = SHN_UNDEF;
    #####: 9502:  addr->offset = 0;
        -: 9503:
    #####: 9504:  if (sym_name != NULL)
    #####: 9505:    *sym_name = (bfd_vma) -1;
        -: 9506:
        -: 9507:  /* If necessary, update the section cache.  */
    #####: 9508:  if (sec != arm_sec->sec)
        -: 9509:    {
        -: 9510:      Elf_Internal_Shdr *relsec;
        -: 9511:
    #####: 9512:      arm_free_section (arm_sec);
        -: 9513:
    #####: 9514:      arm_sec->sec = sec;
    #####: 9515:      arm_sec->data = get_data (NULL, aux->filedata, sec->sh_offset, 1,
    #####: 9516:				sec->sh_size, _("unwind data"));
    #####: 9517:      arm_sec->rela = NULL;
    #####: 9518:      arm_sec->nrelas = 0;
        -: 9519:
    #####: 9520:      for (relsec = filedata->section_headers;
    #####: 9521:	   relsec < filedata->section_headers + filedata->file_header.e_shnum;
    #####: 9522:	   ++relsec)
        -: 9523:	{
    #####: 9524:	  if (relsec->sh_info >= filedata->file_header.e_shnum
    #####: 9525:	      || filedata->section_headers + relsec->sh_info != sec
        -: 9526:	      /* PR 15745: Check the section type as well.  */
    #####: 9527:	      || (relsec->sh_type != SHT_REL
    #####: 9528:		  && relsec->sh_type != SHT_RELA))
    #####: 9529:	    continue;
        -: 9530:
    #####: 9531:	  arm_sec->rel_type = relsec->sh_type;
    #####: 9532:	  if (relsec->sh_type == SHT_REL)
        -: 9533:	    {
    #####: 9534:	      if (!slurp_rel_relocs (aux->filedata, relsec->sh_offset,
        -: 9535:				     relsec->sh_size,
        -: 9536:				     & arm_sec->rela, & arm_sec->nrelas))
    #####: 9537:		return false;
        -: 9538:	    }
        -: 9539:	  else /* relsec->sh_type == SHT_RELA */
        -: 9540:	    {
    #####: 9541:	      if (!slurp_rela_relocs (aux->filedata, relsec->sh_offset,
        -: 9542:				      relsec->sh_size,
        -: 9543:				      & arm_sec->rela, & arm_sec->nrelas))
    #####: 9544:		return false;
        -: 9545:	    }
    #####: 9546:	  break;
        -: 9547:	}
        -: 9548:
    #####: 9549:      arm_sec->next_rela = arm_sec->rela;
        -: 9550:    }
        -: 9551:
        -: 9552:  /* If there is no unwind data we can do nothing.  */
    #####: 9553:  if (arm_sec->data == NULL)
    #####: 9554:    return false;
        -: 9555:
        -: 9556:  /* If the offset is invalid then fail.  */
    #####: 9557:  if (/* PR 21343 *//* PR 18879 */
    #####: 9558:      sec->sh_size < 4
    #####: 9559:      || word_offset > (sec->sh_size - 4)
    #####: 9560:      || ((bfd_signed_vma) word_offset) < 0)
    #####: 9561:    return false;
        -: 9562:
        -: 9563:  /* Get the word at the required offset.  */
    #####: 9564:  word = byte_get (arm_sec->data + word_offset, 4);
        -: 9565:
        -: 9566:  /* PR 17531: file: id:000001,src:001266+003044,op:splice,rep:128.  */
    #####: 9567:  if (arm_sec->rela == NULL)
        -: 9568:    {
    #####: 9569:      * wordp = word;
    #####: 9570:      return true;
        -: 9571:    }
        -: 9572:
        -: 9573:  /* Look through the relocs to find the one that applies to the provided offset.  */
    #####: 9574:  wrapped = false;
    #####: 9575:  for (rp = arm_sec->next_rela; rp != arm_sec->rela + arm_sec->nrelas; rp++)
        -: 9576:    {
        -: 9577:      bfd_vma prelval, offset;
        -: 9578:
    #####: 9579:      if (rp->r_offset > word_offset && !wrapped)
        -: 9580:	{
    #####: 9581:	  rp = arm_sec->rela;
    #####: 9582:	  wrapped = true;
        -: 9583:	}
    #####: 9584:      if (rp->r_offset > word_offset)
    #####: 9585:	break;
        -: 9586:
    #####: 9587:      if (rp->r_offset & 3)
        -: 9588:	{
    #####: 9589:	  warn (_("Skipping unexpected relocation at offset 0x%lx\n"),
    #####: 9590:		(unsigned long) rp->r_offset);
    #####: 9591:	  continue;
        -: 9592:	}
        -: 9593:
    #####: 9594:      if (rp->r_offset < word_offset)
    #####: 9595:	continue;
        -: 9596:
        -: 9597:      /* PR 17531: file: 027-161405-0.004  */
    #####: 9598:      if (aux->symtab == NULL)
    #####: 9599:	continue;
        -: 9600:
    #####: 9601:      if (arm_sec->rel_type == SHT_REL)
        -: 9602:	{
    #####: 9603:	  offset = word & 0x7fffffff;
    #####: 9604:	  if (offset & 0x40000000)
    #####: 9605:	    offset |= ~ (bfd_vma) 0x7fffffff;
        -: 9606:	}
    #####: 9607:      else if (arm_sec->rel_type == SHT_RELA)
    #####: 9608:	offset = rp->r_addend;
        -: 9609:      else
        -: 9610:	{
    #####: 9611:	  error (_("Unknown section relocation type %d encountered\n"),
        -: 9612:		 arm_sec->rel_type);
    #####: 9613:	  break;
        -: 9614:	}
        -: 9615:
        -: 9616:      /* PR 17531 file: 027-1241568-0.004.  */
    #####: 9617:      if (ELF32_R_SYM (rp->r_info) >= aux->nsyms)
        -: 9618:	{
    #####: 9619:	  error (_("Bad symbol index in unwind relocation (%lu > %lu)\n"),
    #####: 9620:		 (unsigned long) ELF32_R_SYM (rp->r_info), aux->nsyms);
    #####: 9621:	  break;
        -: 9622:	}
        -: 9623:
    #####: 9624:      sym = aux->symtab + ELF32_R_SYM (rp->r_info);
    #####: 9625:      offset += sym->st_value;
    #####: 9626:      prelval = offset - (arm_sec->sec->sh_addr + rp->r_offset);
        -: 9627:
        -: 9628:      /* Check that we are processing the expected reloc type.  */
    #####: 9629:      if (filedata->file_header.e_machine == EM_ARM)
        -: 9630:	{
    #####: 9631:	  relname = elf_arm_reloc_type (ELF32_R_TYPE (rp->r_info));
    #####: 9632:	  if (relname == NULL)
        -: 9633:	    {
    #####: 9634:	      warn (_("Skipping unknown ARM relocation type: %d\n"),
    #####: 9635:		    (int) ELF32_R_TYPE (rp->r_info));
    #####: 9636:	      continue;
        -: 9637:	    }
        -: 9638:
    #####: 9639:	  if (streq (relname, "R_ARM_NONE"))
    #####: 9640:	      continue;
        -: 9641:
    #####: 9642:	  if (! streq (relname, "R_ARM_PREL31"))
        -: 9643:	    {
    #####: 9644:	      warn (_("Skipping unexpected ARM relocation type %s\n"), relname);
    #####: 9645:	      continue;
        -: 9646:	    }
        -: 9647:	}
    #####: 9648:      else if (filedata->file_header.e_machine == EM_TI_C6000)
        -: 9649:	{
    #####: 9650:	  relname = elf_tic6x_reloc_type (ELF32_R_TYPE (rp->r_info));
    #####: 9651:	  if (relname == NULL)
        -: 9652:	    {
    #####: 9653:	      warn (_("Skipping unknown C6000 relocation type: %d\n"),
    #####: 9654:		    (int) ELF32_R_TYPE (rp->r_info));
    #####: 9655:	      continue;
        -: 9656:	    }
        -: 9657:
    #####: 9658:	  if (streq (relname, "R_C6000_NONE"))
    #####: 9659:	    continue;
        -: 9660:
    #####: 9661:	  if (! streq (relname, "R_C6000_PREL31"))
        -: 9662:	    {
    #####: 9663:	      warn (_("Skipping unexpected C6000 relocation type %s\n"), relname);
    #####: 9664:	      continue;
        -: 9665:	    }
        -: 9666:
    #####: 9667:	  prelval >>= 1;
        -: 9668:	}
        -: 9669:      else
        -: 9670:	{
        -: 9671:	  /* This function currently only supports ARM and TI unwinders.  */
    #####: 9672:	  warn (_("Only TI and ARM unwinders are currently supported\n"));
    #####: 9673:	  break;
        -: 9674:	}
        -: 9675:
    #####: 9676:      word = (word & ~ (bfd_vma) 0x7fffffff) | (prelval & 0x7fffffff);
    #####: 9677:      addr->section = sym->st_shndx;
    #####: 9678:      addr->offset = offset;
        -: 9679:
    #####: 9680:      if (sym_name)
    #####: 9681:	* sym_name = sym->st_name;
    #####: 9682:      break;
        -: 9683:    }
        -: 9684:
    #####: 9685:  *wordp = word;
    #####: 9686:  arm_sec->next_rela = rp;
        -: 9687:
    #####: 9688:  return true;
        -: 9689:}
        -: 9690:
        -: 9691:static const char *tic6x_unwind_regnames[16] =
        -: 9692:{
        -: 9693:  "A15", "B15", "B14", "B13", "B12", "B11", "B10", "B3",
        -: 9694:  "A14", "A13", "A12", "A11", "A10",
        -: 9695:  "[invalid reg 13]", "[invalid reg 14]", "[invalid reg 15]"
        -: 9696:};
        -: 9697:
        -: 9698:static void
    #####: 9699:decode_tic6x_unwind_regmask (unsigned int mask)
        -: 9700:{
        -: 9701:  int i;
        -: 9702:
    #####: 9703:  for (i = 12; mask; mask >>= 1, i--)
        -: 9704:    {
    #####: 9705:      if (mask & 1)
        -: 9706:	{
    #####: 9707:	  fputs (tic6x_unwind_regnames[i], stdout);
    #####: 9708:	  if (mask > 1)
    #####: 9709:	    fputs (", ", stdout);
        -: 9710:	}
        -: 9711:    }
    #####: 9712:}
        -: 9713:
        -: 9714:#define ADVANCE							\
        -: 9715:  if (remaining == 0 && more_words)				\
        -: 9716:    {								\
        -: 9717:      data_offset += 4;						\
        -: 9718:      if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec,	\
        -: 9719:				     data_offset, & word, & addr, NULL))	\
        -: 9720:	return false;						\
        -: 9721:      remaining = 4;						\
        -: 9722:      more_words--;						\
        -: 9723:    }								\
        -: 9724:
        -: 9725:#define GET_OP(OP)			\
        -: 9726:  ADVANCE;				\
        -: 9727:  if (remaining)			\
        -: 9728:    {					\
        -: 9729:      remaining--;			\
        -: 9730:      (OP) = word >> 24;		\
        -: 9731:      word <<= 8;			\
        -: 9732:    }					\
        -: 9733:  else					\
        -: 9734:    {					\
        -: 9735:      printf (_("[Truncated opcode]\n"));	\
        -: 9736:      return false;			\
        -: 9737:    }					\
        -: 9738:  printf ("0x%02x ", OP)
        -: 9739:
        -: 9740:static bool
    #####: 9741:decode_arm_unwind_bytecode (Filedata *                 filedata,
        -: 9742:			    struct arm_unw_aux_info *  aux,
        -: 9743:			    unsigned int               word,
        -: 9744:			    unsigned int               remaining,
        -: 9745:			    unsigned int               more_words,
        -: 9746:			    bfd_vma                    data_offset,
        -: 9747:			    Elf_Internal_Shdr *        data_sec,
        -: 9748:			    struct arm_section *       data_arm_sec)
        -: 9749:{
        -: 9750:  struct absaddr addr;
    #####: 9751:  bool res = true;
        -: 9752:
        -: 9753:  /* Decode the unwinding instructions.  */
        -: 9754:  while (1)
    #####: 9755:    {
        -: 9756:      unsigned int op, op2;
        -: 9757:
    #####: 9758:      ADVANCE;
    #####: 9759:      if (remaining == 0)
    #####: 9760:	break;
    #####: 9761:      remaining--;
    #####: 9762:      op = word >> 24;
    #####: 9763:      word <<= 8;
        -: 9764:
    #####: 9765:      printf ("  0x%02x ", op);
        -: 9766:
    #####: 9767:      if ((op & 0xc0) == 0x00)
        -: 9768:	{
    #####: 9769:	  int offset = ((op & 0x3f) << 2) + 4;
        -: 9770:
    #####: 9771:	  printf ("     vsp = vsp + %d", offset);
        -: 9772:	}
    #####: 9773:      else if ((op & 0xc0) == 0x40)
        -: 9774:	{
    #####: 9775:	  int offset = ((op & 0x3f) << 2) + 4;
        -: 9776:
    #####: 9777:	  printf ("     vsp = vsp - %d", offset);
        -: 9778:	}
    #####: 9779:      else if ((op & 0xf0) == 0x80)
        -: 9780:	{
    #####: 9781:	  GET_OP (op2);
    #####: 9782:	  if (op == 0x80 && op2 == 0)
    #####: 9783:	    printf (_("Refuse to unwind"));
        -: 9784:	  else
        -: 9785:	    {
    #####: 9786:	      unsigned int mask = ((op & 0x0f) << 8) | op2;
    #####: 9787:	      bool first = true;
        -: 9788:	      int i;
        -: 9789:
    #####: 9790:	      printf ("pop {");
    #####: 9791:	      for (i = 0; i < 12; i++)
    #####: 9792:		if (mask & (1 << i))
        -: 9793:		  {
    #####: 9794:		    if (first)
    #####: 9795:		      first = false;
        -: 9796:		    else
    #####: 9797:		      printf (", ");
    #####: 9798:		    printf ("r%d", 4 + i);
        -: 9799:		  }
    #####: 9800:	      printf ("}");
        -: 9801:	    }
        -: 9802:	}
    #####: 9803:      else if ((op & 0xf0) == 0x90)
        -: 9804:	{
    #####: 9805:	  if (op == 0x9d || op == 0x9f)
    #####: 9806:	    printf (_("     [Reserved]"));
        -: 9807:	  else
    #####: 9808:	    printf ("     vsp = r%d", op & 0x0f);
        -: 9809:	}
    #####: 9810:      else if ((op & 0xf0) == 0xa0)
        -: 9811:	{
    #####: 9812:	  int end = 4 + (op & 0x07);
    #####: 9813:	  bool first = true;
        -: 9814:	  int i;
        -: 9815:
    #####: 9816:	  printf ("     pop {");
    #####: 9817:	  for (i = 4; i <= end; i++)
        -: 9818:	    {
    #####: 9819:	      if (first)
    #####: 9820:		first = false;
        -: 9821:	      else
    #####: 9822:		printf (", ");
    #####: 9823:	      printf ("r%d", i);
        -: 9824:	    }
    #####: 9825:	  if (op & 0x08)
        -: 9826:	    {
    #####: 9827:	      if (!first)
    #####: 9828:		printf (", ");
    #####: 9829:	      printf ("r14");
        -: 9830:	    }
    #####: 9831:	  printf ("}");
        -: 9832:	}
    #####: 9833:      else if (op == 0xb0)
    #####: 9834:	printf (_("     finish"));
    #####: 9835:      else if (op == 0xb1)
        -: 9836:	{
    #####: 9837:	  GET_OP (op2);
    #####: 9838:	  if (op2 == 0 || (op2 & 0xf0) != 0)
    #####: 9839:	    printf (_("[Spare]"));
        -: 9840:	  else
        -: 9841:	    {
    #####: 9842:	      unsigned int mask = op2 & 0x0f;
    #####: 9843:	      bool first = true;
        -: 9844:	      int i;
        -: 9845:
    #####: 9846:	      printf ("pop {");
    #####: 9847:	      for (i = 0; i < 12; i++)
    #####: 9848:		if (mask & (1 << i))
        -: 9849:		  {
    #####: 9850:		    if (first)
    #####: 9851:		      first = false;
        -: 9852:		    else
    #####: 9853:		      printf (", ");
    #####: 9854:		    printf ("r%d", i);
        -: 9855:		  }
    #####: 9856:	      printf ("}");
        -: 9857:	    }
        -: 9858:	}
    #####: 9859:      else if (op == 0xb2)
        -: 9860:	{
        -: 9861:	  unsigned char buf[9];
        -: 9862:	  unsigned int i, len;
        -: 9863:	  unsigned long offset;
        -: 9864:
    #####: 9865:	  for (i = 0; i < sizeof (buf); i++)
        -: 9866:	    {
    #####: 9867:	      GET_OP (buf[i]);
    #####: 9868:	      if ((buf[i] & 0x80) == 0)
    #####: 9869:		break;
        -: 9870:	    }
    #####: 9871:	  if (i == sizeof (buf))
        -: 9872:	    {
    #####: 9873:	      error (_("corrupt change to vsp\n"));
    #####: 9874:	      res = false;
        -: 9875:	    }
        -: 9876:	  else
        -: 9877:	    {
    #####: 9878:	      offset = read_leb128 (buf, buf + i + 1, false, &len, NULL);
    #####: 9879:	      assert (len == i + 1);
    #####: 9880:	      offset = offset * 4 + 0x204;
    #####: 9881:	      printf ("vsp = vsp + %ld", offset);
        -: 9882:	    }
        -: 9883:	}
    #####: 9884:      else if (op == 0xb3 || op == 0xc8 || op == 0xc9)
    #####: 9885:	{
        -: 9886:	  unsigned int first, last;
        -: 9887:
    #####: 9888:	  GET_OP (op2);
    #####: 9889:	  first = op2 >> 4;
    #####: 9890:	  last = op2 & 0x0f;
    #####: 9891:	  if (op == 0xc8)
    #####: 9892:	    first = first + 16;
    #####: 9893:	  printf ("pop {D%d", first);
    #####: 9894:	  if (last)
    #####: 9895:	    printf ("-D%d", first + last);
    #####: 9896:	  printf ("}");
        -: 9897:	}
    #####: 9898:      else if (op == 0xb4)
    #####: 9899:	printf (_("     pop {ra_auth_code}"));
    #####: 9900:      else if ((op & 0xf8) == 0xb8 || (op & 0xf8) == 0xd0)
    #####: 9901:	{
    #####: 9902:	  unsigned int count = op & 0x07;
        -: 9903:
    #####: 9904:	  printf ("pop {D8");
    #####: 9905:	  if (count)
    #####: 9906:	    printf ("-D%d", 8 + count);
    #####: 9907:	  printf ("}");
        -: 9908:	}
    #####: 9909:      else if (op >= 0xc0 && op <= 0xc5)
    #####: 9910:	{
    #####: 9911:	  unsigned int count = op & 0x07;
        -: 9912:
    #####: 9913:	  printf ("     pop {wR10");
    #####: 9914:	  if (count)
    #####: 9915:	    printf ("-wR%d", 10 + count);
    #####: 9916:	  printf ("}");
        -: 9917:	}
    #####: 9918:      else if (op == 0xc6)
        -: 9919:	{
        -: 9920:	  unsigned int first, last;
        -: 9921:
    #####: 9922:	  GET_OP (op2);
    #####: 9923:	  first = op2 >> 4;
    #####: 9924:	  last = op2 & 0x0f;
    #####: 9925:	  printf ("pop {wR%d", first);
    #####: 9926:	  if (last)
    #####: 9927:	    printf ("-wR%d", first + last);
    #####: 9928:	  printf ("}");
        -: 9929:	}
    #####: 9930:      else if (op == 0xc7)
        -: 9931:	{
    #####: 9932:	  GET_OP (op2);
    #####: 9933:	  if (op2 == 0 || (op2 & 0xf0) != 0)
    #####: 9934:	    printf (_("[Spare]"));
        -: 9935:	  else
        -: 9936:	    {
    #####: 9937:	      unsigned int mask = op2 & 0x0f;
    #####: 9938:	      bool first = true;
        -: 9939:	      int i;
        -: 9940:
    #####: 9941:	      printf ("pop {");
    #####: 9942:	      for (i = 0; i < 4; i++)
    #####: 9943:		if (mask & (1 << i))
        -: 9944:		  {
    #####: 9945:		    if (first)
    #####: 9946:		      first = false;
        -: 9947:		    else
    #####: 9948:		      printf (", ");
    #####: 9949:		    printf ("wCGR%d", i);
        -: 9950:		  }
    #####: 9951:	      printf ("}");
        -: 9952:	    }
        -: 9953:	}
        -: 9954:      else
        -: 9955:	{
    #####: 9956:	  printf (_("     [unsupported opcode]"));
    #####: 9957:	  res = false;
        -: 9958:	}
        -: 9959:
    #####: 9960:      printf ("\n");
        -: 9961:    }
        -: 9962:
    #####: 9963:  return res;
        -: 9964:}
        -: 9965:
        -: 9966:static bool
    #####: 9967:decode_tic6x_unwind_bytecode (Filedata *                 filedata,
        -: 9968:			      struct arm_unw_aux_info *  aux,
        -: 9969:			      unsigned int               word,
        -: 9970:			      unsigned int               remaining,
        -: 9971:			      unsigned int               more_words,
        -: 9972:			      bfd_vma                    data_offset,
        -: 9973:			      Elf_Internal_Shdr *        data_sec,
        -: 9974:			      struct arm_section *       data_arm_sec)
        -: 9975:{
        -: 9976:  struct absaddr addr;
        -: 9977:
        -: 9978:  /* Decode the unwinding instructions.  */
        -: 9979:  while (1)
    #####: 9980:    {
        -: 9981:      unsigned int op, op2;
        -: 9982:
    #####: 9983:      ADVANCE;
    #####: 9984:      if (remaining == 0)
    #####: 9985:	break;
    #####: 9986:      remaining--;
    #####: 9987:      op = word >> 24;
    #####: 9988:      word <<= 8;
        -: 9989:
    #####: 9990:      printf ("  0x%02x ", op);
        -: 9991:
    #####: 9992:      if ((op & 0xc0) == 0x00)
        -: 9993:	{
    #####: 9994:	  int offset = ((op & 0x3f) << 3) + 8;
    #####: 9995:	  printf ("     sp = sp + %d", offset);
        -: 9996:	}
    #####: 9997:      else if ((op & 0xc0) == 0x80)
        -: 9998:	{
    #####: 9999:	  GET_OP (op2);
    #####:10000:	  if (op == 0x80 && op2 == 0)
    #####:10001:	    printf (_("Refuse to unwind"));
        -:10002:	  else
        -:10003:	    {
    #####:10004:	      unsigned int mask = ((op & 0x1f) << 8) | op2;
    #####:10005:	      if (op & 0x20)
    #####:10006:		printf ("pop compact {");
        -:10007:	      else
    #####:10008:		printf ("pop {");
        -:10009:
    #####:10010:	      decode_tic6x_unwind_regmask (mask);
    #####:10011:	      printf("}");
        -:10012:	    }
        -:10013:	}
    #####:10014:      else if ((op & 0xf0) == 0xc0)
        -:10015:	{
        -:10016:	  unsigned int reg;
        -:10017:	  unsigned int nregs;
        -:10018:	  unsigned int i;
        -:10019:	  const char *name;
        -:10020:	  struct
        -:10021:	  {
        -:10022:	    unsigned int offset;
        -:10023:	    unsigned int reg;
        -:10024:	  } regpos[16];
        -:10025:
        -:10026:	  /* Scan entire instruction first so that GET_OP output is not
        -:10027:	     interleaved with disassembly.  */
    #####:10028:	  nregs = 0;
    #####:10029:	  for (i = 0; nregs < (op & 0xf); i++)
        -:10030:	    {
    #####:10031:	      GET_OP (op2);
    #####:10032:	      reg = op2 >> 4;
    #####:10033:	      if (reg != 0xf)
        -:10034:		{
    #####:10035:		  regpos[nregs].offset = i * 2;
    #####:10036:		  regpos[nregs].reg = reg;
    #####:10037:		  nregs++;
        -:10038:		}
        -:10039:
    #####:10040:	      reg = op2 & 0xf;
    #####:10041:	      if (reg != 0xf)
        -:10042:		{
    #####:10043:		  regpos[nregs].offset = i * 2 + 1;
    #####:10044:		  regpos[nregs].reg = reg;
    #####:10045:		  nregs++;
        -:10046:		}
        -:10047:	    }
        -:10048:
    #####:10049:	  printf (_("pop frame {"));
    #####:10050:	  if (nregs == 0)
        -:10051:	    {
    #####:10052:	      printf (_("*corrupt* - no registers specified"));
        -:10053:	    }
        -:10054:	  else
        -:10055:	    {
    #####:10056:	      reg = nregs - 1;
    #####:10057:	      for (i = i * 2; i > 0; i--)
        -:10058:		{
    #####:10059:		  if (regpos[reg].offset == i - 1)
        -:10060:		    {
    #####:10061:		      name = tic6x_unwind_regnames[regpos[reg].reg];
    #####:10062:		      if (reg > 0)
    #####:10063:			reg--;
        -:10064:		    }
        -:10065:		  else
    #####:10066:		    name = _("[pad]");
        -:10067:
    #####:10068:		  fputs (name, stdout);
    #####:10069:		  if (i > 1)
    #####:10070:		    printf (", ");
        -:10071:		}
        -:10072:	    }
        -:10073:
    #####:10074:	  printf ("}");
        -:10075:	}
    #####:10076:      else if (op == 0xd0)
    #####:10077:	printf ("     MOV FP, SP");
    #####:10078:      else if (op == 0xd1)
    #####:10079:	printf ("     __c6xabi_pop_rts");
    #####:10080:      else if (op == 0xd2)
        -:10081:	{
        -:10082:	  unsigned char buf[9];
        -:10083:	  unsigned int i, len;
        -:10084:	  unsigned long offset;
        -:10085:
    #####:10086:	  for (i = 0; i < sizeof (buf); i++)
        -:10087:	    {
    #####:10088:	      GET_OP (buf[i]);
    #####:10089:	      if ((buf[i] & 0x80) == 0)
    #####:10090:		break;
        -:10091:	    }
        -:10092:	  /* PR 17531: file: id:000001,src:001906+004739,op:splice,rep:2.  */
    #####:10093:	  if (i == sizeof (buf))
        -:10094:	    {
    #####:10095:	      warn (_("Corrupt stack pointer adjustment detected\n"));
    #####:10096:	      return false;
        -:10097:	    }
        -:10098:
    #####:10099:	  offset = read_leb128 (buf, buf + i + 1, false, &len, NULL);
    #####:10100:	  assert (len == i + 1);
    #####:10101:	  offset = offset * 8 + 0x408;
    #####:10102:	  printf (_("sp = sp + %ld"), offset);
        -:10103:	}
    #####:10104:      else if ((op & 0xf0) == 0xe0)
        -:10105:	{
    #####:10106:	  if ((op & 0x0f) == 7)
    #####:10107:	    printf ("     RETURN");
        -:10108:	  else
    #####:10109:	    printf ("     MV %s, B3", tic6x_unwind_regnames[op & 0x0f]);
        -:10110:	}
        -:10111:      else
        -:10112:	{
    #####:10113:	  printf (_("     [unsupported opcode]"));
        -:10114:	}
    #####:10115:      putchar ('\n');
        -:10116:    }
        -:10117:
    #####:10118:  return true;
        -:10119:}
        -:10120:
        -:10121:static bfd_vma
    #####:10122:arm_expand_prel31 (Filedata * filedata, bfd_vma word, bfd_vma where)
        -:10123:{
        -:10124:  bfd_vma offset;
        -:10125:
    #####:10126:  offset = word & 0x7fffffff;
    #####:10127:  if (offset & 0x40000000)
    #####:10128:    offset |= ~ (bfd_vma) 0x7fffffff;
        -:10129:
    #####:10130:  if (filedata->file_header.e_machine == EM_TI_C6000)
    #####:10131:    offset <<= 1;
        -:10132:
    #####:10133:  return offset + where;
        -:10134:}
        -:10135:
        -:10136:static bool
    #####:10137:decode_arm_unwind (Filedata *                 filedata,
        -:10138:		   struct arm_unw_aux_info *  aux,
        -:10139:		   unsigned int               word,
        -:10140:		   unsigned int               remaining,
        -:10141:		   bfd_vma                    data_offset,
        -:10142:		   Elf_Internal_Shdr *        data_sec,
        -:10143:		   struct arm_section *       data_arm_sec)
        -:10144:{
        -:10145:  int per_index;
    #####:10146:  unsigned int more_words = 0;
        -:10147:  struct absaddr addr;
    #####:10148:  bfd_vma sym_name = (bfd_vma) -1;
    #####:10149:  bool res = true;
        -:10150:
    #####:10151:  if (remaining == 0)
        -:10152:    {
        -:10153:      /* Fetch the first word.
        -:10154:	 Note - when decoding an object file the address extracted
        -:10155:	 here will always be 0.  So we also pass in the sym_name
        -:10156:	 parameter so that we can find the symbol associated with
        -:10157:	 the personality routine.  */
    #####:10158:      if (! get_unwind_section_word (filedata, aux, data_arm_sec, data_sec, data_offset,
        -:10159:				     & word, & addr, & sym_name))
    #####:10160:	return false;
        -:10161:
    #####:10162:      remaining = 4;
        -:10163:    }
        -:10164:  else
        -:10165:    {
    #####:10166:      addr.section = SHN_UNDEF;
    #####:10167:      addr.offset = 0;
        -:10168:    }
        -:10169:
    #####:10170:  if ((word & 0x80000000) == 0)
        -:10171:    {
        -:10172:      /* Expand prel31 for personality routine.  */
        -:10173:      bfd_vma fn;
        -:10174:      const char *procname;
        -:10175:
    #####:10176:      fn = arm_expand_prel31 (filedata, word, data_sec->sh_addr + data_offset);
    #####:10177:      printf (_("  Personality routine: "));
    #####:10178:      if (fn == 0
    #####:10179:	  && addr.section == SHN_UNDEF && addr.offset == 0
    #####:10180:	  && sym_name != (bfd_vma) -1 && sym_name < aux->strtab_size)
        -:10181:	{
    #####:10182:	  procname = aux->strtab + sym_name;
    #####:10183:	  print_vma (fn, PREFIX_HEX);
    #####:10184:	  if (procname)
        -:10185:	    {
    #####:10186:	      fputs (" <", stdout);
    #####:10187:	      fputs (procname, stdout);
    #####:10188:	      fputc ('>', stdout);
        -:10189:	    }
        -:10190:	}
        -:10191:      else
    #####:10192:	procname = arm_print_vma_and_name (filedata, aux, fn, addr);
    #####:10193:      fputc ('\n', stdout);
        -:10194:
        -:10195:      /* The GCC personality routines use the standard compact
        -:10196:	 encoding, starting with one byte giving the number of
        -:10197:	 words.  */
    #####:10198:      if (procname != NULL
    #####:10199:	  && (startswith (procname, "__gcc_personality_v0")
    #####:10200:	      || startswith (procname, "__gxx_personality_v0")
    #####:10201:	      || startswith (procname, "__gcj_personality_v0")
    #####:10202:	      || startswith (procname, "__gnu_objc_personality_v0")))
        -:10203:	{
    #####:10204:	  remaining = 0;
    #####:10205:	  more_words = 1;
    #####:10206:	  ADVANCE;
    #####:10207:	  if (!remaining)
        -:10208:	    {
    #####:10209:	      printf (_("  [Truncated data]\n"));
    #####:10210:	      return false;
        -:10211:	    }
    #####:10212:	  more_words = word >> 24;
    #####:10213:	  word <<= 8;
    #####:10214:	  remaining--;
    #####:10215:	  per_index = -1;
        -:10216:	}
        -:10217:      else
    #####:10218:	return true;
        -:10219:    }
        -:10220:  else
        -:10221:    {
        -:10222:      /* ARM EHABI Section 6.3:
        -:10223:
        -:10224:	 An exception-handling table entry for the compact model looks like:
        -:10225:
        -:10226:           31 30-28 27-24 23-0
        -:10227:	   -- ----- ----- ----
        -:10228:            1   0   index Data for personalityRoutine[index]    */
        -:10229:
    #####:10230:      if (filedata->file_header.e_machine == EM_ARM
    #####:10231:	  && (word & 0x70000000))
        -:10232:	{
    #####:10233:	  warn (_("Corrupt ARM compact model table entry: %x \n"), word);
    #####:10234:	  res = false;
        -:10235:	}
        -:10236:
    #####:10237:      per_index = (word >> 24) & 0x7f;
    #####:10238:      printf (_("  Compact model index: %d\n"), per_index);
    #####:10239:      if (per_index == 0)
        -:10240:	{
    #####:10241:	  more_words = 0;
    #####:10242:	  word <<= 8;
    #####:10243:	  remaining--;
        -:10244:	}
    #####:10245:      else if (per_index < 3)
        -:10246:	{
    #####:10247:	  more_words = (word >> 16) & 0xff;
    #####:10248:	  word <<= 16;
    #####:10249:	  remaining -= 2;
        -:10250:	}
        -:10251:    }
        -:10252:
    #####:10253:  switch (filedata->file_header.e_machine)
        -:10254:    {
    #####:10255:    case EM_ARM:
    #####:10256:      if (per_index < 3)
        -:10257:	{
    #####:10258:	  if (! decode_arm_unwind_bytecode (filedata, aux, word, remaining, more_words,
        -:10259:					    data_offset, data_sec, data_arm_sec))
    #####:10260:	    res = false;
        -:10261:	}
        -:10262:      else
        -:10263:	{
    #####:10264:	  warn (_("Unknown ARM compact model index encountered\n"));
    #####:10265:	  printf (_("  [reserved]\n"));
    #####:10266:	  res = false;
        -:10267:	}
    #####:10268:      break;
        -:10269:
    #####:10270:    case EM_TI_C6000:
    #####:10271:      if (per_index < 3)
        -:10272:	{
    #####:10273:	  if (! decode_tic6x_unwind_bytecode (filedata, aux, word, remaining, more_words,
        -:10274:					      data_offset, data_sec, data_arm_sec))
    #####:10275:	    res = false;
        -:10276:	}
    #####:10277:      else if (per_index < 5)
        -:10278:	{
    #####:10279:	  if (((word >> 17) & 0x7f) == 0x7f)
    #####:10280:	    printf (_("  Restore stack from frame pointer\n"));
        -:10281:	  else
    #####:10282:	    printf (_("  Stack increment %d\n"), (word >> 14) & 0x1fc);
    #####:10283:	  printf (_("  Registers restored: "));
    #####:10284:	  if (per_index == 4)
    #####:10285:	    printf (" (compact) ");
    #####:10286:	  decode_tic6x_unwind_regmask ((word >> 4) & 0x1fff);
    #####:10287:	  putchar ('\n');
    #####:10288:	  printf (_("  Return register: %s\n"),
    #####:10289:		  tic6x_unwind_regnames[word & 0xf]);
        -:10290:	}
        -:10291:      else
    #####:10292:	printf (_("  [reserved (%d)]\n"), per_index);
    #####:10293:      break;
        -:10294:
    #####:10295:    default:
    #####:10296:      error (_("Unsupported architecture type %d encountered when decoding unwind table\n"),
    #####:10297:	     filedata->file_header.e_machine);
    #####:10298:      res = false;
        -:10299:    }
        -:10300:
        -:10301:  /* Decode the descriptors.  Not implemented.  */
        -:10302:
    #####:10303:  return res;
        -:10304:}
        -:10305:
        -:10306:static bool
    #####:10307:dump_arm_unwind (Filedata *                 filedata,
        -:10308:		 struct arm_unw_aux_info *  aux,
        -:10309:		 Elf_Internal_Shdr *        exidx_sec)
        -:10310:{
        -:10311:  struct arm_section exidx_arm_sec, extab_arm_sec;
        -:10312:  unsigned int i, exidx_len;
        -:10313:  unsigned long j, nfuns;
    #####:10314:  bool res = true;
        -:10315:
    #####:10316:  memset (&exidx_arm_sec, 0, sizeof (exidx_arm_sec));
    #####:10317:  memset (&extab_arm_sec, 0, sizeof (extab_arm_sec));
    #####:10318:  exidx_len = exidx_sec->sh_size / 8;
        -:10319:
    #####:10320:  aux->funtab = xmalloc (aux->nsyms * sizeof (Elf_Internal_Sym));
    #####:10321:  for (nfuns = 0, j = 0; j < aux->nsyms; j++)
    #####:10322:    if (aux->symtab[j].st_value && ELF_ST_TYPE (aux->symtab[j].st_info) == STT_FUNC)
    #####:10323:      aux->funtab[nfuns++] = aux->symtab[j];
    #####:10324:  aux->nfuns = nfuns;
    #####:10325:  qsort (aux->funtab, aux->nfuns, sizeof (Elf_Internal_Sym), symcmp);
        -:10326:
    #####:10327:  for (i = 0; i < exidx_len; i++)
        -:10328:    {
        -:10329:      unsigned int exidx_fn, exidx_entry;
        -:10330:      struct absaddr fn_addr, entry_addr;
        -:10331:      bfd_vma fn;
        -:10332:
    #####:10333:      fputc ('\n', stdout);
        -:10334:
    #####:10335:      if (! get_unwind_section_word (filedata, aux, & exidx_arm_sec, exidx_sec,
    #####:10336:				     8 * i, & exidx_fn, & fn_addr, NULL)
    #####:10337:	  || ! get_unwind_section_word (filedata, aux, & exidx_arm_sec, exidx_sec,
    #####:10338:					8 * i + 4, & exidx_entry, & entry_addr, NULL))
        -:10339:	{
    #####:10340:	  free (aux->funtab);
    #####:10341:	  arm_free_section (& exidx_arm_sec);
    #####:10342:	  arm_free_section (& extab_arm_sec);
    #####:10343:	  return false;
        -:10344:	}
        -:10345:
        -:10346:      /* ARM EHABI, Section 5:
        -:10347:	 An index table entry consists of 2 words.
        -:10348:         The first word contains a prel31 offset to the start of a function, with bit 31 clear.  */
    #####:10349:      if (exidx_fn & 0x80000000)
        -:10350:	{
    #####:10351:	  warn (_("corrupt index table entry: %x\n"), exidx_fn);
    #####:10352:	  res = false;
        -:10353:	}
        -:10354:
    #####:10355:      fn = arm_expand_prel31 (filedata, exidx_fn, exidx_sec->sh_addr + 8 * i);
        -:10356:
    #####:10357:      arm_print_vma_and_name (filedata, aux, fn, fn_addr);
    #####:10358:      fputs (": ", stdout);
        -:10359:
    #####:10360:      if (exidx_entry == 1)
        -:10361:	{
    #####:10362:	  print_vma (exidx_entry, PREFIX_HEX);
    #####:10363:	  fputs (" [cantunwind]\n", stdout);
        -:10364:	}
    #####:10365:      else if (exidx_entry & 0x80000000)
        -:10366:	{
    #####:10367:	  print_vma (exidx_entry, PREFIX_HEX);
    #####:10368:	  fputc ('\n', stdout);
    #####:10369:	  decode_arm_unwind (filedata, aux, exidx_entry, 4, 0, NULL, NULL);
        -:10370:	}
        -:10371:      else
        -:10372:	{
    #####:10373:	  bfd_vma table, table_offset = 0;
        -:10374:	  Elf_Internal_Shdr *table_sec;
        -:10375:
    #####:10376:	  fputs ("@", stdout);
    #####:10377:	  table = arm_expand_prel31 (filedata, exidx_entry, exidx_sec->sh_addr + 8 * i + 4);
    #####:10378:	  print_vma (table, PREFIX_HEX);
    #####:10379:	  printf ("\n");
        -:10380:
        -:10381:	  /* Locate the matching .ARM.extab.  */
    #####:10382:	  if (entry_addr.section != SHN_UNDEF
    #####:10383:	      && entry_addr.section < filedata->file_header.e_shnum)
        -:10384:	    {
    #####:10385:	      table_sec = filedata->section_headers + entry_addr.section;
    #####:10386:	      table_offset = entry_addr.offset;
        -:10387:	      /* PR 18879 */
    #####:10388:	      if (table_offset > table_sec->sh_size
    #####:10389:		  || ((bfd_signed_vma) table_offset) < 0)
        -:10390:		{
    #####:10391:		  warn (_("Unwind entry contains corrupt offset (0x%lx) into section %s\n"),
        -:10392:			(unsigned long) table_offset,
        -:10393:			printable_section_name (filedata, table_sec));
    #####:10394:		  res = false;
    #####:10395:		  continue;
        -:10396:		}
        -:10397:	    }
        -:10398:	  else
        -:10399:	    {
    #####:10400:	      table_sec = find_section_by_address (filedata, table);
    #####:10401:	      if (table_sec != NULL)
    #####:10402:		table_offset = table - table_sec->sh_addr;
        -:10403:	    }
        -:10404:
    #####:10405:	  if (table_sec == NULL)
        -:10406:	    {
    #####:10407:	      warn (_("Could not locate .ARM.extab section containing 0x%lx.\n"),
        -:10408:		    (unsigned long) table);
    #####:10409:	      res = false;
    #####:10410:	      continue;
        -:10411:	    }
        -:10412:
    #####:10413:	  if (! decode_arm_unwind (filedata, aux, 0, 0, table_offset, table_sec,
        -:10414:				   &extab_arm_sec))
    #####:10415:	    res = false;
        -:10416:	}
        -:10417:    }
        -:10418:
    #####:10419:  printf ("\n");
        -:10420:
    #####:10421:  free (aux->funtab);
    #####:10422:  arm_free_section (&exidx_arm_sec);
    #####:10423:  arm_free_section (&extab_arm_sec);
        -:10424:
    #####:10425:  return res;
        -:10426:}
        -:10427:
        -:10428:/* Used for both ARM and C6X unwinding tables.  */
        -:10429:
        -:10430:static bool
    #####:10431:arm_process_unwind (Filedata * filedata)
        -:10432:{
        -:10433:  struct arm_unw_aux_info aux;
    #####:10434:  Elf_Internal_Shdr *unwsec = NULL;
        -:10435:  Elf_Internal_Shdr *sec;
        -:10436:  unsigned long i;
        -:10437:  unsigned int sec_type;
    #####:10438:  bool res = true;
        -:10439:
    #####:10440:  switch (filedata->file_header.e_machine)
        -:10441:    {
    #####:10442:    case EM_ARM:
    #####:10443:      sec_type = SHT_ARM_EXIDX;
    #####:10444:      break;
        -:10445:
    #####:10446:    case EM_TI_C6000:
    #####:10447:      sec_type = SHT_C6000_UNWIND;
    #####:10448:      break;
        -:10449:
    #####:10450:    default:
    #####:10451:      error (_("Unsupported architecture type %d encountered when processing unwind table\n"),
    #####:10452:	     filedata->file_header.e_machine);
    #####:10453:      return false;
        -:10454:    }
        -:10455:
    #####:10456:  if (filedata->string_table == NULL)
    #####:10457:    return false;
        -:10458:
    #####:10459:  memset (& aux, 0, sizeof (aux));
    #####:10460:  aux.filedata = filedata;
        -:10461:
    #####:10462:  for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
        -:10463:    {
    #####:10464:      if (sec->sh_type == SHT_SYMTAB)
        -:10465:	{
    #####:10466:	  if (aux.symtab)
        -:10467:	    {
    #####:10468:	      error (_("Multiple symbol tables encountered\n"));
    #####:10469:	      free (aux.symtab);
    #####:10470:	      aux.symtab = NULL;
    #####:10471:	      free (aux.strtab);
    #####:10472:	      aux.strtab = NULL;
        -:10473:	    }
    #####:10474:	  if (!get_symtab (filedata, sec, &aux.symtab, &aux.nsyms,
        -:10475:			   &aux.strtab, &aux.strtab_size))
    #####:10476:	    return false;
        -:10477:	}
    #####:10478:      else if (sec->sh_type == sec_type)
    #####:10479:	unwsec = sec;
        -:10480:    }
        -:10481:
    #####:10482:  if (unwsec == NULL)
    #####:10483:    printf (_("\nThere are no unwind sections in this file.\n"));
        -:10484:  else
    #####:10485:    for (i = 0, sec = filedata->section_headers; i < filedata->file_header.e_shnum; ++i, ++sec)
        -:10486:      {
    #####:10487:	if (sec->sh_type == sec_type)
        -:10488:	  {
    #####:10489:	    unsigned long num_unwind = sec->sh_size / (2 * eh_addr_size);
    #####:10490:	    printf (ngettext ("\nUnwind section '%s' at offset 0x%lx "
        -:10491:			      "contains %lu entry:\n",
        -:10492:			      "\nUnwind section '%s' at offset 0x%lx "
        -:10493:			      "contains %lu entries:\n",
        -:10494:			      num_unwind),
        -:10495:		    printable_section_name (filedata, sec),
    #####:10496:		    (unsigned long) sec->sh_offset,
        -:10497:		    num_unwind);
        -:10498:
    #####:10499:	    if (! dump_arm_unwind (filedata, &aux, sec))
    #####:10500:	      res = false;
        -:10501:	  }
        -:10502:      }
        -:10503:
    #####:10504:  free (aux.symtab);
    #####:10505:  free ((char *) aux.strtab);
        -:10506:
    #####:10507:  return res;
        -:10508:}
        -:10509:
        -:10510:static bool
       92:10511:no_processor_specific_unwind (Filedata * filedata ATTRIBUTE_UNUSED)
        -:10512:{
       92:10513:  printf (_("No processor specific unwind information to decode\n"));
       92:10514:  return true;
        -:10515:}
        -:10516:
        -:10517:static bool
     1391:10518:process_unwind (Filedata * filedata)
        -:10519:{
        -:10520:  struct unwind_handler
        -:10521:  {
        -:10522:    unsigned int machtype;
        -:10523:    bool (* handler)(Filedata *);
     1391:10524:  } handlers[] =
        -:10525:  {
        -:10526:    { EM_ARM, arm_process_unwind },
        -:10527:    { EM_IA_64, ia64_process_unwind },
        -:10528:    { EM_PARISC, hppa_process_unwind },
        -:10529:    { EM_TI_C6000, arm_process_unwind },
        -:10530:    { EM_386, no_processor_specific_unwind },
        -:10531:    { EM_X86_64, no_processor_specific_unwind },
        -:10532:    { 0, NULL }
        -:10533:  };
        -:10534:  int i;
        -:10535:
     1391:10536:  if (!do_unwind)
     1228:10537:    return true;
        -:10538:
      901:10539:  for (i = 0; handlers[i].handler != NULL; i++)
      844:10540:    if (filedata->file_header.e_machine == handlers[i].machtype)
      106:10541:      return handlers[i].handler (filedata);
        -:10542:
       57:10543:  printf (_("\nThe decoding of unwind sections for machine type %s is not currently supported.\n"),
       57:10544:	  get_machine_name (filedata->file_header.e_machine));
       57:10545:  return true;
        -:10546:}
        -:10547:
        -:10548:static void
    #####:10549:dynamic_section_aarch64_val (Elf_Internal_Dyn * entry)
        -:10550:{
    #####:10551:  switch (entry->d_tag)
        -:10552:    {
    #####:10553:    case DT_AARCH64_BTI_PLT:
        -:10554:    case DT_AARCH64_PAC_PLT:
    #####:10555:      break;
    #####:10556:    default:
    #####:10557:      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
    #####:10558:      break;
        -:10559:    }
    #####:10560:  putchar ('\n');
    #####:10561:}
        -:10562:
        -:10563:static void
        2:10564:dynamic_section_mips_val (Filedata * filedata, Elf_Internal_Dyn * entry)
        -:10565:{
        2:10566:  switch (entry->d_tag)
        -:10567:    {
    #####:10568:    case DT_MIPS_FLAGS:
    #####:10569:      if (entry->d_un.d_val == 0)
    #####:10570:	printf (_("NONE"));
        -:10571:      else
        -:10572:	{
        -:10573:	  static const char * opts[] =
        -:10574:	  {
        -:10575:	    "QUICKSTART", "NOTPOT", "NO_LIBRARY_REPLACEMENT",
        -:10576:	    "NO_MOVE", "SGI_ONLY", "GUARANTEE_INIT", "DELTA_C_PLUS_PLUS",
        -:10577:	    "GUARANTEE_START_INIT", "PIXIE", "DEFAULT_DELAY_LOAD",
        -:10578:	    "REQUICKSTART", "REQUICKSTARTED", "CORD", "NO_UNRES_UNDEF",
        -:10579:	    "RLD_ORDER_SAFE"
        -:10580:	  };
        -:10581:	  unsigned int cnt;
    #####:10582:	  bool first = true;
        -:10583:
    #####:10584:	  for (cnt = 0; cnt < ARRAY_SIZE (opts); ++cnt)
    #####:10585:	    if (entry->d_un.d_val & (1 << cnt))
        -:10586:	      {
    #####:10587:		printf ("%s%s", first ? "" : " ", opts[cnt]);
    #####:10588:		first = false;
        -:10589:	      }
        -:10590:	}
    #####:10591:      break;
        -:10592:
    #####:10593:    case DT_MIPS_IVERSION:
    #####:10594:      if (valid_dynamic_name (filedata, entry->d_un.d_val))
    #####:10595:	printf (_("Interface Version: %s"),
        -:10596:		get_dynamic_name (filedata, entry->d_un.d_val));
        -:10597:      else
        -:10598:	{
        -:10599:	  char buf[40];
    #####:10600:	  sprintf_vma (buf, entry->d_un.d_ptr);
        -:10601:	  /* Note: coded this way so that there is a single string for translation.  */
    #####:10602:	  printf (_("<corrupt: %s>"), buf);
        -:10603:	}
    #####:10604:      break;
        -:10605:
    #####:10606:    case DT_MIPS_TIME_STAMP:
        -:10607:      {
        -:10608:	char timebuf[128];
        -:10609:	struct tm * tmp;
    #####:10610:	time_t atime = entry->d_un.d_val;
        -:10611:
    #####:10612:	tmp = gmtime (&atime);
        -:10613:	/* PR 17531: file: 6accc532.  */
    #####:10614:	if (tmp == NULL)
    #####:10615:	  snprintf (timebuf, sizeof (timebuf), _("<corrupt>"));
        -:10616:	else
    #####:10617:	  snprintf (timebuf, sizeof (timebuf), "%04u-%02u-%02uT%02u:%02u:%02u",
    #####:10618:		    tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
        -:10619:		    tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
    #####:10620:	printf (_("Time Stamp: %s"), timebuf);
        -:10621:      }
    #####:10622:      break;
        -:10623:
    #####:10624:    case DT_MIPS_RLD_VERSION:
        -:10625:    case DT_MIPS_LOCAL_GOTNO:
        -:10626:    case DT_MIPS_CONFLICTNO:
        -:10627:    case DT_MIPS_LIBLISTNO:
        -:10628:    case DT_MIPS_SYMTABNO:
        -:10629:    case DT_MIPS_UNREFEXTNO:
        -:10630:    case DT_MIPS_HIPAGENO:
        -:10631:    case DT_MIPS_DELTA_CLASS_NO:
        -:10632:    case DT_MIPS_DELTA_INSTANCE_NO:
        -:10633:    case DT_MIPS_DELTA_RELOC_NO:
        -:10634:    case DT_MIPS_DELTA_SYM_NO:
        -:10635:    case DT_MIPS_DELTA_CLASSSYM_NO:
        -:10636:    case DT_MIPS_COMPACT_SIZE:
    #####:10637:      print_vma (entry->d_un.d_val, DEC);
    #####:10638:      break;
        -:10639:
    #####:10640:    case DT_MIPS_XHASH:
    #####:10641:      filedata->dynamic_info_DT_MIPS_XHASH = entry->d_un.d_val;
    #####:10642:      filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
        -:10643:      /* Falls through.  */
        -:10644:
        2:10645:    default:
        2:10646:      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
        -:10647:    }
        2:10648:    putchar ('\n');
        2:10649:}
        -:10650:
        -:10651:static void
        2:10652:dynamic_section_parisc_val (Elf_Internal_Dyn * entry)
        -:10653:{
        2:10654:  switch (entry->d_tag)
        -:10655:    {
    #####:10656:    case DT_HP_DLD_FLAGS:
        -:10657:      {
        -:10658:	static struct
        -:10659:	{
        -:10660:	  long int bit;
        -:10661:	  const char * str;
        -:10662:	}
        -:10663:	flags[] =
        -:10664:	{
        -:10665:	  { DT_HP_DEBUG_PRIVATE, "HP_DEBUG_PRIVATE" },
        -:10666:	  { DT_HP_DEBUG_CALLBACK, "HP_DEBUG_CALLBACK" },
        -:10667:	  { DT_HP_DEBUG_CALLBACK_BOR, "HP_DEBUG_CALLBACK_BOR" },
        -:10668:	  { DT_HP_NO_ENVVAR, "HP_NO_ENVVAR" },
        -:10669:	  { DT_HP_BIND_NOW, "HP_BIND_NOW" },
        -:10670:	  { DT_HP_BIND_NONFATAL, "HP_BIND_NONFATAL" },
        -:10671:	  { DT_HP_BIND_VERBOSE, "HP_BIND_VERBOSE" },
        -:10672:	  { DT_HP_BIND_RESTRICTED, "HP_BIND_RESTRICTED" },
        -:10673:	  { DT_HP_BIND_SYMBOLIC, "HP_BIND_SYMBOLIC" },
        -:10674:	  { DT_HP_RPATH_FIRST, "HP_RPATH_FIRST" },
        -:10675:	  { DT_HP_BIND_DEPTH_FIRST, "HP_BIND_DEPTH_FIRST" },
        -:10676:	  { DT_HP_GST, "HP_GST" },
        -:10677:	  { DT_HP_SHLIB_FIXED, "HP_SHLIB_FIXED" },
        -:10678:	  { DT_HP_MERGE_SHLIB_SEG, "HP_MERGE_SHLIB_SEG" },
        -:10679:	  { DT_HP_NODELETE, "HP_NODELETE" },
        -:10680:	  { DT_HP_GROUP, "HP_GROUP" },
        -:10681:	  { DT_HP_PROTECT_LINKAGE_TABLE, "HP_PROTECT_LINKAGE_TABLE" }
        -:10682:	};
    #####:10683:	bool first = true;
        -:10684:	size_t cnt;
    #####:10685:	bfd_vma val = entry->d_un.d_val;
        -:10686:
    #####:10687:	for (cnt = 0; cnt < ARRAY_SIZE (flags); ++cnt)
    #####:10688:	  if (val & flags[cnt].bit)
        -:10689:	    {
    #####:10690:	      if (! first)
    #####:10691:		putchar (' ');
    #####:10692:	      fputs (flags[cnt].str, stdout);
    #####:10693:	      first = false;
    #####:10694:	      val ^= flags[cnt].bit;
        -:10695:	    }
        -:10696:
    #####:10697:	if (val != 0 || first)
        -:10698:	  {
    #####:10699:	    if (! first)
    #####:10700:	      putchar (' ');
    #####:10701:	    print_vma (val, HEX);
        -:10702:	  }
        -:10703:      }
    #####:10704:      break;
        -:10705:
        2:10706:    default:
        2:10707:      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
        2:10708:      break;
        -:10709:    }
        2:10710:  putchar ('\n');
        2:10711:}
        -:10712:
        -:10713:#ifdef BFD64
        -:10714:
        -:10715:/* VMS vs Unix time offset and factor.  */
        -:10716:
        -:10717:#define VMS_EPOCH_OFFSET 35067168000000000LL
        -:10718:#define VMS_GRANULARITY_FACTOR 10000000
        -:10719:#ifndef INT64_MIN
        -:10720:#define INT64_MIN (-9223372036854775807LL - 1)
        -:10721:#endif
        -:10722:
        -:10723:/* Display a VMS time in a human readable format.  */
        -:10724:
        -:10725:static void
    #####:10726:print_vms_time (int64_t vmstime)
        -:10727:{
    #####:10728:  struct tm *tm = NULL;
        -:10729:  time_t unxtime;
        -:10730:
    #####:10731:  if (vmstime >= INT64_MIN + VMS_EPOCH_OFFSET)
        -:10732:    {
    #####:10733:      vmstime = (vmstime - VMS_EPOCH_OFFSET) / VMS_GRANULARITY_FACTOR;
    #####:10734:      unxtime = vmstime;
    #####:10735:      if (unxtime == vmstime)
    #####:10736:	tm = gmtime (&unxtime);
        -:10737:    }
    #####:10738:  if (tm != NULL)
    #####:10739:    printf ("%04u-%02u-%02uT%02u:%02u:%02u",
    #####:10740:	    tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
        -:10741:	    tm->tm_hour, tm->tm_min, tm->tm_sec);
    #####:10742:}
        -:10743:#endif /* BFD64 */
        -:10744:
        -:10745:static void
    #####:10746:dynamic_section_ia64_val (Elf_Internal_Dyn * entry)
        -:10747:{
    #####:10748:  switch (entry->d_tag)
        -:10749:    {
    #####:10750:    case DT_IA_64_PLT_RESERVE:
        -:10751:      /* First 3 slots reserved.  */
    #####:10752:      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
    #####:10753:      printf (" -- ");
    #####:10754:      print_vma (entry->d_un.d_ptr + (3 * 8), PREFIX_HEX);
    #####:10755:      break;
        -:10756:
    #####:10757:    case DT_IA_64_VMS_LINKTIME:
        -:10758:#ifdef BFD64
    #####:10759:      print_vms_time (entry->d_un.d_val);
        -:10760:#endif
    #####:10761:      break;
        -:10762:
    #####:10763:    case DT_IA_64_VMS_LNKFLAGS:
    #####:10764:      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
    #####:10765:      if (entry->d_un.d_val & VMS_LF_CALL_DEBUG)
    #####:10766:        printf (" CALL_DEBUG");
    #####:10767:      if (entry->d_un.d_val & VMS_LF_NOP0BUFS)
    #####:10768:        printf (" NOP0BUFS");
    #####:10769:      if (entry->d_un.d_val & VMS_LF_P0IMAGE)
    #####:10770:        printf (" P0IMAGE");
    #####:10771:      if (entry->d_un.d_val & VMS_LF_MKTHREADS)
    #####:10772:        printf (" MKTHREADS");
    #####:10773:      if (entry->d_un.d_val & VMS_LF_UPCALLS)
    #####:10774:        printf (" UPCALLS");
    #####:10775:      if (entry->d_un.d_val & VMS_LF_IMGSTA)
    #####:10776:        printf (" IMGSTA");
    #####:10777:      if (entry->d_un.d_val & VMS_LF_INITIALIZE)
    #####:10778:        printf (" INITIALIZE");
    #####:10779:      if (entry->d_un.d_val & VMS_LF_MAIN)
    #####:10780:        printf (" MAIN");
    #####:10781:      if (entry->d_un.d_val & VMS_LF_EXE_INIT)
    #####:10782:        printf (" EXE_INIT");
    #####:10783:      if (entry->d_un.d_val & VMS_LF_TBK_IN_IMG)
    #####:10784:        printf (" TBK_IN_IMG");
    #####:10785:      if (entry->d_un.d_val & VMS_LF_DBG_IN_IMG)
    #####:10786:        printf (" DBG_IN_IMG");
    #####:10787:      if (entry->d_un.d_val & VMS_LF_TBK_IN_DSF)
    #####:10788:        printf (" TBK_IN_DSF");
    #####:10789:      if (entry->d_un.d_val & VMS_LF_DBG_IN_DSF)
    #####:10790:        printf (" DBG_IN_DSF");
    #####:10791:      if (entry->d_un.d_val & VMS_LF_SIGNATURES)
    #####:10792:        printf (" SIGNATURES");
    #####:10793:      if (entry->d_un.d_val & VMS_LF_REL_SEG_OFF)
    #####:10794:        printf (" REL_SEG_OFF");
    #####:10795:      break;
        -:10796:
    #####:10797:    default:
    #####:10798:      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
    #####:10799:      break;
        -:10800:    }
    #####:10801:  putchar ('\n');
    #####:10802:}
        -:10803:
        -:10804:static bool
       37:10805:get_32bit_dynamic_section (Filedata * filedata)
        -:10806:{
        -:10807:  Elf32_External_Dyn * edyn;
        -:10808:  Elf32_External_Dyn * ext;
        -:10809:  Elf_Internal_Dyn * entry;
        -:10810:
       37:10811:  edyn = (Elf32_External_Dyn *) get_data (NULL, filedata,
        -:10812:					  filedata->dynamic_addr, 1,
        -:10813:					  filedata->dynamic_size,
       37:10814:					  _("dynamic section"));
       37:10815:  if (!edyn)
        1:10816:    return false;
        -:10817:
        -:10818:  /* SGI's ELF has more than one section in the DYNAMIC segment, and we
        -:10819:     might not have the luxury of section headers.  Look for the DT_NULL
        -:10820:     terminator to determine the number of entries.  */
       36:10821:  for (ext = edyn, filedata->dynamic_nent = 0;
      103:10822:       (char *) (ext + 1) <= (char *) edyn + filedata->dynamic_size;
       67:10823:       ext++)
        -:10824:    {
       80:10825:      filedata->dynamic_nent++;
       80:10826:      if (BYTE_GET (ext->d_tag) == DT_NULL)
       13:10827:	break;
        -:10828:    }
        -:10829:
        -:10830:  filedata->dynamic_section
       36:10831:    = (Elf_Internal_Dyn *) cmalloc (filedata->dynamic_nent, sizeof (* entry));
       36:10832:  if (filedata->dynamic_section == NULL)
        -:10833:    {
    #####:10834:      error (_("Out of memory allocating space for %lu dynamic entries\n"),
    #####:10835:	     (unsigned long) filedata->dynamic_nent);
    #####:10836:      free (edyn);
    #####:10837:      return false;
        -:10838:    }
        -:10839:
       36:10840:  for (ext = edyn, entry = filedata->dynamic_section;
      116:10841:       entry < filedata->dynamic_section + filedata->dynamic_nent;
       80:10842:       ext++, entry++)
        -:10843:    {
       80:10844:      entry->d_tag      = BYTE_GET (ext->d_tag);
       80:10845:      entry->d_un.d_val = BYTE_GET (ext->d_un.d_val);
        -:10846:    }
        -:10847:
       36:10848:  free (edyn);
        -:10849:
       36:10850:  return true;
        -:10851:}
        -:10852:
        -:10853:static bool
    #####:10854:get_64bit_dynamic_section (Filedata * filedata)
        -:10855:{
        -:10856:  Elf64_External_Dyn * edyn;
        -:10857:  Elf64_External_Dyn * ext;
        -:10858:  Elf_Internal_Dyn * entry;
        -:10859:
        -:10860:  /* Read in the data.  */
    #####:10861:  edyn = (Elf64_External_Dyn *) get_data (NULL, filedata,
        -:10862:					  filedata->dynamic_addr, 1,
        -:10863:					  filedata->dynamic_size,
    #####:10864:					  _("dynamic section"));
    #####:10865:  if (!edyn)
    #####:10866:    return false;
        -:10867:
        -:10868:  /* SGI's ELF has more than one section in the DYNAMIC segment, and we
        -:10869:     might not have the luxury of section headers.  Look for the DT_NULL
        -:10870:     terminator to determine the number of entries.  */
    #####:10871:  for (ext = edyn, filedata->dynamic_nent = 0;
        -:10872:       /* PR 17533 file: 033-67080-0.004 - do not read past end of buffer.  */
    #####:10873:       (char *) (ext + 1) <= (char *) edyn + filedata->dynamic_size;
    #####:10874:       ext++)
        -:10875:    {
    #####:10876:      filedata->dynamic_nent++;
    #####:10877:      if (BYTE_GET (ext->d_tag) == DT_NULL)
    #####:10878:	break;
        -:10879:    }
        -:10880:
        -:10881:  filedata->dynamic_section
    #####:10882:    = (Elf_Internal_Dyn *) cmalloc (filedata->dynamic_nent, sizeof (* entry));
    #####:10883:  if (filedata->dynamic_section == NULL)
        -:10884:    {
    #####:10885:      error (_("Out of memory allocating space for %lu dynamic entries\n"),
    #####:10886:	     (unsigned long) filedata->dynamic_nent);
    #####:10887:      free (edyn);
    #####:10888:      return false;
        -:10889:    }
        -:10890:
        -:10891:  /* Convert from external to internal formats.  */
    #####:10892:  for (ext = edyn, entry = filedata->dynamic_section;
    #####:10893:       entry < filedata->dynamic_section + filedata->dynamic_nent;
    #####:10894:       ext++, entry++)
        -:10895:    {
    #####:10896:      entry->d_tag      = BYTE_GET (ext->d_tag);
    #####:10897:      entry->d_un.d_val = BYTE_GET (ext->d_un.d_val);
        -:10898:    }
        -:10899:
    #####:10900:  free (edyn);
        -:10901:
    #####:10902:  return true;
        -:10903:}
        -:10904:
        -:10905:static bool
       40:10906:get_dynamic_section (Filedata *filedata)
        -:10907:{
       40:10908:  if (filedata->dynamic_section)
        3:10909:    return true;
        -:10910:
       37:10911:  if (is_32bit_elf)
       37:10912:    return get_32bit_dynamic_section (filedata);
        -:10913:  else
    #####:10914:    return get_64bit_dynamic_section (filedata);
        -:10915:}
        -:10916:
        -:10917:static void
    #####:10918:print_dynamic_flags (bfd_vma flags)
        -:10919:{
    #####:10920:  bool first = true;
        -:10921:
    #####:10922:  while (flags)
        -:10923:    {
        -:10924:      bfd_vma flag;
        -:10925:
    #####:10926:      flag = flags & - flags;
    #####:10927:      flags &= ~ flag;
        -:10928:
    #####:10929:      if (first)
    #####:10930:	first = false;
        -:10931:      else
    #####:10932:	putc (' ', stdout);
        -:10933:
    #####:10934:      switch (flag)
        -:10935:	{
    #####:10936:	case DF_ORIGIN:		fputs ("ORIGIN", stdout); break;
    #####:10937:	case DF_SYMBOLIC:	fputs ("SYMBOLIC", stdout); break;
    #####:10938:	case DF_TEXTREL:	fputs ("TEXTREL", stdout); break;
    #####:10939:	case DF_BIND_NOW:	fputs ("BIND_NOW", stdout); break;
    #####:10940:	case DF_STATIC_TLS:	fputs ("STATIC_TLS", stdout); break;
    #####:10941:	default:		fputs (_("unknown"), stdout); break;
        -:10942:	}
        -:10943:    }
    #####:10944:  puts ("");
    #####:10945:}
        -:10946:
        -:10947:static bfd_vma *
    #####:10948:get_dynamic_data (Filedata * filedata, bfd_size_type number, unsigned int ent_size)
        -:10949:{
        -:10950:  unsigned char * e_data;
        -:10951:  bfd_vma * i_data;
        -:10952:
        -:10953:  /* If the size_t type is smaller than the bfd_size_type, eg because
        -:10954:     you are building a 32-bit tool on a 64-bit host, then make sure
        -:10955:     that when (number) is cast to (size_t) no information is lost.  */
        -:10956:  if (sizeof (size_t) < sizeof (bfd_size_type)
        -:10957:      && (bfd_size_type) ((size_t) number) != number)
        -:10958:    {
        -:10959:      error (_("Size truncation prevents reading %s elements of size %u\n"),
        -:10960:	     bfd_vmatoa ("u", number), ent_size);
        -:10961:      return NULL;
        -:10962:    }
        -:10963:
        -:10964:  /* Be kind to memory checkers (eg valgrind, address sanitizer) by not
        -:10965:     attempting to allocate memory when the read is bound to fail.  */
    #####:10966:  if (ent_size * number > filedata->file_size)
        -:10967:    {
    #####:10968:      error (_("Invalid number of dynamic entries: %s\n"),
        -:10969:	     bfd_vmatoa ("u", number));
    #####:10970:      return NULL;
        -:10971:    }
        -:10972:
    #####:10973:  e_data = (unsigned char *) cmalloc ((size_t) number, ent_size);
    #####:10974:  if (e_data == NULL)
        -:10975:    {
    #####:10976:      error (_("Out of memory reading %s dynamic entries\n"),
        -:10977:	     bfd_vmatoa ("u", number));
    #####:10978:      return NULL;
        -:10979:    }
        -:10980:
    #####:10981:  if (fread (e_data, ent_size, (size_t) number, filedata->handle) != number)
        -:10982:    {
    #####:10983:      error (_("Unable to read in %s bytes of dynamic data\n"),
        -:10984:	     bfd_vmatoa ("u", number * ent_size));
    #####:10985:      free (e_data);
    #####:10986:      return NULL;
        -:10987:    }
        -:10988:
    #####:10989:  i_data = (bfd_vma *) cmalloc ((size_t) number, sizeof (*i_data));
    #####:10990:  if (i_data == NULL)
        -:10991:    {
    #####:10992:      error (_("Out of memory allocating space for %s dynamic entries\n"),
        -:10993:	     bfd_vmatoa ("u", number));
    #####:10994:      free (e_data);
    #####:10995:      return NULL;
        -:10996:    }
        -:10997:
    #####:10998:  while (number--)
    #####:10999:    i_data[number] = byte_get (e_data + number * ent_size, ent_size);
        -:11000:
    #####:11001:  free (e_data);
        -:11002:
    #####:11003:  return i_data;
        -:11004:}
        -:11005:
        -:11006:static unsigned long
       36:11007:get_num_dynamic_syms (Filedata * filedata)
        -:11008:{
       36:11009:  unsigned long num_of_syms = 0;
        -:11010:
      36*:11011:  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))
    #####:11012:    return num_of_syms;
        -:11013:
       36:11014:  if (filedata->dynamic_info[DT_HASH])
        -:11015:    {
        -:11016:      unsigned char nb[8];
        -:11017:      unsigned char nc[8];
    #####:11018:      unsigned int hash_ent_size = 4;
        -:11019:
    #####:11020:      if ((filedata->file_header.e_machine == EM_ALPHA
    #####:11021:	   || filedata->file_header.e_machine == EM_S390
    #####:11022:	   || filedata->file_header.e_machine == EM_S390_OLD)
    #####:11023:	  && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)
    #####:11024:	hash_ent_size = 8;
        -:11025:
    #####:11026:      if (fseek (filedata->handle,
    #####:11027:		 (filedata->archive_file_offset
    #####:11028:		  + offset_from_vma (filedata, filedata->dynamic_info[DT_HASH],
        -:11029:				     sizeof nb + sizeof nc)),
        -:11030:		 SEEK_SET))
        -:11031:	{
    #####:11032:	  error (_("Unable to seek to start of dynamic information\n"));
    #####:11033:	  goto no_hash;
        -:11034:	}
        -:11035:
    #####:11036:      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)
        -:11037:	{
    #####:11038:	  error (_("Failed to read in number of buckets\n"));
    #####:11039:	  goto no_hash;
        -:11040:	}
        -:11041:
    #####:11042:      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)
        -:11043:	{
    #####:11044:	  error (_("Failed to read in number of chains\n"));
    #####:11045:	  goto no_hash;
        -:11046:	}
        -:11047:
    #####:11048:      filedata->nbuckets = byte_get (nb, hash_ent_size);
    #####:11049:      filedata->nchains = byte_get (nc, hash_ent_size);
        -:11050:
    #####:11051:      if (filedata->nbuckets != 0 && filedata->nchains != 0)
        -:11052:	{
    #####:11053:	  filedata->buckets = get_dynamic_data (filedata, filedata->nbuckets,
        -:11054:						hash_ent_size);
    #####:11055:	  filedata->chains  = get_dynamic_data (filedata, filedata->nchains,
        -:11056:						hash_ent_size);
        -:11057:
    #####:11058:	  if (filedata->buckets != NULL && filedata->chains != NULL)
    #####:11059:	    num_of_syms = filedata->nchains;
        -:11060:	}
    #####:11061:    no_hash:
    #####:11062:      if (num_of_syms == 0)
        -:11063:	{
    #####:11064:	  free (filedata->buckets);
    #####:11065:	  filedata->buckets = NULL;
    #####:11066:	  free (filedata->chains);
    #####:11067:	  filedata->chains = NULL;
    #####:11068:	  filedata->nbuckets = 0;
        -:11069:	}
        -:11070:    }
        -:11071:
       36:11072:  if (filedata->dynamic_info_DT_GNU_HASH)
        -:11073:    {
        -:11074:      unsigned char nb[16];
    #####:11075:      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;
        -:11076:      bfd_vma buckets_vma;
        -:11077:      unsigned long hn;
        -:11078:
    #####:11079:      if (fseek (filedata->handle,
    #####:11080:		 (filedata->archive_file_offset
    #####:11081:		  + offset_from_vma (filedata,
        -:11082:				     filedata->dynamic_info_DT_GNU_HASH,
        -:11083:				     sizeof nb)),
        -:11084:		 SEEK_SET))
        -:11085:	{
    #####:11086:	  error (_("Unable to seek to start of dynamic information\n"));
    #####:11087:	  goto no_gnu_hash;
        -:11088:	}
        -:11089:
    #####:11090:      if (fread (nb, 16, 1, filedata->handle) != 1)
        -:11091:	{
    #####:11092:	  error (_("Failed to read in number of buckets\n"));
    #####:11093:	  goto no_gnu_hash;
        -:11094:	}
        -:11095:
    #####:11096:      filedata->ngnubuckets = byte_get (nb, 4);
    #####:11097:      filedata->gnusymidx = byte_get (nb + 4, 4);
    #####:11098:      bitmaskwords = byte_get (nb + 8, 4);
    #####:11099:      buckets_vma = filedata->dynamic_info_DT_GNU_HASH + 16;
    #####:11100:      if (is_32bit_elf)
    #####:11101:	buckets_vma += bitmaskwords * 4;
        -:11102:      else
    #####:11103:	buckets_vma += bitmaskwords * 8;
        -:11104:
    #####:11105:      if (fseek (filedata->handle,
    #####:11106:		 (filedata->archive_file_offset
    #####:11107:		  + offset_from_vma (filedata, buckets_vma, 4)),
        -:11108:		 SEEK_SET))
        -:11109:	{
    #####:11110:	  error (_("Unable to seek to start of dynamic information\n"));
    #####:11111:	  goto no_gnu_hash;
        -:11112:	}
        -:11113:
        -:11114:      filedata->gnubuckets
    #####:11115:	= get_dynamic_data (filedata, filedata->ngnubuckets, 4);
        -:11116:
    #####:11117:      if (filedata->gnubuckets == NULL)
    #####:11118:	goto no_gnu_hash;
        -:11119:
    #####:11120:      for (i = 0; i < filedata->ngnubuckets; i++)
    #####:11121:	if (filedata->gnubuckets[i] != 0)
        -:11122:	  {
    #####:11123:	    if (filedata->gnubuckets[i] < filedata->gnusymidx)
    #####:11124:	      goto no_gnu_hash;
        -:11125:
    #####:11126:	    if (maxchain == 0xffffffff || filedata->gnubuckets[i] > maxchain)
    #####:11127:	      maxchain = filedata->gnubuckets[i];
        -:11128:	  }
        -:11129:
    #####:11130:      if (maxchain == 0xffffffff)
    #####:11131:	goto no_gnu_hash;
        -:11132:
    #####:11133:      maxchain -= filedata->gnusymidx;
        -:11134:
    #####:11135:      if (fseek (filedata->handle,
    #####:11136:		 (filedata->archive_file_offset
    #####:11137:		  + offset_from_vma (filedata,
    #####:11138:				     buckets_vma + 4 * (filedata->ngnubuckets
    #####:11139:							+ maxchain),
        -:11140:				      4)),
        -:11141:		 SEEK_SET))
        -:11142:	{
    #####:11143:	  error (_("Unable to seek to start of dynamic information\n"));
    #####:11144:	  goto no_gnu_hash;
        -:11145:	}
        -:11146:
        -:11147:      do
        -:11148:	{
    #####:11149:	  if (fread (nb, 4, 1, filedata->handle) != 1)
        -:11150:	    {
    #####:11151:	      error (_("Failed to determine last chain length\n"));
    #####:11152:	      goto no_gnu_hash;
        -:11153:	    }
        -:11154:
    #####:11155:	  if (maxchain + 1 == 0)
    #####:11156:	    goto no_gnu_hash;
        -:11157:
    #####:11158:	  ++maxchain;
        -:11159:	}
    #####:11160:      while ((byte_get (nb, 4) & 1) == 0);
        -:11161:
    #####:11162:      if (fseek (filedata->handle,
    #####:11163:		 (filedata->archive_file_offset
    #####:11164:		  + offset_from_vma (filedata, (buckets_vma
    #####:11165:						+ 4 * filedata->ngnubuckets),
        -:11166:				     4)),
        -:11167:		 SEEK_SET))
        -:11168:	{
    #####:11169:	  error (_("Unable to seek to start of dynamic information\n"));
    #####:11170:	  goto no_gnu_hash;
        -:11171:	}
        -:11172:
    #####:11173:      filedata->gnuchains = get_dynamic_data (filedata, maxchain, 4);
    #####:11174:      filedata->ngnuchains = maxchain;
        -:11175:
    #####:11176:      if (filedata->gnuchains == NULL)
    #####:11177:	goto no_gnu_hash;
        -:11178:
    #####:11179:      if (filedata->dynamic_info_DT_MIPS_XHASH)
        -:11180:	{
    #####:11181:	  if (fseek (filedata->handle,
    #####:11182:		     (filedata->archive_file_offset
    #####:11183:		      + offset_from_vma (filedata, (buckets_vma
    #####:11184:						    + 4 * (filedata->ngnubuckets
    #####:11185:							   + maxchain)), 4)),
        -:11186:		     SEEK_SET))
        -:11187:	    {
    #####:11188:	      error (_("Unable to seek to start of dynamic information\n"));
    #####:11189:	      goto no_gnu_hash;
        -:11190:	    }
        -:11191:
    #####:11192:	  filedata->mipsxlat = get_dynamic_data (filedata, maxchain, 4);
    #####:11193:	  if (filedata->mipsxlat == NULL)
    #####:11194:	    goto no_gnu_hash;
        -:11195:	}
        -:11196:
    #####:11197:      for (hn = 0; hn < filedata->ngnubuckets; ++hn)
    #####:11198:	if (filedata->gnubuckets[hn] != 0)
        -:11199:	  {
    #####:11200:	    bfd_vma si = filedata->gnubuckets[hn];
    #####:11201:	    bfd_vma off = si - filedata->gnusymidx;
        -:11202:
        -:11203:	    do
        -:11204:	      {
    #####:11205:		if (filedata->dynamic_info_DT_MIPS_XHASH)
        -:11206:		  {
    #####:11207:		    if (off < filedata->ngnuchains
    #####:11208:			&& filedata->mipsxlat[off] >= num_of_syms)
    #####:11209:		      num_of_syms = filedata->mipsxlat[off] + 1;
        -:11210:		  }
        -:11211:		else
        -:11212:		  {
    #####:11213:		    if (si >= num_of_syms)
    #####:11214:		      num_of_syms = si + 1;
        -:11215:		  }
    #####:11216:		si++;
        -:11217:	      }
    #####:11218:	    while (off < filedata->ngnuchains
    #####:11219:		   && (filedata->gnuchains[off++] & 1) == 0);
        -:11220:	  }
        -:11221:
    #####:11222:      if (num_of_syms == 0)
        -:11223:	{
    #####:11224:	no_gnu_hash:
    #####:11225:	  free (filedata->mipsxlat);
    #####:11226:	  filedata->mipsxlat = NULL;
    #####:11227:	  free (filedata->gnuchains);
    #####:11228:	  filedata->gnuchains = NULL;
    #####:11229:	  free (filedata->gnubuckets);
    #####:11230:	  filedata->gnubuckets = NULL;
    #####:11231:	  filedata->ngnubuckets = 0;
    #####:11232:	  filedata->ngnuchains = 0;
        -:11233:	}
        -:11234:    }
        -:11235:
       36:11236:  return num_of_syms;
        -:11237:}
        -:11238:
        -:11239:/* Parse and display the contents of the dynamic section.  */
        -:11240:
        -:11241:static bool
     1391:11242:process_dynamic_section (Filedata * filedata)
        -:11243:{
        -:11244:  Elf_Internal_Dyn * entry;
        -:11245:
     1391:11246:  if (filedata->dynamic_size <= 1)
        -:11247:    {
     1354:11248:      if (do_dynamic)
        -:11249:	{
     1354:11250:	  if (filedata->is_separate)
    #####:11251:	    printf (_("\nThere is no dynamic section in linked file '%s'.\n"),
        -:11252:		    filedata->file_name);
        -:11253:	  else
     1354:11254:	    printf (_("\nThere is no dynamic section in this file.\n"));
        -:11255:	}
        -:11256:
     1354:11257:      return true;
        -:11258:    }
        -:11259:
       37:11260:  if (!get_dynamic_section (filedata))
        1:11261:    return false;
        -:11262:
        -:11263:  /* Find the appropriate symbol table.  */
       36:11264:  if (filedata->dynamic_symbols == NULL || do_histogram)
        -:11265:    {
        -:11266:      unsigned long num_of_syms;
        -:11267:
       36:11268:      for (entry = filedata->dynamic_section;
      116:11269:	   entry < filedata->dynamic_section + filedata->dynamic_nent;
       80:11270:	   ++entry)
       80:11271:	if (entry->d_tag == DT_SYMTAB)
        1:11272:	  filedata->dynamic_info[DT_SYMTAB] = entry->d_un.d_val;
       79:11273:	else if (entry->d_tag == DT_SYMENT)
    #####:11274:	  filedata->dynamic_info[DT_SYMENT] = entry->d_un.d_val;
       79:11275:	else if (entry->d_tag == DT_HASH)
    #####:11276:	  filedata->dynamic_info[DT_HASH] = entry->d_un.d_val;
       79:11277:	else if (entry->d_tag == DT_GNU_HASH)
    #####:11278:	  filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
       79:11279:	else if ((filedata->file_header.e_machine == EM_MIPS
       78:11280:		  || filedata->file_header.e_machine == EM_MIPS_RS3_LE)
        3:11281:		 && entry->d_tag == DT_MIPS_XHASH)
        -:11282:	  {
    #####:11283:	    filedata->dynamic_info_DT_MIPS_XHASH = entry->d_un.d_val;
    #####:11284:	    filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
        -:11285:	  }
        -:11286:
       36:11287:      num_of_syms = get_num_dynamic_syms (filedata);
        -:11288:
       36:11289:      if (num_of_syms != 0
    #####:11290:	  && filedata->dynamic_symbols == NULL
    #####:11291:	  && filedata->dynamic_info[DT_SYMTAB]
    #####:11292:	  && filedata->dynamic_info[DT_SYMENT])
        -:11293:	{
        -:11294:	  Elf_Internal_Phdr *seg;
    #####:11295:	  bfd_vma vma = filedata->dynamic_info[DT_SYMTAB];
        -:11296:
    #####:11297:	  if (! get_program_headers (filedata))
        -:11298:	    {
    #####:11299:	      error (_("Cannot interpret virtual addresses "
        -:11300:		       "without program headers.\n"));
    #####:11301:	      return false;
        -:11302:	    }
        -:11303:
    #####:11304:	  for (seg = filedata->program_headers;
    #####:11305:	       seg < filedata->program_headers + filedata->file_header.e_phnum;
    #####:11306:	       ++seg)
        -:11307:	    {
    #####:11308:	      if (seg->p_type != PT_LOAD)
    #####:11309:		continue;
        -:11310:
    #####:11311:	      if (seg->p_offset + seg->p_filesz > filedata->file_size)
        -:11312:		{
        -:11313:		  /* See PR 21379 for a reproducer.  */
    #####:11314:		  error (_("Invalid PT_LOAD entry\n"));
    #####:11315:		  return false;
        -:11316:		}
        -:11317:
    #####:11318:	      if (vma >= (seg->p_vaddr & -seg->p_align)
    #####:11319:		  && vma < seg->p_vaddr + seg->p_filesz)
        -:11320:		{
        -:11321:		  /* Since we do not know how big the symbol table is,
        -:11322:		     we default to reading in up to the end of PT_LOAD
        -:11323:		     segment and processing that.  This is overkill, I
        -:11324:		     know, but it should work.  */
        -:11325:		  Elf_Internal_Shdr section;
    #####:11326:		  section.sh_offset = (vma - seg->p_vaddr
    #####:11327:				       + seg->p_offset);
    #####:11328:		  section.sh_size = (num_of_syms
    #####:11329:				     * filedata->dynamic_info[DT_SYMENT]);
    #####:11330:		  section.sh_entsize = filedata->dynamic_info[DT_SYMENT];
        -:11331:
    #####:11332:		  if (do_checks
    #####:11333:		      && filedata->dynamic_symtab_section != NULL
    #####:11334:		      && ((filedata->dynamic_symtab_section->sh_offset
    #####:11335:			   != section.sh_offset)
    #####:11336:			  || (filedata->dynamic_symtab_section->sh_size
    #####:11337:			      != section.sh_size)
    #####:11338:			  || (filedata->dynamic_symtab_section->sh_entsize
    #####:11339:			      != section.sh_entsize)))
    #####:11340:		    warn (_("\
        -:11341:the .dynsym section doesn't match the DT_SYMTAB and DT_SYMENT tags\n"));
        -:11342:
    #####:11343:		  section.sh_name = filedata->string_table_length;
        -:11344:		  filedata->dynamic_symbols
    #####:11345:		    = get_elf_symbols (filedata, &section,
        -:11346:				       &filedata->num_dynamic_syms);
    #####:11347:		  if (filedata->dynamic_symbols == NULL
    #####:11348:		      || filedata->num_dynamic_syms != num_of_syms)
        -:11349:		    {
    #####:11350:		      error (_("Corrupt DT_SYMTAB dynamic entry\n"));
    #####:11351:		      return false;
        -:11352:		    }
    #####:11353:		  break;
        -:11354:		}
        -:11355:	    }
        -:11356:	}
        -:11357:    }
        -:11358:
        -:11359:  /* Similarly find a string table.  */
       36:11360:  if (filedata->dynamic_strings == NULL)
       36:11361:    for (entry = filedata->dynamic_section;
      116:11362:	 entry < filedata->dynamic_section + filedata->dynamic_nent;
       80:11363:	 ++entry)
        -:11364:      {
       80:11365:	if (entry->d_tag == DT_STRTAB)
    #####:11366:	  filedata->dynamic_info[DT_STRTAB] = entry->d_un.d_val;
        -:11367:
       80:11368:	if (entry->d_tag == DT_STRSZ)
    #####:11369:	  filedata->dynamic_info[DT_STRSZ] = entry->d_un.d_val;
        -:11370:
       80:11371:	if (filedata->dynamic_info[DT_STRTAB]
    #####:11372:	    && filedata->dynamic_info[DT_STRSZ])
        -:11373:	  {
        -:11374:	    unsigned long offset;
    #####:11375:	    bfd_size_type str_tab_len = filedata->dynamic_info[DT_STRSZ];
        -:11376:
    #####:11377:	    offset = offset_from_vma (filedata,
        -:11378:				      filedata->dynamic_info[DT_STRTAB],
        -:11379:				      str_tab_len);
    #####:11380:	    if (do_checks
    #####:11381:		&& filedata->dynamic_strtab_section
    #####:11382:		&& ((filedata->dynamic_strtab_section->sh_offset
    #####:11383:		     != (file_ptr) offset)
    #####:11384:		    || (filedata->dynamic_strtab_section->sh_size
        -:11385:			!= str_tab_len)))
    #####:11386:	      warn (_("\
        -:11387:the .dynstr section doesn't match the DT_STRTAB and DT_STRSZ tags\n"));
        -:11388:
        -:11389:	    filedata->dynamic_strings
    #####:11390:	      = (char *) get_data (NULL, filedata, offset, 1, str_tab_len,
    #####:11391:				   _("dynamic string table"));
    #####:11392:	    if (filedata->dynamic_strings == NULL)
        -:11393:	      {
    #####:11394:		error (_("Corrupt DT_STRTAB dynamic entry\n"));
    #####:11395:		break;
        -:11396:	      }
        -:11397:
    #####:11398:	    filedata->dynamic_strings_length = str_tab_len;
    #####:11399:	    break;
        -:11400:	  }
        -:11401:      }
        -:11402:
        -:11403:  /* And find the syminfo section if available.  */
       36:11404:  if (filedata->dynamic_syminfo == NULL)
        -:11405:    {
       36:11406:      unsigned long syminsz = 0;
        -:11407:
       36:11408:      for (entry = filedata->dynamic_section;
      116:11409:	   entry < filedata->dynamic_section + filedata->dynamic_nent;
       80:11410:	   ++entry)
        -:11411:	{
       80:11412:	  if (entry->d_tag == DT_SYMINENT)
        -:11413:	    {
        -:11414:	      /* Note: these braces are necessary to avoid a syntax
        -:11415:		 error from the SunOS4 C compiler.  */
        -:11416:	      /* PR binutils/17531: A corrupt file can trigger this test.
        -:11417:		 So do not use an assert, instead generate an error message.  */
    #####:11418:	      if (sizeof (Elf_External_Syminfo) != entry->d_un.d_val)
    #####:11419:		error (_("Bad value (%d) for SYMINENT entry\n"),
    #####:11420:		       (int) entry->d_un.d_val);
        -:11421:	    }
       80:11422:	  else if (entry->d_tag == DT_SYMINSZ)
    #####:11423:	    syminsz = entry->d_un.d_val;
       80:11424:	  else if (entry->d_tag == DT_SYMINFO)
        -:11425:	    filedata->dynamic_syminfo_offset
    #####:11426:	      = offset_from_vma (filedata, entry->d_un.d_val, syminsz);
        -:11427:	}
        -:11428:
      36*:11429:      if (filedata->dynamic_syminfo_offset != 0 && syminsz != 0)
        -:11430:	{
        -:11431:	  Elf_External_Syminfo * extsyminfo;
        -:11432:	  Elf_External_Syminfo * extsym;
        -:11433:	  Elf_Internal_Syminfo * syminfo;
        -:11434:
        -:11435:	  /* There is a syminfo section.  Read the data.  */
        -:11436:	  extsyminfo = (Elf_External_Syminfo *)
    #####:11437:	    get_data (NULL, filedata, filedata->dynamic_syminfo_offset,
    #####:11438:		      1, syminsz, _("symbol information"));
    #####:11439:	  if (!extsyminfo)
    #####:11440:	    return false;
        -:11441:
    #####:11442:	  if (filedata->dynamic_syminfo != NULL)
        -:11443:	    {
    #####:11444:	      error (_("Multiple dynamic symbol information sections found\n"));
    #####:11445:	      free (filedata->dynamic_syminfo);
        -:11446:	    }
    #####:11447:	  filedata->dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);
    #####:11448:	  if (filedata->dynamic_syminfo == NULL)
        -:11449:	    {
    #####:11450:	      error (_("Out of memory allocating %lu bytes "
        -:11451:		       "for dynamic symbol info\n"),
        -:11452:		     (unsigned long) syminsz);
    #####:11453:	      return false;
        -:11454:	    }
        -:11455:
        -:11456:	  filedata->dynamic_syminfo_nent
    #####:11457:	    = syminsz / sizeof (Elf_External_Syminfo);
    #####:11458:	  for (syminfo = filedata->dynamic_syminfo, extsym = extsyminfo;
    #####:11459:	       syminfo < (filedata->dynamic_syminfo
    #####:11460:			  + filedata->dynamic_syminfo_nent);
    #####:11461:	       ++syminfo, ++extsym)
        -:11462:	    {
    #####:11463:	      syminfo->si_boundto = BYTE_GET (extsym->si_boundto);
    #####:11464:	      syminfo->si_flags = BYTE_GET (extsym->si_flags);
        -:11465:	    }
        -:11466:
    #####:11467:	  free (extsyminfo);
        -:11468:	}
        -:11469:    }
        -:11470:
       36:11471:  if (do_dynamic && filedata->dynamic_addr)
        -:11472:    {
       24:11473:      if (filedata->is_separate)
    #####:11474:	printf (ngettext ("\nIn linked file '%s' the dynamic section at offset 0x%lx contains %lu entry:\n",
        -:11475:			  "\nIn linked file '%s' the dynamic section at offset 0x%lx contains %lu entries:\n",
    #####:11476:			  (unsigned long) filedata->dynamic_nent),
        -:11477:		filedata->file_name,
        -:11478:		filedata->dynamic_addr,
    #####:11479:		(unsigned long) filedata->dynamic_nent);
        -:11480:      else
       24:11481:	printf (ngettext ("\nDynamic section at offset 0x%lx contains %lu entry:\n",
        -:11482:			  "\nDynamic section at offset 0x%lx contains %lu entries:\n",
       24:11483:			  (unsigned long) filedata->dynamic_nent),
        -:11484:		filedata->dynamic_addr,
       24:11485:		(unsigned long) filedata->dynamic_nent);
        -:11486:    }
       36:11487:  if (do_dynamic)
       36:11488:    printf (_("  Tag        Type                         Name/Value\n"));
        -:11489:
       36:11490:  for (entry = filedata->dynamic_section;
      116:11491:       entry < filedata->dynamic_section + filedata->dynamic_nent;
       80:11492:       entry++)
        -:11493:    {
       80:11494:      if (do_dynamic)
        -:11495:	{
        -:11496:	  const char * dtype;
        -:11497:
       80:11498:	  putchar (' ');
       80:11499:	  print_vma (entry->d_tag, FULL_HEX);
       80:11500:	  dtype = get_dynamic_type (filedata, entry->d_tag);
       80:11501:	  printf (" (%s)%*s", dtype,
      80*:11502:		  ((is_32bit_elf ? 27 : 19) - (int) strlen (dtype)), " ");
        -:11503:	}
        -:11504:
       80:11505:      switch (entry->d_tag)
        -:11506:	{
    #####:11507:	case DT_FLAGS:
    #####:11508:	  if (do_dynamic)
    #####:11509:	    print_dynamic_flags (entry->d_un.d_val);
    #####:11510:	  break;
        -:11511:
        1:11512:	case DT_AUXILIARY:
        -:11513:	case DT_FILTER:
        -:11514:	case DT_CONFIG:
        -:11515:	case DT_DEPAUDIT:
        -:11516:	case DT_AUDIT:
        1:11517:	  if (do_dynamic)
        -:11518:	    {
        1:11519:	      switch (entry->d_tag)
        -:11520:		{
    #####:11521:		case DT_AUXILIARY:
    #####:11522:		  printf (_("Auxiliary library"));
    #####:11523:		  break;
        -:11524:
        1:11525:		case DT_FILTER:
        1:11526:		  printf (_("Filter library"));
        1:11527:		  break;
        -:11528:
    #####:11529:		case DT_CONFIG:
    #####:11530:		  printf (_("Configuration file"));
    #####:11531:		  break;
        -:11532:
    #####:11533:		case DT_DEPAUDIT:
    #####:11534:		  printf (_("Dependency audit library"));
    #####:11535:		  break;
        -:11536:
    #####:11537:		case DT_AUDIT:
    #####:11538:		  printf (_("Audit library"));
    #####:11539:		  break;
        -:11540:		}
        -:11541:
        1:11542:	      if (valid_dynamic_name (filedata, entry->d_un.d_val))
    #####:11543:		printf (": [%s]\n",
        -:11544:			get_dynamic_name (filedata, entry->d_un.d_val));
        -:11545:	      else
        -:11546:		{
        1:11547:		  printf (": ");
        1:11548:		  print_vma (entry->d_un.d_val, PREFIX_HEX);
        1:11549:		  putchar ('\n');
        -:11550:		}
        -:11551:	    }
        1:11552:	  break;
        -:11553:
    #####:11554:	case DT_FEATURE:
    #####:11555:	  if (do_dynamic)
        -:11556:	    {
    #####:11557:	      printf (_("Flags:"));
        -:11558:
    #####:11559:	      if (entry->d_un.d_val == 0)
    #####:11560:		printf (_(" None\n"));
        -:11561:	      else
        -:11562:		{
    #####:11563:		  unsigned long int val = entry->d_un.d_val;
        -:11564:
    #####:11565:		  if (val & DTF_1_PARINIT)
        -:11566:		    {
    #####:11567:		      printf (" PARINIT");
    #####:11568:		      val ^= DTF_1_PARINIT;
        -:11569:		    }
    #####:11570:		  if (val & DTF_1_CONFEXP)
        -:11571:		    {
    #####:11572:		      printf (" CONFEXP");
    #####:11573:		      val ^= DTF_1_CONFEXP;
        -:11574:		    }
    #####:11575:		  if (val != 0)
    #####:11576:		    printf (" %lx", val);
    #####:11577:		  puts ("");
        -:11578:		}
        -:11579:	    }
    #####:11580:	  break;
        -:11581:
    #####:11582:	case DT_POSFLAG_1:
    #####:11583:	  if (do_dynamic)
        -:11584:	    {
    #####:11585:	      printf (_("Flags:"));
        -:11586:
    #####:11587:	      if (entry->d_un.d_val == 0)
    #####:11588:		printf (_(" None\n"));
        -:11589:	      else
        -:11590:		{
    #####:11591:		  unsigned long int val = entry->d_un.d_val;
        -:11592:
    #####:11593:		  if (val & DF_P1_LAZYLOAD)
        -:11594:		    {
    #####:11595:		      printf (" LAZYLOAD");
    #####:11596:		      val ^= DF_P1_LAZYLOAD;
        -:11597:		    }
    #####:11598:		  if (val & DF_P1_GROUPPERM)
        -:11599:		    {
    #####:11600:		      printf (" GROUPPERM");
    #####:11601:		      val ^= DF_P1_GROUPPERM;
        -:11602:		    }
    #####:11603:		  if (val != 0)
    #####:11604:		    printf (" %lx", val);
    #####:11605:		  puts ("");
        -:11606:		}
        -:11607:	    }
    #####:11608:	  break;
        -:11609:
    #####:11610:	case DT_FLAGS_1:
    #####:11611:	  if (do_dynamic)
        -:11612:	    {
    #####:11613:	      printf (_("Flags:"));
    #####:11614:	      if (entry->d_un.d_val == 0)
    #####:11615:		printf (_(" None\n"));
        -:11616:	      else
        -:11617:		{
    #####:11618:		  unsigned long int val = entry->d_un.d_val;
        -:11619:
    #####:11620:		  if (val & DF_1_NOW)
        -:11621:		    {
    #####:11622:		      printf (" NOW");
    #####:11623:		      val ^= DF_1_NOW;
        -:11624:		    }
    #####:11625:		  if (val & DF_1_GLOBAL)
        -:11626:		    {
    #####:11627:		      printf (" GLOBAL");
    #####:11628:		      val ^= DF_1_GLOBAL;
        -:11629:		    }
    #####:11630:		  if (val & DF_1_GROUP)
        -:11631:		    {
    #####:11632:		      printf (" GROUP");
    #####:11633:		      val ^= DF_1_GROUP;
        -:11634:		    }
    #####:11635:		  if (val & DF_1_NODELETE)
        -:11636:		    {
    #####:11637:		      printf (" NODELETE");
    #####:11638:		      val ^= DF_1_NODELETE;
        -:11639:		    }
    #####:11640:		  if (val & DF_1_LOADFLTR)
        -:11641:		    {
    #####:11642:		      printf (" LOADFLTR");
    #####:11643:		      val ^= DF_1_LOADFLTR;
        -:11644:		    }
    #####:11645:		  if (val & DF_1_INITFIRST)
        -:11646:		    {
    #####:11647:		      printf (" INITFIRST");
    #####:11648:		      val ^= DF_1_INITFIRST;
        -:11649:		    }
    #####:11650:		  if (val & DF_1_NOOPEN)
        -:11651:		    {
    #####:11652:		      printf (" NOOPEN");
    #####:11653:		      val ^= DF_1_NOOPEN;
        -:11654:		    }
    #####:11655:		  if (val & DF_1_ORIGIN)
        -:11656:		    {
    #####:11657:		      printf (" ORIGIN");
    #####:11658:		      val ^= DF_1_ORIGIN;
        -:11659:		    }
    #####:11660:		  if (val & DF_1_DIRECT)
        -:11661:		    {
    #####:11662:		      printf (" DIRECT");
    #####:11663:		      val ^= DF_1_DIRECT;
        -:11664:		    }
    #####:11665:		  if (val & DF_1_TRANS)
        -:11666:		    {
    #####:11667:		      printf (" TRANS");
    #####:11668:		      val ^= DF_1_TRANS;
        -:11669:		    }
    #####:11670:		  if (val & DF_1_INTERPOSE)
        -:11671:		    {
    #####:11672:		      printf (" INTERPOSE");
    #####:11673:		      val ^= DF_1_INTERPOSE;
        -:11674:		    }
    #####:11675:		  if (val & DF_1_NODEFLIB)
        -:11676:		    {
    #####:11677:		      printf (" NODEFLIB");
    #####:11678:		      val ^= DF_1_NODEFLIB;
        -:11679:		    }
    #####:11680:		  if (val & DF_1_NODUMP)
        -:11681:		    {
    #####:11682:		      printf (" NODUMP");
    #####:11683:		      val ^= DF_1_NODUMP;
        -:11684:		    }
    #####:11685:		  if (val & DF_1_CONFALT)
        -:11686:		    {
    #####:11687:		      printf (" CONFALT");
    #####:11688:		      val ^= DF_1_CONFALT;
        -:11689:		    }
    #####:11690:		  if (val & DF_1_ENDFILTEE)
        -:11691:		    {
    #####:11692:		      printf (" ENDFILTEE");
    #####:11693:		      val ^= DF_1_ENDFILTEE;
        -:11694:		    }
    #####:11695:		  if (val & DF_1_DISPRELDNE)
        -:11696:		    {
    #####:11697:		      printf (" DISPRELDNE");
    #####:11698:		      val ^= DF_1_DISPRELDNE;
        -:11699:		    }
    #####:11700:		  if (val & DF_1_DISPRELPND)
        -:11701:		    {
    #####:11702:		      printf (" DISPRELPND");
    #####:11703:		      val ^= DF_1_DISPRELPND;
        -:11704:		    }
    #####:11705:		  if (val & DF_1_NODIRECT)
        -:11706:		    {
    #####:11707:		      printf (" NODIRECT");
    #####:11708:		      val ^= DF_1_NODIRECT;
        -:11709:		    }
    #####:11710:		  if (val & DF_1_IGNMULDEF)
        -:11711:		    {
    #####:11712:		      printf (" IGNMULDEF");
    #####:11713:		      val ^= DF_1_IGNMULDEF;
        -:11714:		    }
    #####:11715:		  if (val & DF_1_NOKSYMS)
        -:11716:		    {
    #####:11717:		      printf (" NOKSYMS");
    #####:11718:		      val ^= DF_1_NOKSYMS;
        -:11719:		    }
    #####:11720:		  if (val & DF_1_NOHDR)
        -:11721:		    {
    #####:11722:		      printf (" NOHDR");
    #####:11723:		      val ^= DF_1_NOHDR;
        -:11724:		    }
    #####:11725:		  if (val & DF_1_EDITED)
        -:11726:		    {
    #####:11727:		      printf (" EDITED");
    #####:11728:		      val ^= DF_1_EDITED;
        -:11729:		    }
    #####:11730:		  if (val & DF_1_NORELOC)
        -:11731:		    {
    #####:11732:		      printf (" NORELOC");
    #####:11733:		      val ^= DF_1_NORELOC;
        -:11734:		    }
    #####:11735:		  if (val & DF_1_SYMINTPOSE)
        -:11736:		    {
    #####:11737:		      printf (" SYMINTPOSE");
    #####:11738:		      val ^= DF_1_SYMINTPOSE;
        -:11739:		    }
    #####:11740:		  if (val & DF_1_GLOBAUDIT)
        -:11741:		    {
    #####:11742:		      printf (" GLOBAUDIT");
    #####:11743:		      val ^= DF_1_GLOBAUDIT;
        -:11744:		    }
    #####:11745:		  if (val & DF_1_SINGLETON)
        -:11746:		    {
    #####:11747:		      printf (" SINGLETON");
    #####:11748:		      val ^= DF_1_SINGLETON;
        -:11749:		    }
    #####:11750:		  if (val & DF_1_STUB)
        -:11751:		    {
    #####:11752:		      printf (" STUB");
    #####:11753:		      val ^= DF_1_STUB;
        -:11754:		    }
    #####:11755:		  if (val & DF_1_PIE)
        -:11756:		    {
    #####:11757:		      printf (" PIE");
    #####:11758:		      val ^= DF_1_PIE;
        -:11759:		    }
    #####:11760:		  if (val & DF_1_KMOD)
        -:11761:		    {
    #####:11762:		      printf (" KMOD");
    #####:11763:		      val ^= DF_1_KMOD;
        -:11764:		    }
    #####:11765:		  if (val & DF_1_WEAKFILTER)
        -:11766:		    {
    #####:11767:		      printf (" WEAKFILTER");
    #####:11768:		      val ^= DF_1_WEAKFILTER;
        -:11769:		    }
    #####:11770:		  if (val & DF_1_NOCOMMON)
        -:11771:		    {
    #####:11772:		      printf (" NOCOMMON");
    #####:11773:		      val ^= DF_1_NOCOMMON;
        -:11774:		    }
    #####:11775:		  if (val != 0)
    #####:11776:		    printf (" %lx", val);
    #####:11777:		  puts ("");
        -:11778:		}
        -:11779:	    }
    #####:11780:	  break;
        -:11781:
    #####:11782:	case DT_PLTREL:
    #####:11783:	  filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;
    #####:11784:	  if (do_dynamic)
    #####:11785:	    puts (get_dynamic_type (filedata, entry->d_un.d_val));
    #####:11786:	  break;
        -:11787:
       17:11788:	case DT_NULL	:
        -:11789:	case DT_NEEDED	:
        -:11790:	case DT_PLTGOT	:
        -:11791:	case DT_HASH	:
        -:11792:	case DT_STRTAB	:
        -:11793:	case DT_SYMTAB	:
        -:11794:	case DT_RELA	:
        -:11795:	case DT_INIT	:
        -:11796:	case DT_FINI	:
        -:11797:	case DT_SONAME	:
        -:11798:	case DT_RPATH	:
        -:11799:	case DT_SYMBOLIC:
        -:11800:	case DT_REL	:
        -:11801:	case DT_RELR    :
        -:11802:	case DT_DEBUG	:
        -:11803:	case DT_TEXTREL	:
        -:11804:	case DT_JMPREL	:
        -:11805:	case DT_RUNPATH	:
       17:11806:	  filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;
        -:11807:
       17:11808:	  if (do_dynamic)
        -:11809:	    {
        -:11810:	      const char *name;
        -:11811:
       17:11812:	      if (valid_dynamic_name (filedata, entry->d_un.d_val))
    #####:11813:		name = get_dynamic_name (filedata, entry->d_un.d_val);
        -:11814:	      else
       17:11815:		name = NULL;
        -:11816:
       17:11817:	      if (name)
        -:11818:		{
    #####:11819:		  switch (entry->d_tag)
        -:11820:		    {
    #####:11821:		    case DT_NEEDED:
    #####:11822:		      printf (_("Shared library: [%s]"), name);
        -:11823:
    #####:11824:		      if (filedata->program_interpreter
    #####:11825:			  && streq (name, filedata->program_interpreter))
    #####:11826:			printf (_(" program interpreter"));
    #####:11827:		      break;
        -:11828:
    #####:11829:		    case DT_SONAME:
    #####:11830:		      printf (_("Library soname: [%s]"), name);
    #####:11831:		      break;
        -:11832:
    #####:11833:		    case DT_RPATH:
    #####:11834:		      printf (_("Library rpath: [%s]"), name);
    #####:11835:		      break;
        -:11836:
    #####:11837:		    case DT_RUNPATH:
    #####:11838:		      printf (_("Library runpath: [%s]"), name);
    #####:11839:		      break;
        -:11840:
    #####:11841:		    default:
    #####:11842:		      print_vma (entry->d_un.d_val, PREFIX_HEX);
    #####:11843:		      break;
        -:11844:		    }
        -:11845:		}
        -:11846:	      else
       17:11847:		print_vma (entry->d_un.d_val, PREFIX_HEX);
        -:11848:
       17:11849:	      putchar ('\n');
        -:11850:	    }
       17:11851:	  break;
        -:11852:
    #####:11853:	case DT_PLTRELSZ:
        -:11854:	case DT_RELASZ	:
        -:11855:	case DT_STRSZ	:
        -:11856:	case DT_RELSZ	:
        -:11857:	case DT_RELAENT	:
        -:11858:	case DT_RELRENT	:
        -:11859:	case DT_RELRSZ	:
        -:11860:	case DT_SYMENT	:
        -:11861:	case DT_RELENT	:
    #####:11862:	  filedata->dynamic_info[entry->d_tag] = entry->d_un.d_val;
        -:11863:	  /* Fall through.  */
    #####:11864:	case DT_PLTPADSZ:
        -:11865:	case DT_MOVEENT	:
        -:11866:	case DT_MOVESZ	:
        -:11867:	case DT_PREINIT_ARRAYSZ:
        -:11868:	case DT_INIT_ARRAYSZ:
        -:11869:	case DT_FINI_ARRAYSZ:
        -:11870:	case DT_GNU_CONFLICTSZ:
        -:11871:	case DT_GNU_LIBLISTSZ:
    #####:11872:	  if (do_dynamic)
        -:11873:	    {
    #####:11874:	      print_vma (entry->d_un.d_val, UNSIGNED);
    #####:11875:	      printf (_(" (bytes)\n"));
        -:11876:	    }
    #####:11877:	  break;
        -:11878:
    #####:11879:	case DT_VERDEFNUM:
        -:11880:	case DT_VERNEEDNUM:
        -:11881:	case DT_RELACOUNT:
        -:11882:	case DT_RELCOUNT:
    #####:11883:	  if (do_dynamic)
        -:11884:	    {
    #####:11885:	      print_vma (entry->d_un.d_val, UNSIGNED);
    #####:11886:	      putchar ('\n');
        -:11887:	    }
    #####:11888:	  break;
        -:11889:
    #####:11890:	case DT_SYMINSZ:
        -:11891:	case DT_SYMINENT:
        -:11892:	case DT_SYMINFO:
        -:11893:	case DT_USED:
        -:11894:	case DT_INIT_ARRAY:
        -:11895:	case DT_FINI_ARRAY:
    #####:11896:	  if (do_dynamic)
        -:11897:	    {
    #####:11898:	      if (entry->d_tag == DT_USED
    #####:11899:		  && valid_dynamic_name (filedata, entry->d_un.d_val))
        -:11900:		{
        -:11901:		  const char *name
    #####:11902:		    = get_dynamic_name (filedata, entry->d_un.d_val);
        -:11903:
    #####:11904:		  if (*name)
        -:11905:		    {
    #####:11906:		      printf (_("Not needed object: [%s]\n"), name);
    #####:11907:		      break;
        -:11908:		    }
        -:11909:		}
        -:11910:
    #####:11911:	      print_vma (entry->d_un.d_val, PREFIX_HEX);
    #####:11912:	      putchar ('\n');
        -:11913:	    }
    #####:11914:	  break;
        -:11915:
    #####:11916:	case DT_BIND_NOW:
        -:11917:	  /* The value of this entry is ignored.  */
    #####:11918:	  if (do_dynamic)
    #####:11919:	    putchar ('\n');
    #####:11920:	  break;
        -:11921:
    #####:11922:	case DT_GNU_PRELINKED:
    #####:11923:	  if (do_dynamic)
        -:11924:	    {
        -:11925:	      struct tm * tmp;
    #####:11926:	      time_t atime = entry->d_un.d_val;
        -:11927:
    #####:11928:	      tmp = gmtime (&atime);
        -:11929:	      /* PR 17533 file: 041-1244816-0.004.  */
    #####:11930:	      if (tmp == NULL)
    #####:11931:		printf (_("<corrupt time val: %lx"),
        -:11932:			(unsigned long) atime);
        -:11933:	      else
    #####:11934:		printf ("%04u-%02u-%02uT%02u:%02u:%02u\n",
    #####:11935:			tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
        -:11936:			tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
        -:11937:
        -:11938:	    }
    #####:11939:	  break;
        -:11940:
    #####:11941:	case DT_GNU_HASH:
    #####:11942:	  filedata->dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
    #####:11943:	  if (do_dynamic)
        -:11944:	    {
    #####:11945:	      print_vma (entry->d_un.d_val, PREFIX_HEX);
    #####:11946:	      putchar ('\n');
        -:11947:	    }
    #####:11948:	  break;
        -:11949:
    #####:11950:	case DT_GNU_FLAGS_1:
    #####:11951:	  if (do_dynamic)
        -:11952:	    {
    #####:11953:	      printf (_("Flags:"));
    #####:11954:	      if (entry->d_un.d_val == 0)
    #####:11955:		printf (_(" None\n"));
        -:11956:	      else
        -:11957:		{
    #####:11958:		  unsigned long int val = entry->d_un.d_val;
        -:11959:
    #####:11960:		  if (val & DF_GNU_1_UNIQUE)
        -:11961:		    {
    #####:11962:		      printf (" UNIQUE");
    #####:11963:		      val ^= DF_GNU_1_UNIQUE;
        -:11964:		    }
    #####:11965:		  if (val != 0)
    #####:11966:		    printf (" %lx", val);
    #####:11967:		  puts ("");
        -:11968:		}
        -:11969:	    }
    #####:11970:	  break;
        -:11971:
       62:11972:	default:
       62:11973:	  if ((entry->d_tag >= DT_VERSYM) && (entry->d_tag <= DT_VERNEEDNUM))
    #####:11974:	    filedata->version_info[DT_VERSIONTAGIDX (entry->d_tag)]
    #####:11975:	      = entry->d_un.d_val;
        -:11976:
       62:11977:	  if (do_dynamic)
        -:11978:	    {
       62:11979:	      switch (filedata->file_header.e_machine)
        -:11980:		{
    #####:11981:		case EM_AARCH64:
    #####:11982:		  dynamic_section_aarch64_val (entry);
    #####:11983:		  break;
        2:11984:		case EM_MIPS:
        -:11985:		case EM_MIPS_RS3_LE:
        2:11986:		  dynamic_section_mips_val (filedata, entry);
        2:11987:		  break;
        2:11988:		case EM_PARISC:
        2:11989:		  dynamic_section_parisc_val (entry);
        2:11990:		  break;
    #####:11991:		case EM_IA_64:
    #####:11992:		  dynamic_section_ia64_val (entry);
    #####:11993:		  break;
       58:11994:		default:
       58:11995:		  print_vma (entry->d_un.d_val, PREFIX_HEX);
       58:11996:		  putchar ('\n');
        -:11997:		}
    #####:11998:	    }
       62:11999:	  break;
        -:12000:	}
        -:12001:    }
        -:12002:
       36:12003:  return true;
        -:12004:}
        -:12005:
        -:12006:static char *
    #####:12007:get_ver_flags (unsigned int flags)
        -:12008:{
        -:12009:  static char buff[128];
        -:12010:
    #####:12011:  buff[0] = 0;
        -:12012:
    #####:12013:  if (flags == 0)
    #####:12014:    return _("none");
        -:12015:
    #####:12016:  if (flags & VER_FLG_BASE)
    #####:12017:    strcat (buff, "BASE");
        -:12018:
    #####:12019:  if (flags & VER_FLG_WEAK)
        -:12020:    {
    #####:12021:      if (flags & VER_FLG_BASE)
    #####:12022:	strcat (buff, " | ");
        -:12023:
    #####:12024:      strcat (buff, "WEAK");
        -:12025:    }
        -:12026:
    #####:12027:  if (flags & VER_FLG_INFO)
        -:12028:    {
    #####:12029:      if (flags & (VER_FLG_BASE|VER_FLG_WEAK))
    #####:12030:	strcat (buff, " | ");
        -:12031:
    #####:12032:      strcat (buff, "INFO");
        -:12033:    }
        -:12034:
    #####:12035:  if (flags & ~(VER_FLG_BASE | VER_FLG_WEAK | VER_FLG_INFO))
        -:12036:    {
    #####:12037:      if (flags & (VER_FLG_BASE | VER_FLG_WEAK | VER_FLG_INFO))
    #####:12038:	strcat (buff, " | ");
        -:12039:
    #####:12040:      strcat (buff, _("<unknown>"));
        -:12041:    }
        -:12042:
    #####:12043:  return buff;
        -:12044:}
        -:12045:
        -:12046:/* Display the contents of the version sections.  */
        -:12047:
        -:12048:static bool
     1391:12049:process_version_sections (Filedata * filedata)
        -:12050:{
        -:12051:  Elf_Internal_Shdr * section;
        -:12052:  unsigned i;
     1391:12053:  bool found = false;
        -:12054:
     1391:12055:  if (! do_version)
     1228:12056:    return true;
        -:12057:
      163:12058:  for (i = 0, section = filedata->section_headers;
      807:12059:       i < filedata->file_header.e_shnum;
      644:12060:       i++, section++)
        -:12061:    {
      644:12062:      switch (section->sh_type)
        -:12063:	{
    #####:12064:	case SHT_GNU_verdef:
        -:12065:	  {
        -:12066:	    Elf_External_Verdef * edefs;
        -:12067:	    unsigned long idx;
        -:12068:	    unsigned long cnt;
        -:12069:	    char * endbuf;
        -:12070:
    #####:12071:	    found = true;
        -:12072:
    #####:12073:	    if (filedata->is_separate)
    #####:12074:	      printf (ngettext ("\nIn linked file '%s' the version definition section '%s' contains %u entry:\n",
        -:12075:				"\nIn linked file '%s' the version definition section '%s' contains %u entries:\n",
    #####:12076:				section->sh_info),
        -:12077:		      filedata->file_name,
        -:12078:		      printable_section_name (filedata, section),
        -:12079:		      section->sh_info);
        -:12080:	    else
    #####:12081:	      printf (ngettext ("\nVersion definition section '%s' "
        -:12082:				"contains %u entry:\n",
        -:12083:				"\nVersion definition section '%s' "
        -:12084:				"contains %u entries:\n",
    #####:12085:				section->sh_info),
        -:12086:		      printable_section_name (filedata, section),
        -:12087:		      section->sh_info);
        -:12088:
    #####:12089:	    printf (_(" Addr: 0x"));
    #####:12090:	    printf_vma (section->sh_addr);
    #####:12091:	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
    #####:12092:		    (unsigned long) section->sh_offset, section->sh_link,
    #####:12093:		    printable_section_name_from_index (filedata, section->sh_link));
        -:12094:
        -:12095:	    edefs = (Elf_External_Verdef *)
    #####:12096:                get_data (NULL, filedata, section->sh_offset, 1,section->sh_size,
    #####:12097:                          _("version definition section"));
    #####:12098:	    if (!edefs)
    #####:12099:	      break;
    #####:12100:	    endbuf = (char *) edefs + section->sh_size;
        -:12101:
    #####:12102:	    for (idx = cnt = 0; cnt < section->sh_info; ++cnt)
        -:12103:	      {
        -:12104:		char * vstart;
        -:12105:		Elf_External_Verdef * edef;
        -:12106:		Elf_Internal_Verdef ent;
        -:12107:		Elf_External_Verdaux * eaux;
        -:12108:		Elf_Internal_Verdaux aux;
        -:12109:		unsigned long isum;
        -:12110:		int j;
        -:12111:
    #####:12112:		vstart = ((char *) edefs) + idx;
    #####:12113:		if (vstart + sizeof (*edef) > endbuf)
    #####:12114:		  break;
        -:12115:
    #####:12116:		edef = (Elf_External_Verdef *) vstart;
        -:12117:
    #####:12118:		ent.vd_version = BYTE_GET (edef->vd_version);
    #####:12119:		ent.vd_flags   = BYTE_GET (edef->vd_flags);
    #####:12120:		ent.vd_ndx     = BYTE_GET (edef->vd_ndx);
    #####:12121:		ent.vd_cnt     = BYTE_GET (edef->vd_cnt);
    #####:12122:		ent.vd_hash    = BYTE_GET (edef->vd_hash);
    #####:12123:		ent.vd_aux     = BYTE_GET (edef->vd_aux);
    #####:12124:		ent.vd_next    = BYTE_GET (edef->vd_next);
        -:12125:
    #####:12126:		printf (_("  %#06lx: Rev: %d  Flags: %s"),
    #####:12127:			idx, ent.vd_version, get_ver_flags (ent.vd_flags));
        -:12128:
    #####:12129:		printf (_("  Index: %d  Cnt: %d  "),
    #####:12130:			ent.vd_ndx, ent.vd_cnt);
        -:12131:
        -:12132:		/* Check for overflow.  */
    #####:12133:		if (ent.vd_aux > (size_t) (endbuf - vstart))
    #####:12134:		  break;
        -:12135:
    #####:12136:		vstart += ent.vd_aux;
        -:12137:
    #####:12138:		if (vstart + sizeof (*eaux) > endbuf)
    #####:12139:		  break;
    #####:12140:		eaux = (Elf_External_Verdaux *) vstart;
        -:12141:
    #####:12142:		aux.vda_name = BYTE_GET (eaux->vda_name);
    #####:12143:		aux.vda_next = BYTE_GET (eaux->vda_next);
        -:12144:
    #####:12145:		if (valid_dynamic_name (filedata, aux.vda_name))
    #####:12146:		  printf (_("Name: %s\n"),
        -:12147:			  get_dynamic_name (filedata, aux.vda_name));
        -:12148:		else
    #####:12149:		  printf (_("Name index: %ld\n"), aux.vda_name);
        -:12150:
    #####:12151:		isum = idx + ent.vd_aux;
        -:12152:
    #####:12153:		for (j = 1; j < ent.vd_cnt; j++)
        -:12154:		  {
    #####:12155:		    if (aux.vda_next < sizeof (*eaux)
    #####:12156:			&& !(j == ent.vd_cnt - 1 && aux.vda_next == 0))
        -:12157:		      {
    #####:12158:			warn (_("Invalid vda_next field of %lx\n"),
        -:12159:			      aux.vda_next);
    #####:12160:			j = ent.vd_cnt;
    #####:12161:			break;
        -:12162:		      }
        -:12163:		    /* Check for overflow.  */
    #####:12164:		    if (aux.vda_next > (size_t) (endbuf - vstart))
    #####:12165:		      break;
        -:12166:
    #####:12167:		    isum   += aux.vda_next;
    #####:12168:		    vstart += aux.vda_next;
        -:12169:
    #####:12170:		    if (vstart + sizeof (*eaux) > endbuf)
    #####:12171:		      break;
    #####:12172:		    eaux = (Elf_External_Verdaux *) vstart;
        -:12173:
    #####:12174:		    aux.vda_name = BYTE_GET (eaux->vda_name);
    #####:12175:		    aux.vda_next = BYTE_GET (eaux->vda_next);
        -:12176:
    #####:12177:		    if (valid_dynamic_name (filedata, aux.vda_name))
    #####:12178:		      printf (_("  %#06lx: Parent %d: %s\n"),
        -:12179:			      isum, j,
        -:12180:			      get_dynamic_name (filedata, aux.vda_name));
        -:12181:		    else
    #####:12182:		      printf (_("  %#06lx: Parent %d, name index: %ld\n"),
        -:12183:			      isum, j, aux.vda_name);
        -:12184:		  }
        -:12185:
    #####:12186:		if (j < ent.vd_cnt)
    #####:12187:		  printf (_("  Version def aux past end of section\n"));
        -:12188:
        -:12189:		/* PR 17531:
        -:12190:		   file: id:000001,src:000172+005151,op:splice,rep:2.  */
    #####:12191:		if (ent.vd_next < sizeof (*edef)
    #####:12192:		    && !(cnt == section->sh_info - 1 && ent.vd_next == 0))
        -:12193:		  {
    #####:12194:		    warn (_("Invalid vd_next field of %lx\n"), ent.vd_next);
    #####:12195:		    cnt = section->sh_info;
    #####:12196:		    break;
        -:12197:		  }
    #####:12198:		if (ent.vd_next > (size_t) (endbuf - ((char *) edefs + idx)))
    #####:12199:		  break;
        -:12200:
    #####:12201:		idx += ent.vd_next;
        -:12202:	      }
        -:12203:
    #####:12204:	    if (cnt < section->sh_info)
    #####:12205:	      printf (_("  Version definition past end of section\n"));
        -:12206:
    #####:12207:	    free (edefs);
        -:12208:	  }
    #####:12209:	  break;
        -:12210:
    #####:12211:	case SHT_GNU_verneed:
        -:12212:	  {
        -:12213:	    Elf_External_Verneed * eneed;
        -:12214:	    unsigned long idx;
        -:12215:	    unsigned long cnt;
        -:12216:	    char * endbuf;
        -:12217:
    #####:12218:	    found = true;
        -:12219:
    #####:12220:	    if (filedata->is_separate)
    #####:12221:	      printf (ngettext ("\nIn linked file '%s' the version needs section '%s' contains %u entry:\n",
        -:12222:				"\nIn linked file '%s' the version needs section '%s' contains %u entries:\n",
    #####:12223:				section->sh_info),
        -:12224:		      filedata->file_name,
        -:12225:		      printable_section_name (filedata, section),
        -:12226:		      section->sh_info);
        -:12227:	    else
    #####:12228:	      printf (ngettext ("\nVersion needs section '%s' "
        -:12229:				"contains %u entry:\n",
        -:12230:				"\nVersion needs section '%s' "
        -:12231:				"contains %u entries:\n",
    #####:12232:				section->sh_info),
        -:12233:		      printable_section_name (filedata, section),
        -:12234:		      section->sh_info);
        -:12235:
    #####:12236:	    printf (_(" Addr: 0x"));
    #####:12237:	    printf_vma (section->sh_addr);
    #####:12238:	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
    #####:12239:		    (unsigned long) section->sh_offset, section->sh_link,
    #####:12240:		    printable_section_name_from_index (filedata, section->sh_link));
        -:12241:
    #####:12242:	    eneed = (Elf_External_Verneed *) get_data (NULL, filedata,
    #####:12243:                                                       section->sh_offset, 1,
        -:12244:                                                       section->sh_size,
    #####:12245:                                                       _("Version Needs section"));
    #####:12246:	    if (!eneed)
    #####:12247:	      break;
    #####:12248:	    endbuf = (char *) eneed + section->sh_size;
        -:12249:
    #####:12250:	    for (idx = cnt = 0; cnt < section->sh_info; ++cnt)
        -:12251:	      {
        -:12252:		Elf_External_Verneed * entry;
        -:12253:		Elf_Internal_Verneed ent;
        -:12254:		unsigned long isum;
        -:12255:		int j;
        -:12256:		char * vstart;
        -:12257:
    #####:12258:		vstart = ((char *) eneed) + idx;
    #####:12259:		if (vstart + sizeof (*entry) > endbuf)
    #####:12260:		  break;
        -:12261:
    #####:12262:		entry = (Elf_External_Verneed *) vstart;
        -:12263:
    #####:12264:		ent.vn_version = BYTE_GET (entry->vn_version);
    #####:12265:		ent.vn_cnt     = BYTE_GET (entry->vn_cnt);
    #####:12266:		ent.vn_file    = BYTE_GET (entry->vn_file);
    #####:12267:		ent.vn_aux     = BYTE_GET (entry->vn_aux);
    #####:12268:		ent.vn_next    = BYTE_GET (entry->vn_next);
        -:12269:
    #####:12270:		printf (_("  %#06lx: Version: %d"), idx, ent.vn_version);
        -:12271:
    #####:12272:		if (valid_dynamic_name (filedata, ent.vn_file))
    #####:12273:		  printf (_("  File: %s"),
        -:12274:			  get_dynamic_name (filedata, ent.vn_file));
        -:12275:		else
    #####:12276:		  printf (_("  File: %lx"), ent.vn_file);
        -:12277:
    #####:12278:		printf (_("  Cnt: %d\n"), ent.vn_cnt);
        -:12279:
        -:12280:		/* Check for overflow.  */
    #####:12281:		if (ent.vn_aux > (size_t) (endbuf - vstart))
    #####:12282:		  break;
    #####:12283:		vstart += ent.vn_aux;
        -:12284:
    #####:12285:		for (j = 0, isum = idx + ent.vn_aux; j < ent.vn_cnt; ++j)
        -:12286:		  {
        -:12287:		    Elf_External_Vernaux * eaux;
        -:12288:		    Elf_Internal_Vernaux aux;
        -:12289:
    #####:12290:		    if (vstart + sizeof (*eaux) > endbuf)
    #####:12291:		      break;
    #####:12292:		    eaux = (Elf_External_Vernaux *) vstart;
        -:12293:
    #####:12294:		    aux.vna_hash  = BYTE_GET (eaux->vna_hash);
    #####:12295:		    aux.vna_flags = BYTE_GET (eaux->vna_flags);
    #####:12296:		    aux.vna_other = BYTE_GET (eaux->vna_other);
    #####:12297:		    aux.vna_name  = BYTE_GET (eaux->vna_name);
    #####:12298:		    aux.vna_next  = BYTE_GET (eaux->vna_next);
        -:12299:
    #####:12300:		    if (valid_dynamic_name (filedata, aux.vna_name))
    #####:12301:		      printf (_("  %#06lx:   Name: %s"),
        -:12302:			      isum, get_dynamic_name (filedata, aux.vna_name));
        -:12303:		    else
    #####:12304:		      printf (_("  %#06lx:   Name index: %lx"),
        -:12305:			      isum, aux.vna_name);
        -:12306:
    #####:12307:		    printf (_("  Flags: %s  Version: %d\n"),
    #####:12308:			    get_ver_flags (aux.vna_flags), aux.vna_other);
        -:12309:
    #####:12310:		    if (aux.vna_next < sizeof (*eaux)
    #####:12311:			&& !(j == ent.vn_cnt - 1 && aux.vna_next == 0))
        -:12312:		      {
    #####:12313:			warn (_("Invalid vna_next field of %lx\n"),
        -:12314:			      aux.vna_next);
    #####:12315:			j = ent.vn_cnt;
    #####:12316:			break;
        -:12317:		      }
        -:12318:		    /* Check for overflow.  */
    #####:12319:		    if (aux.vna_next > (size_t) (endbuf - vstart))
    #####:12320:		      break;
    #####:12321:		    isum   += aux.vna_next;
    #####:12322:		    vstart += aux.vna_next;
        -:12323:		  }
        -:12324:
    #####:12325:		if (j < ent.vn_cnt)
    #####:12326:		  warn (_("Missing Version Needs auxiliary information\n"));
        -:12327:
    #####:12328:		if (ent.vn_next < sizeof (*entry)
    #####:12329:		    && !(cnt == section->sh_info - 1 && ent.vn_next == 0))
        -:12330:		  {
    #####:12331:		    warn (_("Invalid vn_next field of %lx\n"), ent.vn_next);
    #####:12332:		    cnt = section->sh_info;
    #####:12333:		    break;
        -:12334:		  }
    #####:12335:		if (ent.vn_next > (size_t) (endbuf - ((char *) eneed + idx)))
    #####:12336:		  break;
    #####:12337:		idx += ent.vn_next;
        -:12338:	      }
        -:12339:
    #####:12340:	    if (cnt < section->sh_info)
    #####:12341:	      warn (_("Missing Version Needs information\n"));
        -:12342:
    #####:12343:	    free (eneed);
        -:12344:	  }
    #####:12345:	  break;
        -:12346:
    #####:12347:	case SHT_GNU_versym:
        -:12348:	  {
        -:12349:	    Elf_Internal_Shdr * link_section;
        -:12350:	    size_t total;
        -:12351:	    unsigned int cnt;
        -:12352:	    unsigned char * edata;
        -:12353:	    unsigned short * data;
        -:12354:	    char * strtab;
        -:12355:	    Elf_Internal_Sym * symbols;
        -:12356:	    Elf_Internal_Shdr * string_sec;
        -:12357:	    unsigned long num_syms;
        -:12358:	    long off;
        -:12359:
    #####:12360:	    if (section->sh_link >= filedata->file_header.e_shnum)
    #####:12361:	      break;
        -:12362:
    #####:12363:	    link_section = filedata->section_headers + section->sh_link;
    #####:12364:	    total = section->sh_size / sizeof (Elf_External_Versym);
        -:12365:
    #####:12366:	    if (link_section->sh_link >= filedata->file_header.e_shnum)
    #####:12367:	      break;
        -:12368:
    #####:12369:	    found = true;
        -:12370:
    #####:12371:	    symbols = get_elf_symbols (filedata, link_section, & num_syms);
    #####:12372:	    if (symbols == NULL)
    #####:12373:	      break;
        -:12374:
    #####:12375:	    string_sec = filedata->section_headers + link_section->sh_link;
        -:12376:
    #####:12377:	    strtab = (char *) get_data (NULL, filedata, string_sec->sh_offset, 1,
        -:12378:                                        string_sec->sh_size,
    #####:12379:                                        _("version string table"));
    #####:12380:	    if (!strtab)
        -:12381:	      {
    #####:12382:		free (symbols);
    #####:12383:		break;
        -:12384:	      }
        -:12385:
    #####:12386:	    if (filedata->is_separate)
    #####:12387:	      printf (ngettext ("\nIn linked file '%s' the version symbols section '%s' contains %lu entry:\n",
        -:12388:				"\nIn linked file '%s' the version symbols section '%s' contains %lu entries:\n",
        -:12389:				total),
        -:12390:		      filedata->file_name,
        -:12391:		      printable_section_name (filedata, section),
        -:12392:		      (unsigned long) total);
        -:12393:	    else
    #####:12394:	      printf (ngettext ("\nVersion symbols section '%s' "
        -:12395:				"contains %lu entry:\n",
        -:12396:				"\nVersion symbols section '%s' "
        -:12397:				"contains %lu entries:\n",
        -:12398:				total),
        -:12399:		      printable_section_name (filedata, section),
        -:12400:		      (unsigned long) total);
        -:12401:
    #####:12402:	    printf (_(" Addr: 0x"));
    #####:12403:	    printf_vma (section->sh_addr);
    #####:12404:	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
    #####:12405:		    (unsigned long) section->sh_offset, section->sh_link,
        -:12406:		    printable_section_name (filedata, link_section));
        -:12407:
    #####:12408:	    off = offset_from_vma (filedata,
        -:12409:				   filedata->version_info[DT_VERSIONTAGIDX (DT_VERSYM)],
        -:12410:				   total * sizeof (short));
    #####:12411:	    edata = (unsigned char *) get_data (NULL, filedata, off,
        -:12412:						sizeof (short), total,
    #####:12413:						_("version symbol data"));
    #####:12414:	    if (!edata)
        -:12415:	      {
    #####:12416:		free (strtab);
    #####:12417:		free (symbols);
    #####:12418:		break;
        -:12419:	      }
        -:12420:
    #####:12421:	    data = (short unsigned int *) cmalloc (total, sizeof (short));
        -:12422:
    #####:12423:	    for (cnt = total; cnt --;)
    #####:12424:	      data[cnt] = byte_get (edata + cnt * sizeof (short),
        -:12425:				    sizeof (short));
        -:12426:
    #####:12427:	    free (edata);
        -:12428:
    #####:12429:	    for (cnt = 0; cnt < total; cnt += 4)
        -:12430:	      {
        -:12431:		int j, nn;
        -:12432:		char *name;
    #####:12433:		char *invalid = _("*invalid*");
        -:12434:
    #####:12435:		printf ("  %03x:", cnt);
        -:12436:
    #####:12437:		for (j = 0; (j < 4) && (cnt + j) < total; ++j)
    #####:12438:		  switch (data[cnt + j])
        -:12439:		    {
    #####:12440:		    case 0:
    #####:12441:		      fputs (_("   0 (*local*)    "), stdout);
    #####:12442:		      break;
        -:12443:
    #####:12444:		    case 1:
    #####:12445:		      fputs (_("   1 (*global*)   "), stdout);
    #####:12446:		      break;
        -:12447:
    #####:12448:		    default:
    #####:12449:		      nn = printf ("%4x%c", data[cnt + j] & VERSYM_VERSION,
    #####:12450:				   data[cnt + j] & VERSYM_HIDDEN ? 'h' : ' ');
        -:12451:
        -:12452:		      /* If this index value is greater than the size of the symbols
        -:12453:		         array, break to avoid an out-of-bounds read.  */
    #####:12454:		      if ((unsigned long)(cnt + j) >= num_syms)
        -:12455:		        {
    #####:12456:		          warn (_("invalid index into symbol array\n"));
    #####:12457:		          break;
        -:12458:			}
        -:12459:
    #####:12460:		      name = NULL;
    #####:12461:		      if (filedata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)])
        -:12462:			{
        -:12463:			  Elf_Internal_Verneed ivn;
        -:12464:			  unsigned long offset;
        -:12465:
    #####:12466:			  offset = offset_from_vma
        -:12467:			    (filedata,
        -:12468:			     filedata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)],
        -:12469:			     sizeof (Elf_External_Verneed));
        -:12470:
        -:12471:			  do
        -:12472:			    {
        -:12473:			      Elf_Internal_Vernaux ivna;
        -:12474:			      Elf_External_Verneed evn;
        -:12475:			      Elf_External_Vernaux evna;
        -:12476:			      unsigned long a_off;
        -:12477:
    #####:12478:			      if (get_data (&evn, filedata, offset, sizeof (evn), 1,
    #####:12479:					    _("version need")) == NULL)
    #####:12480:				break;
        -:12481:
    #####:12482:			      ivn.vn_aux  = BYTE_GET (evn.vn_aux);
    #####:12483:			      ivn.vn_next = BYTE_GET (evn.vn_next);
        -:12484:
    #####:12485:			      a_off = offset + ivn.vn_aux;
        -:12486:
        -:12487:			      do
        -:12488:				{
    #####:12489:				  if (get_data (&evna, filedata, a_off, sizeof (evna),
    #####:12490:						1, _("version need aux (2)")) == NULL)
        -:12491:				    {
    #####:12492:				      ivna.vna_next  = 0;
    #####:12493:				      ivna.vna_other = 0;
        -:12494:				    }
        -:12495:				  else
        -:12496:				    {
    #####:12497:				      ivna.vna_next  = BYTE_GET (evna.vna_next);
    #####:12498:				      ivna.vna_other = BYTE_GET (evna.vna_other);
        -:12499:				    }
        -:12500:
    #####:12501:				  a_off += ivna.vna_next;
        -:12502:				}
    #####:12503:			      while (ivna.vna_other != data[cnt + j]
    #####:12504:				     && ivna.vna_next != 0);
        -:12505:
    #####:12506:			      if (ivna.vna_other == data[cnt + j])
        -:12507:				{
    #####:12508:				  ivna.vna_name = BYTE_GET (evna.vna_name);
        -:12509:
    #####:12510:				  if (ivna.vna_name >= string_sec->sh_size)
    #####:12511:				    name = invalid;
        -:12512:				  else
    #####:12513:				    name = strtab + ivna.vna_name;
    #####:12514:				  break;
        -:12515:				}
        -:12516:
    #####:12517:			      offset += ivn.vn_next;
        -:12518:			    }
    #####:12519:			  while (ivn.vn_next);
        -:12520:			}
        -:12521:
    #####:12522:		      if (data[cnt + j] != 0x8001
    #####:12523:			  && filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)])
        -:12524:			{
        -:12525:			  Elf_Internal_Verdef ivd;
        -:12526:			  Elf_External_Verdef evd;
        -:12527:			  unsigned long offset;
        -:12528:
    #####:12529:			  offset = offset_from_vma
        -:12530:			    (filedata,
        -:12531:			     filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)],
        -:12532:			     sizeof evd);
        -:12533:
        -:12534:			  do
        -:12535:			    {
    #####:12536:			      if (get_data (&evd, filedata, offset, sizeof (evd), 1,
    #####:12537:					    _("version def")) == NULL)
        -:12538:				{
    #####:12539:				  ivd.vd_next = 0;
        -:12540:				  /* PR 17531: file: 046-1082287-0.004.  */
    #####:12541:				  ivd.vd_ndx  = (data[cnt + j] & VERSYM_VERSION) + 1;
    #####:12542:				  break;
        -:12543:				}
        -:12544:			      else
        -:12545:				{
    #####:12546:				  ivd.vd_next = BYTE_GET (evd.vd_next);
    #####:12547:				  ivd.vd_ndx  = BYTE_GET (evd.vd_ndx);
        -:12548:				}
        -:12549:
    #####:12550:			      offset += ivd.vd_next;
        -:12551:			    }
    #####:12552:			  while (ivd.vd_ndx != (data[cnt + j] & VERSYM_VERSION)
    #####:12553:				 && ivd.vd_next != 0);
        -:12554:
    #####:12555:			  if (ivd.vd_ndx == (data[cnt + j] & VERSYM_VERSION))
        -:12556:			    {
        -:12557:			      Elf_External_Verdaux evda;
        -:12558:			      Elf_Internal_Verdaux ivda;
        -:12559:
    #####:12560:			      ivd.vd_aux = BYTE_GET (evd.vd_aux);
        -:12561:
    #####:12562:			      if (get_data (&evda, filedata,
    #####:12563:					    offset - ivd.vd_next + ivd.vd_aux,
        -:12564:					    sizeof (evda), 1,
    #####:12565:					    _("version def aux")) == NULL)
    #####:12566:				break;
        -:12567:
    #####:12568:			      ivda.vda_name = BYTE_GET (evda.vda_name);
        -:12569:
    #####:12570:			      if (ivda.vda_name >= string_sec->sh_size)
    #####:12571:				name = invalid;
    #####:12572:			      else if (name != NULL && name != invalid)
    #####:12573:				name = _("*both*");
        -:12574:			      else
    #####:12575:				name = strtab + ivda.vda_name;
        -:12576:			    }
        -:12577:			}
    #####:12578:		      if (name != NULL)
    #####:12579:			nn += printf ("(%s%-*s",
        -:12580:				      name,
    #####:12581:				      12 - (int) strlen (name),
        -:12582:				      ")");
        -:12583:
    #####:12584:		      if (nn < 18)
    #####:12585:			printf ("%*c", 18 - nn, ' ');
        -:12586:		    }
        -:12587:
    #####:12588:		putchar ('\n');
        -:12589:	      }
        -:12590:
    #####:12591:	    free (data);
    #####:12592:	    free (strtab);
    #####:12593:	    free (symbols);
        -:12594:	  }
    #####:12595:	  break;
        -:12596:
      644:12597:	default:
      644:12598:	  break;
        -:12599:	}
        -:12600:    }
        -:12601:
      163:12602:  if (! found)
        -:12603:    {
      163:12604:      if (filedata->is_separate)
    #####:12605:	printf (_("\nNo version information found in linked file '%s'.\n"),
        -:12606:		filedata->file_name);
        -:12607:      else
      163:12608:	printf (_("\nNo version information found in this file.\n"));
        -:12609:    }
        -:12610:
      163:12611:  return true;
        -:12612:}
        -:12613:
        -:12614:static const char *
      143:12615:get_symbol_binding (Filedata * filedata, unsigned int binding)
        -:12616:{
        -:12617:  static char buff[64];
        -:12618:
      143:12619:  switch (binding)
        -:12620:    {
      101:12621:    case STB_LOCAL:	return "LOCAL";
        1:12622:    case STB_GLOBAL:	return "GLOBAL";
    #####:12623:    case STB_WEAK:	return "WEAK";
       41:12624:    default:
      41*:12625:      if (binding >= STB_LOPROC && binding <= STB_HIPROC)
    #####:12626:	snprintf (buff, sizeof (buff), _("<processor specific>: %d"),
        -:12627:		  binding);
       41:12628:      else if (binding >= STB_LOOS && binding <= STB_HIOS)
        -:12629:	{
        2:12630:	  if (binding == STB_GNU_UNIQUE
        1:12631:	      && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_GNU)
    #####:12632:	    return "UNIQUE";
        2:12633:	  snprintf (buff, sizeof (buff), _("<OS specific>: %d"), binding);
        -:12634:	}
        -:12635:      else
       39:12636:	snprintf (buff, sizeof (buff), _("<unknown>: %d"), binding);
       41:12637:      return buff;
        -:12638:    }
        -:12639:}
        -:12640:
        -:12641:static const char *
      143:12642:get_symbol_type (Filedata * filedata, unsigned int type)
        -:12643:{
        -:12644:  static char buff[64];
        -:12645:
      143:12646:  switch (type)
        -:12647:    {
       79:12648:    case STT_NOTYPE:	return "NOTYPE";
        1:12649:    case STT_OBJECT:	return "OBJECT";
       12:12650:    case STT_FUNC:	return "FUNC";
        6:12651:    case STT_SECTION:	return "SECTION";
       22:12652:    case STT_FILE:	return "FILE";
        8:12653:    case STT_COMMON:	return "COMMON";
        7:12654:    case STT_TLS:	return "TLS";
        4:12655:    case STT_RELC:      return "RELC";
    #####:12656:    case STT_SRELC:     return "SRELC";
        4:12657:    default:
       4*:12658:      if (type >= STT_LOPROC && type <= STT_HIPROC)
        -:12659:	{
    #####:12660:	  if (filedata->file_header.e_machine == EM_ARM && type == STT_ARM_TFUNC)
    #####:12661:	    return "THUMB_FUNC";
        -:12662:
    #####:12663:	  if (filedata->file_header.e_machine == EM_SPARCV9 && type == STT_REGISTER)
    #####:12664:	    return "REGISTER";
        -:12665:
    #####:12666:	  if (filedata->file_header.e_machine == EM_PARISC && type == STT_PARISC_MILLI)
    #####:12667:	    return "PARISC_MILLI";
        -:12668:
    #####:12669:	  snprintf (buff, sizeof (buff), _("<processor specific>: %d"), type);
        -:12670:	}
        4:12671:      else if (type >= STT_LOOS && type <= STT_HIOS)
        -:12672:	{
        3:12673:	  if (filedata->file_header.e_machine == EM_PARISC)
        -:12674:	    {
    #####:12675:	      if (type == STT_HP_OPAQUE)
    #####:12676:		return "HP_OPAQUE";
    #####:12677:	      if (type == STT_HP_STUB)
    #####:12678:		return "HP_STUB";
        -:12679:	    }
        -:12680:
        3:12681:	  if (type == STT_GNU_IFUNC
    #####:12682:	      && (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_GNU
    #####:12683:		  || filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_FREEBSD))
    #####:12684:	    return "IFUNC";
        -:12685:
        3:12686:	  snprintf (buff, sizeof (buff), _("<OS specific>: %d"), type);
        -:12687:	}
        -:12688:      else
        1:12689:	snprintf (buff, sizeof (buff), _("<unknown>: %d"), type);
        4:12690:      return buff;
        -:12691:    }
        -:12692:}
        -:12693:
        -:12694:static const char *
      143:12695:get_symbol_visibility (unsigned int visibility)
        -:12696:{
      143:12697:  switch (visibility)
        -:12698:    {
      120:12699:    case STV_DEFAULT:	return "DEFAULT";
       11:12700:    case STV_INTERNAL:	return "INTERNAL";
       10:12701:    case STV_HIDDEN:	return "HIDDEN";
        2:12702:    case STV_PROTECTED: return "PROTECTED";
    #####:12703:    default:
    #####:12704:      error (_("Unrecognized visibility value: %u\n"), visibility);
    #####:12705:      return _("<unknown>");
        -:12706:    }
        -:12707:}
        -:12708:
        -:12709:static const char *
    #####:12710:get_alpha_symbol_other (unsigned int other)
        -:12711:{
    #####:12712:  switch (other)
        -:12713:    {
    #####:12714:    case STO_ALPHA_NOPV:       return "NOPV";
    #####:12715:    case STO_ALPHA_STD_GPLOAD: return "STD GPLOAD";
    #####:12716:    default:
    #####:12717:      error (_("Unrecognized alpha specific other value: %u\n"), other);
    #####:12718:      return _("<unknown>");
        -:12719:    }
        -:12720:}
        -:12721:
        -:12722:static const char *
    #####:12723:get_solaris_symbol_visibility (unsigned int visibility)
        -:12724:{
    #####:12725:  switch (visibility)
        -:12726:    {
    #####:12727:    case 4: return "EXPORTED";
    #####:12728:    case 5: return "SINGLETON";
    #####:12729:    case 6: return "ELIMINATE";
    #####:12730:    default: return get_symbol_visibility (visibility);
        -:12731:    }
        -:12732:}
        -:12733:
        -:12734:static const char *
    #####:12735:get_aarch64_symbol_other (unsigned int other)
        -:12736:{
        -:12737:  static char buf[32];
        -:12738:
    #####:12739:  if (other & STO_AARCH64_VARIANT_PCS)
        -:12740:    {
    #####:12741:      other &= ~STO_AARCH64_VARIANT_PCS;
    #####:12742:      if (other == 0)
    #####:12743:	return "VARIANT_PCS";
    #####:12744:      snprintf (buf, sizeof buf, "VARIANT_PCS | %x", other);
    #####:12745:      return buf;
        -:12746:    }
    #####:12747:  return NULL;
        -:12748:}
        -:12749:
        -:12750:static const char *
    #####:12751:get_mips_symbol_other (unsigned int other)
        -:12752:{
    #####:12753:  switch (other)
        -:12754:    {
    #####:12755:    case STO_OPTIONAL:      return "OPTIONAL";
    #####:12756:    case STO_MIPS_PLT:      return "MIPS PLT";
    #####:12757:    case STO_MIPS_PIC:      return "MIPS PIC";
    #####:12758:    case STO_MICROMIPS:     return "MICROMIPS";
    #####:12759:    case STO_MICROMIPS | STO_MIPS_PIC:      return "MICROMIPS, MIPS PIC";
    #####:12760:    case STO_MIPS16:        return "MIPS16";
    #####:12761:    default:	            return NULL;
        -:12762:    }
        -:12763:}
        -:12764:
        -:12765:static const char *
    #####:12766:get_ia64_symbol_other (Filedata * filedata, unsigned int other)
        -:12767:{
    #####:12768:  if (is_ia64_vms (filedata))
        -:12769:    {
        -:12770:      static char res[32];
        -:12771:
    #####:12772:      res[0] = 0;
        -:12773:
        -:12774:      /* Function types is for images and .STB files only.  */
    #####:12775:      switch (filedata->file_header.e_type)
        -:12776:        {
    #####:12777:        case ET_DYN:
        -:12778:        case ET_EXEC:
    #####:12779:          switch (VMS_ST_FUNC_TYPE (other))
        -:12780:            {
    #####:12781:            case VMS_SFT_CODE_ADDR:
    #####:12782:              strcat (res, " CA");
    #####:12783:              break;
    #####:12784:            case VMS_SFT_SYMV_IDX:
    #####:12785:              strcat (res, " VEC");
    #####:12786:              break;
    #####:12787:            case VMS_SFT_FD:
    #####:12788:              strcat (res, " FD");
    #####:12789:              break;
    #####:12790:            case VMS_SFT_RESERVE:
    #####:12791:              strcat (res, " RSV");
    #####:12792:              break;
    #####:12793:            default:
    #####:12794:	      warn (_("Unrecognized IA64 VMS ST Function type: %d\n"),
    #####:12795:		    VMS_ST_FUNC_TYPE (other));
    #####:12796:	      strcat (res, " <unknown>");
    #####:12797:	      break;
        -:12798:            }
    #####:12799:          break;
    #####:12800:        default:
    #####:12801:          break;
        -:12802:        }
    #####:12803:      switch (VMS_ST_LINKAGE (other))
        -:12804:        {
    #####:12805:        case VMS_STL_IGNORE:
    #####:12806:          strcat (res, " IGN");
    #####:12807:          break;
    #####:12808:        case VMS_STL_RESERVE:
    #####:12809:          strcat (res, " RSV");
    #####:12810:          break;
    #####:12811:        case VMS_STL_STD:
    #####:12812:          strcat (res, " STD");
    #####:12813:          break;
    #####:12814:        case VMS_STL_LNK:
    #####:12815:          strcat (res, " LNK");
    #####:12816:          break;
    #####:12817:        default:
    #####:12818:	  warn (_("Unrecognized IA64 VMS ST Linkage: %d\n"),
    #####:12819:		VMS_ST_LINKAGE (other));
    #####:12820:	  strcat (res, " <unknown>");
    #####:12821:	  break;
        -:12822:        }
        -:12823:
    #####:12824:      if (res[0] != 0)
    #####:12825:        return res + 1;
        -:12826:      else
    #####:12827:        return res;
        -:12828:    }
    #####:12829:  return NULL;
        -:12830:}
        -:12831:
        -:12832:static const char *
    #####:12833:get_ppc64_symbol_other (unsigned int other)
        -:12834:{
    #####:12835:  if ((other & ~STO_PPC64_LOCAL_MASK) != 0)
    #####:12836:    return NULL;
        -:12837:
    #####:12838:  other >>= STO_PPC64_LOCAL_BIT;
    #####:12839:  if (other <= 6)
        -:12840:    {
        -:12841:      static char buf[64];
    #####:12842:      if (other >= 2)
    #####:12843:	other = ppc64_decode_local_entry (other);
    #####:12844:      snprintf (buf, sizeof buf, _("<localentry>: %d"), other);
    #####:12845:      return buf;
        -:12846:    }
    #####:12847:  return NULL;
        -:12848:}
        -:12849:
        -:12850:static const char *
    #####:12851:get_riscv_symbol_other (unsigned int other)
        -:12852:{
        -:12853:  static char buf[32];
    #####:12854:  buf[0] = 0;
        -:12855:
    #####:12856:  if (other & STO_RISCV_VARIANT_CC)
        -:12857:    {
    #####:12858:      strcat (buf, _(" VARIANT_CC"));
    #####:12859:      other &= ~STO_RISCV_VARIANT_CC;
        -:12860:    }
        -:12861:
    #####:12862:  if (other != 0)
    #####:12863:    snprintf (buf, sizeof buf, " %x", other);
        -:12864:
        -:12865:
    #####:12866:  if (buf[0] != 0)
    #####:12867:    return buf + 1;
        -:12868:  else
    #####:12869:    return buf;
        -:12870:}
        -:12871:
        -:12872:static const char *
       47:12873:get_symbol_other (Filedata * filedata, unsigned int other)
        -:12874:{
       47:12875:  const char * result = NULL;
        -:12876:  static char buff [64];
        -:12877:
       47:12878:  if (other == 0)
    #####:12879:    return "";
        -:12880:
       47:12881:  switch (filedata->file_header.e_machine)
        -:12882:    {
    #####:12883:    case EM_ALPHA:
    #####:12884:      result = get_alpha_symbol_other (other);
    #####:12885:      break;
    #####:12886:    case EM_AARCH64:
    #####:12887:      result = get_aarch64_symbol_other (other);
    #####:12888:      break;
    #####:12889:    case EM_MIPS:
    #####:12890:      result = get_mips_symbol_other (other);
    #####:12891:      break;
    #####:12892:    case EM_IA_64:
    #####:12893:      result = get_ia64_symbol_other (filedata, other);
    #####:12894:      break;
    #####:12895:    case EM_PPC64:
    #####:12896:      result = get_ppc64_symbol_other (other);
    #####:12897:      break;
    #####:12898:    case EM_RISCV:
    #####:12899:      result = get_riscv_symbol_other (other);
    #####:12900:      break;
       47:12901:    default:
       47:12902:      result = NULL;
       47:12903:      break;
        -:12904:    }
        -:12905:
       47:12906:  if (result)
    #####:12907:    return result;
        -:12908:
       47:12909:  snprintf (buff, sizeof buff, _("<other>: %x"), other);
       47:12910:  return buff;
        -:12911:}
        -:12912:
        -:12913:static const char *
      143:12914:get_symbol_index_type (Filedata * filedata, unsigned int type)
        -:12915:{
        -:12916:  static char buff[32];
        -:12917:
      143:12918:  switch (type)
        -:12919:    {
       77:12920:    case SHN_UNDEF:	return "UND";
    #####:12921:    case SHN_ABS:	return "ABS";
    #####:12922:    case SHN_COMMON:	return "COM";
       66:12923:    default:
       66:12924:      if (type == SHN_IA_64_ANSI_COMMON
    #####:12925:	  && filedata->file_header.e_machine == EM_IA_64
    #####:12926:	  && filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_HPUX)
    #####:12927:	return "ANSI_COM";
       66:12928:      else if ((filedata->file_header.e_machine == EM_X86_64
       66:12929:		|| filedata->file_header.e_machine == EM_L1OM
       66:12930:		|| filedata->file_header.e_machine == EM_K1OM)
    #####:12931:	       && type == SHN_X86_64_LCOMMON)
    #####:12932:	return "LARGE_COM";
       66:12933:      else if ((type == SHN_MIPS_SCOMMON
    #####:12934:		&& filedata->file_header.e_machine == EM_MIPS)
       66:12935:	       || (type == SHN_TIC6X_SCOMMON
    #####:12936:		   && filedata->file_header.e_machine == EM_TI_C6000))
    #####:12937:	return "SCOM";
       66:12938:      else if (type == SHN_MIPS_SUNDEFINED
    #####:12939:	       && filedata->file_header.e_machine == EM_MIPS)
    #####:12940:	return "SUND";
      66*:12941:      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)
    #####:12942:	sprintf (buff, "PRC[0x%04x]", type & 0xffff);
      66*:12943:      else if (type >= SHN_LOOS && type <= SHN_HIOS)
    #####:12944:	sprintf (buff, "OS [0x%04x]", type & 0xffff);
       66:12945:      else if (type >= SHN_LORESERVE)
    #####:12946:	sprintf (buff, "RSV[0x%04x]", type & 0xffff);
       66:12947:      else if (filedata->file_header.e_shnum != 0
       66:12948:	       && type >= filedata->file_header.e_shnum)
       66:12949:	sprintf (buff, _("bad section index[%3d]"), type);
        -:12950:      else
    #####:12951:	sprintf (buff, "%3d", type);
       66:12952:      break;
        -:12953:    }
        -:12954:
       66:12955:  return buff;
        -:12956:}
        -:12957:
        -:12958:static const char *
      143:12959:get_symbol_version_string (Filedata *                   filedata,
        -:12960:			   bool                         is_dynsym,
        -:12961:			   const char *                 strtab,
        -:12962:			   unsigned long int            strtab_size,
        -:12963:			   unsigned int                 si,
        -:12964:			   Elf_Internal_Sym *           psym,
        -:12965:			   enum versioned_symbol_info * sym_info,
        -:12966:			   unsigned short *             vna_other)
        -:12967:{
        -:12968:  unsigned char data[2];
        -:12969:  unsigned short vers_data;
        -:12970:  unsigned long offset;
        -:12971:  unsigned short max_vd_ndx;
        -:12972:
      143:12973:  if (!is_dynsym
       16:12974:      || filedata->version_info[DT_VERSIONTAGIDX (DT_VERSYM)] == 0)
      143:12975:    return NULL;
        -:12976:
    #####:12977:  offset = offset_from_vma (filedata,
        -:12978:			    filedata->version_info[DT_VERSIONTAGIDX (DT_VERSYM)],
    #####:12979:			    sizeof data + si * sizeof (vers_data));
        -:12980:
    #####:12981:  if (get_data (&data, filedata, offset + si * sizeof (vers_data),
    #####:12982:		sizeof (data), 1, _("version data")) == NULL)
    #####:12983:    return NULL;
        -:12984:
    #####:12985:  vers_data = byte_get (data, 2);
        -:12986:
    #####:12987:  if ((vers_data & VERSYM_HIDDEN) == 0 && vers_data == 0)
    #####:12988:    return NULL;
        -:12989:
    #####:12990:  *sym_info = (vers_data & VERSYM_HIDDEN) != 0 ? symbol_hidden : symbol_public;
    #####:12991:  max_vd_ndx = 0;
        -:12992:
        -:12993:  /* Usually we'd only see verdef for defined symbols, and verneed for
        -:12994:     undefined symbols.  However, symbols defined by the linker in
        -:12995:     .dynbss for variables copied from a shared library in order to
        -:12996:     avoid text relocations are defined yet have verneed.  We could
        -:12997:     use a heuristic to detect the special case, for example, check
        -:12998:     for verneed first on symbols defined in SHT_NOBITS sections, but
        -:12999:     it is simpler and more reliable to just look for both verdef and
        -:13000:     verneed.  .dynbss might not be mapped to a SHT_NOBITS section.  */
        -:13001:
    #####:13002:  if (psym->st_shndx != SHN_UNDEF
    #####:13003:      && vers_data != 0x8001
    #####:13004:      && filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)])
        -:13005:    {
        -:13006:      Elf_Internal_Verdef ivd;
        -:13007:      Elf_Internal_Verdaux ivda;
        -:13008:      Elf_External_Verdaux evda;
        -:13009:      unsigned long off;
        -:13010:
    #####:13011:      off = offset_from_vma (filedata,
        -:13012:			     filedata->version_info[DT_VERSIONTAGIDX (DT_VERDEF)],
        -:13013:			     sizeof (Elf_External_Verdef));
        -:13014:
        -:13015:      do
        -:13016:	{
        -:13017:	  Elf_External_Verdef evd;
        -:13018:
    #####:13019:	  if (get_data (&evd, filedata, off, sizeof (evd), 1,
    #####:13020:			_("version def")) == NULL)
        -:13021:	    {
    #####:13022:	      ivd.vd_ndx = 0;
    #####:13023:	      ivd.vd_aux = 0;
    #####:13024:	      ivd.vd_next = 0;
    #####:13025:	      ivd.vd_flags = 0;
        -:13026:	    }
        -:13027:	  else
        -:13028:	    {
    #####:13029:	      ivd.vd_ndx = BYTE_GET (evd.vd_ndx);
    #####:13030:	      ivd.vd_aux = BYTE_GET (evd.vd_aux);
    #####:13031:	      ivd.vd_next = BYTE_GET (evd.vd_next);
    #####:13032:	      ivd.vd_flags = BYTE_GET (evd.vd_flags);
        -:13033:	    }
        -:13034:
    #####:13035:	  if ((ivd.vd_ndx & VERSYM_VERSION) > max_vd_ndx)
    #####:13036:	    max_vd_ndx = ivd.vd_ndx & VERSYM_VERSION;
        -:13037:
    #####:13038:	  off += ivd.vd_next;
        -:13039:	}
    #####:13040:      while (ivd.vd_ndx != (vers_data & VERSYM_VERSION) && ivd.vd_next != 0);
        -:13041:
    #####:13042:      if (ivd.vd_ndx == (vers_data & VERSYM_VERSION))
        -:13043:	{
    #####:13044:	  if (ivd.vd_ndx == 1 && ivd.vd_flags == VER_FLG_BASE)
    #####:13045:	    return NULL;
        -:13046:
    #####:13047:	  off -= ivd.vd_next;
    #####:13048:	  off += ivd.vd_aux;
        -:13049:
    #####:13050:	  if (get_data (&evda, filedata, off, sizeof (evda), 1,
    #####:13051:			_("version def aux")) != NULL)
        -:13052:	    {
    #####:13053:	      ivda.vda_name = BYTE_GET (evda.vda_name);
        -:13054:
    #####:13055:	      if (psym->st_name != ivda.vda_name)
    #####:13056:		return (ivda.vda_name < strtab_size
    #####:13057:			? strtab + ivda.vda_name : _("<corrupt>"));
        -:13058:	    }
        -:13059:	}
        -:13060:    }
        -:13061:
    #####:13062:  if (filedata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)])
        -:13063:    {
        -:13064:      Elf_External_Verneed evn;
        -:13065:      Elf_Internal_Verneed ivn;
        -:13066:      Elf_Internal_Vernaux ivna;
        -:13067:
    #####:13068:      offset = offset_from_vma (filedata,
        -:13069:				filedata->version_info[DT_VERSIONTAGIDX (DT_VERNEED)],
        -:13070:				sizeof evn);
        -:13071:      do
        -:13072:	{
        -:13073:	  unsigned long vna_off;
        -:13074:
    #####:13075:	  if (get_data (&evn, filedata, offset, sizeof (evn), 1,
    #####:13076:			_("version need")) == NULL)
        -:13077:	    {
    #####:13078:	      ivna.vna_next = 0;
    #####:13079:	      ivna.vna_other = 0;
    #####:13080:	      ivna.vna_name = 0;
    #####:13081:	      break;
        -:13082:	    }
        -:13083:
    #####:13084:	  ivn.vn_aux  = BYTE_GET (evn.vn_aux);
    #####:13085:	  ivn.vn_next = BYTE_GET (evn.vn_next);
        -:13086:
    #####:13087:	  vna_off = offset + ivn.vn_aux;
        -:13088:
        -:13089:	  do
        -:13090:	    {
        -:13091:	      Elf_External_Vernaux evna;
        -:13092:
    #####:13093:	      if (get_data (&evna, filedata, vna_off, sizeof (evna), 1,
    #####:13094:			    _("version need aux (3)")) == NULL)
        -:13095:		{
    #####:13096:		  ivna.vna_next = 0;
    #####:13097:		  ivna.vna_other = 0;
    #####:13098:		  ivna.vna_name = 0;
        -:13099:		}
        -:13100:	      else
        -:13101:		{
    #####:13102:		  ivna.vna_other = BYTE_GET (evna.vna_other);
    #####:13103:		  ivna.vna_next  = BYTE_GET (evna.vna_next);
    #####:13104:		  ivna.vna_name  = BYTE_GET (evna.vna_name);
        -:13105:		}
        -:13106:
    #####:13107:	      vna_off += ivna.vna_next;
        -:13108:	    }
    #####:13109:	  while (ivna.vna_other != vers_data && ivna.vna_next != 0);
        -:13110:
    #####:13111:	  if (ivna.vna_other == vers_data)
    #####:13112:	    break;
        -:13113:
    #####:13114:	  offset += ivn.vn_next;
        -:13115:	}
    #####:13116:      while (ivn.vn_next != 0);
        -:13117:
    #####:13118:      if (ivna.vna_other == vers_data)
        -:13119:	{
    #####:13120:	  *sym_info = symbol_undefined;
    #####:13121:	  *vna_other = ivna.vna_other;
    #####:13122:	  return (ivna.vna_name < strtab_size
    #####:13123:		  ? strtab + ivna.vna_name : _("<corrupt>"));
        -:13124:	}
    #####:13125:      else if ((max_vd_ndx || (vers_data & VERSYM_VERSION) != 1)
    #####:13126:	       && (vers_data & VERSYM_VERSION) > max_vd_ndx)
    #####:13127:	return _("<corrupt>");
        -:13128:    }
    #####:13129:  return NULL;
        -:13130:}
        -:13131:
        -:13132:/* Display a symbol size on stdout.  Format is based on --sym-base setting.  */
        -:13133:
        -:13134:static unsigned int
      143:13135:print_dynamic_symbol_size (bfd_vma vma, int base)
        -:13136:{
      143:13137:  switch (base)
        -:13138:    {
    #####:13139:    case 8:
    #####:13140:      return print_vma (vma, OCTAL_5);
        -:13141:
    #####:13142:    case 10:
    #####:13143:      return print_vma (vma, UNSIGNED_5);
        -:13144:
    #####:13145:    case 16:
    #####:13146:      return print_vma (vma, PREFIX_HEX_5);
        -:13147:
      143:13148:    case 0:
        -:13149:    default:
      143:13150:      return print_vma (vma, DEC_5);
        -:13151:    }
        -:13152:}
        -:13153:
        -:13154:static void
      143:13155:print_dynamic_symbol (Filedata *filedata, unsigned long si,
        -:13156:		      Elf_Internal_Sym *symtab,
        -:13157:		      Elf_Internal_Shdr *section,
        -:13158:		      char *strtab, size_t strtab_size)
        -:13159:{
        -:13160:  const char *version_string;
        -:13161:  enum versioned_symbol_info sym_info;
        -:13162:  unsigned short vna_other;
        -:13163:  bool is_valid;
        -:13164:  const char * sstr;
      143:13165:  Elf_Internal_Sym *psym = symtab + si;
        -:13166:
      143:13167:  printf ("%6ld: ", si);
      143:13168:  print_vma (psym->st_value, LONG_HEX);
      143:13169:  putchar (' ');
      143:13170:  print_dynamic_symbol_size (psym->st_size, sym_base);
      143:13171:  printf (" %-7s", get_symbol_type (filedata, ELF_ST_TYPE (psym->st_info)));
      143:13172:  printf (" %-6s", get_symbol_binding (filedata, ELF_ST_BIND (psym->st_info)));
      143:13173:  if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_SOLARIS)
    #####:13174:    printf (" %-7s",  get_solaris_symbol_visibility (psym->st_other));
        -:13175:  else
        -:13176:    {
      143:13177:      unsigned int vis = ELF_ST_VISIBILITY (psym->st_other);
        -:13178:
      143:13179:      printf (" %-7s", get_symbol_visibility (vis));
        -:13180:      /* Check to see if any other bits in the st_other field are set.
        -:13181:	 Note - displaying this information disrupts the layout of the
        -:13182:	 table being generated, but for the moment this case is very rare.  */
      143:13183:      if (psym->st_other ^ vis)
       47:13184:	printf (" [%s] ", get_symbol_other (filedata, psym->st_other ^ vis));
        -:13185:    }
      143:13186:  printf (" %4s ", get_symbol_index_type (filedata, psym->st_shndx));
        -:13187:
      143:13188:  if (ELF_ST_TYPE (psym->st_info) == STT_SECTION
        6:13189:      && psym->st_shndx < filedata->file_header.e_shnum
        2:13190:      && filedata->section_headers != NULL
        2:13191:      && psym->st_name == 0)
        -:13192:    {
        -:13193:      is_valid
        1:13194:	= section_name_valid (filedata,
        1:13195:			      filedata->section_headers + psym->st_shndx);
        1:13196:      sstr = is_valid ?
        1:13197:	section_name_print (filedata,
        1:13198:			    filedata->section_headers + psym->st_shndx)
       1*:13199:	: _("<corrupt>");
        -:13200:    }
        -:13201:  else
        -:13202:    {
      142:13203:      is_valid = valid_symbol_name (strtab, strtab_size, psym->st_name);
      142:13204:      sstr = is_valid  ? strtab + psym->st_name : _("<corrupt>");
        -:13205:    }
        -:13206:
        -:13207:  version_string
      286:13208:    = get_symbol_version_string (filedata,
        -:13209:				 (section == NULL
      143:13210:				  || section->sh_type == SHT_DYNSYM),
        -:13211:				 strtab, strtab_size, si,
        -:13212:				 psym, &sym_info, &vna_other);
        -:13213:
      143:13214:  int len_avail = 21;
      143:13215:  if (! do_wide && version_string != NULL)
        -:13216:    {
        -:13217:      char buffer[16];
        -:13218:
    #####:13219:      len_avail -= 1 + strlen (version_string);
        -:13220:
    #####:13221:      if (sym_info == symbol_undefined)
    #####:13222:	len_avail -= sprintf (buffer," (%d)", vna_other);
    #####:13223:      else if (sym_info != symbol_hidden)
    #####:13224:	len_avail -= 1;
        -:13225:    }
        -:13226:
      143:13227:  print_symbol (len_avail, sstr);
        -:13228:
      143:13229:  if (version_string)
        -:13230:    {
    #####:13231:      if (sym_info == symbol_undefined)
    #####:13232:	printf ("@%s (%d)", version_string, vna_other);
        -:13233:      else
    #####:13234:	printf (sym_info == symbol_hidden ? "@%s" : "@@%s",
        -:13235:		version_string);
        -:13236:    }
        -:13237:
      143:13238:  putchar ('\n');
        -:13239:
      143:13240:  if (ELF_ST_BIND (psym->st_info) == STB_LOCAL
      101:13241:      && section != NULL
      101:13242:      && si >= section->sh_info
        -:13243:      /* Irix 5 and 6 MIPS binaries are known to ignore this requirement.  */
       88:13244:      && filedata->file_header.e_machine != EM_MIPS
        -:13245:      /* Solaris binaries have been found to violate this requirement as
        -:13246:	 well.  Not sure if this is a bug or an ABI requirement.  */
       88:13247:      && filedata->file_header.e_ident[EI_OSABI] != ELFOSABI_SOLARIS)
       88:13248:    warn (_("local symbol %lu found at index >= %s's sh_info value of %u\n"),
        -:13249:	  si, printable_section_name (filedata, section), section->sh_info);
      143:13250:}
        -:13251:
        -:13252:static const char *
    #####:13253:get_lto_kind (unsigned int kind)
        -:13254:{
    #####:13255:  switch (kind)
        -:13256:    {
    #####:13257:    case 0: return "DEF";
    #####:13258:    case 1: return "WEAKDEF";
    #####:13259:    case 2: return "UNDEF";
    #####:13260:    case 3: return "WEAKUNDEF";
    #####:13261:    case 4: return "COMMON";
    #####:13262:    default:
    #####:13263:      break;
        -:13264:    }
        -:13265:
        -:13266:  static char buffer[30];
    #####:13267:  error (_("Unknown LTO symbol definition encountered: %u\n"), kind);
    #####:13268:  sprintf (buffer, "<unknown: %u>", kind);
    #####:13269:  return buffer;
        -:13270:}
        -:13271:
        -:13272:static const char *
    #####:13273:get_lto_visibility (unsigned int visibility)
        -:13274:{
    #####:13275:  switch (visibility)
        -:13276:    {
    #####:13277:    case 0: return "DEFAULT";
    #####:13278:    case 1: return "PROTECTED";
    #####:13279:    case 2: return "INTERNAL";
    #####:13280:    case 3: return "HIDDEN";
    #####:13281:    default:
    #####:13282:      break;
        -:13283:    }
        -:13284:
        -:13285:  static char buffer[30];
    #####:13286:  error (_("Unknown LTO symbol visibility encountered: %u\n"), visibility);
    #####:13287:  sprintf (buffer, "<unknown: %u>", visibility);
    #####:13288:  return buffer;
        -:13289:}
        -:13290:
        -:13291:static const char *
    #####:13292:get_lto_sym_type (unsigned int sym_type)
        -:13293:{
    #####:13294:  switch (sym_type)
        -:13295:    {
    #####:13296:    case 0: return "UNKNOWN";
    #####:13297:    case 1: return "FUNCTION";
    #####:13298:    case 2: return "VARIABLE";
    #####:13299:    default:
    #####:13300:      break;
        -:13301:    }
        -:13302:
        -:13303:  static char buffer[30];
    #####:13304:  error (_("Unknown LTO symbol type encountered: %u\n"), sym_type);
    #####:13305:  sprintf (buffer, "<unknown: %u>", sym_type);
    #####:13306:  return buffer;
        -:13307:}
        -:13308:
        -:13309:/* Display an LTO format symbol table.
        -:13310:   FIXME: The format of LTO symbol tables is not formalized.
        -:13311:   So this code could need changing in the future.  */
        -:13312:
        -:13313:static bool
    #####:13314:display_lto_symtab (Filedata *           filedata,
        -:13315:		    Elf_Internal_Shdr *  section)
        -:13316:{
    #####:13317:  if (section->sh_size == 0)
        -:13318:    {
    #####:13319:      if (filedata->is_separate)
    #####:13320:	printf (_("\nThe LTO Symbol table section '%s' in linked file '%s' is empty!\n"),
        -:13321:		printable_section_name (filedata, section),
        -:13322:		filedata->file_name);
        -:13323:      else
    #####:13324:	printf (_("\nLTO Symbol table '%s' is empty!\n"),
        -:13325:		printable_section_name (filedata, section));
        -:13326:
    #####:13327:      return true;
        -:13328:    }
        -:13329:
    #####:13330:  if (section->sh_size > filedata->file_size)
        -:13331:    {
    #####:13332:      error (_("Section %s has an invalid sh_size of 0x%lx\n"),
        -:13333:	     printable_section_name (filedata, section),
    #####:13334:	     (unsigned long) section->sh_size);
    #####:13335:      return false;
        -:13336:    }
        -:13337:
    #####:13338:  void * alloced_data = get_data (NULL, filedata, section->sh_offset,
    #####:13339:				  section->sh_size, 1, _("LTO symbols"));
    #####:13340:  if (alloced_data == NULL)
    #####:13341:    return false;
        -:13342:
        -:13343:  /* Look for extended data for the symbol table.  */
        -:13344:  Elf_Internal_Shdr * ext;
    #####:13345:  void * ext_data_orig = NULL;
    #####:13346:  char * ext_data = NULL;
    #####:13347:  char * ext_data_end = NULL;
    #####:13348:  char * ext_name = NULL;
        -:13349:
    #####:13350:  if (asprintf (& ext_name, ".gnu.lto_.ext_symtab.%s",
    #####:13351:		(section_name (filedata, section)
        -:13352:		 + sizeof (".gnu.lto_.symtab.") - 1)) > 0
    #####:13353:      && ext_name != NULL /* Paranoia.  */
    #####:13354:      && (ext = find_section (filedata, ext_name)) != NULL)
        -:13355:    {
    #####:13356:      if (ext->sh_size < 3)
    #####:13357:	error (_("LTO Symbol extension table '%s' is empty!\n"),
        -:13358:	       printable_section_name (filedata, ext));
        -:13359:      else
        -:13360:	{
    #####:13361:	  ext_data_orig = ext_data = get_data (NULL, filedata, ext->sh_offset,
        -:13362:					       ext->sh_size, 1,
    #####:13363:					       _("LTO ext symbol data"));
    #####:13364:	  if (ext_data != NULL)
        -:13365:	    {
    #####:13366:	      ext_data_end = ext_data + ext->sh_size;
    #####:13367:	      if (* ext_data++ != 1)
    #####:13368:		error (_("Unexpected version number in symbol extension table\n"));
        -:13369:	    }
        -:13370:	}
        -:13371:    }
        -:13372:
    #####:13373:  const unsigned char * data = (const unsigned char *) alloced_data;
    #####:13374:  const unsigned char * end = data + section->sh_size;
        -:13375:
    #####:13376:  if (filedata->is_separate)
    #####:13377:    printf (_("\nIn linked file '%s': "), filedata->file_name);
        -:13378:  else
    #####:13379:    printf ("\n");
        -:13380:
    #####:13381:  if (ext_data_orig != NULL)
        -:13382:    {
    #####:13383:      if (do_wide)
    #####:13384:	printf (_("LTO Symbol table '%s' and extension table '%s' contain:\n"),
        -:13385:		printable_section_name (filedata, section),
        -:13386:		printable_section_name (filedata, ext));
        -:13387:      else
        -:13388:	{
    #####:13389:	  printf (_("LTO Symbol table '%s'\n"),
        -:13390:		  printable_section_name (filedata, section));
    #####:13391:	  printf (_(" and extension table '%s' contain:\n"),
        -:13392:		  printable_section_name (filedata, ext));
        -:13393:	}
        -:13394:    }
        -:13395:  else
    #####:13396:    printf (_("LTO Symbol table '%s' contains:\n"),
        -:13397:	    printable_section_name (filedata, section));
        -:13398:
        -:13399:  /* FIXME: Add a wide version.  */
    #####:13400:  if (ext_data_orig != NULL)
    #####:13401:    printf (_("  Comdat_Key       Kind  Visibility     Size      Slot      Type  Section Name\n"));
        -:13402:  else
    #####:13403:    printf (_("  Comdat_Key       Kind  Visibility     Size      Slot Name\n"));
        -:13404:
        -:13405:  /* FIXME: We do not handle style prefixes.  */
        -:13406:
    #####:13407:  while (data < end)
        -:13408:    {
    #####:13409:      const unsigned char * sym_name = data;
    #####:13410:      data += strnlen ((const char *) sym_name, end - data) + 1;
    #####:13411:      if (data >= end)
    #####:13412:	goto fail;
        -:13413:
    #####:13414:      const unsigned char * comdat_key = data;
    #####:13415:      data += strnlen ((const char *) comdat_key, end - data) + 1;
    #####:13416:      if (data >= end)
    #####:13417:	goto fail;
        -:13418:
    #####:13419:      if (data + 2 + 8 + 4 > end)
    #####:13420:	goto fail;
        -:13421:
    #####:13422:      unsigned int kind = *data++;
    #####:13423:      unsigned int visibility = *data++;
        -:13424:
    #####:13425:      elf_vma size = byte_get (data, 8);
    #####:13426:      data += 8;
        -:13427:
    #####:13428:      elf_vma slot = byte_get (data, 4);
    #####:13429:      data += 4;
        -:13430:
    #####:13431:      if (ext_data != NULL)
        -:13432:	{
    #####:13433:	  if (ext_data < (ext_data_end - 1))
        -:13434:	    {
    #####:13435:	      unsigned int sym_type = * ext_data ++;
    #####:13436:	      unsigned int sec_kind = * ext_data ++;
        -:13437:
    #####:13438:	      printf ("  %10s %10s %11s %08lx  %08lx %9s %08lx _",
    #####:13439:		      * comdat_key == 0 ? "-" : (char *) comdat_key,
        -:13440:		      get_lto_kind (kind),
        -:13441:		      get_lto_visibility (visibility),
        -:13442:		      (long) size,
        -:13443:		      (long) slot,
        -:13444:		      get_lto_sym_type (sym_type),
        -:13445:		      (long) sec_kind);
    #####:13446:	      print_symbol (6, (const char *) sym_name);
        -:13447:	    }
        -:13448:	  else
        -:13449:	    {
    #####:13450:	      error (_("Ran out of LTO symbol extension data\n"));
    #####:13451:	      ext_data = NULL;
        -:13452:	      /* FIXME: return FAIL result ?  */
        -:13453:	    }
        -:13454:	}
        -:13455:      else
        -:13456:	{
    #####:13457:	  printf ("  %10s %10s %11s %08lx  %08lx _",
    #####:13458:		  * comdat_key == 0 ? "-" : (char *) comdat_key,
        -:13459:		  get_lto_kind (kind),
        -:13460:		  get_lto_visibility (visibility),
        -:13461:		  (long) size,
        -:13462:		  (long) slot);
    #####:13463:	  print_symbol (21, (const char *) sym_name);
        -:13464:	}
    #####:13465:      putchar ('\n');
        -:13466:    }
        -:13467:
    #####:13468:  if (ext_data != NULL && ext_data < ext_data_end)
        -:13469:    {
    #####:13470:      error (_("Data remains in the LTO symbol extension table\n"));
    #####:13471:      goto fail;
        -:13472:    }
        -:13473:
    #####:13474:  free (alloced_data);
    #####:13475:  free (ext_data_orig);
    #####:13476:  free (ext_name);
    #####:13477:  return true;
        -:13478:
    #####:13479: fail:
    #####:13480:  error (_("Buffer overrun encountered whilst decoding LTO symbol table\n"));
    #####:13481:  free (alloced_data);
    #####:13482:  free (ext_data_orig);
    #####:13483:  free (ext_name);
    #####:13484:  return false;
        -:13485:}
        -:13486:
        -:13487:/* Display LTO symbol tables.  */
        -:13488:
        -:13489:static bool
     1391:13490:process_lto_symbol_tables (Filedata * filedata)
        -:13491:{
        -:13492:  Elf_Internal_Shdr * section;
        -:13493:  unsigned int i;
     1391:13494:  bool res = true;
        -:13495:
     1391:13496:  if (!do_lto_syms)
     1391:13497:    return true;
        -:13498:
    #####:13499:  if (filedata->section_headers == NULL)
    #####:13500:    return true;
        -:13501:
    #####:13502:  for (i = 0, section = filedata->section_headers;
    #####:13503:       i < filedata->file_header.e_shnum;
    #####:13504:       i++, section++)
    #####:13505:    if (section_name_valid (filedata, section)
    #####:13506:	&& startswith (section_name (filedata, section), ".gnu.lto_.symtab."))
    #####:13507:      res &= display_lto_symtab (filedata, section);
        -:13508:
    #####:13509:  return res;
        -:13510:}
        -:13511:
        -:13512:/* Dump the symbol table.  */
        -:13513:
        -:13514:static bool
     1391:13515:process_symbol_table (Filedata * filedata)
        -:13516:{
        -:13517:  Elf_Internal_Shdr * section;
        -:13518:
     1391:13519:  if (!do_syms && !do_dyn_syms && !do_histogram)
    #####:13520:    return true;
        -:13521:
     1391:13522:  if ((filedata->dynamic_info[DT_HASH] || filedata->dynamic_info_DT_GNU_HASH)
    #####:13523:      && do_syms
    #####:13524:      && do_using_dynamic
    #####:13525:      && filedata->dynamic_strings != NULL
    #####:13526:      && filedata->dynamic_symbols != NULL)
    #####:13527:    {
        -:13528:      unsigned long si;
        -:13529:
    #####:13530:      if (filedata->is_separate)
        -:13531:	{
    #####:13532:	  printf (ngettext ("\nIn linked file '%s' the dynamic symbol table contains %lu entry:\n",
        -:13533:			    "\nIn linked file '%s' the dynamic symbol table contains %lu entries:\n",
        -:13534:			    filedata->num_dynamic_syms),
        -:13535:		  filedata->file_name,
        -:13536:		  filedata->num_dynamic_syms);
        -:13537:	}
        -:13538:      else
        -:13539:	{
    #####:13540:	  printf (ngettext ("\nSymbol table for image contains %lu entry:\n",
        -:13541:			    "\nSymbol table for image contains %lu entries:\n",
        -:13542:			    filedata->num_dynamic_syms),
        -:13543:		  filedata->num_dynamic_syms);
        -:13544:	}
    #####:13545:      if (is_32bit_elf)
    #####:13546:	printf (_("   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"));
        -:13547:      else
    #####:13548:	printf (_("   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"));
        -:13549:
    #####:13550:      for (si = 0; si < filedata->num_dynamic_syms; si++)
    #####:13551:	print_dynamic_symbol (filedata, si, filedata->dynamic_symbols, NULL,
        -:13552:			      filedata->dynamic_strings,
        -:13553:			      filedata->dynamic_strings_length);
        -:13554:    }
     1391:13555:  else if ((do_dyn_syms || (do_syms && !do_using_dynamic))
      163:13556:	   && filedata->section_headers != NULL)
      162:13557:    {
        -:13558:      unsigned int i;
        -:13559:
      162:13560:      for (i = 0, section = filedata->section_headers;
      806:13561:	   i < filedata->file_header.e_shnum;
      644:13562:	   i++, section++)
        -:13563:	{
      644:13564:	  char * strtab = NULL;
      644:13565:	  unsigned long int strtab_size = 0;
        -:13566:	  Elf_Internal_Sym * symtab;
        -:13567:	  unsigned long si, num_syms;
        -:13568:
      644:13569:	  if ((section->sh_type != SHT_SYMTAB
      615:13570:	       && section->sh_type != SHT_DYNSYM)
       38:13571:	      || (!do_syms
    #####:13572:		  && section->sh_type == SHT_SYMTAB))
      623:13573:	    continue;
        -:13574:
       38:13575:	  if (section->sh_entsize == 0)
        -:13576:	    {
    #####:13577:	      printf (_("\nSymbol table '%s' has a sh_entsize of zero!\n"),
        -:13578:		      printable_section_name (filedata, section));
    #####:13579:	      continue;
        -:13580:	    }
        -:13581:
       38:13582:	  num_syms = section->sh_size / section->sh_entsize;
        -:13583:
       38:13584:	  if (filedata->is_separate)
    #####:13585:	    printf (ngettext ("\nIn linked file '%s' symbol section '%s' contains %lu entry:\n",
        -:13586:			      "\nIn linked file '%s' symbol section '%s' contains %lu entries:\n",
        -:13587:			      num_syms),
        -:13588:		    filedata->file_name,
        -:13589:		    printable_section_name (filedata, section),
        -:13590:		    num_syms);
        -:13591:	  else
       38:13592:	    printf (ngettext ("\nSymbol table '%s' contains %lu entry:\n",
        -:13593:			      "\nSymbol table '%s' contains %lu entries:\n",
        -:13594:			      num_syms),
        -:13595:		    printable_section_name (filedata, section),
        -:13596:		    num_syms);
        -:13597:
       38:13598:	  if (is_32bit_elf)
       38:13599:	    printf (_("   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"));
        -:13600:	  else
    #####:13601:	    printf (_("   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"));
        -:13602:
       38:13603:	  symtab = get_elf_symbols (filedata, section, & num_syms);
       38:13604:	  if (symtab == NULL)
       17:13605:	    continue;
        -:13606:
       21:13607:	  if (section->sh_link == filedata->file_header.e_shstrndx)
        -:13608:	    {
    #####:13609:	      strtab = filedata->string_table;
    #####:13610:	      strtab_size = filedata->string_table_length;
        -:13611:	    }
       21:13612:	  else if (section->sh_link < filedata->file_header.e_shnum)
        -:13613:	    {
        -:13614:	      Elf_Internal_Shdr * string_sec;
        -:13615:
       19:13616:	      string_sec = filedata->section_headers + section->sh_link;
        -:13617:
       19:13618:	      strtab = (char *) get_data (NULL, filedata, string_sec->sh_offset,
        -:13619:                                          1, string_sec->sh_size,
       19:13620:                                          _("string table"));
       19:13621:	      strtab_size = strtab != NULL ? string_sec->sh_size : 0;
        -:13622:	    }
        -:13623:
      164:13624:	  for (si = 0; si < num_syms; si++)
      143:13625:	    print_dynamic_symbol (filedata, si, symtab, section,
        -:13626:				  strtab, strtab_size);
        -:13627:
       21:13628:	  free (symtab);
       21:13629:	  if (strtab != filedata->string_table)
       20:13630:	    free (strtab);
        -:13631:	}
        -:13632:    }
     1229:13633:  else if (do_syms)
        1:13634:    printf
        1:13635:      (_("\nDynamic symbol information is not available for displaying symbols.\n"));
        -:13636:
     1391:13637:  if (do_histogram && filedata->buckets != NULL)
        -:13638:    {
        -:13639:      unsigned long * lengths;
        -:13640:      unsigned long * counts;
        -:13641:      unsigned long hn;
        -:13642:      bfd_vma si;
    #####:13643:      unsigned long maxlength = 0;
    #####:13644:      unsigned long nzero_counts = 0;
    #####:13645:      unsigned long nsyms = 0;
        -:13646:      char *visited;
        -:13647:
    #####:13648:      printf (ngettext ("\nHistogram for bucket list length "
        -:13649:			"(total of %lu bucket):\n",
        -:13650:			"\nHistogram for bucket list length "
        -:13651:			"(total of %lu buckets):\n",
    #####:13652:			(unsigned long) filedata->nbuckets),
    #####:13653:	      (unsigned long) filedata->nbuckets);
        -:13654:
    #####:13655:      lengths = (unsigned long *) calloc (filedata->nbuckets,
        -:13656:					  sizeof (*lengths));
    #####:13657:      if (lengths == NULL)
        -:13658:	{
    #####:13659:	  error (_("Out of memory allocating space for histogram buckets\n"));
    #####:13660:	  goto err_out;
        -:13661:	}
    #####:13662:      visited = xcmalloc (filedata->nchains, 1);
    #####:13663:      memset (visited, 0, filedata->nchains);
        -:13664:
    #####:13665:      printf (_(" Length  Number     %% of total  Coverage\n"));
    #####:13666:      for (hn = 0; hn < filedata->nbuckets; ++hn)
        -:13667:	{
    #####:13668:	  for (si = filedata->buckets[hn]; si > 0; si = filedata->chains[si])
        -:13669:	    {
    #####:13670:	      ++nsyms;
    #####:13671:	      if (maxlength < ++lengths[hn])
    #####:13672:		++maxlength;
    #####:13673:	      if (si >= filedata->nchains || visited[si])
        -:13674:		{
    #####:13675:		  error (_("histogram chain is corrupt\n"));
    #####:13676:		  break;
        -:13677:		}
    #####:13678:	      visited[si] = 1;
        -:13679:	    }
        -:13680:	}
    #####:13681:      free (visited);
        -:13682:
    #####:13683:      counts = (unsigned long *) calloc (maxlength + 1, sizeof (*counts));
    #####:13684:      if (counts == NULL)
        -:13685:	{
    #####:13686:	  free (lengths);
    #####:13687:	  error (_("Out of memory allocating space for histogram counts\n"));
    #####:13688:	  goto err_out;
        -:13689:	}
        -:13690:
    #####:13691:      for (hn = 0; hn < filedata->nbuckets; ++hn)
    #####:13692:	++counts[lengths[hn]];
        -:13693:
    #####:13694:      if (filedata->nbuckets > 0)
        -:13695:	{
        -:13696:	  unsigned long i;
    #####:13697:	  printf ("      0  %-10lu (%5.1f%%)\n",
    #####:13698:		  counts[0], (counts[0] * 100.0) / filedata->nbuckets);
    #####:13699:	  for (i = 1; i <= maxlength; ++i)
        -:13700:	    {
    #####:13701:	      nzero_counts += counts[i] * i;
    #####:13702:	      printf ("%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
    #####:13703:		      i, counts[i], (counts[i] * 100.0) / filedata->nbuckets,
    #####:13704:		      (nzero_counts * 100.0) / nsyms);
        -:13705:	    }
        -:13706:	}
        -:13707:
    #####:13708:      free (counts);
    #####:13709:      free (lengths);
        -:13710:    }
        -:13711:
     1391:13712:  free (filedata->buckets);
     1391:13713:  filedata->buckets = NULL;
     1391:13714:  filedata->nbuckets = 0;
     1391:13715:  free (filedata->chains);
     1391:13716:  filedata->chains = NULL;
        -:13717:
     1391:13718:  if (do_histogram && filedata->gnubuckets != NULL)
        -:13719:    {
        -:13720:      unsigned long * lengths;
        -:13721:      unsigned long * counts;
        -:13722:      unsigned long hn;
    #####:13723:      unsigned long maxlength = 0;
    #####:13724:      unsigned long nzero_counts = 0;
    #####:13725:      unsigned long nsyms = 0;
        -:13726:
    #####:13727:      printf (ngettext ("\nHistogram for `%s' bucket list length "
        -:13728:			"(total of %lu bucket):\n",
        -:13729:			"\nHistogram for `%s' bucket list length "
        -:13730:			"(total of %lu buckets):\n",
    #####:13731:			(unsigned long) filedata->ngnubuckets),
    #####:13732:	      GNU_HASH_SECTION_NAME (filedata),
    #####:13733:	      (unsigned long) filedata->ngnubuckets);
        -:13734:
    #####:13735:      lengths = (unsigned long *) calloc (filedata->ngnubuckets,
        -:13736:					  sizeof (*lengths));
    #####:13737:      if (lengths == NULL)
        -:13738:	{
    #####:13739:	  error (_("Out of memory allocating space for gnu histogram buckets\n"));
    #####:13740:	  goto err_out;
        -:13741:	}
        -:13742:
    #####:13743:      printf (_(" Length  Number     %% of total  Coverage\n"));
        -:13744:
    #####:13745:      for (hn = 0; hn < filedata->ngnubuckets; ++hn)
    #####:13746:	if (filedata->gnubuckets[hn] != 0)
        -:13747:	  {
    #####:13748:	    bfd_vma off, length = 1;
        -:13749:
    #####:13750:	    for (off = filedata->gnubuckets[hn] - filedata->gnusymidx;
        -:13751:		 /* PR 17531 file: 010-77222-0.004.  */
    #####:13752:		 off < filedata->ngnuchains
    #####:13753:		   && (filedata->gnuchains[off] & 1) == 0;
    #####:13754:		 ++off)
    #####:13755:	      ++length;
    #####:13756:	    lengths[hn] = length;
    #####:13757:	    if (length > maxlength)
    #####:13758:	      maxlength = length;
    #####:13759:	    nsyms += length;
        -:13760:	  }
        -:13761:
    #####:13762:      counts = (unsigned long *) calloc (maxlength + 1, sizeof (*counts));
    #####:13763:      if (counts == NULL)
        -:13764:	{
    #####:13765:	  free (lengths);
    #####:13766:	  error (_("Out of memory allocating space for gnu histogram counts\n"));
    #####:13767:	  goto err_out;
        -:13768:	}
        -:13769:
    #####:13770:      for (hn = 0; hn < filedata->ngnubuckets; ++hn)
    #####:13771:	++counts[lengths[hn]];
        -:13772:
    #####:13773:      if (filedata->ngnubuckets > 0)
        -:13774:	{
        -:13775:	  unsigned long j;
    #####:13776:	  printf ("      0  %-10lu (%5.1f%%)\n",
    #####:13777:		  counts[0], (counts[0] * 100.0) / filedata->ngnubuckets);
    #####:13778:	  for (j = 1; j <= maxlength; ++j)
        -:13779:	    {
    #####:13780:	      nzero_counts += counts[j] * j;
    #####:13781:	      printf ("%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
    #####:13782:		      j, counts[j], (counts[j] * 100.0) / filedata->ngnubuckets,
    #####:13783:		      (nzero_counts * 100.0) / nsyms);
        -:13784:	    }
        -:13785:	}
        -:13786:
    #####:13787:      free (counts);
    #####:13788:      free (lengths);
        -:13789:    }
     1391:13790:  free (filedata->gnubuckets);
     1391:13791:  filedata->gnubuckets = NULL;
     1391:13792:  filedata->ngnubuckets = 0;
     1391:13793:  free (filedata->gnuchains);
     1391:13794:  filedata->gnuchains = NULL;
     1391:13795:  filedata->ngnuchains = 0;
     1391:13796:  free (filedata->mipsxlat);
     1391:13797:  filedata->mipsxlat = NULL;
     1391:13798:  return true;
        -:13799:
    #####:13800: err_out:
    #####:13801:  free (filedata->gnubuckets);
    #####:13802:  filedata->gnubuckets = NULL;
    #####:13803:  filedata->ngnubuckets = 0;
    #####:13804:  free (filedata->gnuchains);
    #####:13805:  filedata->gnuchains = NULL;
    #####:13806:  filedata->ngnuchains = 0;
    #####:13807:  free (filedata->mipsxlat);
    #####:13808:  filedata->mipsxlat = NULL;
    #####:13809:  free (filedata->buckets);
    #####:13810:  filedata->buckets = NULL;
    #####:13811:  filedata->nbuckets = 0;
    #####:13812:  free (filedata->chains);
    #####:13813:  filedata->chains = NULL;
    #####:13814:  return false;
        -:13815:}
        -:13816:
        -:13817:static bool
     1391:13818:process_syminfo (Filedata * filedata)
        -:13819:{
        -:13820:  unsigned int i;
        -:13821:
     1391:13822:  if (filedata->dynamic_syminfo == NULL
    #####:13823:      || !do_dynamic)
        -:13824:    /* No syminfo, this is ok.  */
     1391:13825:    return true;
        -:13826:
        -:13827:  /* There better should be a dynamic symbol section.  */
    #####:13828:  if (filedata->dynamic_symbols == NULL || filedata->dynamic_strings == NULL)
    #####:13829:    return false;
        -:13830:
    #####:13831:  if (filedata->is_separate)
    #####:13832:    printf (ngettext ("\nIn linked file '%s: the dynamic info segment at offset 0x%lx contains %d entry:\n",
        -:13833:		      "\nIn linked file '%s: the dynamic info segment at offset 0x%lx contains %d entries:\n",
    #####:13834:		      filedata->dynamic_syminfo_nent),
        -:13835:	    filedata->file_name,
        -:13836:	    filedata->dynamic_syminfo_offset,
        -:13837:	    filedata->dynamic_syminfo_nent);
        -:13838:  else
    #####:13839:    printf (ngettext ("\nDynamic info segment at offset 0x%lx "
        -:13840:		      "contains %d entry:\n",
        -:13841:		      "\nDynamic info segment at offset 0x%lx "
        -:13842:		      "contains %d entries:\n",
    #####:13843:		      filedata->dynamic_syminfo_nent),
        -:13844:	    filedata->dynamic_syminfo_offset,
        -:13845:	    filedata->dynamic_syminfo_nent);
        -:13846:
    #####:13847:  printf (_(" Num: Name                           BoundTo     Flags\n"));
    #####:13848:  for (i = 0; i < filedata->dynamic_syminfo_nent; ++i)
        -:13849:    {
    #####:13850:      unsigned short int flags = filedata->dynamic_syminfo[i].si_flags;
        -:13851:
    #####:13852:      printf ("%4d: ", i);
    #####:13853:      if (i >= filedata->num_dynamic_syms)
    #####:13854:	printf (_("<corrupt index>"));
    #####:13855:      else if (valid_dynamic_name (filedata, filedata->dynamic_symbols[i].st_name))
    #####:13856:	print_symbol (30, get_dynamic_name (filedata,
    #####:13857:					    filedata->dynamic_symbols[i].st_name));
        -:13858:      else
    #####:13859:	printf (_("<corrupt: %19ld>"), filedata->dynamic_symbols[i].st_name);
    #####:13860:      putchar (' ');
        -:13861:
    #####:13862:      switch (filedata->dynamic_syminfo[i].si_boundto)
        -:13863:	{
    #####:13864:	case SYMINFO_BT_SELF:
    #####:13865:	  fputs ("SELF       ", stdout);
    #####:13866:	  break;
    #####:13867:	case SYMINFO_BT_PARENT:
    #####:13868:	  fputs ("PARENT     ", stdout);
    #####:13869:	  break;
    #####:13870:	default:
    #####:13871:	  if (filedata->dynamic_syminfo[i].si_boundto > 0
    #####:13872:	      && filedata->dynamic_syminfo[i].si_boundto < filedata->dynamic_nent
    #####:13873:	      && valid_dynamic_name (filedata,
    #####:13874:				     filedata->dynamic_section[filedata->dynamic_syminfo[i].si_boundto].d_un.d_val))
        -:13875:	    {
    #####:13876:	      print_symbol (10, get_dynamic_name (filedata,
    #####:13877:						  filedata->dynamic_section[filedata->dynamic_syminfo[i].si_boundto].d_un.d_val));
    #####:13878:	      putchar (' ' );
        -:13879:	    }
        -:13880:	  else
    #####:13881:	    printf ("%-10d ", filedata->dynamic_syminfo[i].si_boundto);
    #####:13882:	  break;
        -:13883:	}
        -:13884:
    #####:13885:      if (flags & SYMINFO_FLG_DIRECT)
    #####:13886:	printf (" DIRECT");
    #####:13887:      if (flags & SYMINFO_FLG_PASSTHRU)
    #####:13888:	printf (" PASSTHRU");
    #####:13889:      if (flags & SYMINFO_FLG_COPY)
    #####:13890:	printf (" COPY");
    #####:13891:      if (flags & SYMINFO_FLG_LAZYLOAD)
    #####:13892:	printf (" LAZYLOAD");
        -:13893:
    #####:13894:      puts ("");
        -:13895:    }
        -:13896:
    #####:13897:  return true;
        -:13898:}
        -:13899:
        -:13900:/* A macro which evaluates to TRUE if the region ADDR .. ADDR + NELEM
        -:13901:   is contained by the region START .. END.  The types of ADDR, START
        -:13902:   and END should all be the same.  Note both ADDR + NELEM and END
        -:13903:   point to just beyond the end of the regions that are being tested.  */
        -:13904:#define IN_RANGE(START,END,ADDR,NELEM)		\
        -:13905:  (((ADDR) >= (START)) && ((ADDR) < (END)) && ((ADDR) + (NELEM) <= (END)))
        -:13906:
        -:13907:/* Check to see if the given reloc needs to be handled in a target specific
        -:13908:   manner.  If so then process the reloc and return TRUE otherwise return
        -:13909:   FALSE.
        -:13910:
        -:13911:   If called with reloc == NULL, then this is a signal that reloc processing
        -:13912:   for the current section has finished, and any saved state should be
        -:13913:   discarded.  */
        -:13914:
        -:13915:static bool
    #####:13916:target_specific_reloc_handling (Filedata *           filedata,
        -:13917:				Elf_Internal_Rela *  reloc,
        -:13918:				unsigned char *      start,
        -:13919:				unsigned char *      end,
        -:13920:				Elf_Internal_Sym *   symtab,
        -:13921:				unsigned long        num_syms)
        -:13922:{
    #####:13923:  unsigned int reloc_type = 0;
    #####:13924:  unsigned long sym_index = 0;
        -:13925:
    #####:13926:  if (reloc)
        -:13927:    {
    #####:13928:      reloc_type = get_reloc_type (filedata, reloc->r_info);
    #####:13929:      sym_index = get_reloc_symindex (reloc->r_info);
        -:13930:    }
        -:13931:
    #####:13932:  switch (filedata->file_header.e_machine)
        -:13933:    {
    #####:13934:    case EM_MSP430:
        -:13935:    case EM_MSP430_OLD:
        -:13936:      {
        -:13937:	static Elf_Internal_Sym * saved_sym = NULL;
        -:13938:
    #####:13939:	if (reloc == NULL)
        -:13940:	  {
    #####:13941:	    saved_sym = NULL;
    #####:13942:	    return true;
        -:13943:	  }
        -:13944:
        -:13945:	switch (reloc_type)
        -:13946:	  {
    #####:13947:	  case 10: /* R_MSP430_SYM_DIFF */
        -:13948:	  case 12: /* R_MSP430_GNU_SUB_ULEB128 */
    #####:13949:	    if (uses_msp430x_relocs (filedata))
    #####:13950:	      break;
        -:13951:	    /* Fall through.  */
        -:13952:	  case 21: /* R_MSP430X_SYM_DIFF */
        -:13953:	  case 23: /* R_MSP430X_GNU_SUB_ULEB128 */
        -:13954:	    /* PR 21139.  */
    #####:13955:	    if (sym_index >= num_syms)
    #####:13956:	      error (_("MSP430 SYM_DIFF reloc contains invalid symbol index %lu\n"),
        -:13957:		     sym_index);
        -:13958:	    else
    #####:13959:	      saved_sym = symtab + sym_index;
    #####:13960:	    return true;
        -:13961:
    #####:13962:	  case 1: /* R_MSP430_32 or R_MSP430_ABS32 */
        -:13963:	  case 3: /* R_MSP430_16 or R_MSP430_ABS8 */
    #####:13964:	    goto handle_sym_diff;
        -:13965:
    #####:13966:	  case 5: /* R_MSP430_16_BYTE */
        -:13967:	  case 9: /* R_MSP430_8 */
        -:13968:	  case 11: /* R_MSP430_GNU_SET_ULEB128 */
    #####:13969:	    if (uses_msp430x_relocs (filedata))
    #####:13970:	      break;
    #####:13971:	    goto handle_sym_diff;
        -:13972:
    #####:13973:	  case 2: /* R_MSP430_ABS16 */
        -:13974:	  case 15: /* R_MSP430X_ABS16 */
        -:13975:	  case 22: /* R_MSP430X_GNU_SET_ULEB128 */
    #####:13976:	    if (! uses_msp430x_relocs (filedata))
    #####:13977:	      break;
    #####:13978:	    goto handle_sym_diff;
        -:13979:
    #####:13980:	  handle_sym_diff:
    #####:13981:	    if (saved_sym != NULL)
        -:13982:	      {
        -:13983:		bfd_vma value;
    #####:13984:		unsigned int reloc_size = 0;
    #####:13985:		int leb_ret = 0;
        -:13986:		switch (reloc_type)
        -:13987:		  {
    #####:13988:		  case 1: /* R_MSP430_32 or R_MSP430_ABS32 */
    #####:13989:		    reloc_size = 4;
    #####:13990:		    break;
    #####:13991:		  case 11: /* R_MSP430_GNU_SET_ULEB128 */
        -:13992:		  case 22: /* R_MSP430X_GNU_SET_ULEB128 */
    #####:13993:		    if (reloc->r_offset < (size_t) (end - start))
    #####:13994:		      read_leb128 (start + reloc->r_offset, end, false,
        -:13995:				   &reloc_size, &leb_ret);
    #####:13996:		    break;
    #####:13997:		  default:
    #####:13998:		    reloc_size = 2;
    #####:13999:		    break;
        -:14000:		  }
        -:14001:
    #####:14002:		if (leb_ret != 0 || reloc_size == 0 || reloc_size > 8)
    #####:14003:		  error (_("MSP430 ULEB128 field at 0x%lx contains invalid "
        -:14004:			   "ULEB128 value\n"),
    #####:14005:			 (long) reloc->r_offset);
    #####:14006:		else if (sym_index >= num_syms)
    #####:14007:		  error (_("MSP430 reloc contains invalid symbol index %lu\n"),
        -:14008:			 sym_index);
        -:14009:		else
        -:14010:		  {
    #####:14011:		    value = reloc->r_addend + (symtab[sym_index].st_value
    #####:14012:					       - saved_sym->st_value);
        -:14013:
    #####:14014:		    if (IN_RANGE (start, end, start + reloc->r_offset, reloc_size))
    #####:14015:		      byte_put (start + reloc->r_offset, value, reloc_size);
        -:14016:		    else
        -:14017:		      /* PR 21137 */
    #####:14018:		      error (_("MSP430 sym diff reloc contains invalid offset: 0x%lx\n"),
    #####:14019:			     (long) reloc->r_offset);
        -:14020:		  }
        -:14021:
    #####:14022:		saved_sym = NULL;
    #####:14023:		return true;
        -:14024:	      }
    #####:14025:	    break;
        -:14026:
    #####:14027:	  default:
    #####:14028:	    if (saved_sym != NULL)
    #####:14029:	      error (_("Unhandled MSP430 reloc type found after SYM_DIFF reloc\n"));
    #####:14030:	    break;
        -:14031:	  }
    #####:14032:	break;
        -:14033:      }
        -:14034:
    #####:14035:    case EM_MN10300:
        -:14036:    case EM_CYGNUS_MN10300:
        -:14037:      {
        -:14038:	static Elf_Internal_Sym * saved_sym = NULL;
        -:14039:
    #####:14040:	if (reloc == NULL)
        -:14041:	  {
    #####:14042:	    saved_sym = NULL;
    #####:14043:	    return true;
        -:14044:	  }
        -:14045:
        -:14046:	switch (reloc_type)
        -:14047:	  {
    #####:14048:	  case 34: /* R_MN10300_ALIGN */
    #####:14049:	    return true;
    #####:14050:	  case 33: /* R_MN10300_SYM_DIFF */
    #####:14051:	    if (sym_index >= num_syms)
    #####:14052:	      error (_("MN10300_SYM_DIFF reloc contains invalid symbol index %lu\n"),
        -:14053:		     sym_index);
        -:14054:	    else
    #####:14055:	      saved_sym = symtab + sym_index;
    #####:14056:	    return true;
        -:14057:
    #####:14058:	  case 1: /* R_MN10300_32 */
        -:14059:	  case 2: /* R_MN10300_16 */
    #####:14060:	    if (saved_sym != NULL)
        -:14061:	      {
    #####:14062:		int reloc_size = reloc_type == 1 ? 4 : 2;
        -:14063:		bfd_vma value;
        -:14064:
    #####:14065:		if (sym_index >= num_syms)
    #####:14066:		  error (_("MN10300 reloc contains invalid symbol index %lu\n"),
        -:14067:			 sym_index);
        -:14068:		else
        -:14069:		  {
    #####:14070:		    value = reloc->r_addend + (symtab[sym_index].st_value
    #####:14071:					       - saved_sym->st_value);
        -:14072:
    #####:14073:		    if (IN_RANGE (start, end, start + reloc->r_offset, reloc_size))
    #####:14074:		      byte_put (start + reloc->r_offset, value, reloc_size);
        -:14075:		    else
    #####:14076:		      error (_("MN10300 sym diff reloc contains invalid offset: 0x%lx\n"),
    #####:14077:			     (long) reloc->r_offset);
        -:14078:		  }
        -:14079:
    #####:14080:		saved_sym = NULL;
    #####:14081:		return true;
        -:14082:	      }
    #####:14083:	    break;
    #####:14084:	  default:
    #####:14085:	    if (saved_sym != NULL)
    #####:14086:	      error (_("Unhandled MN10300 reloc type found after SYM_DIFF reloc\n"));
    #####:14087:	    break;
        -:14088:	  }
    #####:14089:	break;
        -:14090:      }
        -:14091:
    #####:14092:    case EM_RL78:
        -:14093:      {
        -:14094:	static bfd_vma saved_sym1 = 0;
        -:14095:	static bfd_vma saved_sym2 = 0;
        -:14096:	static bfd_vma value;
        -:14097:
    #####:14098:	if (reloc == NULL)
        -:14099:	  {
    #####:14100:	    saved_sym1 = saved_sym2 = 0;
    #####:14101:	    return true;
        -:14102:	  }
        -:14103:
        -:14104:	switch (reloc_type)
        -:14105:	  {
    #####:14106:	  case 0x80: /* R_RL78_SYM.  */
    #####:14107:	    saved_sym1 = saved_sym2;
    #####:14108:	    if (sym_index >= num_syms)
    #####:14109:	      error (_("RL78_SYM reloc contains invalid symbol index %lu\n"),
        -:14110:		     sym_index);
        -:14111:	    else
        -:14112:	      {
    #####:14113:		saved_sym2 = symtab[sym_index].st_value;
    #####:14114:		saved_sym2 += reloc->r_addend;
        -:14115:	      }
    #####:14116:	    return true;
        -:14117:
    #####:14118:	  case 0x83: /* R_RL78_OPsub.  */
    #####:14119:	    value = saved_sym1 - saved_sym2;
    #####:14120:	    saved_sym2 = saved_sym1 = 0;
    #####:14121:	    return true;
        -:14122:	    break;
        -:14123:
    #####:14124:	  case 0x41: /* R_RL78_ABS32.  */
    #####:14125:	    if (IN_RANGE (start, end, start + reloc->r_offset, 4))
    #####:14126:	      byte_put (start + reloc->r_offset, value, 4);
        -:14127:	    else
    #####:14128:	      error (_("RL78 sym diff reloc contains invalid offset: 0x%lx\n"),
    #####:14129:		     (long) reloc->r_offset);
    #####:14130:	    value = 0;
    #####:14131:	    return true;
        -:14132:
    #####:14133:	  case 0x43: /* R_RL78_ABS16.  */
    #####:14134:	    if (IN_RANGE (start, end, start + reloc->r_offset, 2))
    #####:14135:	      byte_put (start + reloc->r_offset, value, 2);
        -:14136:	    else
    #####:14137:	      error (_("RL78 sym diff reloc contains invalid offset: 0x%lx\n"),
    #####:14138:		     (long) reloc->r_offset);
    #####:14139:	    value = 0;
    #####:14140:	    return true;
        -:14141:
    #####:14142:	  default:
    #####:14143:	    break;
        -:14144:	  }
    #####:14145:	break;
        -:14146:      }
        -:14147:    }
        -:14148:
    #####:14149:  return false;
        -:14150:}
        -:14151:
        -:14152:/* Returns TRUE iff RELOC_TYPE is a 32-bit absolute RELA relocation used in
        -:14153:   DWARF debug sections.  This is a target specific test.  Note - we do not
        -:14154:   go through the whole including-target-headers-multiple-times route, (as
        -:14155:   we have already done with <elf/h8.h>) because this would become very
        -:14156:   messy and even then this function would have to contain target specific
        -:14157:   information (the names of the relocs instead of their numeric values).
        -:14158:   FIXME: This is not the correct way to solve this problem.  The proper way
        -:14159:   is to have target specific reloc sizing and typing functions created by
        -:14160:   the reloc-macros.h header, in the same way that it already creates the
        -:14161:   reloc naming functions.  */
        -:14162:
        -:14163:static bool
    #####:14164:is_32bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14165:{
        -:14166:  /* Please keep this table alpha-sorted for ease of visual lookup.  */
    #####:14167:  switch (filedata->file_header.e_machine)
        -:14168:    {
    #####:14169:    case EM_386:
        -:14170:    case EM_IAMCU:
    #####:14171:      return reloc_type == 1; /* R_386_32.  */
    #####:14172:    case EM_68K:
    #####:14173:      return reloc_type == 1; /* R_68K_32.  */
    #####:14174:    case EM_860:
    #####:14175:      return reloc_type == 1; /* R_860_32.  */
    #####:14176:    case EM_960:
    #####:14177:      return reloc_type == 2; /* R_960_32.  */
    #####:14178:    case EM_AARCH64:
        -:14179:      return (reloc_type == 258
    #####:14180:	      || reloc_type == 1); /* R_AARCH64_ABS32 || R_AARCH64_P32_ABS32 */
    #####:14181:    case EM_BPF:
    #####:14182:      return reloc_type == 11; /* R_BPF_DATA_32 */
    #####:14183:    case EM_ADAPTEVA_EPIPHANY:
    #####:14184:      return reloc_type == 3;
    #####:14185:    case EM_ALPHA:
    #####:14186:      return reloc_type == 1; /* R_ALPHA_REFLONG.  */
    #####:14187:    case EM_ARC:
    #####:14188:      return reloc_type == 1; /* R_ARC_32.  */
    #####:14189:    case EM_ARC_COMPACT:
        -:14190:    case EM_ARC_COMPACT2:
    #####:14191:      return reloc_type == 4; /* R_ARC_32.  */
    #####:14192:    case EM_ARM:
    #####:14193:      return reloc_type == 2; /* R_ARM_ABS32 */
    #####:14194:    case EM_AVR_OLD:
        -:14195:    case EM_AVR:
    #####:14196:      return reloc_type == 1;
    #####:14197:    case EM_BLACKFIN:
    #####:14198:      return reloc_type == 0x12; /* R_byte4_data.  */
    #####:14199:    case EM_CRIS:
    #####:14200:      return reloc_type == 3; /* R_CRIS_32.  */
    #####:14201:    case EM_CR16:
    #####:14202:      return reloc_type == 3; /* R_CR16_NUM32.  */
    #####:14203:    case EM_CRX:
    #####:14204:      return reloc_type == 15; /* R_CRX_NUM32.  */
    #####:14205:    case EM_CSKY:
    #####:14206:      return reloc_type == 1; /* R_CKCORE_ADDR32.  */
    #####:14207:    case EM_CYGNUS_FRV:
    #####:14208:      return reloc_type == 1;
    #####:14209:    case EM_CYGNUS_D10V:
        -:14210:    case EM_D10V:
    #####:14211:      return reloc_type == 6; /* R_D10V_32.  */
    #####:14212:    case EM_CYGNUS_D30V:
        -:14213:    case EM_D30V:
    #####:14214:      return reloc_type == 12; /* R_D30V_32_NORMAL.  */
    #####:14215:    case EM_DLX:
    #####:14216:      return reloc_type == 3; /* R_DLX_RELOC_32.  */
    #####:14217:    case EM_CYGNUS_FR30:
        -:14218:    case EM_FR30:
    #####:14219:      return reloc_type == 3; /* R_FR30_32.  */
    #####:14220:    case EM_FT32:
    #####:14221:      return reloc_type == 1; /* R_FT32_32.  */
    #####:14222:    case EM_H8S:
        -:14223:    case EM_H8_300:
        -:14224:    case EM_H8_300H:
    #####:14225:      return reloc_type == 1; /* R_H8_DIR32.  */
    #####:14226:    case EM_IA_64:
        -:14227:      return (reloc_type == 0x64    /* R_IA64_SECREL32MSB.  */
    #####:14228:	      || reloc_type == 0x65 /* R_IA64_SECREL32LSB.  */
    #####:14229:	      || reloc_type == 0x24 /* R_IA64_DIR32MSB.  */
    #####:14230:	      || reloc_type == 0x25 /* R_IA64_DIR32LSB.  */);
    #####:14231:    case EM_IP2K_OLD:
        -:14232:    case EM_IP2K:
    #####:14233:      return reloc_type == 2; /* R_IP2K_32.  */
    #####:14234:    case EM_IQ2000:
    #####:14235:      return reloc_type == 2; /* R_IQ2000_32.  */
    #####:14236:    case EM_LATTICEMICO32:
    #####:14237:      return reloc_type == 3; /* R_LM32_32.  */
    #####:14238:    case EM_LOONGARCH:
    #####:14239:      return reloc_type == 1; /* R_LARCH_32. */
    #####:14240:    case EM_M32C_OLD:
        -:14241:    case EM_M32C:
    #####:14242:      return reloc_type == 3; /* R_M32C_32.  */
    #####:14243:    case EM_M32R:
    #####:14244:      return reloc_type == 34; /* R_M32R_32_RELA.  */
    #####:14245:    case EM_68HC11:
        -:14246:    case EM_68HC12:
    #####:14247:      return reloc_type == 6; /* R_M68HC11_32.  */
    #####:14248:    case EM_S12Z:
    #####:14249:      return reloc_type == 7 || /* R_S12Z_EXT32 */
        -:14250:	reloc_type == 6;        /* R_S12Z_CW32.  */
    #####:14251:    case EM_MCORE:
    #####:14252:      return reloc_type == 1; /* R_MCORE_ADDR32.  */
    #####:14253:    case EM_CYGNUS_MEP:
    #####:14254:      return reloc_type == 4; /* R_MEP_32.  */
    #####:14255:    case EM_METAG:
    #####:14256:      return reloc_type == 2; /* R_METAG_ADDR32.  */
    #####:14257:    case EM_MICROBLAZE:
    #####:14258:      return reloc_type == 1; /* R_MICROBLAZE_32.  */
    #####:14259:    case EM_MIPS:
    #####:14260:      return reloc_type == 2; /* R_MIPS_32.  */
    #####:14261:    case EM_MMIX:
    #####:14262:      return reloc_type == 4; /* R_MMIX_32.  */
    #####:14263:    case EM_CYGNUS_MN10200:
        -:14264:    case EM_MN10200:
    #####:14265:      return reloc_type == 1; /* R_MN10200_32.  */
    #####:14266:    case EM_CYGNUS_MN10300:
        -:14267:    case EM_MN10300:
    #####:14268:      return reloc_type == 1; /* R_MN10300_32.  */
    #####:14269:    case EM_MOXIE:
    #####:14270:      return reloc_type == 1; /* R_MOXIE_32.  */
    #####:14271:    case EM_MSP430_OLD:
        -:14272:    case EM_MSP430:
    #####:14273:      return reloc_type == 1; /* R_MSP430_32 or R_MSP320_ABS32.  */
    #####:14274:    case EM_MT:
    #####:14275:      return reloc_type == 2; /* R_MT_32.  */
    #####:14276:    case EM_NDS32:
    #####:14277:      return reloc_type == 20; /* R_NDS32_32_RELA.  */
    #####:14278:    case EM_ALTERA_NIOS2:
    #####:14279:      return reloc_type == 12; /* R_NIOS2_BFD_RELOC_32.  */
    #####:14280:    case EM_NIOS32:
    #####:14281:      return reloc_type == 1; /* R_NIOS_32.  */
    #####:14282:    case EM_OR1K:
    #####:14283:      return reloc_type == 1; /* R_OR1K_32.  */
    #####:14284:    case EM_PARISC:
        -:14285:      return (reloc_type == 1 /* R_PARISC_DIR32.  */
    #####:14286:	      || reloc_type == 2 /* R_PARISC_DIR21L.  */
    #####:14287:	      || reloc_type == 41); /* R_PARISC_SECREL32.  */
    #####:14288:    case EM_PJ:
        -:14289:    case EM_PJ_OLD:
    #####:14290:      return reloc_type == 1; /* R_PJ_DATA_DIR32.  */
    #####:14291:    case EM_PPC64:
    #####:14292:      return reloc_type == 1; /* R_PPC64_ADDR32.  */
    #####:14293:    case EM_PPC:
    #####:14294:      return reloc_type == 1; /* R_PPC_ADDR32.  */
    #####:14295:    case EM_TI_PRU:
    #####:14296:      return reloc_type == 11; /* R_PRU_BFD_RELOC_32.  */
    #####:14297:    case EM_RISCV:
    #####:14298:      return reloc_type == 1; /* R_RISCV_32.  */
    #####:14299:    case EM_RL78:
    #####:14300:      return reloc_type == 1; /* R_RL78_DIR32.  */
    #####:14301:    case EM_RX:
    #####:14302:      return reloc_type == 1; /* R_RX_DIR32.  */
    #####:14303:    case EM_S370:
    #####:14304:      return reloc_type == 1; /* R_I370_ADDR31.  */
    #####:14305:    case EM_S390_OLD:
        -:14306:    case EM_S390:
    #####:14307:      return reloc_type == 4; /* R_S390_32.  */
    #####:14308:    case EM_SCORE:
    #####:14309:      return reloc_type == 8; /* R_SCORE_ABS32.  */
    #####:14310:    case EM_SH:
    #####:14311:      return reloc_type == 1; /* R_SH_DIR32.  */
    #####:14312:    case EM_SPARC32PLUS:
        -:14313:    case EM_SPARCV9:
        -:14314:    case EM_SPARC:
        -:14315:      return reloc_type == 3 /* R_SPARC_32.  */
    #####:14316:	|| reloc_type == 23; /* R_SPARC_UA32.  */
    #####:14317:    case EM_SPU:
    #####:14318:      return reloc_type == 6; /* R_SPU_ADDR32 */
    #####:14319:    case EM_TI_C6000:
    #####:14320:      return reloc_type == 1; /* R_C6000_ABS32.  */
    #####:14321:    case EM_TILEGX:
    #####:14322:      return reloc_type == 2; /* R_TILEGX_32.  */
    #####:14323:    case EM_TILEPRO:
    #####:14324:      return reloc_type == 1; /* R_TILEPRO_32.  */
    #####:14325:    case EM_CYGNUS_V850:
        -:14326:    case EM_V850:
    #####:14327:      return reloc_type == 6; /* R_V850_ABS32.  */
    #####:14328:    case EM_V800:
    #####:14329:      return reloc_type == 0x33; /* R_V810_WORD.  */
    #####:14330:    case EM_VAX:
    #####:14331:      return reloc_type == 1; /* R_VAX_32.  */
    #####:14332:    case EM_VISIUM:
    #####:14333:      return reloc_type == 3;  /* R_VISIUM_32. */
    #####:14334:    case EM_WEBASSEMBLY:
    #####:14335:      return reloc_type == 1;  /* R_WASM32_32.  */
    #####:14336:    case EM_X86_64:
        -:14337:    case EM_L1OM:
        -:14338:    case EM_K1OM:
    #####:14339:      return reloc_type == 10; /* R_X86_64_32.  */
    #####:14340:    case EM_XGATE:
    #####:14341:      return reloc_type == 4; /* R_XGATE_32.  */
    #####:14342:    case EM_XSTORMY16:
    #####:14343:      return reloc_type == 1; /* R_XSTROMY16_32.  */
    #####:14344:    case EM_XTENSA_OLD:
        -:14345:    case EM_XTENSA:
    #####:14346:      return reloc_type == 1; /* R_XTENSA_32.  */
    #####:14347:    case EM_Z80:
    #####:14348:      return reloc_type == 6; /* R_Z80_32.  */
    #####:14349:    default:
        -:14350:      {
        -:14351:	static unsigned int prev_warn = 0;
        -:14352:
        -:14353:	/* Avoid repeating the same warning multiple times.  */
    #####:14354:	if (prev_warn != filedata->file_header.e_machine)
    #####:14355:	  error (_("Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n"),
    #####:14356:		 filedata->file_header.e_machine);
    #####:14357:	prev_warn = filedata->file_header.e_machine;
    #####:14358:	return false;
        -:14359:      }
        -:14360:    }
        -:14361:}
        -:14362:
        -:14363:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14364:   a 32-bit pc-relative RELA relocation used in DWARF debug sections.  */
        -:14365:
        -:14366:static bool
    #####:14367:is_32bit_pcrel_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14368:{
    #####:14369:  switch (filedata->file_header.e_machine)
        -:14370:  /* Please keep this table alpha-sorted for ease of visual lookup.  */
        -:14371:    {
    #####:14372:    case EM_386:
        -:14373:    case EM_IAMCU:
    #####:14374:      return reloc_type == 2;  /* R_386_PC32.  */
    #####:14375:    case EM_68K:
    #####:14376:      return reloc_type == 4;  /* R_68K_PC32.  */
    #####:14377:    case EM_AARCH64:
    #####:14378:      return reloc_type == 261; /* R_AARCH64_PREL32 */
    #####:14379:    case EM_ADAPTEVA_EPIPHANY:
    #####:14380:      return reloc_type == 6;
    #####:14381:    case EM_ALPHA:
    #####:14382:      return reloc_type == 10; /* R_ALPHA_SREL32.  */
    #####:14383:    case EM_ARC_COMPACT:
        -:14384:    case EM_ARC_COMPACT2:
    #####:14385:      return reloc_type == 49; /* R_ARC_32_PCREL.  */
    #####:14386:    case EM_ARM:
    #####:14387:      return reloc_type == 3;  /* R_ARM_REL32 */
    #####:14388:    case EM_AVR_OLD:
        -:14389:    case EM_AVR:
    #####:14390:      return reloc_type == 36; /* R_AVR_32_PCREL.  */
    #####:14391:    case EM_MICROBLAZE:
    #####:14392:      return reloc_type == 2;  /* R_MICROBLAZE_32_PCREL.  */
    #####:14393:    case EM_OR1K:
    #####:14394:      return reloc_type == 9; /* R_OR1K_32_PCREL.  */
    #####:14395:    case EM_PARISC:
    #####:14396:      return reloc_type == 9;  /* R_PARISC_PCREL32.  */
    #####:14397:    case EM_PPC:
    #####:14398:      return reloc_type == 26; /* R_PPC_REL32.  */
    #####:14399:    case EM_PPC64:
    #####:14400:      return reloc_type == 26; /* R_PPC64_REL32.  */
    #####:14401:    case EM_RISCV:
    #####:14402:      return reloc_type == 57;	/* R_RISCV_32_PCREL.  */
    #####:14403:    case EM_S390_OLD:
        -:14404:    case EM_S390:
    #####:14405:      return reloc_type == 5;  /* R_390_PC32.  */
    #####:14406:    case EM_SH:
    #####:14407:      return reloc_type == 2;  /* R_SH_REL32.  */
    #####:14408:    case EM_SPARC32PLUS:
        -:14409:    case EM_SPARCV9:
        -:14410:    case EM_SPARC:
    #####:14411:      return reloc_type == 6;  /* R_SPARC_DISP32.  */
    #####:14412:    case EM_SPU:
    #####:14413:      return reloc_type == 13; /* R_SPU_REL32.  */
    #####:14414:    case EM_TILEGX:
    #####:14415:      return reloc_type == 6; /* R_TILEGX_32_PCREL.  */
    #####:14416:    case EM_TILEPRO:
    #####:14417:      return reloc_type == 4; /* R_TILEPRO_32_PCREL.  */
    #####:14418:    case EM_VISIUM:
    #####:14419:      return reloc_type == 6;  /* R_VISIUM_32_PCREL */
    #####:14420:    case EM_X86_64:
        -:14421:    case EM_L1OM:
        -:14422:    case EM_K1OM:
    #####:14423:      return reloc_type == 2;  /* R_X86_64_PC32.  */
    #####:14424:    case EM_VAX:
    #####:14425:      return reloc_type == 4;  /* R_VAX_PCREL32.  */
    #####:14426:    case EM_XTENSA_OLD:
        -:14427:    case EM_XTENSA:
    #####:14428:      return reloc_type == 14; /* R_XTENSA_32_PCREL.  */
    #####:14429:    default:
        -:14430:      /* Do not abort or issue an error message here.  Not all targets use
        -:14431:	 pc-relative 32-bit relocs in their DWARF debug information and we
        -:14432:	 have already tested for target coverage in is_32bit_abs_reloc.  A
        -:14433:	 more helpful warning message will be generated by apply_relocations
        -:14434:	 anyway, so just return.  */
    #####:14435:      return false;
        -:14436:    }
        -:14437:}
        -:14438:
        -:14439:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14440:   a 64-bit absolute RELA relocation used in DWARF debug sections.  */
        -:14441:
        -:14442:static bool
    #####:14443:is_64bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14444:{
    #####:14445:  switch (filedata->file_header.e_machine)
        -:14446:    {
    #####:14447:    case EM_AARCH64:
    #####:14448:      return reloc_type == 257;	/* R_AARCH64_ABS64.  */
    #####:14449:    case EM_ALPHA:
    #####:14450:      return reloc_type == 2; /* R_ALPHA_REFQUAD.  */
    #####:14451:    case EM_IA_64:
        -:14452:      return (reloc_type == 0x26    /* R_IA64_DIR64MSB.  */
    #####:14453:	      || reloc_type == 0x27 /* R_IA64_DIR64LSB.  */);
    #####:14454:    case EM_LOONGARCH:
    #####:14455:      return reloc_type == 2;      /* R_LARCH_64 */
    #####:14456:    case EM_PARISC:
    #####:14457:      return reloc_type == 80; /* R_PARISC_DIR64.  */
    #####:14458:    case EM_PPC64:
    #####:14459:      return reloc_type == 38; /* R_PPC64_ADDR64.  */
    #####:14460:    case EM_RISCV:
    #####:14461:      return reloc_type == 2; /* R_RISCV_64.  */
    #####:14462:    case EM_SPARC32PLUS:
        -:14463:    case EM_SPARCV9:
        -:14464:    case EM_SPARC:
        -:14465:      return reloc_type == 32 /* R_SPARC_64.  */
    #####:14466:	|| reloc_type == 54; /* R_SPARC_UA64.  */
    #####:14467:    case EM_X86_64:
        -:14468:    case EM_L1OM:
        -:14469:    case EM_K1OM:
    #####:14470:      return reloc_type == 1; /* R_X86_64_64.  */
    #####:14471:    case EM_S390_OLD:
        -:14472:    case EM_S390:
    #####:14473:      return reloc_type == 22;	/* R_S390_64.  */
    #####:14474:    case EM_TILEGX:
    #####:14475:      return reloc_type == 1; /* R_TILEGX_64.  */
    #####:14476:    case EM_MIPS:
    #####:14477:      return reloc_type == 18;	/* R_MIPS_64.  */
    #####:14478:    default:
    #####:14479:      return false;
        -:14480:    }
        -:14481:}
        -:14482:
        -:14483:/* Like is_32bit_pcrel_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14484:   a 64-bit pc-relative RELA relocation used in DWARF debug sections.  */
        -:14485:
        -:14486:static bool
    #####:14487:is_64bit_pcrel_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14488:{
    #####:14489:  switch (filedata->file_header.e_machine)
        -:14490:    {
    #####:14491:    case EM_AARCH64:
    #####:14492:      return reloc_type == 260;	/* R_AARCH64_PREL64.  */
    #####:14493:    case EM_ALPHA:
    #####:14494:      return reloc_type == 11; /* R_ALPHA_SREL64.  */
    #####:14495:    case EM_IA_64:
        -:14496:      return (reloc_type == 0x4e    /* R_IA64_PCREL64MSB.  */
    #####:14497:	      || reloc_type == 0x4f /* R_IA64_PCREL64LSB.  */);
    #####:14498:    case EM_PARISC:
    #####:14499:      return reloc_type == 72; /* R_PARISC_PCREL64.  */
    #####:14500:    case EM_PPC64:
    #####:14501:      return reloc_type == 44; /* R_PPC64_REL64.  */
    #####:14502:    case EM_SPARC32PLUS:
        -:14503:    case EM_SPARCV9:
        -:14504:    case EM_SPARC:
    #####:14505:      return reloc_type == 46; /* R_SPARC_DISP64.  */
    #####:14506:    case EM_X86_64:
        -:14507:    case EM_L1OM:
        -:14508:    case EM_K1OM:
    #####:14509:      return reloc_type == 24; /* R_X86_64_PC64.  */
    #####:14510:    case EM_S390_OLD:
        -:14511:    case EM_S390:
    #####:14512:      return reloc_type == 23;	/* R_S390_PC64.  */
    #####:14513:    case EM_TILEGX:
    #####:14514:      return reloc_type == 5;  /* R_TILEGX_64_PCREL.  */
    #####:14515:    default:
    #####:14516:      return false;
        -:14517:    }
        -:14518:}
        -:14519:
        -:14520:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14521:   a 24-bit absolute RELA relocation used in DWARF debug sections.  */
        -:14522:
        -:14523:static bool
    #####:14524:is_24bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14525:{
    #####:14526:  switch (filedata->file_header.e_machine)
        -:14527:    {
    #####:14528:    case EM_CYGNUS_MN10200:
        -:14529:    case EM_MN10200:
    #####:14530:      return reloc_type == 4; /* R_MN10200_24.  */
    #####:14531:    case EM_FT32:
    #####:14532:      return reloc_type == 5; /* R_FT32_20.  */
    #####:14533:    case EM_Z80:
    #####:14534:      return reloc_type == 5; /* R_Z80_24. */
    #####:14535:    default:
    #####:14536:      return false;
        -:14537:    }
        -:14538:}
        -:14539:
        -:14540:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14541:   a 16-bit absolute RELA relocation used in DWARF debug sections.  */
        -:14542:
        -:14543:static bool
    #####:14544:is_16bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14545:{
        -:14546:  /* Please keep this table alpha-sorted for ease of visual lookup.  */
    #####:14547:  switch (filedata->file_header.e_machine)
        -:14548:    {
    #####:14549:    case EM_ARC:
        -:14550:    case EM_ARC_COMPACT:
        -:14551:    case EM_ARC_COMPACT2:
    #####:14552:      return reloc_type == 2; /* R_ARC_16.  */
    #####:14553:    case EM_ADAPTEVA_EPIPHANY:
    #####:14554:      return reloc_type == 5;
    #####:14555:    case EM_AVR_OLD:
        -:14556:    case EM_AVR:
    #####:14557:      return reloc_type == 4; /* R_AVR_16.  */
    #####:14558:    case EM_CYGNUS_D10V:
        -:14559:    case EM_D10V:
    #####:14560:      return reloc_type == 3; /* R_D10V_16.  */
    #####:14561:    case EM_FT32:
    #####:14562:      return reloc_type == 2; /* R_FT32_16.  */
    #####:14563:    case EM_H8S:
        -:14564:    case EM_H8_300:
        -:14565:    case EM_H8_300H:
    #####:14566:      return reloc_type == R_H8_DIR16;
    #####:14567:    case EM_IP2K_OLD:
        -:14568:    case EM_IP2K:
    #####:14569:      return reloc_type == 1; /* R_IP2K_16.  */
    #####:14570:    case EM_M32C_OLD:
        -:14571:    case EM_M32C:
    #####:14572:      return reloc_type == 1; /* R_M32C_16 */
    #####:14573:    case EM_CYGNUS_MN10200:
        -:14574:    case EM_MN10200:
    #####:14575:      return reloc_type == 2; /* R_MN10200_16.  */
    #####:14576:    case EM_CYGNUS_MN10300:
        -:14577:    case EM_MN10300:
    #####:14578:      return reloc_type == 2; /* R_MN10300_16.  */
    #####:14579:    case EM_MSP430:
    #####:14580:      if (uses_msp430x_relocs (filedata))
    #####:14581:	return reloc_type == 2; /* R_MSP430_ABS16.  */
        -:14582:      /* Fall through.  */
        -:14583:    case EM_MSP430_OLD:
    #####:14584:      return reloc_type == 5; /* R_MSP430_16_BYTE.  */
    #####:14585:    case EM_NDS32:
    #####:14586:      return reloc_type == 19; /* R_NDS32_16_RELA.  */
    #####:14587:    case EM_ALTERA_NIOS2:
    #####:14588:      return reloc_type == 13; /* R_NIOS2_BFD_RELOC_16.  */
    #####:14589:    case EM_NIOS32:
    #####:14590:      return reloc_type == 9; /* R_NIOS_16.  */
    #####:14591:    case EM_OR1K:
    #####:14592:      return reloc_type == 2; /* R_OR1K_16.  */
    #####:14593:    case EM_RISCV:
    #####:14594:      return reloc_type == 55; /* R_RISCV_SET16.  */
    #####:14595:    case EM_TI_PRU:
    #####:14596:      return reloc_type == 8; /* R_PRU_BFD_RELOC_16.  */
    #####:14597:    case EM_TI_C6000:
    #####:14598:      return reloc_type == 2; /* R_C6000_ABS16.  */
    #####:14599:    case EM_VISIUM:
    #####:14600:      return reloc_type == 2; /* R_VISIUM_16. */
    #####:14601:    case EM_XGATE:
    #####:14602:      return reloc_type == 3; /* R_XGATE_16.  */
    #####:14603:    case EM_Z80:
    #####:14604:      return reloc_type == 4; /* R_Z80_16.  */
    #####:14605:    default:
    #####:14606:      return false;
        -:14607:    }
        -:14608:}
        -:14609:
        -:14610:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14611:   a 8-bit absolute RELA relocation used in DWARF debug sections.  */
        -:14612:
        -:14613:static bool
    #####:14614:is_8bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14615:{
    #####:14616:  switch (filedata->file_header.e_machine)
        -:14617:    {
    #####:14618:    case EM_RISCV:
    #####:14619:      return reloc_type == 54; /* R_RISCV_SET8.  */
    #####:14620:    case EM_Z80:
    #####:14621:      return reloc_type == 1;  /* R_Z80_8.  */
    #####:14622:    default:
    #####:14623:      return false;
        -:14624:    }
        -:14625:}
        -:14626:
        -:14627:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14628:   a 6-bit absolute RELA relocation used in DWARF debug sections.  */
        -:14629:
        -:14630:static bool
    #####:14631:is_6bit_abs_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14632:{
    #####:14633:  switch (filedata->file_header.e_machine)
        -:14634:    {
    #####:14635:    case EM_RISCV:
    #####:14636:      return reloc_type == 53; /* R_RISCV_SET6.  */
    #####:14637:    default:
    #####:14638:      return false;
        -:14639:    }
        -:14640:}
        -:14641:
        -:14642:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14643:   a 32-bit inplace add RELA relocation used in DWARF debug sections.  */
        -:14644:
        -:14645:static bool
    #####:14646:is_32bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14647:{
        -:14648:  /* Please keep this table alpha-sorted for ease of visual lookup.  */
    #####:14649:  switch (filedata->file_header.e_machine)
        -:14650:    {
    #####:14651:    case EM_RISCV:
    #####:14652:      return reloc_type == 35; /* R_RISCV_ADD32.  */
    #####:14653:    default:
    #####:14654:      return false;
        -:14655:    }
        -:14656:}
        -:14657:
        -:14658:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14659:   a 32-bit inplace sub RELA relocation used in DWARF debug sections.  */
        -:14660:
        -:14661:static bool
    #####:14662:is_32bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14663:{
        -:14664:  /* Please keep this table alpha-sorted for ease of visual lookup.  */
    #####:14665:  switch (filedata->file_header.e_machine)
        -:14666:    {
    #####:14667:    case EM_RISCV:
    #####:14668:      return reloc_type == 39; /* R_RISCV_SUB32.  */
    #####:14669:    default:
    #####:14670:      return false;
        -:14671:    }
        -:14672:}
        -:14673:
        -:14674:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14675:   a 64-bit inplace add RELA relocation used in DWARF debug sections.  */
        -:14676:
        -:14677:static bool
    #####:14678:is_64bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14679:{
        -:14680:  /* Please keep this table alpha-sorted for ease of visual lookup.  */
    #####:14681:  switch (filedata->file_header.e_machine)
        -:14682:    {
    #####:14683:    case EM_RISCV:
    #####:14684:      return reloc_type == 36; /* R_RISCV_ADD64.  */
    #####:14685:    default:
    #####:14686:      return false;
        -:14687:    }
        -:14688:}
        -:14689:
        -:14690:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14691:   a 64-bit inplace sub RELA relocation used in DWARF debug sections.  */
        -:14692:
        -:14693:static bool
    #####:14694:is_64bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14695:{
        -:14696:  /* Please keep this table alpha-sorted for ease of visual lookup.  */
    #####:14697:  switch (filedata->file_header.e_machine)
        -:14698:    {
    #####:14699:    case EM_RISCV:
    #####:14700:      return reloc_type == 40; /* R_RISCV_SUB64.  */
    #####:14701:    default:
    #####:14702:      return false;
        -:14703:    }
        -:14704:}
        -:14705:
        -:14706:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14707:   a 16-bit inplace add RELA relocation used in DWARF debug sections.  */
        -:14708:
        -:14709:static bool
    #####:14710:is_16bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14711:{
        -:14712:  /* Please keep this table alpha-sorted for ease of visual lookup.  */
    #####:14713:  switch (filedata->file_header.e_machine)
        -:14714:    {
    #####:14715:    case EM_RISCV:
    #####:14716:      return reloc_type == 34; /* R_RISCV_ADD16.  */
    #####:14717:    default:
    #####:14718:      return false;
        -:14719:    }
        -:14720:}
        -:14721:
        -:14722:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14723:   a 16-bit inplace sub RELA relocation used in DWARF debug sections.  */
        -:14724:
        -:14725:static bool
    #####:14726:is_16bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14727:{
        -:14728:  /* Please keep this table alpha-sorted for ease of visual lookup.  */
    #####:14729:  switch (filedata->file_header.e_machine)
        -:14730:    {
    #####:14731:    case EM_RISCV:
    #####:14732:      return reloc_type == 38; /* R_RISCV_SUB16.  */
    #####:14733:    default:
    #####:14734:      return false;
        -:14735:    }
        -:14736:}
        -:14737:
        -:14738:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14739:   a 8-bit inplace add RELA relocation used in DWARF debug sections.  */
        -:14740:
        -:14741:static bool
    #####:14742:is_8bit_inplace_add_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14743:{
        -:14744:  /* Please keep this table alpha-sorted for ease of visual lookup.  */
    #####:14745:  switch (filedata->file_header.e_machine)
        -:14746:    {
    #####:14747:    case EM_RISCV:
    #####:14748:      return reloc_type == 33; /* R_RISCV_ADD8.  */
    #####:14749:    default:
    #####:14750:      return false;
        -:14751:    }
        -:14752:}
        -:14753:
        -:14754:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14755:   a 8-bit inplace sub RELA relocation used in DWARF debug sections.  */
        -:14756:
        -:14757:static bool
    #####:14758:is_8bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14759:{
        -:14760:  /* Please keep this table alpha-sorted for ease of visual lookup.  */
    #####:14761:  switch (filedata->file_header.e_machine)
        -:14762:    {
    #####:14763:    case EM_RISCV:
    #####:14764:      return reloc_type == 37; /* R_RISCV_SUB8.  */
    #####:14765:    default:
    #####:14766:      return false;
        -:14767:    }
        -:14768:}
        -:14769:
        -:14770:/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
        -:14771:   a 6-bit inplace sub RELA relocation used in DWARF debug sections.  */
        -:14772:
        -:14773:static bool
    #####:14774:is_6bit_inplace_sub_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14775:{
    #####:14776:  switch (filedata->file_header.e_machine)
        -:14777:    {
    #####:14778:    case EM_RISCV:
    #####:14779:      return reloc_type == 52; /* R_RISCV_SUB6.  */
    #####:14780:    default:
    #####:14781:      return false;
        -:14782:    }
        -:14783:}
        -:14784:
        -:14785:/* Returns TRUE iff RELOC_TYPE is a NONE relocation used for discarded
        -:14786:   relocation entries (possibly formerly used for SHT_GROUP sections).  */
        -:14787:
        -:14788:static bool
    #####:14789:is_none_reloc (Filedata * filedata, unsigned int reloc_type)
        -:14790:{
    #####:14791:  switch (filedata->file_header.e_machine)
        -:14792:    {
    #####:14793:    case EM_386:     /* R_386_NONE.  */
        -:14794:    case EM_68K:     /* R_68K_NONE.  */
        -:14795:    case EM_ADAPTEVA_EPIPHANY:
        -:14796:    case EM_ALPHA:   /* R_ALPHA_NONE.  */
        -:14797:    case EM_ALTERA_NIOS2: /* R_NIOS2_NONE.  */
        -:14798:    case EM_ARC:     /* R_ARC_NONE.  */
        -:14799:    case EM_ARC_COMPACT2: /* R_ARC_NONE.  */
        -:14800:    case EM_ARC_COMPACT: /* R_ARC_NONE.  */
        -:14801:    case EM_ARM:     /* R_ARM_NONE.  */
        -:14802:    case EM_CRIS:    /* R_CRIS_NONE.  */
        -:14803:    case EM_FT32:    /* R_FT32_NONE.  */
        -:14804:    case EM_IA_64:   /* R_IA64_NONE.  */
        -:14805:    case EM_K1OM:    /* R_X86_64_NONE.  */
        -:14806:    case EM_L1OM:    /* R_X86_64_NONE.  */
        -:14807:    case EM_M32R:    /* R_M32R_NONE.  */
        -:14808:    case EM_MIPS:    /* R_MIPS_NONE.  */
        -:14809:    case EM_MN10300: /* R_MN10300_NONE.  */
        -:14810:    case EM_MOXIE:   /* R_MOXIE_NONE.  */
        -:14811:    case EM_NIOS32:  /* R_NIOS_NONE.  */
        -:14812:    case EM_OR1K:    /* R_OR1K_NONE. */
        -:14813:    case EM_PARISC:  /* R_PARISC_NONE.  */
        -:14814:    case EM_PPC64:   /* R_PPC64_NONE.  */
        -:14815:    case EM_PPC:     /* R_PPC_NONE.  */
        -:14816:    case EM_RISCV:   /* R_RISCV_NONE.  */
        -:14817:    case EM_S390:    /* R_390_NONE.  */
        -:14818:    case EM_S390_OLD:
        -:14819:    case EM_SH:      /* R_SH_NONE.  */
        -:14820:    case EM_SPARC32PLUS:
        -:14821:    case EM_SPARC:   /* R_SPARC_NONE.  */
        -:14822:    case EM_SPARCV9:
        -:14823:    case EM_TILEGX:  /* R_TILEGX_NONE.  */
        -:14824:    case EM_TILEPRO: /* R_TILEPRO_NONE.  */
        -:14825:    case EM_TI_C6000:/* R_C6000_NONE.  */
        -:14826:    case EM_X86_64:  /* R_X86_64_NONE.  */
        -:14827:    case EM_Z80:     /* R_Z80_NONE. */
        -:14828:    case EM_WEBASSEMBLY: /* R_WASM32_NONE.  */
    #####:14829:      return reloc_type == 0;
        -:14830:
    #####:14831:    case EM_AARCH64:
    #####:14832:      return reloc_type == 0 || reloc_type == 256;
    #####:14833:    case EM_AVR_OLD:
        -:14834:    case EM_AVR:
        -:14835:      return (reloc_type == 0 /* R_AVR_NONE.  */
    #####:14836:	      || reloc_type == 30 /* R_AVR_DIFF8.  */
    #####:14837:	      || reloc_type == 31 /* R_AVR_DIFF16.  */
    #####:14838:	      || reloc_type == 32 /* R_AVR_DIFF32.  */);
    #####:14839:    case EM_METAG:
    #####:14840:      return reloc_type == 3; /* R_METAG_NONE.  */
    #####:14841:    case EM_NDS32:
        -:14842:      return (reloc_type == 0       /* R_NDS32_NONE.  */
    #####:14843:	      || reloc_type == 205  /* R_NDS32_DIFF8.  */
    #####:14844:	      || reloc_type == 206  /* R_NDS32_DIFF16.  */
    #####:14845:	      || reloc_type == 207  /* R_NDS32_DIFF32.  */
    #####:14846:	      || reloc_type == 208  /* R_NDS32_DIFF_ULEB128.  */);
    #####:14847:    case EM_TI_PRU:
        -:14848:      return (reloc_type == 0       /* R_PRU_NONE.  */
    #####:14849:	      || reloc_type == 65   /* R_PRU_DIFF8.  */
    #####:14850:	      || reloc_type == 66   /* R_PRU_DIFF16.  */
    #####:14851:	      || reloc_type == 67   /* R_PRU_DIFF32.  */);
    #####:14852:    case EM_XTENSA_OLD:
        -:14853:    case EM_XTENSA:
        -:14854:      return (reloc_type == 0      /* R_XTENSA_NONE.  */
    #####:14855:	      || reloc_type == 17  /* R_XTENSA_DIFF8.  */
    #####:14856:	      || reloc_type == 18  /* R_XTENSA_DIFF16.  */
    #####:14857:	      || reloc_type == 19  /* R_XTENSA_DIFF32.  */
    #####:14858:	      || reloc_type == 57  /* R_XTENSA_PDIFF8.  */
    #####:14859:	      || reloc_type == 58  /* R_XTENSA_PDIFF16.  */
    #####:14860:	      || reloc_type == 59  /* R_XTENSA_PDIFF32.  */
    #####:14861:	      || reloc_type == 60  /* R_XTENSA_NDIFF8.  */
    #####:14862:	      || reloc_type == 61  /* R_XTENSA_NDIFF16.  */
    #####:14863:	      || reloc_type == 62  /* R_XTENSA_NDIFF32.  */);
        -:14864:    }
    #####:14865:  return false;
        -:14866:}
        -:14867:
        -:14868:/* Returns TRUE if there is a relocation against
        -:14869:   section NAME at OFFSET bytes.  */
        -:14870:
        -:14871:bool
    #####:14872:reloc_at (struct dwarf_section * dsec, dwarf_vma offset)
        -:14873:{
        -:14874:  Elf_Internal_Rela * relocs;
        -:14875:  Elf_Internal_Rela * rp;
        -:14876:
    #####:14877:  if (dsec == NULL || dsec->reloc_info == NULL)
    #####:14878:    return false;
        -:14879:
    #####:14880:  relocs = (Elf_Internal_Rela *) dsec->reloc_info;
        -:14881:
    #####:14882:  for (rp = relocs; rp < relocs + dsec->num_relocs; ++rp)
    #####:14883:    if (rp->r_offset == offset)
    #####:14884:      return true;
        -:14885:
    #####:14886:   return false;
        -:14887:}
        -:14888:
        -:14889:/* Apply relocations to a section.
        -:14890:   Returns TRUE upon success, FALSE otherwise.
        -:14891:   If RELOCS_RETURN is non-NULL then it is set to point to the loaded relocs.
        -:14892:   It is then the caller's responsibility to free them.  NUM_RELOCS_RETURN
        -:14893:   will be set to the number of relocs loaded.
        -:14894:
        -:14895:   Note: So far support has been added only for those relocations
        -:14896:   which can be found in debug sections. FIXME: Add support for
        -:14897:   more relocations ?  */
        -:14898:
        -:14899:static bool
       16:14900:apply_relocations (Filedata *                 filedata,
        -:14901:		   const Elf_Internal_Shdr *  section,
        -:14902:		   unsigned char *            start,
        -:14903:		   bfd_size_type              size,
        -:14904:		   void **                    relocs_return,
        -:14905:		   unsigned long *            num_relocs_return)
        -:14906:{
        -:14907:  Elf_Internal_Shdr * relsec;
       16:14908:  unsigned char * end = start + size;
        -:14909:
       16:14910:  if (relocs_return != NULL)
        -:14911:    {
    #####:14912:      * (Elf_Internal_Rela **) relocs_return = NULL;
    #####:14913:      * num_relocs_return = 0;
        -:14914:    }
        -:14915:
       16:14916:  if (filedata->file_header.e_type != ET_REL)
        -:14917:    /* No relocs to apply.  */
       15:14918:    return true;
        -:14919:
        -:14920:  /* Find the reloc section associated with the section.  */
        1:14921:  for (relsec = filedata->section_headers;
        5:14922:       relsec < filedata->section_headers + filedata->file_header.e_shnum;
        4:14923:       ++relsec)
        -:14924:    {
        -:14925:      bool is_rela;
        -:14926:      unsigned long num_relocs;
        -:14927:      Elf_Internal_Rela * relocs;
        -:14928:      Elf_Internal_Rela * rp;
        -:14929:      Elf_Internal_Shdr * symsec;
        -:14930:      Elf_Internal_Sym * symtab;
        -:14931:      unsigned long num_syms;
        -:14932:      Elf_Internal_Sym * sym;
        -:14933:
        4:14934:      if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
    #####:14935:	  || relsec->sh_info >= filedata->file_header.e_shnum
    #####:14936:	  || filedata->section_headers + relsec->sh_info != section
    #####:14937:	  || relsec->sh_size == 0
    #####:14938:	  || relsec->sh_link >= filedata->file_header.e_shnum)
        4:14939:	continue;
        -:14940:
    #####:14941:      symsec = filedata->section_headers + relsec->sh_link;
    #####:14942:      if (symsec->sh_type != SHT_SYMTAB
    #####:14943:	  && symsec->sh_type != SHT_DYNSYM)
    #####:14944:	return false;
        -:14945:
    #####:14946:      is_rela = relsec->sh_type == SHT_RELA;
        -:14947:
    #####:14948:      if (is_rela)
        -:14949:	{
    #####:14950:	  if (!slurp_rela_relocs (filedata, relsec->sh_offset,
        -:14951:                                  relsec->sh_size, & relocs, & num_relocs))
    #####:14952:	    return false;
        -:14953:	}
        -:14954:      else
        -:14955:	{
    #####:14956:	  if (!slurp_rel_relocs (filedata, relsec->sh_offset,
        -:14957:                                 relsec->sh_size, & relocs, & num_relocs))
    #####:14958:	    return false;
        -:14959:	}
        -:14960:
        -:14961:      /* SH uses RELA but uses in place value instead of the addend field.  */
    #####:14962:      if (filedata->file_header.e_machine == EM_SH)
    #####:14963:	is_rela = false;
        -:14964:
    #####:14965:      symtab = get_elf_symbols (filedata, symsec, & num_syms);
        -:14966:
    #####:14967:      for (rp = relocs; rp < relocs + num_relocs; ++rp)
        -:14968:	{
        -:14969:	  bfd_vma addend;
        -:14970:	  unsigned int reloc_type;
        -:14971:	  unsigned int reloc_size;
    #####:14972:	  bool reloc_inplace = false;
    #####:14973:	  bool reloc_subtract = false;
        -:14974:	  unsigned char *rloc;
        -:14975:	  unsigned long sym_index;
        -:14976:
    #####:14977:	  reloc_type = get_reloc_type (filedata, rp->r_info);
        -:14978:
    #####:14979:	  if (target_specific_reloc_handling (filedata, rp, start, end, symtab, num_syms))
    #####:14980:	    continue;
    #####:14981:	  else if (is_none_reloc (filedata, reloc_type))
    #####:14982:	    continue;
    #####:14983:	  else if (is_32bit_abs_reloc (filedata, reloc_type)
    #####:14984:		   || is_32bit_pcrel_reloc (filedata, reloc_type))
    #####:14985:	    reloc_size = 4;
    #####:14986:	  else if (is_64bit_abs_reloc (filedata, reloc_type)
    #####:14987:		   || is_64bit_pcrel_reloc (filedata, reloc_type))
    #####:14988:	    reloc_size = 8;
    #####:14989:	  else if (is_24bit_abs_reloc (filedata, reloc_type))
    #####:14990:	    reloc_size = 3;
    #####:14991:	  else if (is_16bit_abs_reloc (filedata, reloc_type))
    #####:14992:	    reloc_size = 2;
    #####:14993:	  else if (is_8bit_abs_reloc (filedata, reloc_type)
    #####:14994:		   || is_6bit_abs_reloc (filedata, reloc_type))
    #####:14995:	    reloc_size = 1;
    #####:14996:	  else if ((reloc_subtract = is_32bit_inplace_sub_reloc (filedata,
        -:14997:								 reloc_type))
    #####:14998:		   || is_32bit_inplace_add_reloc (filedata, reloc_type))
        -:14999:	    {
    #####:15000:	      reloc_size = 4;
    #####:15001:	      reloc_inplace = true;
        -:15002:	    }
    #####:15003:	  else if ((reloc_subtract = is_64bit_inplace_sub_reloc (filedata,
        -:15004:								 reloc_type))
    #####:15005:		   || is_64bit_inplace_add_reloc (filedata, reloc_type))
        -:15006:	    {
    #####:15007:	      reloc_size = 8;
    #####:15008:	      reloc_inplace = true;
        -:15009:	    }
    #####:15010:	  else if ((reloc_subtract = is_16bit_inplace_sub_reloc (filedata,
        -:15011:								 reloc_type))
    #####:15012:		   || is_16bit_inplace_add_reloc (filedata, reloc_type))
        -:15013:	    {
    #####:15014:	      reloc_size = 2;
    #####:15015:	      reloc_inplace = true;
        -:15016:	    }
    #####:15017:	  else if ((reloc_subtract = is_8bit_inplace_sub_reloc (filedata,
        -:15018:								reloc_type))
    #####:15019:		   || is_8bit_inplace_add_reloc (filedata, reloc_type))
        -:15020:	    {
    #####:15021:	      reloc_size = 1;
    #####:15022:	      reloc_inplace = true;
        -:15023:	    }
    #####:15024:	  else if ((reloc_subtract = is_6bit_inplace_sub_reloc (filedata,
        -:15025:								reloc_type)))
        -:15026:	    {
    #####:15027:	      reloc_size = 1;
    #####:15028:	      reloc_inplace = true;
        -:15029:	    }
        -:15030:	  else
        -:15031:	    {
        -:15032:	      static unsigned int prev_reloc = 0;
        -:15033:
    #####:15034:	      if (reloc_type != prev_reloc)
    #####:15035:		warn (_("unable to apply unsupported reloc type %d to section %s\n"),
        -:15036:		      reloc_type, printable_section_name (filedata, section));
    #####:15037:	      prev_reloc = reloc_type;
    #####:15038:	      continue;
        -:15039:	    }
        -:15040:
    #####:15041:	  rloc = start + rp->r_offset;
    #####:15042:	  if (!IN_RANGE (start, end, rloc, reloc_size))
        -:15043:	    {
    #####:15044:	      warn (_("skipping invalid relocation offset 0x%lx in section %s\n"),
    #####:15045:		    (unsigned long) rp->r_offset,
        -:15046:		    printable_section_name (filedata, section));
    #####:15047:	      continue;
        -:15048:	    }
        -:15049:
    #####:15050:	  sym_index = (unsigned long) get_reloc_symindex (rp->r_info);
    #####:15051:	  if (sym_index >= num_syms)
        -:15052:	    {
    #####:15053:	      warn (_("skipping invalid relocation symbol index 0x%lx in section %s\n"),
        -:15054:		    sym_index, printable_section_name (filedata, section));
    #####:15055:	      continue;
        -:15056:	    }
    #####:15057:	  sym = symtab + sym_index;
        -:15058:
        -:15059:	  /* If the reloc has a symbol associated with it,
        -:15060:	     make sure that it is of an appropriate type.
        -:15061:
        -:15062:	     Relocations against symbols without type can happen.
        -:15063:	     Gcc -feliminate-dwarf2-dups may generate symbols
        -:15064:	     without type for debug info.
        -:15065:
        -:15066:	     Icc generates relocations against function symbols
        -:15067:	     instead of local labels.
        -:15068:
        -:15069:	     Relocations against object symbols can happen, eg when
        -:15070:	     referencing a global array.  For an example of this see
        -:15071:	     the _clz.o binary in libgcc.a.  */
    #####:15072:	  if (sym != symtab
    #####:15073:	      && ELF_ST_TYPE (sym->st_info) != STT_COMMON
    #####:15074:	      && ELF_ST_TYPE (sym->st_info) > STT_SECTION)
        -:15075:	    {
    #####:15076:	      warn (_("skipping unexpected symbol type %s in section %s relocation %ld\n"),
    #####:15077:		    get_symbol_type (filedata, ELF_ST_TYPE (sym->st_info)),
        -:15078:		    printable_section_name (filedata, relsec),
    #####:15079:		    (long int)(rp - relocs));
    #####:15080:	      continue;
        -:15081:	    }
        -:15082:
    #####:15083:	  addend = 0;
    #####:15084:	  if (is_rela)
    #####:15085:	    addend += rp->r_addend;
        -:15086:	  /* R_XTENSA_32, R_PJ_DATA_DIR32 and R_D30V_32_NORMAL are
        -:15087:	     partial_inplace.  */
    #####:15088:	  if (!is_rela
    #####:15089:	      || (filedata->file_header.e_machine == EM_XTENSA
    #####:15090:		  && reloc_type == 1)
    #####:15091:	      || ((filedata->file_header.e_machine == EM_PJ
    #####:15092:		   || filedata->file_header.e_machine == EM_PJ_OLD)
    #####:15093:		  && reloc_type == 1)
    #####:15094:	      || ((filedata->file_header.e_machine == EM_D30V
    #####:15095:		   || filedata->file_header.e_machine == EM_CYGNUS_D30V)
    #####:15096:		  && reloc_type == 12)
    #####:15097:	      || reloc_inplace)
        -:15098:	    {
    #####:15099:	      if (is_6bit_inplace_sub_reloc (filedata, reloc_type))
    #####:15100:		addend += byte_get (rloc, reloc_size) & 0x3f;
        -:15101:	      else
    #####:15102:		addend += byte_get (rloc, reloc_size);
        -:15103:	    }
        -:15104:
    #####:15105:	  if (is_32bit_pcrel_reloc (filedata, reloc_type)
    #####:15106:	      || is_64bit_pcrel_reloc (filedata, reloc_type))
        -:15107:	    {
        -:15108:	      /* On HPPA, all pc-relative relocations are biased by 8.  */
    #####:15109:	      if (filedata->file_header.e_machine == EM_PARISC)
    #####:15110:		addend -= 8;
    #####:15111:	      byte_put (rloc, (addend + sym->st_value) - rp->r_offset,
        -:15112:		        reloc_size);
        -:15113:	    }
    #####:15114:	  else if (is_6bit_abs_reloc (filedata, reloc_type)
    #####:15115:		   || is_6bit_inplace_sub_reloc (filedata, reloc_type))
        -:15116:	    {
    #####:15117:	      if (reloc_subtract)
    #####:15118:		addend -= sym->st_value;
        -:15119:	      else
    #####:15120:		addend += sym->st_value;
    #####:15121:	      addend = (addend & 0x3f) | (byte_get (rloc, reloc_size) & 0xc0);
    #####:15122:	      byte_put (rloc, addend, reloc_size);
        -:15123:	    }
    #####:15124:	  else if (reloc_subtract)
    #####:15125:	    byte_put (rloc, addend - sym->st_value, reloc_size);
        -:15126:	  else
    #####:15127:	    byte_put (rloc, addend + sym->st_value, reloc_size);
        -:15128:	}
        -:15129:
    #####:15130:      free (symtab);
        -:15131:      /* Let the target specific reloc processing code know that
        -:15132:	 we have finished with these relocs.  */
    #####:15133:      target_specific_reloc_handling (filedata, NULL, NULL, NULL, NULL, 0);
        -:15134:
    #####:15135:      if (relocs_return)
        -:15136:	{
    #####:15137:	  * (Elf_Internal_Rela **) relocs_return = relocs;
    #####:15138:	  * num_relocs_return = num_relocs;
        -:15139:	}
        -:15140:      else
    #####:15141:	free (relocs);
        -:15142:
    #####:15143:      break;
        -:15144:    }
        -:15145:
        1:15146:  return true;
        -:15147:}
        -:15148:
        -:15149:#ifdef SUPPORT_DISASSEMBLY
        -:15150:static bool
        -:15151:disassemble_section (Elf_Internal_Shdr * section, Filedata * filedata)
        -:15152:{
        -:15153:  printf (_("\nAssembly dump of section %s\n"), printable_section_name (filedata, section));
        -:15154:
        -:15155:  /* FIXME: XXX -- to be done --- XXX */
        -:15156:
        -:15157:  return true;
        -:15158:}
        -:15159:#endif
        -:15160:
        -:15161:/* Reads in the contents of SECTION from FILE, returning a pointer
        -:15162:   to a malloc'ed buffer or NULL if something went wrong.  */
        -:15163:
        -:15164:static char *
       17:15165:get_section_contents (Elf_Internal_Shdr * section, Filedata * filedata)
        -:15166:{
       17:15167:  bfd_size_type num_bytes = section->sh_size;
        -:15168:
       17:15169:  if (num_bytes == 0 || section->sh_type == SHT_NOBITS)
        -:15170:    {
    #####:15171:      printf (_("Section '%s' has no data to dump.\n"),
        -:15172:	      printable_section_name (filedata, section));
    #####:15173:      return NULL;
        -:15174:    }
        -:15175:
       17:15176:  return  (char *) get_data (NULL, filedata, section->sh_offset, 1, num_bytes,
       17:15177:                             _("section contents"));
        -:15178:}
        -:15179:
        -:15180:/* Uncompresses a section that was compressed using zlib, in place.  */
        -:15181:
        -:15182:static bool
    #####:15183:uncompress_section_contents (unsigned char **   buffer,
        -:15184:			     dwarf_size_type    uncompressed_size,
        -:15185:			     dwarf_size_type *  size)
        -:15186:{
    #####:15187:  dwarf_size_type compressed_size = *size;
    #####:15188:  unsigned char * compressed_buffer = *buffer;
        -:15189:  unsigned char * uncompressed_buffer;
        -:15190:  z_stream strm;
        -:15191:  int rc;
        -:15192:
        -:15193:  /* It is possible the section consists of several compressed
        -:15194:     buffers concatenated together, so we uncompress in a loop.  */
        -:15195:  /* PR 18313: The state field in the z_stream structure is supposed
        -:15196:     to be invisible to the user (ie us), but some compilers will
        -:15197:     still complain about it being used without initialisation.  So
        -:15198:     we first zero the entire z_stream structure and then set the fields
        -:15199:     that we need.  */
    #####:15200:  memset (& strm, 0, sizeof strm);
    #####:15201:  strm.avail_in = compressed_size;
    #####:15202:  strm.next_in = (Bytef *) compressed_buffer;
    #####:15203:  strm.avail_out = uncompressed_size;
    #####:15204:  uncompressed_buffer = (unsigned char *) xmalloc (uncompressed_size);
        -:15205:
    #####:15206:  rc = inflateInit (& strm);
    #####:15207:  while (strm.avail_in > 0)
        -:15208:    {
    #####:15209:      if (rc != Z_OK)
    #####:15210:        break;
    #####:15211:      strm.next_out = ((Bytef *) uncompressed_buffer
    #####:15212:                       + (uncompressed_size - strm.avail_out));
    #####:15213:      rc = inflate (&strm, Z_FINISH);
    #####:15214:      if (rc != Z_STREAM_END)
    #####:15215:        break;
    #####:15216:      rc = inflateReset (& strm);
        -:15217:    }
    #####:15218:  if (inflateEnd (& strm) != Z_OK
    #####:15219:      || rc != Z_OK
    #####:15220:      || strm.avail_out != 0)
    #####:15221:    goto fail;
        -:15222:
    #####:15223:  *buffer = uncompressed_buffer;
    #####:15224:  *size = uncompressed_size;
    #####:15225:  return true;
        -:15226:
    #####:15227: fail:
    #####:15228:  free (uncompressed_buffer);
        -:15229:  /* Indicate decompression failure.  */
    #####:15230:  *buffer = NULL;
    #####:15231:  return false;
        -:15232:}
        -:15233:
        -:15234:static bool
    #####:15235:dump_section_as_strings (Elf_Internal_Shdr * section, Filedata * filedata)
        -:15236:{
        -:15237:  Elf_Internal_Shdr *relsec;
        -:15238:  bfd_size_type num_bytes;
        -:15239:  unsigned char *data;
        -:15240:  unsigned char *end;
        -:15241:  unsigned char *real_start;
        -:15242:  unsigned char *start;
        -:15243:  bool some_strings_shown;
        -:15244:
    #####:15245:  real_start = start = (unsigned char *) get_section_contents (section, filedata);
    #####:15246:  if (start == NULL)
        -:15247:    /* PR 21820: Do not fail if the section was empty.  */
    #####:15248:    return section->sh_size == 0 || section->sh_type == SHT_NOBITS;
        -:15249:
    #####:15250:  num_bytes = section->sh_size;
        -:15251:
    #####:15252:  if (filedata->is_separate)
    #####:15253:    printf (_("\nString dump of section '%s' in linked file %s:\n"),
        -:15254:	    printable_section_name (filedata, section),
        -:15255:	    filedata->file_name);
        -:15256:  else
    #####:15257:    printf (_("\nString dump of section '%s':\n"),
        -:15258:	    printable_section_name (filedata, section));
        -:15259:
    #####:15260:  if (decompress_dumps)
        -:15261:    {
    #####:15262:      dwarf_size_type new_size = num_bytes;
    #####:15263:      dwarf_size_type uncompressed_size = 0;
        -:15264:
    #####:15265:      if ((section->sh_flags & SHF_COMPRESSED) != 0)
        -:15266:	{
        -:15267:	  Elf_Internal_Chdr chdr;
        -:15268:	  unsigned int compression_header_size
    #####:15269:	    = get_compression_header (& chdr, (unsigned char *) start,
        -:15270:				      num_bytes);
    #####:15271:	  if (compression_header_size == 0)
        -:15272:	    /* An error message will have already been generated
        -:15273:	       by get_compression_header.  */
    #####:15274:	    goto error_out;
        -:15275:
    #####:15276:	  if (chdr.ch_type != ELFCOMPRESS_ZLIB)
        -:15277:	    {
    #####:15278:	      warn (_("section '%s' has unsupported compress type: %d\n"),
        -:15279:		    printable_section_name (filedata, section), chdr.ch_type);
    #####:15280:	      goto error_out;
        -:15281:	    }
    #####:15282:	  uncompressed_size = chdr.ch_size;
    #####:15283:	  start += compression_header_size;
    #####:15284:	  new_size -= compression_header_size;
        -:15285:	}
    #####:15286:      else if (new_size > 12 && streq ((char *) start, "ZLIB"))
        -:15287:	{
        -:15288:	  /* Read the zlib header.  In this case, it should be "ZLIB"
        -:15289:	     followed by the uncompressed section size, 8 bytes in
        -:15290:	     big-endian order.  */
    #####:15291:	  uncompressed_size = start[4]; uncompressed_size <<= 8;
    #####:15292:	  uncompressed_size += start[5]; uncompressed_size <<= 8;
    #####:15293:	  uncompressed_size += start[6]; uncompressed_size <<= 8;
    #####:15294:	  uncompressed_size += start[7]; uncompressed_size <<= 8;
    #####:15295:	  uncompressed_size += start[8]; uncompressed_size <<= 8;
    #####:15296:	  uncompressed_size += start[9]; uncompressed_size <<= 8;
    #####:15297:	  uncompressed_size += start[10]; uncompressed_size <<= 8;
    #####:15298:	  uncompressed_size += start[11];
    #####:15299:	  start += 12;
    #####:15300:	  new_size -= 12;
        -:15301:	}
        -:15302:
    #####:15303:      if (uncompressed_size)
        -:15304:	{
    #####:15305:	  if (uncompress_section_contents (& start,
        -:15306:					   uncompressed_size, & new_size))
    #####:15307:	    num_bytes = new_size;
        -:15308:	  else
        -:15309:	    {
    #####:15310:	      error (_("Unable to decompress section %s\n"),
        -:15311:		     printable_section_name (filedata, section));
    #####:15312:	      goto error_out;
        -:15313:	    }
        -:15314:	}
        -:15315:      else
    #####:15316:	start = real_start;
        -:15317:    }
        -:15318:
        -:15319:  /* If the section being dumped has relocations against it the user might
        -:15320:     be expecting these relocations to have been applied.  Check for this
        -:15321:     case and issue a warning message in order to avoid confusion.
        -:15322:     FIXME: Maybe we ought to have an option that dumps a section with
        -:15323:     relocs applied ?  */
    #####:15324:  for (relsec = filedata->section_headers;
    #####:15325:       relsec < filedata->section_headers + filedata->file_header.e_shnum;
    #####:15326:       ++relsec)
        -:15327:    {
    #####:15328:      if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
    #####:15329:	  || relsec->sh_info >= filedata->file_header.e_shnum
    #####:15330:	  || filedata->section_headers + relsec->sh_info != section
    #####:15331:	  || relsec->sh_size == 0
    #####:15332:	  || relsec->sh_link >= filedata->file_header.e_shnum)
    #####:15333:	continue;
        -:15334:
    #####:15335:      printf (_("  Note: This section has relocations against it, but these have NOT been applied to this dump.\n"));
    #####:15336:      break;
        -:15337:    }
        -:15338:
    #####:15339:  data = start;
    #####:15340:  end  = start + num_bytes;
    #####:15341:  some_strings_shown = false;
        -:15342:
        -:15343:#ifdef HAVE_MBSTATE_T
        -:15344:  mbstate_t state;
        -:15345:  /* Initialise the multibyte conversion state.  */
    #####:15346:  memset (& state, 0, sizeof (state));
        -:15347:#endif
        -:15348:
    #####:15349:  bool continuing = false;
        -:15350:
    #####:15351:  while (data < end)
        -:15352:    {
    #####:15353:      while (!ISPRINT (* data))
    #####:15354:	if (++ data >= end)
    #####:15355:	  break;
        -:15356:
    #####:15357:      if (data < end)
        -:15358:	{
    #####:15359:	  size_t maxlen = end - data;
        -:15360:
    #####:15361:	  if (continuing)
        -:15362:	    {
    #####:15363:	      printf ("            ");
    #####:15364:	      continuing = false;
        -:15365:	    }
        -:15366:	  else
        -:15367:	    {
    #####:15368:	      printf ("  [%6lx]  ", (unsigned long) (data - start));
        -:15369:	    }
        -:15370:
    #####:15371:	  if (maxlen > 0)
        -:15372:	    {
    #####:15373:	      char c = 0;
        -:15374:
    #####:15375:	      while (maxlen)
        -:15376:		{
    #####:15377:		  c = *data++;
        -:15378:
    #####:15379:		  if (c == 0)
    #####:15380:		    break;
        -:15381:
        -:15382:		  /* PR 25543: Treat new-lines as string-ending characters.  */
    #####:15383:		  if (c == '\n')
        -:15384:		    {
    #####:15385:		      printf ("\\n\n");
    #####:15386:		      if (*data != 0)
    #####:15387:			continuing = true;
    #####:15388:		      break;
        -:15389:		    }
        -:15390:
        -:15391:		  /* Do not print control characters directly as they can affect terminal
        -:15392:		     settings.  Such characters usually appear in the names generated
        -:15393:		     by the assembler for local labels.  */
    #####:15394:		  if (ISCNTRL (c))
        -:15395:		    {
    #####:15396:		      printf ("^%c", c + 0x40);
        -:15397:		    }
    #####:15398:		  else if (ISPRINT (c))
        -:15399:		    {
    #####:15400:		      putchar (c);
        -:15401:		    }
        -:15402:		  else
        -:15403:		    {
        -:15404:		      size_t  n;
        -:15405:#ifdef HAVE_MBSTATE_T
        -:15406:		      wchar_t w;
        -:15407:#endif
        -:15408:		      /* Let printf do the hard work of displaying multibyte characters.  */
    #####:15409:		      printf ("%.1s", data - 1);
        -:15410:#ifdef HAVE_MBSTATE_T
        -:15411:		      /* Try to find out how many bytes made up the character that was
        -:15412:			 just printed.  Advance the symbol pointer past the bytes that
        -:15413:			 were displayed.  */
    #####:15414:		      n = mbrtowc (& w, (char *)(data - 1), MB_CUR_MAX, & state);
        -:15415:#else
        -:15416:		      n = 1;
        -:15417:#endif
    #####:15418:		      if (n != (size_t) -1 && n != (size_t) -2 && n > 0)
    #####:15419:			data += (n - 1);
        -:15420:		    }
        -:15421:		}
        -:15422:
    #####:15423:	      if (c != '\n')
    #####:15424:		putchar ('\n');
        -:15425:	    }
        -:15426:	  else
        -:15427:	    {
    #####:15428:	      printf (_("<corrupt>\n"));
    #####:15429:	      data = end;
        -:15430:	    }
    #####:15431:	  some_strings_shown = true;
        -:15432:	}
        -:15433:    }
        -:15434:
    #####:15435:  if (! some_strings_shown)
    #####:15436:    printf (_("  No strings found in this section."));
        -:15437:
    #####:15438:  free (real_start);
        -:15439:
    #####:15440:  putchar ('\n');
    #####:15441:  return true;
        -:15442:
    #####:15443:error_out:
    #####:15444:  free (real_start);
    #####:15445:  return false;
        -:15446:}
        -:15447:
        -:15448:static bool
    #####:15449:dump_section_as_bytes (Elf_Internal_Shdr *section,
        -:15450:		       Filedata *filedata,
        -:15451:		       bool relocate)
        -:15452:{
        -:15453:  Elf_Internal_Shdr * relsec;
        -:15454:  bfd_size_type       bytes;
        -:15455:  bfd_size_type       section_size;
        -:15456:  bfd_vma             addr;
        -:15457:  unsigned char *     data;
        -:15458:  unsigned char *     real_start;
        -:15459:  unsigned char *     start;
        -:15460:
    #####:15461:  real_start = start = (unsigned char *) get_section_contents (section, filedata);
    #####:15462:  if (start == NULL)
        -:15463:    /* PR 21820: Do not fail if the section was empty.  */
    #####:15464:    return section->sh_size == 0 || section->sh_type == SHT_NOBITS;
        -:15465:
    #####:15466:  section_size = section->sh_size;
        -:15467:
    #####:15468:  if (filedata->is_separate)
    #####:15469:    printf (_("\nHex dump of section '%s' in linked file %s:\n"),
        -:15470:	    printable_section_name (filedata, section),
        -:15471:	    filedata->file_name);
        -:15472:  else
    #####:15473:    printf (_("\nHex dump of section '%s':\n"),
        -:15474:	    printable_section_name (filedata, section));
        -:15475:
    #####:15476:  if (decompress_dumps)
        -:15477:    {
    #####:15478:      dwarf_size_type new_size = section_size;
    #####:15479:      dwarf_size_type uncompressed_size = 0;
        -:15480:
    #####:15481:      if ((section->sh_flags & SHF_COMPRESSED) != 0)
        -:15482:	{
        -:15483:	  Elf_Internal_Chdr chdr;
        -:15484:	  unsigned int compression_header_size
    #####:15485:	    = get_compression_header (& chdr, start, section_size);
        -:15486:
    #####:15487:	  if (compression_header_size == 0)
        -:15488:	    /* An error message will have already been generated
        -:15489:	       by get_compression_header.  */
    #####:15490:	    goto error_out;
        -:15491:
    #####:15492:	  if (chdr.ch_type != ELFCOMPRESS_ZLIB)
        -:15493:	    {
    #####:15494:	      warn (_("section '%s' has unsupported compress type: %d\n"),
        -:15495:		    printable_section_name (filedata, section), chdr.ch_type);
    #####:15496:	      goto error_out;
        -:15497:	    }
    #####:15498:	  uncompressed_size = chdr.ch_size;
    #####:15499:	  start += compression_header_size;
    #####:15500:	  new_size -= compression_header_size;
        -:15501:	}
    #####:15502:      else if (new_size > 12 && streq ((char *) start, "ZLIB"))
        -:15503:	{
        -:15504:	  /* Read the zlib header.  In this case, it should be "ZLIB"
        -:15505:	     followed by the uncompressed section size, 8 bytes in
        -:15506:	     big-endian order.  */
    #####:15507:	  uncompressed_size = start[4]; uncompressed_size <<= 8;
    #####:15508:	  uncompressed_size += start[5]; uncompressed_size <<= 8;
    #####:15509:	  uncompressed_size += start[6]; uncompressed_size <<= 8;
    #####:15510:	  uncompressed_size += start[7]; uncompressed_size <<= 8;
    #####:15511:	  uncompressed_size += start[8]; uncompressed_size <<= 8;
    #####:15512:	  uncompressed_size += start[9]; uncompressed_size <<= 8;
    #####:15513:	  uncompressed_size += start[10]; uncompressed_size <<= 8;
    #####:15514:	  uncompressed_size += start[11];
    #####:15515:	  start += 12;
    #####:15516:	  new_size -= 12;
        -:15517:	}
        -:15518:
    #####:15519:      if (uncompressed_size)
        -:15520:	{
    #####:15521:	  if (uncompress_section_contents (& start, uncompressed_size,
        -:15522:					   & new_size))
        -:15523:	    {
    #####:15524:	      section_size = new_size;
        -:15525:	    }
        -:15526:	  else
        -:15527:	    {
    #####:15528:	      error (_("Unable to decompress section %s\n"),
        -:15529:		     printable_section_name (filedata, section));
        -:15530:	      /* FIXME: Print the section anyway ?  */
    #####:15531:	      goto error_out;
        -:15532:	    }
        -:15533:	}
        -:15534:      else
    #####:15535:	start = real_start;
        -:15536:    }
        -:15537:
    #####:15538:  if (relocate)
        -:15539:    {
    #####:15540:      if (! apply_relocations (filedata, section, start, section_size, NULL, NULL))
    #####:15541:	goto error_out;
        -:15542:    }
        -:15543:  else
        -:15544:    {
        -:15545:      /* If the section being dumped has relocations against it the user might
        -:15546:	 be expecting these relocations to have been applied.  Check for this
        -:15547:	 case and issue a warning message in order to avoid confusion.
        -:15548:	 FIXME: Maybe we ought to have an option that dumps a section with
        -:15549:	 relocs applied ?  */
    #####:15550:      for (relsec = filedata->section_headers;
    #####:15551:	   relsec < filedata->section_headers + filedata->file_header.e_shnum;
    #####:15552:	   ++relsec)
        -:15553:	{
    #####:15554:	  if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
    #####:15555:	      || relsec->sh_info >= filedata->file_header.e_shnum
    #####:15556:	      || filedata->section_headers + relsec->sh_info != section
    #####:15557:	      || relsec->sh_size == 0
    #####:15558:	      || relsec->sh_link >= filedata->file_header.e_shnum)
    #####:15559:	    continue;
        -:15560:
    #####:15561:	  printf (_(" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n"));
    #####:15562:	  break;
        -:15563:	}
        -:15564:    }
        -:15565:
    #####:15566:  addr = section->sh_addr;
    #####:15567:  bytes = section_size;
    #####:15568:  data = start;
        -:15569:
    #####:15570:  while (bytes)
        -:15571:    {
        -:15572:      int j;
        -:15573:      int k;
        -:15574:      int lbytes;
        -:15575:
    #####:15576:      lbytes = (bytes > 16 ? 16 : bytes);
        -:15577:
    #####:15578:      printf ("  0x%8.8lx ", (unsigned long) addr);
        -:15579:
    #####:15580:      for (j = 0; j < 16; j++)
        -:15581:	{
    #####:15582:	  if (j < lbytes)
    #####:15583:	    printf ("%2.2x", data[j]);
        -:15584:	  else
    #####:15585:	    printf ("  ");
        -:15586:
    #####:15587:	  if ((j & 3) == 3)
    #####:15588:	    printf (" ");
        -:15589:	}
        -:15590:
    #####:15591:      for (j = 0; j < lbytes; j++)
        -:15592:	{
    #####:15593:	  k = data[j];
    #####:15594:	  if (k >= ' ' && k < 0x7f)
    #####:15595:	    printf ("%c", k);
        -:15596:	  else
    #####:15597:	    printf (".");
        -:15598:	}
        -:15599:
    #####:15600:      putchar ('\n');
        -:15601:
    #####:15602:      data  += lbytes;
    #####:15603:      addr  += lbytes;
    #####:15604:      bytes -= lbytes;
        -:15605:    }
        -:15606:
    #####:15607:  free (real_start);
        -:15608:
    #####:15609:  putchar ('\n');
    #####:15610:  return true;
        -:15611:
    #####:15612: error_out:
    #####:15613:  free (real_start);
    #####:15614:  return false;
        -:15615:}
        -:15616:
        -:15617:#ifdef ENABLE_LIBCTF
        -:15618:static ctf_sect_t *
    #####:15619:shdr_to_ctf_sect (ctf_sect_t *buf, Elf_Internal_Shdr *shdr, Filedata *filedata)
        -:15620:{
    #####:15621:  buf->cts_name = section_name_print (filedata, shdr);
    #####:15622:  buf->cts_size = shdr->sh_size;
    #####:15623:  buf->cts_entsize = shdr->sh_entsize;
        -:15624:
    #####:15625:  return buf;
        -:15626:}
        -:15627:
        -:15628:/* Formatting callback function passed to ctf_dump.  Returns either the pointer
        -:15629:   it is passed, or a pointer to newly-allocated storage, in which case
        -:15630:   dump_ctf() will free it when it no longer needs it.  */
        -:15631:
        -:15632:static char *
    #####:15633:dump_ctf_indent_lines (ctf_sect_names_t sect ATTRIBUTE_UNUSED,
        -:15634:		       char *s, void *arg)
        -:15635:{
    #####:15636:  const char *blanks = arg;
        -:15637:  char *new_s;
        -:15638:
    #####:15639:  if (asprintf (&new_s, "%s%s", blanks, s) < 0)
    #####:15640:    return s;
    #####:15641:  return new_s;
        -:15642:}
        -:15643:
        -:15644:/* Dump CTF errors/warnings.  */
        -:15645:static void
    #####:15646:dump_ctf_errs (ctf_dict_t *fp)
        -:15647:{
    #####:15648:  ctf_next_t *it = NULL;
        -:15649:  char *errtext;
        -:15650:  int is_warning;
        -:15651:  int err;
        -:15652:
        -:15653:  /* Dump accumulated errors and warnings.  */
    #####:15654:  while ((errtext = ctf_errwarning_next (fp, &it, &is_warning, &err)) != NULL)
        -:15655:    {
    #####:15656:      error (_("%s: %s"), is_warning ? _("warning"): _("error"),
        -:15657:	     errtext);
    #####:15658:      free (errtext);
        -:15659:    }
    #####:15660:  if (err != ECTF_NEXT_END)
    #####:15661:    error (_("CTF error: cannot get CTF errors: `%s'"), ctf_errmsg (err));
    #####:15662:}
        -:15663:
        -:15664:/* Dump one CTF archive member.  */
        -:15665:
        -:15666:static void
    #####:15667:dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, ctf_dict_t *parent,
        -:15668:			 size_t member)
        -:15669:{
    #####:15670:  const char *things[] = {"Header", "Labels", "Data objects",
        -:15671:			  "Function objects", "Variables", "Types", "Strings",
        -:15672:			  ""};
        -:15673:  const char **thing;
        -:15674:  size_t i;
        -:15675:
        -:15676:  /* Don't print out the name of the default-named archive member if it appears
        -:15677:     first in the list.  The name .ctf appears everywhere, even for things that
        -:15678:     aren't really archives, so printing it out is liable to be confusing; also,
        -:15679:     the common case by far is for only one archive member to exist, and hiding
        -:15680:     it in that case seems worthwhile.  */
        -:15681:
    #####:15682:  if (strcmp (name, ".ctf") != 0 || member != 0)
    #####:15683:    printf (_("\nCTF archive member: %s:\n"), name);
        -:15684:
    #####:15685:  if (ctf_parent_name (ctf) != NULL)
    #####:15686:    ctf_import (ctf, parent);
        -:15687:
    #####:15688:  for (i = 0, thing = things; *thing[0]; thing++, i++)
        -:15689:    {
    #####:15690:      ctf_dump_state_t *s = NULL;
        -:15691:      char *item;
        -:15692:
    #####:15693:      printf ("\n  %s:\n", *thing);
    #####:15694:      while ((item = ctf_dump (ctf, &s, i, dump_ctf_indent_lines,
        -:15695:			       (void *) "    ")) != NULL)
        -:15696:	{
    #####:15697:	  printf ("%s\n", item);
    #####:15698:	  free (item);
        -:15699:	}
        -:15700:
    #####:15701:      if (ctf_errno (ctf))
        -:15702:	{
    #####:15703:	  error (_("Iteration failed: %s, %s\n"), *thing,
        -:15704:		 ctf_errmsg (ctf_errno (ctf)));
    #####:15705:	  break;
        -:15706:	}
        -:15707:    }
        -:15708:
    #####:15709:  dump_ctf_errs (ctf);
    #####:15710:}
        -:15711:
        -:15712:static bool
    #####:15713:dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)
        -:15714:{
    #####:15715:  Elf_Internal_Shdr *  symtab_sec = NULL;
    #####:15716:  Elf_Internal_Shdr *  strtab_sec = NULL;
    #####:15717:  void *	       data = NULL;
    #####:15718:  void *	       symdata = NULL;
    #####:15719:  void *	       strdata = NULL;
        -:15720:  ctf_sect_t	       ctfsect, symsect, strsect;
    #####:15721:  ctf_sect_t *	       symsectp = NULL;
    #####:15722:  ctf_sect_t *	       strsectp = NULL;
    #####:15723:  ctf_archive_t *      ctfa = NULL;
    #####:15724:  ctf_dict_t *         parent = NULL;
        -:15725:  ctf_dict_t *         fp;
        -:15726:
    #####:15727:  ctf_next_t *i = NULL;
        -:15728:  const char *name;
    #####:15729:  size_t member = 0;
        -:15730:  int err;
    #####:15731:  bool ret = false;
        -:15732:
    #####:15733:  shdr_to_ctf_sect (&ctfsect, section, filedata);
    #####:15734:  data = get_section_contents (section, filedata);
    #####:15735:  ctfsect.cts_data = data;
        -:15736:
    #####:15737:  if (!dump_ctf_symtab_name)
    #####:15738:    dump_ctf_symtab_name = strdup (".dynsym");
        -:15739:
    #####:15740:  if (!dump_ctf_strtab_name)
    #####:15741:    dump_ctf_strtab_name = strdup (".dynstr");
        -:15742:
    #####:15743:  if (dump_ctf_symtab_name && dump_ctf_symtab_name[0] != 0)
        -:15744:    {
    #####:15745:      if ((symtab_sec = find_section (filedata, dump_ctf_symtab_name)) == NULL)
        -:15746:	{
    #####:15747:	  error (_("No symbol section named %s\n"), dump_ctf_symtab_name);
    #####:15748:	  goto fail;
        -:15749:	}
    #####:15750:      if ((symdata = (void *) get_data (NULL, filedata,
    #####:15751:					symtab_sec->sh_offset, 1,
        -:15752:					symtab_sec->sh_size,
    #####:15753:					_("symbols"))) == NULL)
    #####:15754:	goto fail;
    #####:15755:      symsectp = shdr_to_ctf_sect (&symsect, symtab_sec, filedata);
    #####:15756:      symsect.cts_data = symdata;
        -:15757:    }
        -:15758:
    #####:15759:  if (dump_ctf_strtab_name && dump_ctf_strtab_name[0] != 0)
        -:15760:    {
    #####:15761:      if ((strtab_sec = find_section (filedata, dump_ctf_strtab_name)) == NULL)
        -:15762:	{
    #####:15763:	  error (_("No string table section named %s\n"),
        -:15764:		 dump_ctf_strtab_name);
    #####:15765:	  goto fail;
        -:15766:	}
    #####:15767:      if ((strdata = (void *) get_data (NULL, filedata,
    #####:15768:					strtab_sec->sh_offset, 1,
        -:15769:					strtab_sec->sh_size,
    #####:15770:					_("strings"))) == NULL)
    #####:15771:	goto fail;
    #####:15772:      strsectp = shdr_to_ctf_sect (&strsect, strtab_sec, filedata);
    #####:15773:      strsect.cts_data = strdata;
        -:15774:    }
        -:15775:
        -:15776:  /* Load the CTF file and dump it.  It may be a raw CTF section, or an archive:
        -:15777:     libctf papers over the difference, so we can pretend it is always an
        -:15778:     archive.  */
        -:15779:
    #####:15780:  if ((ctfa = ctf_arc_bufopen (&ctfsect, symsectp, strsectp, &err)) == NULL)
        -:15781:    {
    #####:15782:      dump_ctf_errs (NULL);
    #####:15783:      error (_("CTF open failure: %s\n"), ctf_errmsg (err));
    #####:15784:      goto fail;
        -:15785:    }
        -:15786:
    #####:15787:  ctf_arc_symsect_endianness (ctfa, filedata->file_header.e_ident[EI_DATA]
        -:15788:			      != ELFDATA2MSB);
        -:15789:
        -:15790:  /* Preload the parent dict, since it will need to be imported into every
        -:15791:     child in turn.  */
    #####:15792:  if ((parent = ctf_dict_open (ctfa, dump_ctf_parent_name, &err)) == NULL)
        -:15793:    {
    #####:15794:      dump_ctf_errs (NULL);
    #####:15795:      error (_("CTF open failure: %s\n"), ctf_errmsg (err));
    #####:15796:      goto fail;
        -:15797:    }
        -:15798:
    #####:15799:  ret = true;
        -:15800:
    #####:15801:  if (filedata->is_separate)
    #####:15802:    printf (_("\nDump of CTF section '%s' in linked file %s:\n"),
        -:15803:	    printable_section_name (filedata, section),
        -:15804:	    filedata->file_name);
        -:15805:  else
    #####:15806:    printf (_("\nDump of CTF section '%s':\n"),
        -:15807:	    printable_section_name (filedata, section));
        -:15808:
    #####:15809: while ((fp = ctf_archive_next (ctfa, &i, &name, 0, &err)) != NULL)
    #####:15810:    dump_ctf_archive_member (fp, name, parent, member++);
    #####:15811: if (err != ECTF_NEXT_END)
        -:15812:   {
    #####:15813:     dump_ctf_errs (NULL);
    #####:15814:     error (_("CTF member open failure: %s\n"), ctf_errmsg (err));
    #####:15815:     ret = false;
        -:15816:   }
        -:15817:
    #####:15818: fail:
    #####:15819:  ctf_dict_close (parent);
    #####:15820:  ctf_close (ctfa);
    #####:15821:  free (data);
    #####:15822:  free (symdata);
    #####:15823:  free (strdata);
    #####:15824:  return ret;
        -:15825:}
        -:15826:#endif
        -:15827:
        -:15828:static bool
    #####:15829:load_specific_debug_section (enum dwarf_section_display_enum  debug,
        -:15830:			     const Elf_Internal_Shdr *        sec,
        -:15831:			     void *                           data)
        -:15832:{
    #####:15833:  struct dwarf_section * section = &debug_displays [debug].section;
        -:15834:  char buf [64];
    #####:15835:  Filedata * filedata = (Filedata *) data;
        -:15836:
    #####:15837:  if (section->start != NULL)
        -:15838:    {
        -:15839:      /* If it is already loaded, do nothing.  */
    #####:15840:      if (streq (section->filename, filedata->file_name))
    #####:15841:	return true;
    #####:15842:      free (section->start);
        -:15843:    }
        -:15844:
    #####:15845:  snprintf (buf, sizeof (buf), _("%s section data"), section->name);
    #####:15846:  section->address = sec->sh_addr;
    #####:15847:  section->filename = filedata->file_name;
    #####:15848:  section->start = (unsigned char *) get_data (NULL, filedata,
    #####:15849:                                               sec->sh_offset, 1,
        -:15850:                                               sec->sh_size, buf);
    #####:15851:  if (section->start == NULL)
    #####:15852:    section->size = 0;
        -:15853:  else
        -:15854:    {
    #####:15855:      unsigned char *start = section->start;
    #####:15856:      dwarf_size_type size = sec->sh_size;
    #####:15857:      dwarf_size_type uncompressed_size = 0;
        -:15858:
    #####:15859:      if ((sec->sh_flags & SHF_COMPRESSED) != 0)
        -:15860:	{
        -:15861:	  Elf_Internal_Chdr chdr;
        -:15862:	  unsigned int compression_header_size;
        -:15863:
    #####:15864:	  if (size < (is_32bit_elf
    #####:15865:		      ? sizeof (Elf32_External_Chdr)
    #####:15866:		      : sizeof (Elf64_External_Chdr)))
        -:15867:	    {
    #####:15868:	      warn (_("compressed section %s is too small to contain a compression header\n"),
        -:15869:		    section->name);
    #####:15870:	      return false;
        -:15871:	    }
        -:15872:
    #####:15873:	  compression_header_size = get_compression_header (&chdr, start, size);
    #####:15874:	  if (compression_header_size == 0)
        -:15875:	    /* An error message will have already been generated
        -:15876:	       by get_compression_header.  */
    #####:15877:	    return false;
        -:15878:
    #####:15879:	  if (chdr.ch_type != ELFCOMPRESS_ZLIB)
        -:15880:	    {
    #####:15881:	      warn (_("section '%s' has unsupported compress type: %d\n"),
        -:15882:		    section->name, chdr.ch_type);
    #####:15883:	      return false;
        -:15884:	    }
    #####:15885:	  uncompressed_size = chdr.ch_size;
    #####:15886:	  start += compression_header_size;
    #####:15887:	  size -= compression_header_size;
        -:15888:	}
    #####:15889:      else if (size > 12 && streq ((char *) start, "ZLIB"))
        -:15890:	{
        -:15891:	  /* Read the zlib header.  In this case, it should be "ZLIB"
        -:15892:	     followed by the uncompressed section size, 8 bytes in
        -:15893:	     big-endian order.  */
    #####:15894:	  uncompressed_size = start[4]; uncompressed_size <<= 8;
    #####:15895:	  uncompressed_size += start[5]; uncompressed_size <<= 8;
    #####:15896:	  uncompressed_size += start[6]; uncompressed_size <<= 8;
    #####:15897:	  uncompressed_size += start[7]; uncompressed_size <<= 8;
    #####:15898:	  uncompressed_size += start[8]; uncompressed_size <<= 8;
    #####:15899:	  uncompressed_size += start[9]; uncompressed_size <<= 8;
    #####:15900:	  uncompressed_size += start[10]; uncompressed_size <<= 8;
    #####:15901:	  uncompressed_size += start[11];
    #####:15902:	  start += 12;
    #####:15903:	  size -= 12;
        -:15904:	}
        -:15905:
    #####:15906:      if (uncompressed_size)
        -:15907:	{
    #####:15908:	  if (uncompress_section_contents (&start, uncompressed_size,
        -:15909:					   &size))
        -:15910:	    {
        -:15911:	      /* Free the compressed buffer, update the section buffer
        -:15912:		 and the section size if uncompress is successful.  */
    #####:15913:	      free (section->start);
    #####:15914:	      section->start = start;
        -:15915:	    }
        -:15916:	  else
        -:15917:	    {
    #####:15918:	      error (_("Unable to decompress section %s\n"),
        -:15919:		     printable_section_name (filedata, sec));
    #####:15920:	      return false;
        -:15921:	    }
        -:15922:	}
        -:15923:
    #####:15924:      section->size = size;
        -:15925:    }
        -:15926:
    #####:15927:  if (section->start == NULL)
    #####:15928:    return false;
        -:15929:
    #####:15930:  if (debug_displays [debug].relocate)
        -:15931:    {
    #####:15932:      if (! apply_relocations (filedata, sec, section->start, section->size,
        -:15933:			       & section->reloc_info, & section->num_relocs))
    #####:15934:	return false;
        -:15935:    }
        -:15936:  else
        -:15937:    {
    #####:15938:      section->reloc_info = NULL;
    #####:15939:      section->num_relocs = 0;
        -:15940:    }
        -:15941:
    #####:15942:  return true;
        -:15943:}
        -:15944:
        -:15945:#if HAVE_LIBDEBUGINFOD
        -:15946:/* Return a hex string representation of the build-id.  */
        -:15947:unsigned char *
        -:15948:get_build_id (void * data)
        -:15949:{
        -:15950:  Filedata * filedata = (Filedata *) data;
        -:15951:  Elf_Internal_Shdr * shdr;
        -:15952:  unsigned long i;
        -:15953:
        -:15954:  /* Iterate through notes to find note.gnu.build-id.
        -:15955:     FIXME: Only the first note in any note section is examined.  */
        -:15956:  for (i = 0, shdr = filedata->section_headers;
        -:15957:       i < filedata->file_header.e_shnum && shdr != NULL;
        -:15958:       i++, shdr++)
        -:15959:    {
        -:15960:      if (shdr->sh_type != SHT_NOTE)
        -:15961:        continue;
        -:15962:
        -:15963:      char * next;
        -:15964:      char * end;
        -:15965:      size_t data_remaining;
        -:15966:      size_t min_notesz;
        -:15967:      Elf_External_Note * enote;
        -:15968:      Elf_Internal_Note inote;
        -:15969:
        -:15970:      bfd_vma offset = shdr->sh_offset;
        -:15971:      bfd_vma align = shdr->sh_addralign;
        -:15972:      bfd_vma length = shdr->sh_size;
        -:15973:
        -:15974:      enote = (Elf_External_Note *) get_section_contents (shdr, filedata);
        -:15975:      if (enote == NULL)
        -:15976:        continue;
        -:15977:
        -:15978:      if (align < 4)
        -:15979:        align = 4;
        -:15980:      else if (align != 4 && align != 8)
        -:15981:	{
        -:15982:	  free (enote);
        -:15983:	  continue;
        -:15984:	}
        -:15985:
        -:15986:      end = (char *) enote + length;
        -:15987:      data_remaining = end - (char *) enote;
        -:15988:
        -:15989:      if (!is_ia64_vms (filedata))
        -:15990:        {
        -:15991:          min_notesz = offsetof (Elf_External_Note, name);
        -:15992:          if (data_remaining < min_notesz)
        -:15993:            {
        -:15994:	      warn (_("\
        -:15995:malformed note encountered in section %s whilst scanning for build-id note\n"),
        -:15996:		    printable_section_name (filedata, shdr));
        -:15997:	      free (enote);
        -:15998:              continue;
        -:15999:            }
        -:16000:          data_remaining -= min_notesz;
        -:16001:
        -:16002:          inote.type     = BYTE_GET (enote->type);
        -:16003:          inote.namesz   = BYTE_GET (enote->namesz);
        -:16004:          inote.namedata = enote->name;
        -:16005:          inote.descsz   = BYTE_GET (enote->descsz);
        -:16006:          inote.descdata = ((char *) enote
        -:16007:                            + ELF_NOTE_DESC_OFFSET (inote.namesz, align));
        -:16008:          inote.descpos  = offset + (inote.descdata - (char *) enote);
        -:16009:          next = ((char *) enote
        -:16010:                  + ELF_NOTE_NEXT_OFFSET (inote.namesz, inote.descsz, align));
        -:16011:        }
        -:16012:      else
        -:16013:        {
        -:16014:          Elf64_External_VMS_Note *vms_enote;
        -:16015:
        -:16016:          /* PR binutils/15191
        -:16017:             Make sure that there is enough data to read.  */
        -:16018:          min_notesz = offsetof (Elf64_External_VMS_Note, name);
        -:16019:          if (data_remaining < min_notesz)
        -:16020:            {
        -:16021:	      warn (_("\
        -:16022:malformed note encountered in section %s whilst scanning for build-id note\n"),
        -:16023:		    printable_section_name (filedata, shdr));
        -:16024:	      free (enote);
        -:16025:              continue;
        -:16026:            }
        -:16027:          data_remaining -= min_notesz;
        -:16028:
        -:16029:          vms_enote = (Elf64_External_VMS_Note *) enote;
        -:16030:          inote.type     = BYTE_GET (vms_enote->type);
        -:16031:          inote.namesz   = BYTE_GET (vms_enote->namesz);
        -:16032:          inote.namedata = vms_enote->name;
        -:16033:          inote.descsz   = BYTE_GET (vms_enote->descsz);
        -:16034:          inote.descdata = inote.namedata + align_power (inote.namesz, 3);
        -:16035:          inote.descpos  = offset + (inote.descdata - (char *) enote);
        -:16036:          next = inote.descdata + align_power (inote.descsz, 3);
        -:16037:        }
        -:16038:
        -:16039:      /* Skip malformed notes.  */
        -:16040:      if ((size_t) (inote.descdata - inote.namedata) < inote.namesz
        -:16041:          || (size_t) (inote.descdata - inote.namedata) > data_remaining
        -:16042:          || (size_t) (next - inote.descdata) < inote.descsz
        -:16043:          || ((size_t) (next - inote.descdata)
        -:16044:              > data_remaining - (size_t) (inote.descdata - inote.namedata)))
        -:16045:        {
        -:16046:	  warn (_("\
        -:16047:malformed note encountered in section %s whilst scanning for build-id note\n"),
        -:16048:		printable_section_name (filedata, shdr));
        -:16049:	  free (enote);
        -:16050:          continue;
        -:16051:        }
        -:16052:
        -:16053:      /* Check if this is the build-id note. If so then convert the build-id
        -:16054:         bytes to a hex string.  */
        -:16055:      if (inote.namesz > 0
        -:16056:          && startswith (inote.namedata, "GNU")
        -:16057:          && inote.type == NT_GNU_BUILD_ID)
        -:16058:        {
        -:16059:          unsigned long j;
        -:16060:          char * build_id;
        -:16061:
        -:16062:          build_id = malloc (inote.descsz * 2 + 1);
        -:16063:          if (build_id == NULL)
        -:16064:	    {
        -:16065:	      free (enote);
        -:16066:	      return NULL;
        -:16067:	    }
        -:16068:
        -:16069:          for (j = 0; j < inote.descsz; ++j)
        -:16070:            sprintf (build_id + (j * 2), "%02x", inote.descdata[j] & 0xff);
        -:16071:          build_id[inote.descsz * 2] = '\0';
        -:16072:	  free (enote);
        -:16073:
        -:16074:          return (unsigned char *) build_id;
        -:16075:        }
        -:16076:      free (enote);
        -:16077:    }
        -:16078:
        -:16079:  return NULL;
        -:16080:}
        -:16081:#endif /* HAVE_LIBDEBUGINFOD */
        -:16082:
        -:16083:/* If this is not NULL, load_debug_section will only look for sections
        -:16084:   within the list of sections given here.  */
        -:16085:static unsigned int * section_subset = NULL;
        -:16086:
        -:16087:bool
      150:16088:load_debug_section (enum dwarf_section_display_enum debug, void * data)
        -:16089:{
      150:16090:  struct dwarf_section * section = &debug_displays [debug].section;
        -:16091:  Elf_Internal_Shdr * sec;
      150:16092:  Filedata * filedata = (Filedata *) data;
        -:16093:
      150:16094:  if (!dump_any_debugging)
      150:16095:    return false;
        -:16096:
        -:16097:  /* Without section headers we cannot find any sections.  */
    #####:16098:  if (filedata->section_headers == NULL)
    #####:16099:    return false;
        -:16100:
    #####:16101:  if (filedata->string_table == NULL
    #####:16102:      && filedata->file_header.e_shstrndx != SHN_UNDEF
    #####:16103:      && filedata->file_header.e_shstrndx < filedata->file_header.e_shnum)
        -:16104:    {
        -:16105:      Elf_Internal_Shdr * strs;
        -:16106:
        -:16107:      /* Read in the string table, so that we have section names to scan.  */
    #####:16108:      strs = filedata->section_headers + filedata->file_header.e_shstrndx;
        -:16109:
    #####:16110:      if (strs != NULL && strs->sh_size != 0)
        -:16111:	{
        -:16112:	  filedata->string_table
    #####:16113:	    = (char *) get_data (NULL, filedata, strs->sh_offset,
    #####:16114:				 1, strs->sh_size, _("string table"));
        -:16115:
        -:16116:	  filedata->string_table_length
    #####:16117:	    = filedata->string_table != NULL ? strs->sh_size : 0;
        -:16118:	}
        -:16119:    }
        -:16120:
        -:16121:  /* Locate the debug section.  */
    #####:16122:  sec = find_section_in_set (filedata, section->uncompressed_name, section_subset);
    #####:16123:  if (sec != NULL)
    #####:16124:    section->name = section->uncompressed_name;
        -:16125:  else
        -:16126:    {
    #####:16127:      sec = find_section_in_set (filedata, section->compressed_name, section_subset);
    #####:16128:      if (sec != NULL)
    #####:16129:	section->name = section->compressed_name;
        -:16130:    }
    #####:16131:  if (sec == NULL)
    #####:16132:    return false;
        -:16133:
        -:16134:  /* If we're loading from a subset of sections, and we've loaded
        -:16135:     a section matching this name before, it's likely that it's a
        -:16136:     different one.  */
    #####:16137:  if (section_subset != NULL)
    #####:16138:    free_debug_section (debug);
        -:16139:
    #####:16140:  return load_specific_debug_section (debug, sec, data);
        -:16141:}
        -:16142:
        -:16143:void
    65659:16144:free_debug_section (enum dwarf_section_display_enum debug)
        -:16145:{
    65659:16146:  struct dwarf_section * section = &debug_displays [debug].section;
        -:16147:
    65659:16148:  if (section->start == NULL)
    65659:16149:    return;
        -:16150:
    #####:16151:  free ((char *) section->start);
    #####:16152:  section->start = NULL;
    #####:16153:  section->address = 0;
    #####:16154:  section->size = 0;
        -:16155:
    #####:16156:  free (section->reloc_info);
    #####:16157:  section->reloc_info = NULL;
    #####:16158:  section->num_relocs = 0;
        -:16159:}
        -:16160:
        -:16161:static bool
    #####:16162:display_debug_section (int shndx, Elf_Internal_Shdr * section, Filedata * filedata)
        -:16163:{
    #####:16164:  const char *name = (section_name_valid (filedata, section)
    #####:16165:		      ? section_name (filedata, section) : "");
    #####:16166:  const char *print_name = printable_section_name (filedata, section);
        -:16167:  bfd_size_type length;
    #####:16168:  bool result = true;
        -:16169:  int i;
        -:16170:
    #####:16171:  length = section->sh_size;
    #####:16172:  if (length == 0)
        -:16173:    {
    #####:16174:      printf (_("\nSection '%s' has no debugging data.\n"), print_name);
    #####:16175:      return true;
        -:16176:    }
    #####:16177:  if (section->sh_type == SHT_NOBITS)
        -:16178:    {
        -:16179:      /* There is no point in dumping the contents of a debugging section
        -:16180:	 which has the NOBITS type - the bits in the file will be random.
        -:16181:	 This can happen when a file containing a .eh_frame section is
        -:16182:	 stripped with the --only-keep-debug command line option.  */
    #####:16183:      printf (_("section '%s' has the NOBITS type - its contents are unreliable.\n"),
        -:16184:	      print_name);
    #####:16185:      return false;
        -:16186:    }
        -:16187:
    #####:16188:  if (startswith (name, ".gnu.linkonce.wi."))
    #####:16189:    name = ".debug_info";
        -:16190:
        -:16191:  /* See if we know how to display the contents of this section.  */
    #####:16192:  for (i = 0; i < max; i++)
        -:16193:    {
    #####:16194:      enum dwarf_section_display_enum  id = (enum dwarf_section_display_enum) i;
    #####:16195:      struct dwarf_section_display *   display = debug_displays + i;
    #####:16196:      struct dwarf_section *           sec = & display->section;
        -:16197:
    #####:16198:      if (streq (sec->uncompressed_name, name)
    #####:16199:	  || (id == line && startswith (name, ".debug_line."))
    #####:16200:	  || streq (sec->compressed_name, name))
        -:16201:	{
    #####:16202:	  bool secondary = (section != find_section (filedata, name));
        -:16203:
    #####:16204:	  if (secondary)
    #####:16205:	    free_debug_section (id);
        -:16206:
    #####:16207:	  if (i == line && startswith (name, ".debug_line."))
    #####:16208:	    sec->name = name;
    #####:16209:	  else if (streq (sec->uncompressed_name, name))
    #####:16210:	    sec->name = sec->uncompressed_name;
        -:16211:	  else
    #####:16212:	    sec->name = sec->compressed_name;
        -:16213:
    #####:16214:	  if (load_specific_debug_section (id, section, filedata))
        -:16215:	    {
        -:16216:	      /* If this debug section is part of a CU/TU set in a .dwp file,
        -:16217:		 restrict load_debug_section to the sections in that set.  */
    #####:16218:	      section_subset = find_cu_tu_set (filedata, shndx);
        -:16219:
    #####:16220:	      result &= display->display (sec, filedata);
        -:16221:
    #####:16222:	      section_subset = NULL;
        -:16223:
    #####:16224:	      if (secondary || (id != info && id != abbrev && id != debug_addr))
    #####:16225:		free_debug_section (id);
        -:16226:	    }
    #####:16227:	  break;
        -:16228:	}
        -:16229:    }
        -:16230:
    #####:16231:  if (i == max)
        -:16232:    {
    #####:16233:      printf (_("Unrecognized debug section: %s\n"), print_name);
    #####:16234:      result = false;
        -:16235:    }
        -:16236:
    #####:16237:  return result;
        -:16238:}
        -:16239:
        -:16240:/* Set DUMP_SECTS for all sections where dumps were requested
        -:16241:   based on section name.  */
        -:16242:
        -:16243:static void
    #####:16244:initialise_dumps_byname (Filedata * filedata)
        -:16245:{
        -:16246:  struct dump_list_entry * cur;
        -:16247:
    #####:16248:  for (cur = dump_sects_byname; cur; cur = cur->next)
        -:16249:    {
        -:16250:      unsigned int i;
    #####:16251:      bool any = false;
        -:16252:
    #####:16253:      for (i = 0; i < filedata->file_header.e_shnum; i++)
    #####:16254:	if (section_name_valid (filedata, filedata->section_headers + i)
    #####:16255:	    && streq (section_name (filedata, filedata->section_headers + i),
        -:16256:		      cur->name))
        -:16257:	  {
    #####:16258:	    request_dump_bynumber (&filedata->dump, i, cur->type);
    #####:16259:	    any = true;
        -:16260:	  }
        -:16261:
    #####:16262:      if (!any && !filedata->is_separate)
    #####:16263:	warn (_("Section '%s' was not dumped because it does not exist\n"),
        -:16264:	      cur->name);
        -:16265:    }
    #####:16266:}
        -:16267:
        -:16268:static bool
     1391:16269:process_section_contents (Filedata * filedata)
        -:16270:{
        -:16271:  Elf_Internal_Shdr * section;
        -:16272:  unsigned int i;
     1391:16273:  bool res = true;
        -:16274:
     1391:16275:  if (! do_dump)
     1391:16276:    return true;
        -:16277:
    #####:16278:  initialise_dumps_byname (filedata);
        -:16279:
    #####:16280:  for (i = 0, section = filedata->section_headers;
    #####:16281:       i < filedata->file_header.e_shnum && i < filedata->dump.num_dump_sects;
    #####:16282:       i++, section++)
        -:16283:    {
    #####:16284:      dump_type dump = filedata->dump.dump_sects[i];
        -:16285:
    #####:16286:      if (filedata->is_separate && ! process_links)
    #####:16287:	dump &= DEBUG_DUMP;
        -:16288:
        -:16289:#ifdef SUPPORT_DISASSEMBLY
        -:16290:      if (dump & DISASS_DUMP)
        -:16291:	{
        -:16292:	  if (! disassemble_section (section, filedata))
        -:16293:	    res = false;
        -:16294:	}
        -:16295:#endif
    #####:16296:      if (dump & HEX_DUMP)
        -:16297:	{
    #####:16298:	  if (! dump_section_as_bytes (section, filedata, false))
    #####:16299:	    res = false;
        -:16300:	}
        -:16301:
    #####:16302:      if (dump & RELOC_DUMP)
        -:16303:	{
    #####:16304:	  if (! dump_section_as_bytes (section, filedata, true))
    #####:16305:	    res = false;
        -:16306:	}
        -:16307:
    #####:16308:      if (dump & STRING_DUMP)
        -:16309:	{
    #####:16310:	  if (! dump_section_as_strings (section, filedata))
    #####:16311:	    res = false;
        -:16312:	}
        -:16313:
    #####:16314:      if (dump & DEBUG_DUMP)
        -:16315:	{
    #####:16316:	  if (! display_debug_section (i, section, filedata))
    #####:16317:	    res = false;
        -:16318:	}
        -:16319:
        -:16320:#ifdef ENABLE_LIBCTF
    #####:16321:      if (dump & CTF_DUMP)
        -:16322:	{
    #####:16323:	  if (! dump_section_as_ctf (section, filedata))
    #####:16324:	    res = false;
        -:16325:	}
        -:16326:#endif
        -:16327:    }
        -:16328:
    #####:16329:  if (! filedata->is_separate)
        -:16330:    {
        -:16331:      /* Check to see if the user requested a
        -:16332:	 dump of a section that does not exist.  */
    #####:16333:      for (; i < filedata->dump.num_dump_sects; i++)
    #####:16334:	if (filedata->dump.dump_sects[i])
        -:16335:	  {
    #####:16336:	    warn (_("Section %d was not dumped because it does not exist!\n"), i);
    #####:16337:	    res = false;
        -:16338:	  }
        -:16339:    }
        -:16340:
    #####:16341:  return res;
        -:16342:}
        -:16343:
        -:16344:static void
    #####:16345:process_mips_fpe_exception (int mask)
        -:16346:{
    #####:16347:  if (mask)
        -:16348:    {
    #####:16349:      bool first = true;
        -:16350:
    #####:16351:      if (mask & OEX_FPU_INEX)
    #####:16352:	fputs ("INEX", stdout), first = false;
    #####:16353:      if (mask & OEX_FPU_UFLO)
    #####:16354:	printf ("%sUFLO", first ? "" : "|"), first = false;
    #####:16355:      if (mask & OEX_FPU_OFLO)
    #####:16356:	printf ("%sOFLO", first ? "" : "|"), first = false;
    #####:16357:      if (mask & OEX_FPU_DIV0)
    #####:16358:	printf ("%sDIV0", first ? "" : "|"), first = false;
    #####:16359:      if (mask & OEX_FPU_INVAL)
    #####:16360:	printf ("%sINVAL", first ? "" : "|");
        -:16361:    }
        -:16362:  else
    #####:16363:    fputs ("0", stdout);
    #####:16364:}
        -:16365:
        -:16366:/* Display's the value of TAG at location P.  If TAG is
        -:16367:   greater than 0 it is assumed to be an unknown tag, and
        -:16368:   a message is printed to this effect.  Otherwise it is
        -:16369:   assumed that a message has already been printed.
        -:16370:
        -:16371:   If the bottom bit of TAG is set it assumed to have a
        -:16372:   string value, otherwise it is assumed to have an integer
        -:16373:   value.
        -:16374:
        -:16375:   Returns an updated P pointing to the first unread byte
        -:16376:   beyond the end of TAG's value.
        -:16377:
        -:16378:   Reads at or beyond END will not be made.  */
        -:16379:
        -:16380:static unsigned char *
    #####:16381:display_tag_value (signed int tag,
        -:16382:		   unsigned char * p,
        -:16383:		   const unsigned char * const end)
        -:16384:{
        -:16385:  unsigned long val;
        -:16386:
    #####:16387:  if (tag > 0)
    #####:16388:    printf ("  Tag_unknown_%d: ", tag);
        -:16389:
    #####:16390:  if (p >= end)
        -:16391:    {
    #####:16392:      warn (_("<corrupt tag>\n"));
        -:16393:    }
    #####:16394:  else if (tag & 1)
        -:16395:    {
        -:16396:      /* PR 17531 file: 027-19978-0.004.  */
    #####:16397:      size_t maxlen = (end - p) - 1;
        -:16398:
    #####:16399:      putchar ('"');
    #####:16400:      if (maxlen > 0)
        -:16401:	{
    #####:16402:	  print_symbol ((int) maxlen, (const char *) p);
    #####:16403:	  p += strnlen ((char *) p, maxlen) + 1;
        -:16404:	}
        -:16405:      else
        -:16406:	{
    #####:16407:	  printf (_("<corrupt string tag>"));
    #####:16408:	  p = (unsigned char *) end;
        -:16409:	}
    #####:16410:      printf ("\"\n");
        -:16411:    }
        -:16412:  else
        -:16413:    {
    #####:16414:      READ_ULEB (val, p, end);
    #####:16415:      printf ("%ld (0x%lx)\n", val, val);
        -:16416:    }
        -:16417:
    #####:16418:  assert (p <= end);
    #####:16419:  return p;
        -:16420:}
        -:16421:
        -:16422:/* ARC ABI attributes section.  */
        -:16423:
        -:16424:static unsigned char *
    #####:16425:display_arc_attribute (unsigned char * p,
        -:16426:		       const unsigned char * const end)
        -:16427:{
        -:16428:  unsigned int tag;
        -:16429:  unsigned int val;
        -:16430:
    #####:16431:  READ_ULEB (tag, p, end);
        -:16432:
    #####:16433:  switch (tag)
        -:16434:    {
    #####:16435:    case Tag_ARC_PCS_config:
    #####:16436:      READ_ULEB (val, p, end);
    #####:16437:      printf ("  Tag_ARC_PCS_config: ");
        -:16438:      switch (val)
        -:16439:	{
    #####:16440:	case 0:
    #####:16441:	  printf (_("Absent/Non standard\n"));
    #####:16442:	  break;
    #####:16443:	case 1:
    #####:16444:	  printf (_("Bare metal/mwdt\n"));
    #####:16445:	  break;
    #####:16446:	case 2:
    #####:16447:	  printf (_("Bare metal/newlib\n"));
    #####:16448:	  break;
    #####:16449:	case 3:
    #####:16450:	  printf (_("Linux/uclibc\n"));
    #####:16451:	  break;
    #####:16452:	case 4:
    #####:16453:	  printf (_("Linux/glibc\n"));
    #####:16454:	  break;
    #####:16455:	default:
    #####:16456:	  printf (_("Unknown\n"));
    #####:16457:	  break;
        -:16458:	}
    #####:16459:      break;
        -:16460:
    #####:16461:    case Tag_ARC_CPU_base:
    #####:16462:      READ_ULEB (val, p, end);
    #####:16463:      printf ("  Tag_ARC_CPU_base: ");
        -:16464:      switch (val)
        -:16465:	{
    #####:16466:	default:
        -:16467:	case TAG_CPU_NONE:
    #####:16468:	  printf (_("Absent\n"));
    #####:16469:	  break;
    #####:16470:	case TAG_CPU_ARC6xx:
    #####:16471:	  printf ("ARC6xx\n");
    #####:16472:	  break;
    #####:16473:	case TAG_CPU_ARC7xx:
    #####:16474:	  printf ("ARC7xx\n");
    #####:16475:	  break;
    #####:16476:	case TAG_CPU_ARCEM:
    #####:16477:	  printf ("ARCEM\n");
    #####:16478:	  break;
    #####:16479:	case TAG_CPU_ARCHS:
    #####:16480:	  printf ("ARCHS\n");
    #####:16481:	  break;
        -:16482:	}
    #####:16483:      break;
        -:16484:
    #####:16485:    case Tag_ARC_CPU_variation:
    #####:16486:      READ_ULEB (val, p, end);
    #####:16487:      printf ("  Tag_ARC_CPU_variation: ");
        -:16488:      switch (val)
        -:16489:	{
    #####:16490:	default:
    #####:16491:	  if (val > 0 && val < 16)
    #####:16492:	      printf ("Core%d\n", val);
        -:16493:	  else
    #####:16494:	      printf ("Unknown\n");
    #####:16495:	  break;
        -:16496:
    #####:16497:	case 0:
    #####:16498:	  printf (_("Absent\n"));
    #####:16499:	  break;
        -:16500:	}
    #####:16501:      break;
        -:16502:
    #####:16503:    case Tag_ARC_CPU_name:
    #####:16504:      printf ("  Tag_ARC_CPU_name: ");
    #####:16505:      p = display_tag_value (-1, p, end);
    #####:16506:      break;
        -:16507:
    #####:16508:    case Tag_ARC_ABI_rf16:
    #####:16509:      READ_ULEB (val, p, end);
    #####:16510:      printf ("  Tag_ARC_ABI_rf16: %s\n", val ? _("yes") : _("no"));
    #####:16511:      break;
        -:16512:
    #####:16513:    case Tag_ARC_ABI_osver:
    #####:16514:      READ_ULEB (val, p, end);
    #####:16515:      printf ("  Tag_ARC_ABI_osver: v%d\n", val);
    #####:16516:      break;
        -:16517:
    #####:16518:    case Tag_ARC_ABI_pic:
        -:16519:    case Tag_ARC_ABI_sda:
    #####:16520:      READ_ULEB (val, p, end);
    #####:16521:      printf (tag == Tag_ARC_ABI_sda ? "  Tag_ARC_ABI_sda: "
        -:16522:	      : "  Tag_ARC_ABI_pic: ");
        -:16523:      switch (val)
        -:16524:	{
    #####:16525:	case 0:
    #####:16526:	  printf (_("Absent\n"));
    #####:16527:	  break;
    #####:16528:	case 1:
    #####:16529:	  printf ("MWDT\n");
    #####:16530:	  break;
    #####:16531:	case 2:
    #####:16532:	  printf ("GNU\n");
    #####:16533:	  break;
    #####:16534:	default:
    #####:16535:	  printf (_("Unknown\n"));
    #####:16536:	  break;
        -:16537:	}
    #####:16538:      break;
        -:16539:
    #####:16540:    case Tag_ARC_ABI_tls:
    #####:16541:      READ_ULEB (val, p, end);
    #####:16542:      printf ("  Tag_ARC_ABI_tls: %s\n", val ? "r25": "none");
    #####:16543:      break;
        -:16544:
    #####:16545:    case Tag_ARC_ABI_enumsize:
    #####:16546:      READ_ULEB (val, p, end);
    #####:16547:      printf ("  Tag_ARC_ABI_enumsize: %s\n", val ? _("default") :
    #####:16548:	      _("smallest"));
    #####:16549:      break;
        -:16550:
    #####:16551:    case Tag_ARC_ABI_exceptions:
    #####:16552:      READ_ULEB (val, p, end);
    #####:16553:      printf ("  Tag_ARC_ABI_exceptions: %s\n", val ? _("OPTFP")
    #####:16554:	      : _("default"));
    #####:16555:      break;
        -:16556:
    #####:16557:    case Tag_ARC_ABI_double_size:
    #####:16558:      READ_ULEB (val, p, end);
    #####:16559:      printf ("  Tag_ARC_ABI_double_size: %d\n", val);
    #####:16560:      break;
        -:16561:
    #####:16562:    case Tag_ARC_ISA_config:
    #####:16563:      printf ("  Tag_ARC_ISA_config: ");
    #####:16564:      p = display_tag_value (-1, p, end);
    #####:16565:      break;
        -:16566:
    #####:16567:    case Tag_ARC_ISA_apex:
    #####:16568:      printf ("  Tag_ARC_ISA_apex: ");
    #####:16569:      p = display_tag_value (-1, p, end);
    #####:16570:      break;
        -:16571:
    #####:16572:    case Tag_ARC_ISA_mpy_option:
    #####:16573:      READ_ULEB (val, p, end);
    #####:16574:      printf ("  Tag_ARC_ISA_mpy_option: %d\n", val);
    #####:16575:      break;
        -:16576:
    #####:16577:    case Tag_ARC_ATR_version:
    #####:16578:      READ_ULEB (val, p, end);
    #####:16579:      printf ("  Tag_ARC_ATR_version: %d\n", val);
    #####:16580:      break;
        -:16581:
    #####:16582:    default:
    #####:16583:      return display_tag_value (tag & 1, p, end);
        -:16584:    }
        -:16585:
    #####:16586:  return p;
        -:16587:}
        -:16588:
        -:16589:/* ARM EABI attributes section.  */
        -:16590:typedef struct
        -:16591:{
        -:16592:  unsigned int tag;
        -:16593:  const char * name;
        -:16594:  /* 0 = special, 1 = string, 2 = uleb123, > 0x80 == table lookup.  */
        -:16595:  unsigned int type;
        -:16596:  const char *const *table;
        -:16597:} arm_attr_public_tag;
        -:16598:
        -:16599:static const char *const arm_attr_tag_CPU_arch[] =
        -:16600:  {"Pre-v4", "v4", "v4T", "v5T", "v5TE", "v5TEJ", "v6", "v6KZ", "v6T2",
        -:16601:   "v6K", "v7", "v6-M", "v6S-M", "v7E-M", "v8", "v8-R", "v8-M.baseline",
        -:16602:   "v8-M.mainline", "v8.1-A", "v8.2-A", "v8.3-A",
        -:16603:   "v8.1-M.mainline", "v9"};
        -:16604:static const char *const arm_attr_tag_ARM_ISA_use[] = {"No", "Yes"};
        -:16605:static const char *const arm_attr_tag_THUMB_ISA_use[] =
        -:16606:  {"No", "Thumb-1", "Thumb-2", "Yes"};
        -:16607:static const char *const arm_attr_tag_FP_arch[] =
        -:16608:  {"No", "VFPv1", "VFPv2", "VFPv3", "VFPv3-D16", "VFPv4", "VFPv4-D16",
        -:16609:   "FP for ARMv8", "FPv5/FP-D16 for ARMv8"};
        -:16610:static const char *const arm_attr_tag_WMMX_arch[] = {"No", "WMMXv1", "WMMXv2"};
        -:16611:static const char *const arm_attr_tag_Advanced_SIMD_arch[] =
        -:16612:  {"No", "NEONv1", "NEONv1 with Fused-MAC", "NEON for ARMv8",
        -:16613:   "NEON for ARMv8.1"};
        -:16614:static const char *const arm_attr_tag_PCS_config[] =
        -:16615:  {"None", "Bare platform", "Linux application", "Linux DSO", "PalmOS 2004",
        -:16616:   "PalmOS (reserved)", "SymbianOS 2004", "SymbianOS (reserved)"};
        -:16617:static const char *const arm_attr_tag_ABI_PCS_R9_use[] =
        -:16618:  {"V6", "SB", "TLS", "Unused"};
        -:16619:static const char *const arm_attr_tag_ABI_PCS_RW_data[] =
        -:16620:  {"Absolute", "PC-relative", "SB-relative", "None"};
        -:16621:static const char *const arm_attr_tag_ABI_PCS_RO_data[] =
        -:16622:  {"Absolute", "PC-relative", "None"};
        -:16623:static const char *const arm_attr_tag_ABI_PCS_GOT_use[] =
        -:16624:  {"None", "direct", "GOT-indirect"};
        -:16625:static const char *const arm_attr_tag_ABI_PCS_wchar_t[] =
        -:16626:  {"None", "??? 1", "2", "??? 3", "4"};
        -:16627:static const char *const arm_attr_tag_ABI_FP_rounding[] = {"Unused", "Needed"};
        -:16628:static const char *const arm_attr_tag_ABI_FP_denormal[] =
        -:16629:  {"Unused", "Needed", "Sign only"};
        -:16630:static const char *const arm_attr_tag_ABI_FP_exceptions[] = {"Unused", "Needed"};
        -:16631:static const char *const arm_attr_tag_ABI_FP_user_exceptions[] = {"Unused", "Needed"};
        -:16632:static const char *const arm_attr_tag_ABI_FP_number_model[] =
        -:16633:  {"Unused", "Finite", "RTABI", "IEEE 754"};
        -:16634:static const char *const arm_attr_tag_ABI_enum_size[] =
        -:16635:  {"Unused", "small", "int", "forced to int"};
        -:16636:static const char *const arm_attr_tag_ABI_HardFP_use[] =
        -:16637:  {"As Tag_FP_arch", "SP only", "Reserved", "Deprecated"};
        -:16638:static const char *const arm_attr_tag_ABI_VFP_args[] =
        -:16639:  {"AAPCS", "VFP registers", "custom", "compatible"};
        -:16640:static const char *const arm_attr_tag_ABI_WMMX_args[] =
        -:16641:  {"AAPCS", "WMMX registers", "custom"};
        -:16642:static const char *const arm_attr_tag_ABI_optimization_goals[] =
        -:16643:  {"None", "Prefer Speed", "Aggressive Speed", "Prefer Size",
        -:16644:    "Aggressive Size", "Prefer Debug", "Aggressive Debug"};
        -:16645:static const char *const arm_attr_tag_ABI_FP_optimization_goals[] =
        -:16646:  {"None", "Prefer Speed", "Aggressive Speed", "Prefer Size",
        -:16647:    "Aggressive Size", "Prefer Accuracy", "Aggressive Accuracy"};
        -:16648:static const char *const arm_attr_tag_CPU_unaligned_access[] = {"None", "v6"};
        -:16649:static const char *const arm_attr_tag_FP_HP_extension[] =
        -:16650:  {"Not Allowed", "Allowed"};
        -:16651:static const char *const arm_attr_tag_ABI_FP_16bit_format[] =
        -:16652:  {"None", "IEEE 754", "Alternative Format"};
        -:16653:static const char *const arm_attr_tag_DSP_extension[] =
        -:16654:  {"Follow architecture", "Allowed"};
        -:16655:static const char *const arm_attr_tag_MPextension_use[] =
        -:16656:  {"Not Allowed", "Allowed"};
        -:16657:static const char *const arm_attr_tag_DIV_use[] =
        -:16658:  {"Allowed in Thumb-ISA, v7-R or v7-M", "Not allowed",
        -:16659:    "Allowed in v7-A with integer division extension"};
        -:16660:static const char *const arm_attr_tag_T2EE_use[] = {"Not Allowed", "Allowed"};
        -:16661:static const char *const arm_attr_tag_Virtualization_use[] =
        -:16662:  {"Not Allowed", "TrustZone", "Virtualization Extensions",
        -:16663:    "TrustZone and Virtualization Extensions"};
        -:16664:static const char *const arm_attr_tag_MPextension_use_legacy[] =
        -:16665:  {"Not Allowed", "Allowed"};
        -:16666:
        -:16667:static const char *const arm_attr_tag_MVE_arch[] =
        -:16668:  {"No MVE", "MVE Integer only", "MVE Integer and FP"};
        -:16669:
        -:16670:static const char * arm_attr_tag_PAC_extension[] =
        -:16671:  {"No PAC/AUT instructions",
        -:16672:   "PAC/AUT instructions permitted in the NOP space",
        -:16673:   "PAC/AUT instructions permitted in the NOP and in the non-NOP space"};
        -:16674:
        -:16675:static const char * arm_attr_tag_BTI_extension[] =
        -:16676:  {"BTI instructions not permitted",
        -:16677:   "BTI instructions permitted in the NOP space",
        -:16678:   "BTI instructions permitted in the NOP and in the non-NOP space"};
        -:16679:
        -:16680:static const char * arm_attr_tag_BTI_use[] =
        -:16681:  {"Compiled without branch target enforcement",
        -:16682:   "Compiled with branch target enforcement"};
        -:16683:
        -:16684:static const char * arm_attr_tag_PACRET_use[] =
        -:16685:  {"Compiled without return address signing and authentication",
        -:16686:   "Compiled with return address signing and authentication"};
        -:16687:
        -:16688:#define LOOKUP(id, name) \
        -:16689:  {id, #name, 0x80 | ARRAY_SIZE(arm_attr_tag_##name), arm_attr_tag_##name}
        -:16690:static arm_attr_public_tag arm_attr_public_tags[] =
        -:16691:{
        -:16692:  {4, "CPU_raw_name", 1, NULL},
        -:16693:  {5, "CPU_name", 1, NULL},
        -:16694:  LOOKUP(6, CPU_arch),
        -:16695:  {7, "CPU_arch_profile", 0, NULL},
        -:16696:  LOOKUP(8, ARM_ISA_use),
        -:16697:  LOOKUP(9, THUMB_ISA_use),
        -:16698:  LOOKUP(10, FP_arch),
        -:16699:  LOOKUP(11, WMMX_arch),
        -:16700:  LOOKUP(12, Advanced_SIMD_arch),
        -:16701:  LOOKUP(13, PCS_config),
        -:16702:  LOOKUP(14, ABI_PCS_R9_use),
        -:16703:  LOOKUP(15, ABI_PCS_RW_data),
        -:16704:  LOOKUP(16, ABI_PCS_RO_data),
        -:16705:  LOOKUP(17, ABI_PCS_GOT_use),
        -:16706:  LOOKUP(18, ABI_PCS_wchar_t),
        -:16707:  LOOKUP(19, ABI_FP_rounding),
        -:16708:  LOOKUP(20, ABI_FP_denormal),
        -:16709:  LOOKUP(21, ABI_FP_exceptions),
        -:16710:  LOOKUP(22, ABI_FP_user_exceptions),
        -:16711:  LOOKUP(23, ABI_FP_number_model),
        -:16712:  {24, "ABI_align_needed", 0, NULL},
        -:16713:  {25, "ABI_align_preserved", 0, NULL},
        -:16714:  LOOKUP(26, ABI_enum_size),
        -:16715:  LOOKUP(27, ABI_HardFP_use),
        -:16716:  LOOKUP(28, ABI_VFP_args),
        -:16717:  LOOKUP(29, ABI_WMMX_args),
        -:16718:  LOOKUP(30, ABI_optimization_goals),
        -:16719:  LOOKUP(31, ABI_FP_optimization_goals),
        -:16720:  {32, "compatibility", 0, NULL},
        -:16721:  LOOKUP(34, CPU_unaligned_access),
        -:16722:  LOOKUP(36, FP_HP_extension),
        -:16723:  LOOKUP(38, ABI_FP_16bit_format),
        -:16724:  LOOKUP(42, MPextension_use),
        -:16725:  LOOKUP(44, DIV_use),
        -:16726:  LOOKUP(46, DSP_extension),
        -:16727:  LOOKUP(48, MVE_arch),
        -:16728:  LOOKUP(50, PAC_extension),
        -:16729:  LOOKUP(52, BTI_extension),
        -:16730:  LOOKUP(74, BTI_use),
        -:16731:  LOOKUP(76, PACRET_use),
        -:16732:  {64, "nodefaults", 0, NULL},
        -:16733:  {65, "also_compatible_with", 0, NULL},
        -:16734:  LOOKUP(66, T2EE_use),
        -:16735:  {67, "conformance", 1, NULL},
        -:16736:  LOOKUP(68, Virtualization_use),
        -:16737:  LOOKUP(70, MPextension_use_legacy)
        -:16738:};
        -:16739:#undef LOOKUP
        -:16740:
        -:16741:static unsigned char *
    #####:16742:display_arm_attribute (unsigned char * p,
        -:16743:		       const unsigned char * const end)
        -:16744:{
        -:16745:  unsigned int tag;
        -:16746:  unsigned int val;
        -:16747:  arm_attr_public_tag * attr;
        -:16748:  unsigned i;
        -:16749:  unsigned int type;
        -:16750:
    #####:16751:  READ_ULEB (tag, p, end);
    #####:16752:  attr = NULL;
    #####:16753:  for (i = 0; i < ARRAY_SIZE (arm_attr_public_tags); i++)
        -:16754:    {
    #####:16755:      if (arm_attr_public_tags[i].tag == tag)
        -:16756:	{
    #####:16757:	  attr = &arm_attr_public_tags[i];
    #####:16758:	  break;
        -:16759:	}
        -:16760:    }
        -:16761:
    #####:16762:  if (attr)
        -:16763:    {
    #####:16764:      printf ("  Tag_%s: ", attr->name);
    #####:16765:      switch (attr->type)
        -:16766:	{
    #####:16767:	case 0:
        -:16768:	  switch (tag)
        -:16769:	    {
    #####:16770:	    case 7: /* Tag_CPU_arch_profile.  */
    #####:16771:	      READ_ULEB (val, p, end);
        -:16772:	      switch (val)
        -:16773:		{
    #####:16774:		case 0: printf (_("None\n")); break;
    #####:16775:		case 'A': printf (_("Application\n")); break;
    #####:16776:		case 'R': printf (_("Realtime\n")); break;
    #####:16777:		case 'M': printf (_("Microcontroller\n")); break;
    #####:16778:		case 'S': printf (_("Application or Realtime\n")); break;
    #####:16779:		default: printf ("??? (%d)\n", val); break;
        -:16780:		}
    #####:16781:	      break;
        -:16782:
    #####:16783:	    case 24: /* Tag_align_needed.  */
    #####:16784:	      READ_ULEB (val, p, end);
        -:16785:	      switch (val)
        -:16786:		{
    #####:16787:		case 0: printf (_("None\n")); break;
    #####:16788:		case 1: printf (_("8-byte\n")); break;
    #####:16789:		case 2: printf (_("4-byte\n")); break;
    #####:16790:		case 3: printf ("??? 3\n"); break;
    #####:16791:		default:
    #####:16792:		  if (val <= 12)
    #####:16793:		    printf (_("8-byte and up to %d-byte extended\n"),
        -:16794:			    1 << val);
        -:16795:		  else
    #####:16796:		    printf ("??? (%d)\n", val);
    #####:16797:		  break;
        -:16798:		}
    #####:16799:	      break;
        -:16800:
    #####:16801:	    case 25: /* Tag_align_preserved.  */
    #####:16802:	      READ_ULEB (val, p, end);
        -:16803:	      switch (val)
        -:16804:		{
    #####:16805:		case 0: printf (_("None\n")); break;
    #####:16806:		case 1: printf (_("8-byte, except leaf SP\n")); break;
    #####:16807:		case 2: printf (_("8-byte\n")); break;
    #####:16808:		case 3: printf ("??? 3\n"); break;
    #####:16809:		default:
    #####:16810:		  if (val <= 12)
    #####:16811:		    printf (_("8-byte and up to %d-byte extended\n"),
        -:16812:			    1 << val);
        -:16813:		  else
    #####:16814:		    printf ("??? (%d)\n", val);
    #####:16815:		  break;
        -:16816:		}
    #####:16817:	      break;
        -:16818:
    #####:16819:	    case 32: /* Tag_compatibility.  */
        -:16820:	      {
    #####:16821:		READ_ULEB (val, p, end);
    #####:16822:		printf (_("flag = %d, vendor = "), val);
    #####:16823:		if (p < end - 1)
        -:16824:		  {
    #####:16825:		    size_t maxlen = (end - p) - 1;
        -:16826:
    #####:16827:		    print_symbol ((int) maxlen, (const char *) p);
    #####:16828:		    p += strnlen ((char *) p, maxlen) + 1;
        -:16829:		  }
        -:16830:		else
        -:16831:		  {
    #####:16832:		    printf (_("<corrupt>"));
    #####:16833:		    p = (unsigned char *) end;
        -:16834:		  }
    #####:16835:		putchar ('\n');
        -:16836:	      }
    #####:16837:	      break;
        -:16838:
    #####:16839:	    case 64: /* Tag_nodefaults.  */
        -:16840:	      /* PR 17531: file: 001-505008-0.01.  */
    #####:16841:	      if (p < end)
    #####:16842:		p++;
    #####:16843:	      printf (_("True\n"));
    #####:16844:	      break;
        -:16845:
    #####:16846:	    case 65: /* Tag_also_compatible_with.  */
    #####:16847:	      READ_ULEB (val, p, end);
    #####:16848:	      if (val == 6 /* Tag_CPU_arch.  */)
        -:16849:		{
    #####:16850:		  READ_ULEB (val, p, end);
    #####:16851:		  if ((unsigned int) val >= ARRAY_SIZE (arm_attr_tag_CPU_arch))
    #####:16852:		    printf ("??? (%d)\n", val);
        -:16853:		  else
    #####:16854:		    printf ("%s\n", arm_attr_tag_CPU_arch[val]);
        -:16855:		}
        -:16856:	      else
    #####:16857:		printf ("???\n");
    #####:16858:	      while (p < end && *(p++) != '\0' /* NUL terminator.  */)
        -:16859:		;
    #####:16860:	      break;
        -:16861:
    #####:16862:	    default:
    #####:16863:	      printf (_("<unknown: %d>\n"), tag);
    #####:16864:	      break;
        -:16865:	    }
    #####:16866:	  return p;
        -:16867:
    #####:16868:	case 1:
    #####:16869:	  return display_tag_value (-1, p, end);
    #####:16870:	case 2:
    #####:16871:	  return display_tag_value (0, p, end);
        -:16872:
    #####:16873:	default:
    #####:16874:	  assert (attr->type & 0x80);
    #####:16875:	  READ_ULEB (val, p, end);
    #####:16876:	  type = attr->type & 0x7f;
    #####:16877:	  if (val >= type)
    #####:16878:	    printf ("??? (%d)\n", val);
        -:16879:	  else
    #####:16880:	    printf ("%s\n", attr->table[val]);
    #####:16881:	  return p;
        -:16882:	}
        -:16883:    }
        -:16884:
    #####:16885:  return display_tag_value (tag, p, end);
        -:16886:}
        -:16887:
        -:16888:static unsigned char *
    #####:16889:display_gnu_attribute (unsigned char * p,
        -:16890:		       unsigned char * (* display_proc_gnu_attribute) (unsigned char *, unsigned int, const unsigned char * const),
        -:16891:		       const unsigned char * const end)
        -:16892:{
        -:16893:  unsigned int tag;
        -:16894:  unsigned int val;
        -:16895:
    #####:16896:  READ_ULEB (tag, p, end);
        -:16897:
        -:16898:  /* Tag_compatibility is the only generic GNU attribute defined at
        -:16899:     present.  */
    #####:16900:  if (tag == 32)
        -:16901:    {
    #####:16902:      READ_ULEB (val, p, end);
        -:16903:
    #####:16904:      printf (_("flag = %d, vendor = "), val);
    #####:16905:      if (p == end)
        -:16906:	{
    #####:16907:	  printf (_("<corrupt>\n"));
    #####:16908:	  warn (_("corrupt vendor attribute\n"));
        -:16909:	}
        -:16910:      else
        -:16911:	{
    #####:16912:	  if (p < end - 1)
        -:16913:	    {
    #####:16914:	      size_t maxlen = (end - p) - 1;
        -:16915:
    #####:16916:	      print_symbol ((int) maxlen, (const char *) p);
    #####:16917:	      p += strnlen ((char *) p, maxlen) + 1;
        -:16918:	    }
        -:16919:	  else
        -:16920:	    {
    #####:16921:	      printf (_("<corrupt>"));
    #####:16922:	      p = (unsigned char *) end;
        -:16923:	    }
    #####:16924:	  putchar ('\n');
        -:16925:	}
    #####:16926:      return p;
        -:16927:    }
        -:16928:
    #####:16929:  if ((tag & 2) == 0 && display_proc_gnu_attribute)
    #####:16930:    return display_proc_gnu_attribute (p, tag, end);
        -:16931:
    #####:16932:  return display_tag_value (tag, p, end);
        -:16933:}
        -:16934:
        -:16935:static unsigned char *
    #####:16936:display_m68k_gnu_attribute (unsigned char * p,
        -:16937:			    unsigned int tag,
        -:16938:			    const unsigned char * const end)
        -:16939:{
        -:16940:  unsigned int val;
        -:16941:
    #####:16942:  if (tag == Tag_GNU_M68K_ABI_FP)
        -:16943:    {
    #####:16944:      printf ("  Tag_GNU_M68K_ABI_FP: ");
    #####:16945:      if (p == end)
        -:16946:	{
    #####:16947:	  printf (_("<corrupt>\n"));
    #####:16948:	  return p;
        -:16949:	}
    #####:16950:      READ_ULEB (val, p, end);
        -:16951:
    #####:16952:      if (val > 3)
    #####:16953:	printf ("(%#x), ", val);
        -:16954:
    #####:16955:      switch (val & 3)
        -:16956:	{
    #####:16957:	case 0:
    #####:16958:	  printf (_("unspecified hard/soft float\n"));
    #####:16959:	  break;
    #####:16960:	case 1:
    #####:16961:	  printf (_("hard float\n"));
    #####:16962:	  break;
    #####:16963:	case 2:
    #####:16964:	  printf (_("soft float\n"));
    #####:16965:	  break;
        -:16966:	}
    #####:16967:      return p;
        -:16968:    }
        -:16969:
    #####:16970:  return display_tag_value (tag & 1, p, end);
        -:16971:}
        -:16972:
        -:16973:static unsigned char *
    #####:16974:display_power_gnu_attribute (unsigned char * p,
        -:16975:			     unsigned int tag,
        -:16976:			     const unsigned char * const end)
        -:16977:{
        -:16978:  unsigned int val;
        -:16979:
    #####:16980:  if (tag == Tag_GNU_Power_ABI_FP)
        -:16981:    {
    #####:16982:      printf ("  Tag_GNU_Power_ABI_FP: ");
    #####:16983:      if (p == end)
        -:16984:	{
    #####:16985:	  printf (_("<corrupt>\n"));
    #####:16986:	  return p;
        -:16987:	}
    #####:16988:      READ_ULEB (val, p, end);
        -:16989:
    #####:16990:      if (val > 15)
    #####:16991:	printf ("(%#x), ", val);
        -:16992:
    #####:16993:      switch (val & 3)
        -:16994:	{
    #####:16995:	case 0:
    #####:16996:	  printf (_("unspecified hard/soft float, "));
    #####:16997:	  break;
    #####:16998:	case 1:
    #####:16999:	  printf (_("hard float, "));
    #####:17000:	  break;
    #####:17001:	case 2:
    #####:17002:	  printf (_("soft float, "));
    #####:17003:	  break;
    #####:17004:	case 3:
    #####:17005:	  printf (_("single-precision hard float, "));
    #####:17006:	  break;
        -:17007:	}
        -:17008:
    #####:17009:      switch (val & 0xC)
        -:17010:	{
    #####:17011:	case 0:
    #####:17012:	  printf (_("unspecified long double\n"));
    #####:17013:	  break;
    #####:17014:	case 4:
    #####:17015:	  printf (_("128-bit IBM long double\n"));
    #####:17016:	  break;
    #####:17017:	case 8:
    #####:17018:	  printf (_("64-bit long double\n"));
    #####:17019:	  break;
    #####:17020:	case 12:
    #####:17021:	  printf (_("128-bit IEEE long double\n"));
    #####:17022:	  break;
        -:17023:	}
    #####:17024:      return p;
        -:17025:    }
        -:17026:
    #####:17027:  if (tag == Tag_GNU_Power_ABI_Vector)
        -:17028:    {
    #####:17029:      printf ("  Tag_GNU_Power_ABI_Vector: ");
    #####:17030:      if (p == end)
        -:17031:	{
    #####:17032:	  printf (_("<corrupt>\n"));
    #####:17033:	  return p;
        -:17034:	}
    #####:17035:      READ_ULEB (val, p, end);
        -:17036:
    #####:17037:      if (val > 3)
    #####:17038:	printf ("(%#x), ", val);
        -:17039:
    #####:17040:      switch (val & 3)
        -:17041:	{
    #####:17042:	case 0:
    #####:17043:	  printf (_("unspecified\n"));
    #####:17044:	  break;
    #####:17045:	case 1:
    #####:17046:	  printf (_("generic\n"));
    #####:17047:	  break;
    #####:17048:	case 2:
    #####:17049:	  printf ("AltiVec\n");
    #####:17050:	  break;
    #####:17051:	case 3:
    #####:17052:	  printf ("SPE\n");
    #####:17053:	  break;
        -:17054:	}
    #####:17055:      return p;
        -:17056:    }
        -:17057:
    #####:17058:  if (tag == Tag_GNU_Power_ABI_Struct_Return)
        -:17059:    {
    #####:17060:      printf ("  Tag_GNU_Power_ABI_Struct_Return: ");
    #####:17061:      if (p == end)
        -:17062:	{
    #####:17063:	  printf (_("<corrupt>\n"));
    #####:17064:	  return p;
        -:17065:	}
    #####:17066:      READ_ULEB (val, p, end);
        -:17067:
    #####:17068:      if (val > 2)
    #####:17069:	printf ("(%#x), ", val);
        -:17070:
    #####:17071:      switch (val & 3)
        -:17072:	{
    #####:17073:	case 0:
    #####:17074:	  printf (_("unspecified\n"));
    #####:17075:	  break;
    #####:17076:	case 1:
    #####:17077:	  printf ("r3/r4\n");
    #####:17078:	  break;
    #####:17079:	case 2:
    #####:17080:	  printf (_("memory\n"));
    #####:17081:	  break;
    #####:17082:	case 3:
    #####:17083:	  printf ("???\n");
    #####:17084:	  break;
        -:17085:	}
    #####:17086:      return p;
        -:17087:    }
        -:17088:
    #####:17089:  return display_tag_value (tag & 1, p, end);
        -:17090:}
        -:17091:
        -:17092:static unsigned char *
    #####:17093:display_s390_gnu_attribute (unsigned char * p,
        -:17094:			    unsigned int tag,
        -:17095:			    const unsigned char * const end)
        -:17096:{
        -:17097:  unsigned int val;
        -:17098:
    #####:17099:  if (tag == Tag_GNU_S390_ABI_Vector)
        -:17100:    {
    #####:17101:      printf ("  Tag_GNU_S390_ABI_Vector: ");
    #####:17102:      READ_ULEB (val, p, end);
        -:17103:
    #####:17104:      switch (val)
        -:17105:	{
    #####:17106:	case 0:
    #####:17107:	  printf (_("any\n"));
    #####:17108:	  break;
    #####:17109:	case 1:
    #####:17110:	  printf (_("software\n"));
    #####:17111:	  break;
    #####:17112:	case 2:
    #####:17113:	  printf (_("hardware\n"));
    #####:17114:	  break;
    #####:17115:	default:
    #####:17116:	  printf ("??? (%d)\n", val);
    #####:17117:	  break;
        -:17118:	}
    #####:17119:      return p;
        -:17120:   }
        -:17121:
    #####:17122:  return display_tag_value (tag & 1, p, end);
        -:17123:}
        -:17124:
        -:17125:static void
    #####:17126:display_sparc_hwcaps (unsigned int mask)
        -:17127:{
    #####:17128:  if (mask)
        -:17129:    {
    #####:17130:      bool first = true;
        -:17131:
    #####:17132:      if (mask & ELF_SPARC_HWCAP_MUL32)
    #####:17133:	fputs ("mul32", stdout), first = false;
    #####:17134:      if (mask & ELF_SPARC_HWCAP_DIV32)
    #####:17135:	printf ("%sdiv32", first ? "" : "|"), first = false;
    #####:17136:      if (mask & ELF_SPARC_HWCAP_FSMULD)
    #####:17137:	printf ("%sfsmuld", first ? "" : "|"), first = false;
    #####:17138:      if (mask & ELF_SPARC_HWCAP_V8PLUS)
    #####:17139:	printf ("%sv8plus", first ? "" : "|"), first = false;
    #####:17140:      if (mask & ELF_SPARC_HWCAP_POPC)
    #####:17141:	printf ("%spopc", first ? "" : "|"), first = false;
    #####:17142:      if (mask & ELF_SPARC_HWCAP_VIS)
    #####:17143:	printf ("%svis", first ? "" : "|"), first = false;
    #####:17144:      if (mask & ELF_SPARC_HWCAP_VIS2)
    #####:17145:	printf ("%svis2", first ? "" : "|"), first = false;
    #####:17146:      if (mask & ELF_SPARC_HWCAP_ASI_BLK_INIT)
    #####:17147:	printf ("%sASIBlkInit", first ? "" : "|"), first = false;
    #####:17148:      if (mask & ELF_SPARC_HWCAP_FMAF)
    #####:17149:	printf ("%sfmaf", first ? "" : "|"), first = false;
    #####:17150:      if (mask & ELF_SPARC_HWCAP_VIS3)
    #####:17151:	printf ("%svis3", first ? "" : "|"), first = false;
    #####:17152:      if (mask & ELF_SPARC_HWCAP_HPC)
    #####:17153:	printf ("%shpc", first ? "" : "|"), first = false;
    #####:17154:      if (mask & ELF_SPARC_HWCAP_RANDOM)
    #####:17155:	printf ("%srandom", first ? "" : "|"), first = false;
    #####:17156:      if (mask & ELF_SPARC_HWCAP_TRANS)
    #####:17157:	printf ("%strans", first ? "" : "|"), first = false;
    #####:17158:      if (mask & ELF_SPARC_HWCAP_FJFMAU)
    #####:17159:	printf ("%sfjfmau", first ? "" : "|"), first = false;
    #####:17160:      if (mask & ELF_SPARC_HWCAP_IMA)
    #####:17161:	printf ("%sima", first ? "" : "|"), first = false;
    #####:17162:      if (mask & ELF_SPARC_HWCAP_ASI_CACHE_SPARING)
    #####:17163:	printf ("%scspare", first ? "" : "|"), first = false;
        -:17164:    }
        -:17165:  else
    #####:17166:    fputc ('0', stdout);
    #####:17167:  fputc ('\n', stdout);
    #####:17168:}
        -:17169:
        -:17170:static void
    #####:17171:display_sparc_hwcaps2 (unsigned int mask)
        -:17172:{
    #####:17173:  if (mask)
        -:17174:    {
    #####:17175:      bool first = true;
        -:17176:
    #####:17177:      if (mask & ELF_SPARC_HWCAP2_FJATHPLUS)
    #####:17178:	fputs ("fjathplus", stdout), first = false;
    #####:17179:      if (mask & ELF_SPARC_HWCAP2_VIS3B)
    #####:17180:	printf ("%svis3b", first ? "" : "|"), first = false;
    #####:17181:      if (mask & ELF_SPARC_HWCAP2_ADP)
    #####:17182:	printf ("%sadp", first ? "" : "|"), first = false;
    #####:17183:      if (mask & ELF_SPARC_HWCAP2_SPARC5)
    #####:17184:	printf ("%ssparc5", first ? "" : "|"), first = false;
    #####:17185:      if (mask & ELF_SPARC_HWCAP2_MWAIT)
    #####:17186:	printf ("%smwait", first ? "" : "|"), first = false;
    #####:17187:      if (mask & ELF_SPARC_HWCAP2_XMPMUL)
    #####:17188:	printf ("%sxmpmul", first ? "" : "|"), first = false;
    #####:17189:      if (mask & ELF_SPARC_HWCAP2_XMONT)
    #####:17190:	printf ("%sxmont2", first ? "" : "|"), first = false;
    #####:17191:      if (mask & ELF_SPARC_HWCAP2_NSEC)
    #####:17192:	printf ("%snsec", first ? "" : "|"), first = false;
    #####:17193:      if (mask & ELF_SPARC_HWCAP2_FJATHHPC)
    #####:17194:	printf ("%sfjathhpc", first ? "" : "|"), first = false;
    #####:17195:      if (mask & ELF_SPARC_HWCAP2_FJDES)
    #####:17196:	printf ("%sfjdes", first ? "" : "|"), first = false;
    #####:17197:      if (mask & ELF_SPARC_HWCAP2_FJAES)
    #####:17198:	printf ("%sfjaes", first ? "" : "|"), first = false;
        -:17199:    }
        -:17200:  else
    #####:17201:    fputc ('0', stdout);
    #####:17202:  fputc ('\n', stdout);
    #####:17203:}
        -:17204:
        -:17205:static unsigned char *
    #####:17206:display_sparc_gnu_attribute (unsigned char * p,
        -:17207:			     unsigned int tag,
        -:17208:			     const unsigned char * const end)
        -:17209:{
        -:17210:  unsigned int val;
        -:17211:
    #####:17212:  if (tag == Tag_GNU_Sparc_HWCAPS)
        -:17213:    {
    #####:17214:      READ_ULEB (val, p, end);
    #####:17215:      printf ("  Tag_GNU_Sparc_HWCAPS: ");
    #####:17216:      display_sparc_hwcaps (val);
    #####:17217:      return p;
        -:17218:    }
    #####:17219:  if (tag == Tag_GNU_Sparc_HWCAPS2)
        -:17220:    {
    #####:17221:      READ_ULEB (val, p, end);
    #####:17222:      printf ("  Tag_GNU_Sparc_HWCAPS2: ");
    #####:17223:      display_sparc_hwcaps2 (val);
    #####:17224:      return p;
        -:17225:    }
        -:17226:
    #####:17227:  return display_tag_value (tag, p, end);
        -:17228:}
        -:17229:
        -:17230:static void
    #####:17231:print_mips_fp_abi_value (unsigned int val)
        -:17232:{
    #####:17233:  switch (val)
        -:17234:    {
    #####:17235:    case Val_GNU_MIPS_ABI_FP_ANY:
    #####:17236:      printf (_("Hard or soft float\n"));
    #####:17237:      break;
    #####:17238:    case Val_GNU_MIPS_ABI_FP_DOUBLE:
    #####:17239:      printf (_("Hard float (double precision)\n"));
    #####:17240:      break;
    #####:17241:    case Val_GNU_MIPS_ABI_FP_SINGLE:
    #####:17242:      printf (_("Hard float (single precision)\n"));
    #####:17243:      break;
    #####:17244:    case Val_GNU_MIPS_ABI_FP_SOFT:
    #####:17245:      printf (_("Soft float\n"));
    #####:17246:      break;
    #####:17247:    case Val_GNU_MIPS_ABI_FP_OLD_64:
    #####:17248:      printf (_("Hard float (MIPS32r2 64-bit FPU 12 callee-saved)\n"));
    #####:17249:      break;
    #####:17250:    case Val_GNU_MIPS_ABI_FP_XX:
    #####:17251:      printf (_("Hard float (32-bit CPU, Any FPU)\n"));
    #####:17252:      break;
    #####:17253:    case Val_GNU_MIPS_ABI_FP_64:
    #####:17254:      printf (_("Hard float (32-bit CPU, 64-bit FPU)\n"));
    #####:17255:      break;
    #####:17256:    case Val_GNU_MIPS_ABI_FP_64A:
    #####:17257:      printf (_("Hard float compat (32-bit CPU, 64-bit FPU)\n"));
    #####:17258:      break;
    #####:17259:    case Val_GNU_MIPS_ABI_FP_NAN2008:
    #####:17260:      printf (_("NaN 2008 compatibility\n"));
    #####:17261:      break;
    #####:17262:    default:
    #####:17263:      printf ("??? (%d)\n", val);
    #####:17264:      break;
        -:17265:    }
    #####:17266:}
        -:17267:
        -:17268:static unsigned char *
    #####:17269:display_mips_gnu_attribute (unsigned char * p,
        -:17270:			    unsigned int tag,
        -:17271:			    const unsigned char * const end)
        -:17272:{
    #####:17273:  if (tag == Tag_GNU_MIPS_ABI_FP)
        -:17274:    {
        -:17275:      unsigned int val;
        -:17276:
    #####:17277:      printf ("  Tag_GNU_MIPS_ABI_FP: ");
    #####:17278:      READ_ULEB (val, p, end);
    #####:17279:      print_mips_fp_abi_value (val);
    #####:17280:      return p;
        -:17281:   }
        -:17282:
    #####:17283:  if (tag == Tag_GNU_MIPS_ABI_MSA)
        -:17284:    {
        -:17285:      unsigned int val;
        -:17286:
    #####:17287:      printf ("  Tag_GNU_MIPS_ABI_MSA: ");
    #####:17288:      READ_ULEB (val, p, end);
        -:17289:
    #####:17290:      switch (val)
        -:17291:	{
    #####:17292:	case Val_GNU_MIPS_ABI_MSA_ANY:
    #####:17293:	  printf (_("Any MSA or not\n"));
    #####:17294:	  break;
    #####:17295:	case Val_GNU_MIPS_ABI_MSA_128:
    #####:17296:	  printf (_("128-bit MSA\n"));
    #####:17297:	  break;
    #####:17298:	default:
    #####:17299:	  printf ("??? (%d)\n", val);
    #####:17300:	  break;
        -:17301:	}
    #####:17302:      return p;
        -:17303:    }
        -:17304:
    #####:17305:  return display_tag_value (tag & 1, p, end);
        -:17306:}
        -:17307:
        -:17308:static unsigned char *
    #####:17309:display_tic6x_attribute (unsigned char * p,
        -:17310:			 const unsigned char * const end)
        -:17311:{
        -:17312:  unsigned int tag;
        -:17313:  unsigned int val;
        -:17314:
    #####:17315:  READ_ULEB (tag, p, end);
        -:17316:
    #####:17317:  switch (tag)
        -:17318:    {
    #####:17319:    case Tag_ISA:
    #####:17320:      printf ("  Tag_ISA: ");
    #####:17321:      READ_ULEB (val, p, end);
        -:17322:
        -:17323:      switch (val)
        -:17324:	{
    #####:17325:	case C6XABI_Tag_ISA_none:
    #####:17326:	  printf (_("None\n"));
    #####:17327:	  break;
    #####:17328:	case C6XABI_Tag_ISA_C62X:
    #####:17329:	  printf ("C62x\n");
    #####:17330:	  break;
    #####:17331:	case C6XABI_Tag_ISA_C67X:
    #####:17332:	  printf ("C67x\n");
    #####:17333:	  break;
    #####:17334:	case C6XABI_Tag_ISA_C67XP:
    #####:17335:	  printf ("C67x+\n");
    #####:17336:	  break;
    #####:17337:	case C6XABI_Tag_ISA_C64X:
    #####:17338:	  printf ("C64x\n");
    #####:17339:	  break;
    #####:17340:	case C6XABI_Tag_ISA_C64XP:
    #####:17341:	  printf ("C64x+\n");
    #####:17342:	  break;
    #####:17343:	case C6XABI_Tag_ISA_C674X:
    #####:17344:	  printf ("C674x\n");
    #####:17345:	  break;
    #####:17346:	default:
    #####:17347:	  printf ("??? (%d)\n", val);
    #####:17348:	  break;
        -:17349:	}
    #####:17350:      return p;
        -:17351:
    #####:17352:    case Tag_ABI_wchar_t:
    #####:17353:      printf ("  Tag_ABI_wchar_t: ");
    #####:17354:      READ_ULEB (val, p, end);
        -:17355:      switch (val)
        -:17356:	{
    #####:17357:	case 0:
    #####:17358:	  printf (_("Not used\n"));
    #####:17359:	  break;
    #####:17360:	case 1:
    #####:17361:	  printf (_("2 bytes\n"));
    #####:17362:	  break;
    #####:17363:	case 2:
    #####:17364:	  printf (_("4 bytes\n"));
    #####:17365:	  break;
    #####:17366:	default:
    #####:17367:	  printf ("??? (%d)\n", val);
    #####:17368:	  break;
        -:17369:	}
    #####:17370:      return p;
        -:17371:
    #####:17372:    case Tag_ABI_stack_align_needed:
    #####:17373:      printf ("  Tag_ABI_stack_align_needed: ");
    #####:17374:      READ_ULEB (val, p, end);
        -:17375:      switch (val)
        -:17376:	{
    #####:17377:	case 0:
    #####:17378:	  printf (_("8-byte\n"));
    #####:17379:	  break;
    #####:17380:	case 1:
    #####:17381:	  printf (_("16-byte\n"));
    #####:17382:	  break;
    #####:17383:	default:
    #####:17384:	  printf ("??? (%d)\n", val);
    #####:17385:	  break;
        -:17386:	}
    #####:17387:      return p;
        -:17388:
    #####:17389:    case Tag_ABI_stack_align_preserved:
    #####:17390:      READ_ULEB (val, p, end);
    #####:17391:      printf ("  Tag_ABI_stack_align_preserved: ");
        -:17392:      switch (val)
        -:17393:	{
    #####:17394:	case 0:
    #####:17395:	  printf (_("8-byte\n"));
    #####:17396:	  break;
    #####:17397:	case 1:
    #####:17398:	  printf (_("16-byte\n"));
    #####:17399:	  break;
    #####:17400:	default:
    #####:17401:	  printf ("??? (%d)\n", val);
    #####:17402:	  break;
        -:17403:	}
    #####:17404:      return p;
        -:17405:
    #####:17406:    case Tag_ABI_DSBT:
    #####:17407:      READ_ULEB (val, p, end);
    #####:17408:      printf ("  Tag_ABI_DSBT: ");
        -:17409:      switch (val)
        -:17410:	{
    #####:17411:	case 0:
    #####:17412:	  printf (_("DSBT addressing not used\n"));
    #####:17413:	  break;
    #####:17414:	case 1:
    #####:17415:	  printf (_("DSBT addressing used\n"));
    #####:17416:	  break;
    #####:17417:	default:
    #####:17418:	  printf ("??? (%d)\n", val);
    #####:17419:	  break;
        -:17420:	}
    #####:17421:      return p;
        -:17422:
    #####:17423:    case Tag_ABI_PID:
    #####:17424:      READ_ULEB (val, p, end);
    #####:17425:      printf ("  Tag_ABI_PID: ");
        -:17426:      switch (val)
        -:17427:	{
    #####:17428:	case 0:
    #####:17429:	  printf (_("Data addressing position-dependent\n"));
    #####:17430:	  break;
    #####:17431:	case 1:
    #####:17432:	  printf (_("Data addressing position-independent, GOT near DP\n"));
    #####:17433:	  break;
    #####:17434:	case 2:
    #####:17435:	  printf (_("Data addressing position-independent, GOT far from DP\n"));
    #####:17436:	  break;
    #####:17437:	default:
    #####:17438:	  printf ("??? (%d)\n", val);
    #####:17439:	  break;
        -:17440:	}
    #####:17441:      return p;
        -:17442:
    #####:17443:    case Tag_ABI_PIC:
    #####:17444:      READ_ULEB (val, p, end);
    #####:17445:      printf ("  Tag_ABI_PIC: ");
        -:17446:      switch (val)
        -:17447:	{
    #####:17448:	case 0:
    #####:17449:	  printf (_("Code addressing position-dependent\n"));
    #####:17450:	  break;
    #####:17451:	case 1:
    #####:17452:	  printf (_("Code addressing position-independent\n"));
    #####:17453:	  break;
    #####:17454:	default:
    #####:17455:	  printf ("??? (%d)\n", val);
    #####:17456:	  break;
        -:17457:	}
    #####:17458:      return p;
        -:17459:
    #####:17460:    case Tag_ABI_array_object_alignment:
    #####:17461:      READ_ULEB (val, p, end);
    #####:17462:      printf ("  Tag_ABI_array_object_alignment: ");
        -:17463:      switch (val)
        -:17464:	{
    #####:17465:	case 0:
    #####:17466:	  printf (_("8-byte\n"));
    #####:17467:	  break;
    #####:17468:	case 1:
    #####:17469:	  printf (_("4-byte\n"));
    #####:17470:	  break;
    #####:17471:	case 2:
    #####:17472:	  printf (_("16-byte\n"));
    #####:17473:	  break;
    #####:17474:	default:
    #####:17475:	  printf ("??? (%d)\n", val);
    #####:17476:	  break;
        -:17477:	}
    #####:17478:      return p;
        -:17479:
    #####:17480:    case Tag_ABI_array_object_align_expected:
    #####:17481:      READ_ULEB (val, p, end);
    #####:17482:      printf ("  Tag_ABI_array_object_align_expected: ");
        -:17483:      switch (val)
        -:17484:	{
    #####:17485:	case 0:
    #####:17486:	  printf (_("8-byte\n"));
    #####:17487:	  break;
    #####:17488:	case 1:
    #####:17489:	  printf (_("4-byte\n"));
    #####:17490:	  break;
    #####:17491:	case 2:
    #####:17492:	  printf (_("16-byte\n"));
    #####:17493:	  break;
    #####:17494:	default:
    #####:17495:	  printf ("??? (%d)\n", val);
    #####:17496:	  break;
        -:17497:	}
    #####:17498:      return p;
        -:17499:
    #####:17500:    case Tag_ABI_compatibility:
        -:17501:      {
    #####:17502:	READ_ULEB (val, p, end);
    #####:17503:	printf ("  Tag_ABI_compatibility: ");
    #####:17504:	printf (_("flag = %d, vendor = "), val);
    #####:17505:	if (p < end - 1)
        -:17506:	  {
    #####:17507:	    size_t maxlen = (end - p) - 1;
        -:17508:
    #####:17509:	    print_symbol ((int) maxlen, (const char *) p);
    #####:17510:	    p += strnlen ((char *) p, maxlen) + 1;
        -:17511:	  }
        -:17512:	else
        -:17513:	  {
    #####:17514:	    printf (_("<corrupt>"));
    #####:17515:	    p = (unsigned char *) end;
        -:17516:	  }
    #####:17517:	putchar ('\n');
    #####:17518:	return p;
        -:17519:      }
        -:17520:
    #####:17521:    case Tag_ABI_conformance:
        -:17522:      {
    #####:17523:	printf ("  Tag_ABI_conformance: \"");
    #####:17524:	if (p < end - 1)
        -:17525:	  {
    #####:17526:	    size_t maxlen = (end - p) - 1;
        -:17527:
    #####:17528:	    print_symbol ((int) maxlen, (const char *) p);
    #####:17529:	    p += strnlen ((char *) p, maxlen) + 1;
        -:17530:	  }
        -:17531:	else
        -:17532:	  {
    #####:17533:	    printf (_("<corrupt>"));
    #####:17534:	    p = (unsigned char *) end;
        -:17535:	  }
    #####:17536:	printf ("\"\n");
    #####:17537:	return p;
        -:17538:      }
        -:17539:    }
        -:17540:
    #####:17541:  return display_tag_value (tag, p, end);
        -:17542:}
        -:17543:
        -:17544:static void
    #####:17545:display_raw_attribute (unsigned char * p, unsigned char const * const end)
        -:17546:{
    #####:17547:  unsigned long addr = 0;
    #####:17548:  size_t bytes = end - p;
        -:17549:
    #####:17550:  assert (end >= p);
    #####:17551:  while (bytes)
        -:17552:    {
        -:17553:      int j;
        -:17554:      int k;
    #####:17555:      int lbytes = (bytes > 16 ? 16 : bytes);
        -:17556:
    #####:17557:      printf ("  0x%8.8lx ", addr);
        -:17558:
    #####:17559:      for (j = 0; j < 16; j++)
        -:17560:	{
    #####:17561:	  if (j < lbytes)
    #####:17562:	    printf ("%2.2x", p[j]);
        -:17563:	  else
    #####:17564:	    printf ("  ");
        -:17565:
    #####:17566:	  if ((j & 3) == 3)
    #####:17567:	    printf (" ");
        -:17568:	}
        -:17569:
    #####:17570:      for (j = 0; j < lbytes; j++)
        -:17571:	{
    #####:17572:	  k = p[j];
    #####:17573:	  if (k >= ' ' && k < 0x7f)
    #####:17574:	    printf ("%c", k);
        -:17575:	  else
    #####:17576:	    printf (".");
        -:17577:	}
        -:17578:
    #####:17579:      putchar ('\n');
        -:17580:
    #####:17581:      p  += lbytes;
    #####:17582:      bytes -= lbytes;
    #####:17583:      addr += lbytes;
        -:17584:    }
        -:17585:
    #####:17586:  putchar ('\n');
    #####:17587:}
        -:17588:
        -:17589:static unsigned char *
    #####:17590:display_msp430_attribute (unsigned char * p,
        -:17591:			   const unsigned char * const end)
        -:17592:{
        -:17593:  unsigned int val;
        -:17594:  unsigned int tag;
        -:17595:
    #####:17596:  READ_ULEB (tag, p, end);
        -:17597:
    #####:17598:  switch (tag)
        -:17599:    {
    #####:17600:    case OFBA_MSPABI_Tag_ISA:
    #####:17601:      printf ("  Tag_ISA: ");
    #####:17602:      READ_ULEB (val, p, end);
        -:17603:      switch (val)
        -:17604:	{
    #####:17605:	case 0: printf (_("None\n")); break;
    #####:17606:	case 1: printf (_("MSP430\n")); break;
    #####:17607:	case 2: printf (_("MSP430X\n")); break;
    #####:17608:	default: printf ("??? (%d)\n", val); break;
        -:17609:	}
    #####:17610:      break;
        -:17611:
    #####:17612:    case OFBA_MSPABI_Tag_Code_Model:
    #####:17613:      printf ("  Tag_Code_Model: ");
    #####:17614:      READ_ULEB (val, p, end);
        -:17615:      switch (val)
        -:17616:	{
    #####:17617:	case 0: printf (_("None\n")); break;
    #####:17618:	case 1: printf (_("Small\n")); break;
    #####:17619:	case 2: printf (_("Large\n")); break;
    #####:17620:	default: printf ("??? (%d)\n", val); break;
        -:17621:	}
    #####:17622:      break;
        -:17623:
    #####:17624:    case OFBA_MSPABI_Tag_Data_Model:
    #####:17625:      printf ("  Tag_Data_Model: ");
    #####:17626:      READ_ULEB (val, p, end);
        -:17627:      switch (val)
        -:17628:	{
    #####:17629:	case 0: printf (_("None\n")); break;
    #####:17630:	case 1: printf (_("Small\n")); break;
    #####:17631:	case 2: printf (_("Large\n")); break;
    #####:17632:	case 3: printf (_("Restricted Large\n")); break;
    #####:17633:	default: printf ("??? (%d)\n", val); break;
        -:17634:	}
    #####:17635:      break;
        -:17636:
    #####:17637:    default:
    #####:17638:      printf (_("  <unknown tag %d>: "), tag);
        -:17639:
    #####:17640:      if (tag & 1)
        -:17641:	{
    #####:17642:	  putchar ('"');
    #####:17643:	  if (p < end - 1)
        -:17644:	    {
    #####:17645:	      size_t maxlen = (end - p) - 1;
        -:17646:
    #####:17647:	      print_symbol ((int) maxlen, (const char *) p);
    #####:17648:	      p += strnlen ((char *) p, maxlen) + 1;
        -:17649:	    }
        -:17650:	  else
        -:17651:	    {
    #####:17652:	      printf (_("<corrupt>"));
    #####:17653:	      p = (unsigned char *) end;
        -:17654:	    }
    #####:17655:	  printf ("\"\n");
        -:17656:	}
        -:17657:      else
        -:17658:	{
    #####:17659:	  READ_ULEB (val, p, end);
    #####:17660:	  printf ("%d (0x%x)\n", val, val);
        -:17661:	}
    #####:17662:      break;
        -:17663:   }
        -:17664:
    #####:17665:  assert (p <= end);
    #####:17666:  return p;
        -:17667:}
        -:17668:
        -:17669:static unsigned char *
    #####:17670:display_msp430_gnu_attribute (unsigned char * p,
        -:17671:			      unsigned int tag,
        -:17672:			      const unsigned char * const end)
        -:17673:{
    #####:17674:  if (tag == Tag_GNU_MSP430_Data_Region)
        -:17675:    {
        -:17676:      unsigned int val;
        -:17677:
    #####:17678:      printf ("  Tag_GNU_MSP430_Data_Region: ");
    #####:17679:      READ_ULEB (val, p, end);
        -:17680:
    #####:17681:      switch (val)
        -:17682:	{
    #####:17683:	case Val_GNU_MSP430_Data_Region_Any:
    #####:17684:	  printf (_("Any Region\n"));
    #####:17685:	  break;
    #####:17686:	case Val_GNU_MSP430_Data_Region_Lower:
    #####:17687:	  printf (_("Lower Region Only\n"));
    #####:17688:	  break;
    #####:17689:	default:
    #####:17690:	  printf ("??? (%u)\n", val);
        -:17691:	}
    #####:17692:      return p;
        -:17693:    }
    #####:17694:  return display_tag_value (tag & 1, p, end);
        -:17695:}
        -:17696:
        -:17697:struct riscv_attr_tag_t {
        -:17698:  const char *name;
        -:17699:  unsigned int tag;
        -:17700:};
        -:17701:
        -:17702:static struct riscv_attr_tag_t riscv_attr_tag[] =
        -:17703:{
        -:17704:#define T(tag) {"Tag_RISCV_" #tag, Tag_RISCV_##tag}
        -:17705:  T(arch),
        -:17706:  T(priv_spec),
        -:17707:  T(priv_spec_minor),
        -:17708:  T(priv_spec_revision),
        -:17709:  T(unaligned_access),
        -:17710:  T(stack_align),
        -:17711:#undef T
        -:17712:};
        -:17713:
        -:17714:static unsigned char *
    #####:17715:display_riscv_attribute (unsigned char *p,
        -:17716:			 const unsigned char * const end)
        -:17717:{
        -:17718:  unsigned int val;
        -:17719:  unsigned int tag;
    #####:17720:  struct riscv_attr_tag_t *attr = NULL;
        -:17721:  unsigned i;
        -:17722:
    #####:17723:  READ_ULEB (tag, p, end);
        -:17724:
        -:17725:  /* Find the name of attribute. */
    #####:17726:  for (i = 0; i < ARRAY_SIZE (riscv_attr_tag); i++)
        -:17727:    {
    #####:17728:      if (riscv_attr_tag[i].tag == tag)
        -:17729:	{
    #####:17730:	  attr = &riscv_attr_tag[i];
    #####:17731:	  break;
        -:17732:	}
        -:17733:    }
        -:17734:
    #####:17735:  if (attr)
    #####:17736:    printf ("  %s: ", attr->name);
        -:17737:  else
    #####:17738:    return display_tag_value (tag, p, end);
        -:17739:
    #####:17740:  switch (tag)
        -:17741:    {
    #####:17742:    case Tag_RISCV_priv_spec:
        -:17743:    case Tag_RISCV_priv_spec_minor:
        -:17744:    case Tag_RISCV_priv_spec_revision:
    #####:17745:      READ_ULEB (val, p, end);
    #####:17746:      printf (_("%u\n"), val);
    #####:17747:      break;
    #####:17748:    case Tag_RISCV_unaligned_access:
    #####:17749:      READ_ULEB (val, p, end);
        -:17750:      switch (val)
        -:17751:	{
    #####:17752:	case 0:
    #####:17753:	  printf (_("No unaligned access\n"));
    #####:17754:	  break;
    #####:17755:	case 1:
    #####:17756:	  printf (_("Unaligned access\n"));
    #####:17757:	  break;
        -:17758:	}
    #####:17759:      break;
    #####:17760:    case Tag_RISCV_stack_align:
    #####:17761:      READ_ULEB (val, p, end);
    #####:17762:      printf (_("%u-bytes\n"), val);
    #####:17763:      break;
    #####:17764:    case Tag_RISCV_arch:
    #####:17765:      p = display_tag_value (-1, p, end);
    #####:17766:      break;
    #####:17767:    default:
    #####:17768:      return display_tag_value (tag, p, end);
        -:17769:    }
        -:17770:
    #####:17771:  return p;
        -:17772:}
        -:17773:
        -:17774:static unsigned char *
    #####:17775:display_csky_attribute (unsigned char * p,
        -:17776:			const unsigned char * const end)
        -:17777:{
        -:17778:  unsigned int tag;
        -:17779:  unsigned int val;
    #####:17780:  READ_ULEB (tag, p, end);
        -:17781:
    #####:17782:  if (tag >= Tag_CSKY_MAX)
        -:17783:    {
    #####:17784:      return display_tag_value (-1, p, end);
        -:17785:    }
        -:17786:
    #####:17787:  switch (tag)
        -:17788:    {
    #####:17789:    case Tag_CSKY_ARCH_NAME:
    #####:17790:      printf ("  Tag_CSKY_ARCH_NAME:\t\t");
    #####:17791:      return display_tag_value (-1, p, end);
    #####:17792:    case Tag_CSKY_CPU_NAME:
    #####:17793:      printf ("  Tag_CSKY_CPU_NAME:\t\t");
    #####:17794:      return display_tag_value (-1, p, end);
        -:17795:
    #####:17796:    case Tag_CSKY_ISA_FLAGS:
    #####:17797:      printf ("  Tag_CSKY_ISA_FLAGS:\t\t");
    #####:17798:      return display_tag_value (0, p, end);
    #####:17799:    case Tag_CSKY_ISA_EXT_FLAGS:
    #####:17800:      printf ("  Tag_CSKY_ISA_EXT_FLAGS:\t");
    #####:17801:      return display_tag_value (0, p, end);
        -:17802:
    #####:17803:    case Tag_CSKY_DSP_VERSION:
    #####:17804:      printf ("  Tag_CSKY_DSP_VERSION:\t\t");
    #####:17805:      READ_ULEB (val, p, end);
    #####:17806:      if (val == VAL_CSKY_DSP_VERSION_EXTENSION)
    #####:17807:	printf ("DSP Extension\n");
    #####:17808:      else if (val == VAL_CSKY_DSP_VERSION_2)
    #####:17809:	printf ("DSP 2.0\n");
    #####:17810:      break;
        -:17811:
    #####:17812:    case Tag_CSKY_VDSP_VERSION:
    #####:17813:      printf ("  Tag_CSKY_VDSP_VERSION:\t");
    #####:17814:      READ_ULEB (val, p, end);
    #####:17815:      printf ("VDSP Version %d\n", val);
    #####:17816:      break;
        -:17817:
    #####:17818:    case Tag_CSKY_FPU_VERSION:
    #####:17819:      printf ("  Tag_CSKY_FPU_VERSION:\t\t");
    #####:17820:      READ_ULEB (val, p, end);
    #####:17821:      if (val == VAL_CSKY_FPU_VERSION_1)
    #####:17822:	printf ("ABIV1 FPU Version 1\n");
    #####:17823:      else if (val == VAL_CSKY_FPU_VERSION_2)
    #####:17824:	printf ("FPU Version 2\n");
    #####:17825:      break;
        -:17826:
    #####:17827:    case Tag_CSKY_FPU_ABI:
    #####:17828:      printf ("  Tag_CSKY_FPU_ABI:\t\t");
    #####:17829:      READ_ULEB (val, p, end);
    #####:17830:      if (val == VAL_CSKY_FPU_ABI_HARD)
    #####:17831:	printf ("Hard\n");
    #####:17832:      else if (val == VAL_CSKY_FPU_ABI_SOFTFP)
    #####:17833:	printf ("SoftFP\n");
    #####:17834:      else if (val == VAL_CSKY_FPU_ABI_SOFT)
    #####:17835:	printf ("Soft\n");
    #####:17836:      break;
    #####:17837:    case Tag_CSKY_FPU_ROUNDING:
    #####:17838:      READ_ULEB (val, p, end);
    #####:17839:      if (val == 1)
        -:17840:	{
    #####:17841:	  printf ("  Tag_CSKY_FPU_ROUNDING:\t");
    #####:17842:	  printf ("Needed\n");
        -:17843:	}
    #####:17844:      break;
    #####:17845:    case Tag_CSKY_FPU_DENORMAL:
    #####:17846:      READ_ULEB (val, p, end);
    #####:17847:      if (val == 1)
        -:17848:	{
    #####:17849:	  printf ("  Tag_CSKY_FPU_DENORMAL:\t");
    #####:17850:	  printf ("Needed\n");
        -:17851:	}
    #####:17852:      break;
    #####:17853:    case Tag_CSKY_FPU_Exception:
    #####:17854:      READ_ULEB (val, p, end);
    #####:17855:      if (val == 1)
        -:17856:	{
    #####:17857:	  printf ("  Tag_CSKY_FPU_Exception:\t");
    #####:17858:	  printf ("Needed\n");
        -:17859:	}
    #####:17860:      break;
    #####:17861:    case Tag_CSKY_FPU_NUMBER_MODULE:
    #####:17862:      printf ("  Tag_CSKY_FPU_NUMBER_MODULE:\t");
    #####:17863:      return display_tag_value (-1, p, end);
    #####:17864:    case Tag_CSKY_FPU_HARDFP:
    #####:17865:      printf ("  Tag_CSKY_FPU_HARDFP:\t\t");
    #####:17866:      READ_ULEB (val, p, end);
    #####:17867:      if (val & VAL_CSKY_FPU_HARDFP_HALF)
    #####:17868:	printf (" Half");
    #####:17869:      if (val & VAL_CSKY_FPU_HARDFP_SINGLE)
    #####:17870:	printf (" Single");
    #####:17871:      if (val & VAL_CSKY_FPU_HARDFP_DOUBLE)
    #####:17872:	printf (" Double");
    #####:17873:      printf ("\n");
    #####:17874:      break;
    #####:17875:    default:
    #####:17876:      return display_tag_value (tag, p, end);
        -:17877:     }
    #####:17878:  return p;
        -:17879:}
        -:17880:
        -:17881:static bool
      163:17882:process_attributes (Filedata * filedata,
        -:17883:		    const char * public_name,
        -:17884:		    unsigned int proc_type,
        -:17885:		    unsigned char * (* display_pub_attribute) (unsigned char *, const unsigned char * const),
        -:17886:		    unsigned char * (* display_proc_gnu_attribute) (unsigned char *, unsigned int, const unsigned char * const))
        -:17887:{
        -:17888:  Elf_Internal_Shdr * sect;
        -:17889:  unsigned i;
      163:17890:  bool res = true;
        -:17891:
        -:17892:  /* Find the section header so that we get the size.  */
      163:17893:  for (i = 0, sect = filedata->section_headers;
      807:17894:       i < filedata->file_header.e_shnum;
      644:17895:       i++, sect++)
        -:17896:    {
        -:17897:      unsigned char * contents;
        -:17898:      unsigned char * p;
        -:17899:
      644:17900:      if (sect->sh_type != proc_type && sect->sh_type != SHT_GNU_ATTRIBUTES)
      644:17901:	continue;
        -:17902:
    #####:17903:      contents = (unsigned char *) get_data (NULL, filedata, sect->sh_offset, 1,
    #####:17904:                                             sect->sh_size, _("attributes"));
    #####:17905:      if (contents == NULL)
        -:17906:	{
    #####:17907:	  res = false;
    #####:17908:	  continue;
        -:17909:	}
        -:17910:
    #####:17911:      p = contents;
        -:17912:      /* The first character is the version of the attributes.
        -:17913:	 Currently only version 1, (aka 'A') is recognised here.  */
    #####:17914:      if (*p != 'A')
        -:17915:	{
    #####:17916:	  printf (_("Unknown attributes version '%c'(%d) - expecting 'A'\n"), *p, *p);
    #####:17917:	  res = false;
        -:17918:	}
        -:17919:      else
        -:17920:	{
        -:17921:	  bfd_vma section_len;
        -:17922:
    #####:17923:	  section_len = sect->sh_size - 1;
    #####:17924:	  p++;
        -:17925:
    #####:17926:	  while (section_len > 0)
        -:17927:	    {
        -:17928:	      bfd_vma attr_len;
        -:17929:	      unsigned int namelen;
        -:17930:	      bool public_section;
        -:17931:	      bool gnu_section;
        -:17932:
    #####:17933:	      if (section_len <= 4)
        -:17934:		{
    #####:17935:		  error (_("Tag section ends prematurely\n"));
    #####:17936:		  res = false;
    #####:17937:		  break;
        -:17938:		}
    #####:17939:	      attr_len = byte_get (p, 4);
    #####:17940:	      p += 4;
        -:17941:
    #####:17942:	      if (attr_len > section_len)
        -:17943:		{
    #####:17944:		  error (_("Bad attribute length (%u > %u)\n"),
        -:17945:			  (unsigned) attr_len, (unsigned) section_len);
    #####:17946:		  attr_len = section_len;
    #####:17947:		  res = false;
        -:17948:		}
        -:17949:	      /* PR 17531: file: 001-101425-0.004  */
    #####:17950:	      else if (attr_len < 5)
        -:17951:		{
    #####:17952:		  error (_("Attribute length of %u is too small\n"), (unsigned) attr_len);
    #####:17953:		  res = false;
    #####:17954:		  break;
        -:17955:		}
        -:17956:
    #####:17957:	      section_len -= attr_len;
    #####:17958:	      attr_len -= 4;
        -:17959:
    #####:17960:	      namelen = strnlen ((char *) p, attr_len) + 1;
    #####:17961:	      if (namelen == 0 || namelen >= attr_len)
        -:17962:		{
    #####:17963:		  error (_("Corrupt attribute section name\n"));
    #####:17964:		  res = false;
    #####:17965:		  break;
        -:17966:		}
        -:17967:
    #####:17968:	      printf (_("Attribute Section: "));
    #####:17969:	      print_symbol (INT_MAX, (const char *) p);
    #####:17970:	      putchar ('\n');
        -:17971:
    #####:17972:	      if (public_name && streq ((char *) p, public_name))
    #####:17973:		public_section = true;
        -:17974:	      else
    #####:17975:		public_section = false;
        -:17976:
    #####:17977:	      if (streq ((char *) p, "gnu"))
    #####:17978:		gnu_section = true;
        -:17979:	      else
    #####:17980:		gnu_section = false;
        -:17981:
    #####:17982:	      p += namelen;
    #####:17983:	      attr_len -= namelen;
        -:17984:
    #####:17985:	      while (attr_len > 0 && p < contents + sect->sh_size)
        -:17986:		{
        -:17987:		  int tag;
        -:17988:		  unsigned int val;
        -:17989:		  bfd_vma size;
        -:17990:		  unsigned char * end;
        -:17991:
        -:17992:		  /* PR binutils/17531: Safe handling of corrupt files.  */
    #####:17993:		  if (attr_len < 6)
        -:17994:		    {
    #####:17995:		      error (_("Unused bytes at end of section\n"));
    #####:17996:		      res = false;
    #####:17997:		      section_len = 0;
    #####:17998:		      break;
        -:17999:		    }
        -:18000:
    #####:18001:		  tag = *(p++);
    #####:18002:		  size = byte_get (p, 4);
    #####:18003:		  if (size > attr_len)
        -:18004:		    {
    #####:18005:		      error (_("Bad subsection length (%u > %u)\n"),
        -:18006:			      (unsigned) size, (unsigned) attr_len);
    #####:18007:		      res = false;
    #####:18008:		      size = attr_len;
        -:18009:		    }
        -:18010:		  /* PR binutils/17531: Safe handling of corrupt files.  */
    #####:18011:		  if (size < 6)
        -:18012:		    {
    #####:18013:		      error (_("Bad subsection length (%u < 6)\n"),
        -:18014:			      (unsigned) size);
    #####:18015:		      res = false;
    #####:18016:		      section_len = 0;
    #####:18017:		      break;
        -:18018:		    }
        -:18019:
    #####:18020:		  attr_len -= size;
    #####:18021:		  end = p + size - 1;
    #####:18022:		  assert (end <= contents + sect->sh_size);
    #####:18023:		  p += 4;
        -:18024:
    #####:18025:		  switch (tag)
        -:18026:		    {
    #####:18027:		    case 1:
    #####:18028:		      printf (_("File Attributes\n"));
    #####:18029:		      break;
    #####:18030:		    case 2:
    #####:18031:		      printf (_("Section Attributes:"));
    #####:18032:		      goto do_numlist;
    #####:18033:		    case 3:
    #####:18034:		      printf (_("Symbol Attributes:"));
        -:18035:		      /* Fall through.  */
    #####:18036:		    do_numlist:
        -:18037:		      for (;;)
        -:18038:			{
    #####:18039:			  READ_ULEB (val, p, end);
    #####:18040:			  if (val == 0)
    #####:18041:			    break;
    #####:18042:			  printf (" %d", val);
        -:18043:			}
    #####:18044:		      printf ("\n");
    #####:18045:		      break;
    #####:18046:		    default:
    #####:18047:		      printf (_("Unknown tag: %d\n"), tag);
    #####:18048:		      public_section = false;
    #####:18049:		      break;
        -:18050:		    }
        -:18051:
    #####:18052:		  if (public_section && display_pub_attribute != NULL)
        -:18053:		    {
    #####:18054:		      while (p < end)
    #####:18055:			p = display_pub_attribute (p, end);
    #####:18056:		      assert (p == end);
        -:18057:		    }
    #####:18058:		  else if (gnu_section && display_proc_gnu_attribute != NULL)
        -:18059:		    {
    #####:18060:		      while (p < end)
    #####:18061:			p = display_gnu_attribute (p,
        -:18062:						   display_proc_gnu_attribute,
        -:18063:						   end);
    #####:18064:		      assert (p == end);
        -:18065:		    }
    #####:18066:		  else if (p < end)
        -:18067:		    {
    #####:18068:		      printf (_("  Unknown attribute:\n"));
    #####:18069:		      display_raw_attribute (p, end);
    #####:18070:		      p = end;
        -:18071:		    }
        -:18072:		  else
    #####:18073:		    attr_len = 0;
        -:18074:		}
        -:18075:	    }
        -:18076:	}
        -:18077:
    #####:18078:      free (contents);
        -:18079:    }
        -:18080:
      163:18081:  return res;
        -:18082:}
        -:18083:
        -:18084:/* DATA points to the contents of a MIPS GOT that starts at VMA PLTGOT.
        -:18085:   Print the Address, Access and Initial fields of an entry at VMA ADDR
        -:18086:   and return the VMA of the next entry, or -1 if there was a problem.
        -:18087:   Does not read from DATA_END or beyond.  */
        -:18088:
        -:18089:static bfd_vma
    #####:18090:print_mips_got_entry (unsigned char * data, bfd_vma pltgot, bfd_vma addr,
        -:18091:		      unsigned char * data_end)
        -:18092:{
    #####:18093:  printf ("  ");
    #####:18094:  print_vma (addr, LONG_HEX);
    #####:18095:  printf (" ");
    #####:18096:  if (addr < pltgot + 0xfff0)
    #####:18097:    printf ("%6d(gp)", (int) (addr - pltgot - 0x7ff0));
        -:18098:  else
    #####:18099:    printf ("%10s", "");
    #####:18100:  printf (" ");
    #####:18101:  if (data == NULL)
    #####:18102:    printf ("%*s", is_32bit_elf ? 8 : 16, _("<unknown>"));
        -:18103:  else
        -:18104:    {
        -:18105:      bfd_vma entry;
    #####:18106:      unsigned char * from = data + addr - pltgot;
        -:18107:
    #####:18108:      if (from + (is_32bit_elf ? 4 : 8) > data_end)
        -:18109:	{
    #####:18110:	  warn (_("MIPS GOT entry extends beyond the end of available data\n"));
    #####:18111:	  printf ("%*s", is_32bit_elf ? 8 : 16, _("<corrupt>"));
    #####:18112:	  return (bfd_vma) -1;
        -:18113:	}
        -:18114:      else
        -:18115:	{
    #####:18116:	  entry = byte_get (data + addr - pltgot, is_32bit_elf ? 4 : 8);
    #####:18117:	  print_vma (entry, LONG_HEX);
        -:18118:	}
        -:18119:    }
    #####:18120:  return addr + (is_32bit_elf ? 4 : 8);
        -:18121:}
        -:18122:
        -:18123:/* DATA points to the contents of a MIPS PLT GOT that starts at VMA
        -:18124:   PLTGOT.  Print the Address and Initial fields of an entry at VMA
        -:18125:   ADDR and return the VMA of the next entry.  */
        -:18126:
        -:18127:static bfd_vma
    #####:18128:print_mips_pltgot_entry (unsigned char * data, bfd_vma pltgot, bfd_vma addr)
        -:18129:{
    #####:18130:  printf ("  ");
    #####:18131:  print_vma (addr, LONG_HEX);
    #####:18132:  printf (" ");
    #####:18133:  if (data == NULL)
    #####:18134:    printf ("%*s", is_32bit_elf ? 8 : 16, _("<unknown>"));
        -:18135:  else
        -:18136:    {
        -:18137:      bfd_vma entry;
        -:18138:
    #####:18139:      entry = byte_get (data + addr - pltgot, is_32bit_elf ? 4 : 8);
    #####:18140:      print_vma (entry, LONG_HEX);
        -:18141:    }
    #####:18142:  return addr + (is_32bit_elf ? 4 : 8);
        -:18143:}
        -:18144:
        -:18145:static void
    #####:18146:print_mips_ases (unsigned int mask)
        -:18147:{
    #####:18148:  if (mask & AFL_ASE_DSP)
    #####:18149:    fputs ("\n\tDSP ASE", stdout);
    #####:18150:  if (mask & AFL_ASE_DSPR2)
    #####:18151:    fputs ("\n\tDSP R2 ASE", stdout);
    #####:18152:  if (mask & AFL_ASE_DSPR3)
    #####:18153:    fputs ("\n\tDSP R3 ASE", stdout);
    #####:18154:  if (mask & AFL_ASE_EVA)
    #####:18155:    fputs ("\n\tEnhanced VA Scheme", stdout);
    #####:18156:  if (mask & AFL_ASE_MCU)
    #####:18157:    fputs ("\n\tMCU (MicroController) ASE", stdout);
    #####:18158:  if (mask & AFL_ASE_MDMX)
    #####:18159:    fputs ("\n\tMDMX ASE", stdout);
    #####:18160:  if (mask & AFL_ASE_MIPS3D)
    #####:18161:    fputs ("\n\tMIPS-3D ASE", stdout);
    #####:18162:  if (mask & AFL_ASE_MT)
    #####:18163:    fputs ("\n\tMT ASE", stdout);
    #####:18164:  if (mask & AFL_ASE_SMARTMIPS)
    #####:18165:    fputs ("\n\tSmartMIPS ASE", stdout);
    #####:18166:  if (mask & AFL_ASE_VIRT)
    #####:18167:    fputs ("\n\tVZ ASE", stdout);
    #####:18168:  if (mask & AFL_ASE_MSA)
    #####:18169:    fputs ("\n\tMSA ASE", stdout);
    #####:18170:  if (mask & AFL_ASE_MIPS16)
    #####:18171:    fputs ("\n\tMIPS16 ASE", stdout);
    #####:18172:  if (mask & AFL_ASE_MICROMIPS)
    #####:18173:    fputs ("\n\tMICROMIPS ASE", stdout);
    #####:18174:  if (mask & AFL_ASE_XPA)
    #####:18175:    fputs ("\n\tXPA ASE", stdout);
    #####:18176:  if (mask & AFL_ASE_MIPS16E2)
    #####:18177:    fputs ("\n\tMIPS16e2 ASE", stdout);
    #####:18178:  if (mask & AFL_ASE_CRC)
    #####:18179:    fputs ("\n\tCRC ASE", stdout);
    #####:18180:  if (mask & AFL_ASE_GINV)
    #####:18181:    fputs ("\n\tGINV ASE", stdout);
    #####:18182:  if (mask & AFL_ASE_LOONGSON_MMI)
    #####:18183:    fputs ("\n\tLoongson MMI ASE", stdout);
    #####:18184:  if (mask & AFL_ASE_LOONGSON_CAM)
    #####:18185:    fputs ("\n\tLoongson CAM ASE", stdout);
    #####:18186:  if (mask & AFL_ASE_LOONGSON_EXT)
    #####:18187:    fputs ("\n\tLoongson EXT ASE", stdout);
    #####:18188:  if (mask & AFL_ASE_LOONGSON_EXT2)
    #####:18189:    fputs ("\n\tLoongson EXT2 ASE", stdout);
    #####:18190:  if (mask == 0)
    #####:18191:    fprintf (stdout, "\n\t%s", _("None"));
    #####:18192:  else if ((mask & ~AFL_ASE_MASK) != 0)
    #####:18193:    fprintf (stdout, "\n\t%s (%x)", _("Unknown"), mask & ~AFL_ASE_MASK);
    #####:18194:}
        -:18195:
        -:18196:static void
    #####:18197:print_mips_isa_ext (unsigned int isa_ext)
        -:18198:{
    #####:18199:  switch (isa_ext)
        -:18200:    {
    #####:18201:    case 0:
    #####:18202:      fputs (_("None"), stdout);
    #####:18203:      break;
    #####:18204:    case AFL_EXT_XLR:
    #####:18205:      fputs ("RMI XLR", stdout);
    #####:18206:      break;
    #####:18207:    case AFL_EXT_OCTEON3:
    #####:18208:      fputs ("Cavium Networks Octeon3", stdout);
    #####:18209:      break;
    #####:18210:    case AFL_EXT_OCTEON2:
    #####:18211:      fputs ("Cavium Networks Octeon2", stdout);
    #####:18212:      break;
    #####:18213:    case AFL_EXT_OCTEONP:
    #####:18214:      fputs ("Cavium Networks OcteonP", stdout);
    #####:18215:      break;
    #####:18216:    case AFL_EXT_OCTEON:
    #####:18217:      fputs ("Cavium Networks Octeon", stdout);
    #####:18218:      break;
    #####:18219:    case AFL_EXT_5900:
    #####:18220:      fputs ("Toshiba R5900", stdout);
    #####:18221:      break;
    #####:18222:    case AFL_EXT_4650:
    #####:18223:      fputs ("MIPS R4650", stdout);
    #####:18224:      break;
    #####:18225:    case AFL_EXT_4010:
    #####:18226:      fputs ("LSI R4010", stdout);
    #####:18227:      break;
    #####:18228:    case AFL_EXT_4100:
    #####:18229:      fputs ("NEC VR4100", stdout);
    #####:18230:      break;
    #####:18231:    case AFL_EXT_3900:
    #####:18232:      fputs ("Toshiba R3900", stdout);
    #####:18233:      break;
    #####:18234:    case AFL_EXT_10000:
    #####:18235:      fputs ("MIPS R10000", stdout);
    #####:18236:      break;
    #####:18237:    case AFL_EXT_SB1:
    #####:18238:      fputs ("Broadcom SB-1", stdout);
    #####:18239:      break;
    #####:18240:    case AFL_EXT_4111:
    #####:18241:      fputs ("NEC VR4111/VR4181", stdout);
    #####:18242:      break;
    #####:18243:    case AFL_EXT_4120:
    #####:18244:      fputs ("NEC VR4120", stdout);
    #####:18245:      break;
    #####:18246:    case AFL_EXT_5400:
    #####:18247:      fputs ("NEC VR5400", stdout);
    #####:18248:      break;
    #####:18249:    case AFL_EXT_5500:
    #####:18250:      fputs ("NEC VR5500", stdout);
    #####:18251:      break;
    #####:18252:    case AFL_EXT_LOONGSON_2E:
    #####:18253:      fputs ("ST Microelectronics Loongson 2E", stdout);
    #####:18254:      break;
    #####:18255:    case AFL_EXT_LOONGSON_2F:
    #####:18256:      fputs ("ST Microelectronics Loongson 2F", stdout);
    #####:18257:      break;
    #####:18258:    case AFL_EXT_INTERAPTIV_MR2:
    #####:18259:      fputs ("Imagination interAptiv MR2", stdout);
    #####:18260:      break;
    #####:18261:    default:
    #####:18262:      fprintf (stdout, "%s (%d)", _("Unknown"), isa_ext);
        -:18263:    }
    #####:18264:}
        -:18265:
        -:18266:static signed int
    #####:18267:get_mips_reg_size (int reg_size)
        -:18268:{
        -:18269:  return (reg_size == AFL_REG_NONE) ? 0
    #####:18270:	 : (reg_size == AFL_REG_32) ? 32
    #####:18271:	 : (reg_size == AFL_REG_64) ? 64
    #####:18272:	 : (reg_size == AFL_REG_128) ? 128
    #####:18273:	 : -1;
        -:18274:}
        -:18275:
        -:18276:static bool
        3:18277:process_mips_specific (Filedata * filedata)
        -:18278:{
        -:18279:  Elf_Internal_Dyn * entry;
        3:18280:  Elf_Internal_Shdr *sect = NULL;
        3:18281:  size_t liblist_offset = 0;
        3:18282:  size_t liblistno = 0;
        3:18283:  size_t conflictsno = 0;
        3:18284:  size_t options_offset = 0;
        3:18285:  size_t conflicts_offset = 0;
        3:18286:  size_t pltrelsz = 0;
        3:18287:  size_t pltrel = 0;
        3:18288:  bfd_vma pltgot = 0;
        3:18289:  bfd_vma mips_pltgot = 0;
        3:18290:  bfd_vma jmprel = 0;
        3:18291:  bfd_vma local_gotno = 0;
        3:18292:  bfd_vma gotsym = 0;
        3:18293:  bfd_vma symtabno = 0;
        3:18294:  bool res = true;
        -:18295:
        3:18296:  if (! process_attributes (filedata, NULL, SHT_GNU_ATTRIBUTES, NULL,
        -:18297:			    display_mips_gnu_attribute))
    #####:18298:    res = false;
        -:18299:
        3:18300:  sect = find_section (filedata, ".MIPS.abiflags");
        -:18301:
        3:18302:  if (sect != NULL)
        -:18303:    {
        -:18304:      Elf_External_ABIFlags_v0 *abiflags_ext;
        -:18305:      Elf_Internal_ABIFlags_v0 abiflags_in;
        -:18306:
    #####:18307:      if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size)
        -:18308:	{
    #####:18309:	  error (_("Corrupt MIPS ABI Flags section.\n"));
    #####:18310:	  res = false;
        -:18311:	}
        -:18312:      else
        -:18313:	{
    #####:18314:	  abiflags_ext = get_data (NULL, filedata, sect->sh_offset, 1,
    #####:18315:				   sect->sh_size, _("MIPS ABI Flags section"));
    #####:18316:	  if (abiflags_ext)
        -:18317:	    {
    #####:18318:	      abiflags_in.version = BYTE_GET (abiflags_ext->version);
    #####:18319:	      abiflags_in.isa_level = BYTE_GET (abiflags_ext->isa_level);
    #####:18320:	      abiflags_in.isa_rev = BYTE_GET (abiflags_ext->isa_rev);
    #####:18321:	      abiflags_in.gpr_size = BYTE_GET (abiflags_ext->gpr_size);
    #####:18322:	      abiflags_in.cpr1_size = BYTE_GET (abiflags_ext->cpr1_size);
    #####:18323:	      abiflags_in.cpr2_size = BYTE_GET (abiflags_ext->cpr2_size);
    #####:18324:	      abiflags_in.fp_abi = BYTE_GET (abiflags_ext->fp_abi);
    #####:18325:	      abiflags_in.isa_ext = BYTE_GET (abiflags_ext->isa_ext);
    #####:18326:	      abiflags_in.ases = BYTE_GET (abiflags_ext->ases);
    #####:18327:	      abiflags_in.flags1 = BYTE_GET (abiflags_ext->flags1);
    #####:18328:	      abiflags_in.flags2 = BYTE_GET (abiflags_ext->flags2);
        -:18329:
    #####:18330:	      printf ("\nMIPS ABI Flags Version: %d\n", abiflags_in.version);
    #####:18331:	      printf ("\nISA: MIPS%d", abiflags_in.isa_level);
    #####:18332:	      if (abiflags_in.isa_rev > 1)
    #####:18333:		printf ("r%d", abiflags_in.isa_rev);
    #####:18334:	      printf ("\nGPR size: %d",
    #####:18335:		      get_mips_reg_size (abiflags_in.gpr_size));
    #####:18336:	      printf ("\nCPR1 size: %d",
    #####:18337:		      get_mips_reg_size (abiflags_in.cpr1_size));
    #####:18338:	      printf ("\nCPR2 size: %d",
    #####:18339:		      get_mips_reg_size (abiflags_in.cpr2_size));
    #####:18340:	      fputs ("\nFP ABI: ", stdout);
    #####:18341:	      print_mips_fp_abi_value (abiflags_in.fp_abi);
    #####:18342:	      fputs ("ISA Extension: ", stdout);
    #####:18343:	      print_mips_isa_ext (abiflags_in.isa_ext);
    #####:18344:	      fputs ("\nASEs:", stdout);
    #####:18345:	      print_mips_ases (abiflags_in.ases);
    #####:18346:	      printf ("\nFLAGS 1: %8.8lx", abiflags_in.flags1);
    #####:18347:	      printf ("\nFLAGS 2: %8.8lx", abiflags_in.flags2);
    #####:18348:	      fputc ('\n', stdout);
    #####:18349:	      free (abiflags_ext);
        -:18350:	    }
        -:18351:	}
        -:18352:    }
        -:18353:
        -:18354:  /* We have a lot of special sections.  Thanks SGI!  */
        3:18355:  if (filedata->dynamic_section == NULL)
        -:18356:    {
        -:18357:      /* No dynamic information available.  See if there is static GOT.  */
        2:18358:      sect = find_section (filedata, ".got");
        2:18359:      if (sect != NULL)
        -:18360:	{
        -:18361:	  unsigned char *data_end;
        -:18362:	  unsigned char *data;
        -:18363:	  bfd_vma ent, end;
        -:18364:	  int addr_size;
        -:18365:
    #####:18366:	  pltgot = sect->sh_addr;
        -:18367:
    #####:18368:	  ent = pltgot;
    #####:18369:	  addr_size = (is_32bit_elf ? 4 : 8);
    #####:18370:	  end = pltgot + sect->sh_size;
        -:18371:
    #####:18372:	  data = (unsigned char *) get_data (NULL, filedata, sect->sh_offset,
        -:18373:					     end - pltgot, 1,
    #####:18374:					     _("Global Offset Table data"));
        -:18375:	  /* PR 12855: Null data is handled gracefully throughout.  */
    #####:18376:	  data_end = data + (end - pltgot);
        -:18377:
    #####:18378:	  printf (_("\nStatic GOT:\n"));
    #####:18379:	  printf (_(" Canonical gp value: "));
    #####:18380:	  print_vma (ent + 0x7ff0, LONG_HEX);
    #####:18381:	  printf ("\n\n");
        -:18382:
        -:18383:	  /* In a dynamic binary GOT[0] is reserved for the dynamic
        -:18384:	     loader to store the lazy resolver pointer, however in
        -:18385:	     a static binary it may well have been omitted and GOT
        -:18386:	     reduced to a table of addresses.
        -:18387:	     PR 21344: Check for the entry being fully available
        -:18388:	     before fetching it.  */
    #####:18389:	  if (data
    #####:18390:	      && data + ent - pltgot + addr_size <= data_end
    #####:18391:	      && byte_get (data + ent - pltgot, addr_size) == 0)
        -:18392:	    {
    #####:18393:	      printf (_(" Reserved entries:\n"));
    #####:18394:	      printf (_("  %*s %10s %*s\n"),
        -:18395:		      addr_size * 2, _("Address"), _("Access"),
        -:18396:		      addr_size * 2, _("Value"));
    #####:18397:	      ent = print_mips_got_entry (data, pltgot, ent, data_end);
    #####:18398:	      printf ("\n");
    #####:18399:	      if (ent == (bfd_vma) -1)
    #####:18400:		goto sgot_print_fail;
        -:18401:
        -:18402:	      /* Check for the MSB of GOT[1] being set, identifying a
        -:18403:		 GNU object.  This entry will be used by some runtime
        -:18404:		 loaders, to store the module pointer.  Otherwise this
        -:18405:		 is an ordinary local entry.
        -:18406:		 PR 21344: Check for the entry being fully available
        -:18407:		 before fetching it.  */
    #####:18408:	      if (data
    #####:18409:		  && data + ent - pltgot + addr_size <= data_end
    #####:18410:		  && (byte_get (data + ent - pltgot, addr_size)
    #####:18411:		      >> (addr_size * 8 - 1)) != 0)
        -:18412:		{
    #####:18413:		  ent = print_mips_got_entry (data, pltgot, ent, data_end);
    #####:18414:		  printf ("\n");
    #####:18415:		  if (ent == (bfd_vma) -1)
    #####:18416:		    goto sgot_print_fail;
        -:18417:		}
    #####:18418:	      printf ("\n");
        -:18419:	    }
        -:18420:
    #####:18421:	  if (data != NULL && ent < end)
        -:18422:	    {
    #####:18423:	      printf (_(" Local entries:\n"));
    #####:18424:	      printf ("  %*s %10s %*s\n",
        -:18425:		      addr_size * 2, _("Address"), _("Access"),
        -:18426:		      addr_size * 2, _("Value"));
    #####:18427:	      while (ent < end)
        -:18428:		{
    #####:18429:		  ent = print_mips_got_entry (data, pltgot, ent, data_end);
    #####:18430:		  printf ("\n");
    #####:18431:		  if (ent == (bfd_vma) -1)
    #####:18432:		    goto sgot_print_fail;
        -:18433:		}
    #####:18434:	      printf ("\n");
        -:18435:	    }
        -:18436:
    #####:18437:	sgot_print_fail:
    #####:18438:	  free (data);
        -:18439:	}
        2:18440:      return res;
        -:18441:    }
        -:18442:
        1:18443:  for (entry = filedata->dynamic_section;
        -:18444:       /* PR 17531 file: 012-50589-0.004.  */
        2:18445:       (entry < filedata->dynamic_section + filedata->dynamic_nent
        1:18446:	&& entry->d_tag != DT_NULL);
        1:18447:       ++entry)
        1:18448:    switch (entry->d_tag)
        -:18449:      {
    #####:18450:      case DT_MIPS_LIBLIST:
        -:18451:	liblist_offset
    #####:18452:	  = offset_from_vma (filedata, entry->d_un.d_val,
        -:18453:			     liblistno * sizeof (Elf32_External_Lib));
    #####:18454:	break;
    #####:18455:      case DT_MIPS_LIBLISTNO:
    #####:18456:	liblistno = entry->d_un.d_val;
    #####:18457:	break;
    #####:18458:      case DT_MIPS_OPTIONS:
    #####:18459:	options_offset = offset_from_vma (filedata, entry->d_un.d_val, 0);
    #####:18460:	break;
    #####:18461:      case DT_MIPS_CONFLICT:
        -:18462:	conflicts_offset
    #####:18463:	  = offset_from_vma (filedata, entry->d_un.d_val,
        -:18464:			     conflictsno * sizeof (Elf32_External_Conflict));
    #####:18465:	break;
    #####:18466:      case DT_MIPS_CONFLICTNO:
    #####:18467:	conflictsno = entry->d_un.d_val;
    #####:18468:	break;
    #####:18469:      case DT_PLTGOT:
    #####:18470:	pltgot = entry->d_un.d_ptr;
    #####:18471:	break;
    #####:18472:      case DT_MIPS_LOCAL_GOTNO:
    #####:18473:	local_gotno = entry->d_un.d_val;
    #####:18474:	break;
    #####:18475:      case DT_MIPS_GOTSYM:
    #####:18476:	gotsym = entry->d_un.d_val;
    #####:18477:	break;
    #####:18478:      case DT_MIPS_SYMTABNO:
    #####:18479:	symtabno = entry->d_un.d_val;
    #####:18480:	break;
    #####:18481:      case DT_MIPS_PLTGOT:
    #####:18482:	mips_pltgot = entry->d_un.d_ptr;
    #####:18483:	break;
    #####:18484:      case DT_PLTREL:
    #####:18485:	pltrel = entry->d_un.d_val;
    #####:18486:	break;
    #####:18487:      case DT_PLTRELSZ:
    #####:18488:	pltrelsz = entry->d_un.d_val;
    #####:18489:	break;
    #####:18490:      case DT_JMPREL:
    #####:18491:	jmprel = entry->d_un.d_ptr;
    #####:18492:	break;
        1:18493:      default:
        1:18494:	break;
        -:18495:      }
        -:18496:
       1*:18497:  if (liblist_offset != 0 && liblistno != 0 && do_dynamic)
        -:18498:    {
        -:18499:      Elf32_External_Lib * elib;
        -:18500:      size_t cnt;
        -:18501:
    #####:18502:      elib = (Elf32_External_Lib *) get_data (NULL, filedata, liblist_offset,
        -:18503:					      sizeof (Elf32_External_Lib),
        -:18504:					      liblistno,
    #####:18505:					      _("liblist section data"));
    #####:18506:      if (elib)
        -:18507:	{
    #####:18508:	  printf (ngettext ("\nSection '.liblist' contains %lu entry:\n",
        -:18509:			    "\nSection '.liblist' contains %lu entries:\n",
        -:18510:			    (unsigned long) liblistno),
        -:18511:		  (unsigned long) liblistno);
    #####:18512:	  fputs (_("     Library              Time Stamp          Checksum   Version Flags\n"),
        -:18513:		 stdout);
        -:18514:
    #####:18515:	  for (cnt = 0; cnt < liblistno; ++cnt)
        -:18516:	    {
        -:18517:	      Elf32_Lib liblist;
        -:18518:	      time_t atime;
        -:18519:	      char timebuf[128];
        -:18520:	      struct tm * tmp;
        -:18521:
    #####:18522:	      liblist.l_name = BYTE_GET (elib[cnt].l_name);
    #####:18523:	      atime = BYTE_GET (elib[cnt].l_time_stamp);
    #####:18524:	      liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);
    #####:18525:	      liblist.l_version = BYTE_GET (elib[cnt].l_version);
    #####:18526:	      liblist.l_flags = BYTE_GET (elib[cnt].l_flags);
        -:18527:
    #####:18528:	      tmp = gmtime (&atime);
    #####:18529:	      snprintf (timebuf, sizeof (timebuf),
        -:18530:			"%04u-%02u-%02uT%02u:%02u:%02u",
    #####:18531:			tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
        -:18532:			tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
        -:18533:
    #####:18534:	      printf ("%3lu: ", (unsigned long) cnt);
    #####:18535:	      if (valid_dynamic_name (filedata, liblist.l_name))
    #####:18536:		print_symbol (20, get_dynamic_name (filedata, liblist.l_name));
        -:18537:	      else
    #####:18538:		printf (_("<corrupt: %9ld>"), liblist.l_name);
    #####:18539:	      printf (" %s %#10lx %-7ld", timebuf, liblist.l_checksum,
        -:18540:		      liblist.l_version);
        -:18541:
    #####:18542:	      if (liblist.l_flags == 0)
    #####:18543:		puts (_(" NONE"));
        -:18544:	      else
        -:18545:		{
        -:18546:		  static const struct
        -:18547:		  {
        -:18548:		    const char * name;
        -:18549:		    int bit;
        -:18550:		  }
        -:18551:		  l_flags_vals[] =
        -:18552:		  {
        -:18553:		    { " EXACT_MATCH", LL_EXACT_MATCH },
        -:18554:		    { " IGNORE_INT_VER", LL_IGNORE_INT_VER },
        -:18555:		    { " REQUIRE_MINOR", LL_REQUIRE_MINOR },
        -:18556:		    { " EXPORTS", LL_EXPORTS },
        -:18557:		    { " DELAY_LOAD", LL_DELAY_LOAD },
        -:18558:		    { " DELTA", LL_DELTA }
        -:18559:		  };
    #####:18560:		  int flags = liblist.l_flags;
        -:18561:		  size_t fcnt;
        -:18562:
    #####:18563:		  for (fcnt = 0; fcnt < ARRAY_SIZE (l_flags_vals); ++fcnt)
    #####:18564:		    if ((flags & l_flags_vals[fcnt].bit) != 0)
        -:18565:		      {
    #####:18566:			fputs (l_flags_vals[fcnt].name, stdout);
    #####:18567:			flags ^= l_flags_vals[fcnt].bit;
        -:18568:		      }
    #####:18569:		  if (flags != 0)
    #####:18570:		    printf (" %#x", (unsigned int) flags);
        -:18571:
    #####:18572:		  puts ("");
        -:18573:		}
        -:18574:	    }
        -:18575:
    #####:18576:	  free (elib);
        -:18577:	}
        -:18578:      else
    #####:18579:	res = false;
        -:18580:    }
        -:18581:
        1:18582:  if (options_offset != 0)
        -:18583:    {
        -:18584:      Elf_External_Options * eopt;
        -:18585:      size_t offset;
        -:18586:      int cnt;
        -:18587:
        -:18588:      /* Find the section header so that we get the size.  */
    #####:18589:      sect = find_section_by_type (filedata, SHT_MIPS_OPTIONS);
        -:18590:      /* PR 17533 file: 012-277276-0.004.  */
    #####:18591:      if (sect == NULL)
        -:18592:	{
    #####:18593:	  error (_("No MIPS_OPTIONS header found\n"));
    #####:18594:	  return false;
        -:18595:	}
        -:18596:      /* PR 24243  */
    #####:18597:      if (sect->sh_size < sizeof (* eopt))
        -:18598:	{
    #####:18599:	  error (_("The MIPS options section is too small.\n"));
    #####:18600:	  return false;
        -:18601:	}
        -:18602:
    #####:18603:      eopt = (Elf_External_Options *) get_data (NULL, filedata, options_offset, 1,
    #####:18604:                                                sect->sh_size, _("options"));
    #####:18605:      if (eopt)
        -:18606:	{
        -:18607:	  Elf_Internal_Options option;
        -:18608:
    #####:18609:	  offset = cnt = 0;
    #####:18610:	  while (offset <= sect->sh_size - sizeof (* eopt))
        -:18611:	    {
        -:18612:	      Elf_External_Options * eoption;
        -:18613:	      unsigned int optsize;
        -:18614:
    #####:18615:	      eoption = (Elf_External_Options *) ((char *) eopt + offset);
        -:18616:
    #####:18617:	      optsize = BYTE_GET (eoption->size);
        -:18618:
        -:18619:	      /* PR 17531: file: ffa0fa3b.  */
    #####:18620:	      if (optsize < sizeof (* eopt)
    #####:18621:		  || optsize > sect->sh_size - offset)
        -:18622:		{
    #####:18623:		  error (_("Invalid size (%u) for MIPS option\n"),
        -:18624:			 optsize);
    #####:18625:		  free (eopt);
    #####:18626:		  return false;
        -:18627:		}
    #####:18628:	      offset += optsize;
    #####:18629:	      ++cnt;
        -:18630:	    }
        -:18631:
    #####:18632:	  printf (ngettext ("\nSection '%s' contains %d entry:\n",
        -:18633:			    "\nSection '%s' contains %d entries:\n",
        -:18634:			    cnt),
        -:18635:		  printable_section_name (filedata, sect), cnt);
        -:18636:
    #####:18637:	  offset = 0;
    #####:18638:	  while (cnt-- > 0)
        -:18639:	    {
        -:18640:	      size_t len;
        -:18641:	      Elf_External_Options * eoption;
        -:18642:
    #####:18643:	      eoption = (Elf_External_Options *) ((char *) eopt + offset);
        -:18644:
    #####:18645:	      option.kind = BYTE_GET (eoption->kind);
    #####:18646:	      option.size = BYTE_GET (eoption->size);
    #####:18647:	      option.section = BYTE_GET (eoption->section);
    #####:18648:	      option.info = BYTE_GET (eoption->info);
        -:18649:
    #####:18650:	      switch (option.kind)
        -:18651:		{
    #####:18652:		case ODK_NULL:
        -:18653:		  /* This shouldn't happen.  */
    #####:18654:		  printf (" NULL       %" PRId16 " %" PRIx32,
    #####:18655:			  option.section, option.info);
    #####:18656:		  break;
        -:18657:
    #####:18658:		case ODK_REGINFO:
    #####:18659:		  printf (" REGINFO    ");
    #####:18660:		  if (filedata->file_header.e_machine == EM_MIPS)
        -:18661:		    {
        -:18662:		      Elf32_External_RegInfo * ereg;
        -:18663:		      Elf32_RegInfo reginfo;
        -:18664:
        -:18665:		      /* 32bit form.  */
    #####:18666:		      if (option.size < (sizeof (Elf_External_Options)
        -:18667:					 + sizeof (Elf32_External_RegInfo)))
        -:18668:			{
    #####:18669:			  printf (_("<corrupt>\n"));
    #####:18670:			  error (_("Truncated MIPS REGINFO option\n"));
    #####:18671:			  cnt = 0;
    #####:18672:			  break;
        -:18673:			}
        -:18674:
    #####:18675:		      ereg = (Elf32_External_RegInfo *) (eoption + 1);
        -:18676:
    #####:18677:		      reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask);
    #####:18678:		      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);
    #####:18679:		      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);
    #####:18680:		      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);
    #####:18681:		      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);
    #####:18682:		      reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value);
        -:18683:
    #####:18684:		      printf ("GPR %08" PRIx32 "  GP 0x%" PRIx32 "\n",
        -:18685:			      reginfo.ri_gprmask, reginfo.ri_gp_value);
    #####:18686:		      printf ("          "
        -:18687:			      "  CPR0 %08" PRIx32 "  CPR1 %08" PRIx32
        -:18688:			      "  CPR2 %08" PRIx32 "  CPR3 %08" PRIx32 "\n",
        -:18689:			      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
        -:18690:			      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
        -:18691:		    }
        -:18692:		  else
        -:18693:		    {
        -:18694:		      /* 64 bit form.  */
        -:18695:		      Elf64_External_RegInfo * ereg;
        -:18696:		      Elf64_Internal_RegInfo reginfo;
        -:18697:
    #####:18698:		      if (option.size < (sizeof (Elf_External_Options)
        -:18699:					 + sizeof (Elf64_External_RegInfo)))
        -:18700:			{
    #####:18701:			  printf (_("<corrupt>\n"));
    #####:18702:			  error (_("Truncated MIPS REGINFO option\n"));
    #####:18703:			  cnt = 0;
    #####:18704:			  break;
        -:18705:			}
        -:18706:
    #####:18707:		      ereg = (Elf64_External_RegInfo *) (eoption + 1);
    #####:18708:		      reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask);
    #####:18709:		      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);
    #####:18710:		      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);
    #####:18711:		      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);
    #####:18712:		      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);
    #####:18713:		      reginfo.ri_gp_value   = BYTE_GET (ereg->ri_gp_value);
        -:18714:
    #####:18715:		      printf ("GPR %08" PRIx32 "  GP 0x%" PRIx64 "\n",
        -:18716:			      reginfo.ri_gprmask, reginfo.ri_gp_value);
    #####:18717:		      printf ("          "
        -:18718:			      "  CPR0 %08" PRIx32 "  CPR1 %08" PRIx32
        -:18719:			      "  CPR2 %08" PRIx32 "  CPR3 %08" PRIx32 "\n",
        -:18720:			      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
        -:18721:			      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
        -:18722:		    }
    #####:18723:		  offset += option.size;
    #####:18724:		  continue;
        -:18725:
    #####:18726:		case ODK_EXCEPTIONS:
    #####:18727:		  fputs (" EXCEPTIONS fpe_min(", stdout);
    #####:18728:		  process_mips_fpe_exception (option.info & OEX_FPU_MIN);
    #####:18729:		  fputs (") fpe_max(", stdout);
    #####:18730:		  process_mips_fpe_exception ((option.info & OEX_FPU_MAX) >> 8);
    #####:18731:		  fputs (")", stdout);
        -:18732:
    #####:18733:		  if (option.info & OEX_PAGE0)
    #####:18734:		    fputs (" PAGE0", stdout);
    #####:18735:		  if (option.info & OEX_SMM)
    #####:18736:		    fputs (" SMM", stdout);
    #####:18737:		  if (option.info & OEX_FPDBUG)
    #####:18738:		    fputs (" FPDBUG", stdout);
    #####:18739:		  if (option.info & OEX_DISMISS)
    #####:18740:		    fputs (" DISMISS", stdout);
    #####:18741:		  break;
        -:18742:
    #####:18743:		case ODK_PAD:
    #####:18744:		  fputs (" PAD       ", stdout);
    #####:18745:		  if (option.info & OPAD_PREFIX)
    #####:18746:		    fputs (" PREFIX", stdout);
    #####:18747:		  if (option.info & OPAD_POSTFIX)
    #####:18748:		    fputs (" POSTFIX", stdout);
    #####:18749:		  if (option.info & OPAD_SYMBOL)
    #####:18750:		    fputs (" SYMBOL", stdout);
    #####:18751:		  break;
        -:18752:
    #####:18753:		case ODK_HWPATCH:
    #####:18754:		  fputs (" HWPATCH   ", stdout);
    #####:18755:		  if (option.info & OHW_R4KEOP)
    #####:18756:		    fputs (" R4KEOP", stdout);
    #####:18757:		  if (option.info & OHW_R8KPFETCH)
    #####:18758:		    fputs (" R8KPFETCH", stdout);
    #####:18759:		  if (option.info & OHW_R5KEOP)
    #####:18760:		    fputs (" R5KEOP", stdout);
    #####:18761:		  if (option.info & OHW_R5KCVTL)
    #####:18762:		    fputs (" R5KCVTL", stdout);
    #####:18763:		  break;
        -:18764:
    #####:18765:		case ODK_FILL:
    #####:18766:		  fputs (" FILL       ", stdout);
        -:18767:		  /* XXX Print content of info word?  */
    #####:18768:		  break;
        -:18769:
    #####:18770:		case ODK_TAGS:
    #####:18771:		  fputs (" TAGS       ", stdout);
        -:18772:		  /* XXX Print content of info word?  */
    #####:18773:		  break;
        -:18774:
    #####:18775:		case ODK_HWAND:
    #####:18776:		  fputs (" HWAND     ", stdout);
    #####:18777:		  if (option.info & OHWA0_R4KEOP_CHECKED)
    #####:18778:		    fputs (" R4KEOP_CHECKED", stdout);
    #####:18779:		  if (option.info & OHWA0_R4KEOP_CLEAN)
    #####:18780:		    fputs (" R4KEOP_CLEAN", stdout);
    #####:18781:		  break;
        -:18782:
    #####:18783:		case ODK_HWOR:
    #####:18784:		  fputs (" HWOR      ", stdout);
    #####:18785:		  if (option.info & OHWA0_R4KEOP_CHECKED)
    #####:18786:		    fputs (" R4KEOP_CHECKED", stdout);
    #####:18787:		  if (option.info & OHWA0_R4KEOP_CLEAN)
    #####:18788:		    fputs (" R4KEOP_CLEAN", stdout);
    #####:18789:		  break;
        -:18790:
    #####:18791:		case ODK_GP_GROUP:
    #####:18792:		  printf (" GP_GROUP  %#06x  self-contained %#06x",
    #####:18793:			  option.info & OGP_GROUP,
    #####:18794:			  (option.info & OGP_SELF) >> 16);
    #####:18795:		  break;
        -:18796:
    #####:18797:		case ODK_IDENT:
    #####:18798:		  printf (" IDENT     %#06x  self-contained %#06x",
    #####:18799:			  option.info & OGP_GROUP,
    #####:18800:			  (option.info & OGP_SELF) >> 16);
    #####:18801:		  break;
        -:18802:
    #####:18803:		default:
        -:18804:		  /* This shouldn't happen.  */
    #####:18805:		  printf (" %3d ???     %" PRId16 " %" PRIx32,
    #####:18806:			  option.kind, option.section, option.info);
    #####:18807:		  break;
        -:18808:		}
        -:18809:
    #####:18810:	      len = sizeof (* eopt);
    #####:18811:	      while (len < option.size)
        -:18812:		{
    #####:18813:		  unsigned char datum = *((unsigned char *) eoption + len);
        -:18814:
    #####:18815:		  if (ISPRINT (datum))
    #####:18816:		    printf ("%c", datum);
        -:18817:		  else
    #####:18818:		    printf ("\\%03o", datum);
    #####:18819:		  len ++;
        -:18820:		}
    #####:18821:	      fputs ("\n", stdout);
        -:18822:
    #####:18823:	      offset += option.size;
        -:18824:	    }
    #####:18825:	  free (eopt);
        -:18826:	}
        -:18827:      else
    #####:18828:	res = false;
        -:18829:    }
        -:18830:
       1*:18831:  if (conflicts_offset != 0 && conflictsno != 0)
        -:18832:    {
        -:18833:      Elf32_Conflict * iconf;
        -:18834:      size_t cnt;
        -:18835:
    #####:18836:      if (filedata->dynamic_symbols == NULL)
        -:18837:	{
    #####:18838:	  error (_("conflict list found without a dynamic symbol table\n"));
    #####:18839:	  return false;
        -:18840:	}
        -:18841:
        -:18842:      /* PR 21345 - print a slightly more helpful error message
        -:18843:	 if we are sure that the cmalloc will fail.  */
    #####:18844:      if (conflictsno > filedata->file_size / sizeof (* iconf))
        -:18845:	{
    #####:18846:	  error (_("Overlarge number of conflicts detected: %lx\n"),
        -:18847:		 (long) conflictsno);
    #####:18848:	  return false;
        -:18849:	}
        -:18850:
    #####:18851:      iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));
    #####:18852:      if (iconf == NULL)
        -:18853:	{
    #####:18854:	  error (_("Out of memory allocating space for dynamic conflicts\n"));
    #####:18855:	  return false;
        -:18856:	}
        -:18857:
    #####:18858:      if (is_32bit_elf)
        -:18859:	{
        -:18860:	  Elf32_External_Conflict * econf32;
        -:18861:
        -:18862:	  econf32 = (Elf32_External_Conflict *)
    #####:18863:	    get_data (NULL, filedata, conflicts_offset,
    #####:18864:		      sizeof (*econf32), conflictsno, _("conflict"));
    #####:18865:	  if (!econf32)
        -:18866:	    {
    #####:18867:	      free (iconf);
    #####:18868:	      return false;
        -:18869:	    }
        -:18870:
    #####:18871:	  for (cnt = 0; cnt < conflictsno; ++cnt)
    #####:18872:	    iconf[cnt] = BYTE_GET (econf32[cnt]);
        -:18873:
    #####:18874:	  free (econf32);
        -:18875:	}
        -:18876:      else
        -:18877:	{
        -:18878:	  Elf64_External_Conflict * econf64;
        -:18879:
        -:18880:	  econf64 = (Elf64_External_Conflict *)
    #####:18881:	    get_data (NULL, filedata, conflicts_offset,
    #####:18882:		      sizeof (*econf64), conflictsno, _("conflict"));
    #####:18883:	  if (!econf64)
        -:18884:	    {
    #####:18885:	      free (iconf);
    #####:18886:	      return false;
        -:18887:	    }
        -:18888:
    #####:18889:	  for (cnt = 0; cnt < conflictsno; ++cnt)
    #####:18890:	    iconf[cnt] = BYTE_GET (econf64[cnt]);
        -:18891:
    #####:18892:	  free (econf64);
        -:18893:	}
        -:18894:
    #####:18895:      printf (ngettext ("\nSection '.conflict' contains %lu entry:\n",
        -:18896:			"\nSection '.conflict' contains %lu entries:\n",
        -:18897:			(unsigned long) conflictsno),
        -:18898:	      (unsigned long) conflictsno);
    #####:18899:      puts (_("  Num:    Index       Value  Name"));
        -:18900:
    #####:18901:      for (cnt = 0; cnt < conflictsno; ++cnt)
        -:18902:	{
    #####:18903:	  printf ("%5lu: %8lu  ", (unsigned long) cnt, iconf[cnt]);
        -:18904:
    #####:18905:	  if (iconf[cnt] >= filedata->num_dynamic_syms)
    #####:18906:	    printf (_("<corrupt symbol index>"));
        -:18907:	  else
        -:18908:	    {
        -:18909:	      Elf_Internal_Sym * psym;
        -:18910:
    #####:18911:	      psym = & filedata->dynamic_symbols[iconf[cnt]];
    #####:18912:	      print_vma (psym->st_value, FULL_HEX);
    #####:18913:	      putchar (' ');
    #####:18914:	      if (valid_dynamic_name (filedata, psym->st_name))
    #####:18915:		print_symbol (25, get_dynamic_name (filedata, psym->st_name));
        -:18916:	      else
    #####:18917:		printf (_("<corrupt: %14ld>"), psym->st_name);
        -:18918:	    }
    #####:18919:	  putchar ('\n');
        -:18920:	}
        -:18921:
    #####:18922:      free (iconf);
        -:18923:    }
        -:18924:
       1*:18925:  if (pltgot != 0 && local_gotno != 0)
        -:18926:    {
        -:18927:      bfd_vma ent, local_end, global_end;
        -:18928:      size_t i, offset;
        -:18929:      unsigned char * data;
        -:18930:      unsigned char * data_end;
        -:18931:      int addr_size;
        -:18932:
    #####:18933:      ent = pltgot;
    #####:18934:      addr_size = (is_32bit_elf ? 4 : 8);
    #####:18935:      local_end = pltgot + local_gotno * addr_size;
        -:18936:
        -:18937:      /* PR binutils/17533 file: 012-111227-0.004  */
    #####:18938:      if (symtabno < gotsym)
        -:18939:	{
    #####:18940:	  error (_("The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\n"),
        -:18941:		 (unsigned long) gotsym, (unsigned long) symtabno);
    #####:18942:	  return false;
        -:18943:	}
        -:18944:
    #####:18945:      global_end = local_end + (symtabno - gotsym) * addr_size;
        -:18946:      /* PR 17531: file: 54c91a34.  */
    #####:18947:      if (global_end < local_end)
        -:18948:	{
    #####:18949:	  error (_("Too many GOT symbols: %lu\n"), (unsigned long) symtabno);
    #####:18950:	  return false;
        -:18951:	}
        -:18952:
    #####:18953:      offset = offset_from_vma (filedata, pltgot, global_end - pltgot);
    #####:18954:      data = (unsigned char *) get_data (NULL, filedata, offset,
        -:18955:                                         global_end - pltgot, 1,
    #####:18956:					 _("Global Offset Table data"));
        -:18957:      /* PR 12855: Null data is handled gracefully throughout.  */
    #####:18958:      data_end = data + (global_end - pltgot);
        -:18959:
    #####:18960:      printf (_("\nPrimary GOT:\n"));
    #####:18961:      printf (_(" Canonical gp value: "));
    #####:18962:      print_vma (pltgot + 0x7ff0, LONG_HEX);
    #####:18963:      printf ("\n\n");
        -:18964:
    #####:18965:      printf (_(" Reserved entries:\n"));
    #####:18966:      printf (_("  %*s %10s %*s Purpose\n"),
        -:18967:	      addr_size * 2, _("Address"), _("Access"),
        -:18968:	      addr_size * 2, _("Initial"));
    #####:18969:      ent = print_mips_got_entry (data, pltgot, ent, data_end);
    #####:18970:      printf (_(" Lazy resolver\n"));
    #####:18971:      if (ent == (bfd_vma) -1)
    #####:18972:	goto got_print_fail;
        -:18973:
        -:18974:      /* Check for the MSB of GOT[1] being set, denoting a GNU object.
        -:18975:	 This entry will be used by some runtime loaders, to store the
        -:18976:	 module pointer.  Otherwise this is an ordinary local entry.
        -:18977:	 PR 21344: Check for the entry being fully available before
        -:18978:	 fetching it.  */
    #####:18979:      if (data
    #####:18980:	  && data + ent - pltgot + addr_size <= data_end
    #####:18981:	  && (byte_get (data + ent - pltgot, addr_size)
    #####:18982:	      >> (addr_size * 8 - 1)) != 0)
        -:18983:	{
    #####:18984:	  ent = print_mips_got_entry (data, pltgot, ent, data_end);
    #####:18985:	  printf (_(" Module pointer (GNU extension)\n"));
    #####:18986:	  if (ent == (bfd_vma) -1)
    #####:18987:	    goto got_print_fail;
        -:18988:	}
    #####:18989:      printf ("\n");
        -:18990:
    #####:18991:      if (data != NULL && ent < local_end)
        -:18992:	{
    #####:18993:	  printf (_(" Local entries:\n"));
    #####:18994:	  printf ("  %*s %10s %*s\n",
        -:18995:		  addr_size * 2, _("Address"), _("Access"),
        -:18996:		  addr_size * 2, _("Initial"));
    #####:18997:	  while (ent < local_end)
        -:18998:	    {
    #####:18999:	      ent = print_mips_got_entry (data, pltgot, ent, data_end);
    #####:19000:	      printf ("\n");
    #####:19001:	      if (ent == (bfd_vma) -1)
    #####:19002:		goto got_print_fail;
        -:19003:	    }
    #####:19004:	  printf ("\n");
        -:19005:	}
        -:19006:
    #####:19007:      if (data != NULL && gotsym < symtabno)
        -:19008:	{
        -:19009:	  int sym_width;
        -:19010:
    #####:19011:	  printf (_(" Global entries:\n"));
    #####:19012:	  printf ("  %*s %10s %*s %*s %-7s %3s %s\n",
        -:19013:		  addr_size * 2, _("Address"),
        -:19014:		  _("Access"),
        -:19015:		  addr_size * 2, _("Initial"),
        -:19016:		  addr_size * 2, _("Sym.Val."),
        -:19017:		  _("Type"),
        -:19018:		  /* Note for translators: "Ndx" = abbreviated form of "Index".  */
        -:19019:		  _("Ndx"), _("Name"));
        -:19020:
    #####:19021:	  sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1;
        -:19022:
    #####:19023:	  for (i = gotsym; i < symtabno; i++)
        -:19024:	    {
    #####:19025:	      ent = print_mips_got_entry (data, pltgot, ent, data_end);
    #####:19026:	      printf (" ");
        -:19027:
    #####:19028:	      if (filedata->dynamic_symbols == NULL)
    #####:19029:		printf (_("<no dynamic symbols>"));
    #####:19030:	      else if (i < filedata->num_dynamic_syms)
        -:19031:		{
    #####:19032:		  Elf_Internal_Sym * psym = filedata->dynamic_symbols + i;
        -:19033:
    #####:19034:		  print_vma (psym->st_value, LONG_HEX);
    #####:19035:		  printf (" %-7s %3s ",
    #####:19036:			  get_symbol_type (filedata, ELF_ST_TYPE (psym->st_info)),
        -:19037:			  get_symbol_index_type (filedata, psym->st_shndx));
        -:19038:
    #####:19039:		  if (valid_dynamic_name (filedata, psym->st_name))
    #####:19040:		    print_symbol (sym_width,
        -:19041:				  get_dynamic_name (filedata, psym->st_name));
        -:19042:		  else
    #####:19043:		    printf (_("<corrupt: %14ld>"), psym->st_name);
        -:19044:		}
        -:19045:	      else
    #####:19046:		printf (_("<symbol index %lu exceeds number of dynamic symbols>"),
        -:19047:			(unsigned long) i);
        -:19048:
    #####:19049:	      printf ("\n");
    #####:19050:	      if (ent == (bfd_vma) -1)
    #####:19051:		break;
        -:19052:	    }
    #####:19053:	  printf ("\n");
        -:19054:	}
        -:19055:
    #####:19056:    got_print_fail:
    #####:19057:      free (data);
        -:19058:    }
        -:19059:
       1*:19060:  if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0)
        -:19061:    {
        -:19062:      bfd_vma ent, end;
        -:19063:      size_t offset, rel_offset;
        -:19064:      unsigned long count, i;
        -:19065:      unsigned char * data;
        -:19066:      int addr_size, sym_width;
        -:19067:      Elf_Internal_Rela * rels;
        -:19068:
    #####:19069:      rel_offset = offset_from_vma (filedata, jmprel, pltrelsz);
    #####:19070:      if (pltrel == DT_RELA)
        -:19071:	{
    #####:19072:	  if (!slurp_rela_relocs (filedata, rel_offset, pltrelsz, &rels, &count))
    #####:19073:	    return false;
        -:19074:	}
        -:19075:      else
        -:19076:	{
    #####:19077:	  if (!slurp_rel_relocs (filedata, rel_offset, pltrelsz, &rels, &count))
    #####:19078:	    return false;
        -:19079:	}
        -:19080:
    #####:19081:      ent = mips_pltgot;
    #####:19082:      addr_size = (is_32bit_elf ? 4 : 8);
    #####:19083:      end = mips_pltgot + (2 + count) * addr_size;
        -:19084:
    #####:19085:      offset = offset_from_vma (filedata, mips_pltgot, end - mips_pltgot);
    #####:19086:      data = (unsigned char *) get_data (NULL, filedata, offset, end - mips_pltgot,
    #####:19087:                                         1, _("Procedure Linkage Table data"));
    #####:19088:      if (data == NULL)
        -:19089:	{
    #####:19090:	  free (rels);
    #####:19091:	  return false;
        -:19092:	}
        -:19093:
    #####:19094:      printf ("\nPLT GOT:\n\n");
    #####:19095:      printf (_(" Reserved entries:\n"));
    #####:19096:      printf (_("  %*s %*s Purpose\n"),
        -:19097:	      addr_size * 2, _("Address"), addr_size * 2, _("Initial"));
    #####:19098:      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
    #####:19099:      printf (_(" PLT lazy resolver\n"));
    #####:19100:      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
    #####:19101:      printf (_(" Module pointer\n"));
    #####:19102:      printf ("\n");
        -:19103:
    #####:19104:      printf (_(" Entries:\n"));
    #####:19105:      printf ("  %*s %*s %*s %-7s %3s %s\n",
        -:19106:	      addr_size * 2, _("Address"),
        -:19107:	      addr_size * 2, _("Initial"),
        -:19108:	      addr_size * 2, _("Sym.Val."), _("Type"), _("Ndx"), _("Name"));
    #####:19109:      sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1;
    #####:19110:      for (i = 0; i < count; i++)
        -:19111:	{
    #####:19112:	  unsigned long idx = get_reloc_symindex (rels[i].r_info);
        -:19113:
    #####:19114:	  ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
    #####:19115:	  printf (" ");
        -:19116:
    #####:19117:	  if (idx >= filedata->num_dynamic_syms)
    #####:19118:	    printf (_("<corrupt symbol index: %lu>"), idx);
        -:19119:	  else
        -:19120:	    {
    #####:19121:	      Elf_Internal_Sym * psym = filedata->dynamic_symbols + idx;
        -:19122:
    #####:19123:	      print_vma (psym->st_value, LONG_HEX);
    #####:19124:	      printf (" %-7s %3s ",
    #####:19125:		      get_symbol_type (filedata, ELF_ST_TYPE (psym->st_info)),
        -:19126:		      get_symbol_index_type (filedata, psym->st_shndx));
    #####:19127:	      if (valid_dynamic_name (filedata, psym->st_name))
    #####:19128:		print_symbol (sym_width,
        -:19129:			      get_dynamic_name (filedata, psym->st_name));
        -:19130:	      else
    #####:19131:		printf (_("<corrupt: %14ld>"), psym->st_name);
        -:19132:	    }
    #####:19133:	  printf ("\n");
        -:19134:	}
    #####:19135:      printf ("\n");
        -:19136:
    #####:19137:      free (data);
    #####:19138:      free (rels);
        -:19139:    }
        -:19140:
        1:19141:  return res;
        -:19142:}
        -:19143:
        -:19144:static bool
    #####:19145:process_nds32_specific (Filedata * filedata)
        -:19146:{
    #####:19147:  Elf_Internal_Shdr *sect = NULL;
        -:19148:
    #####:19149:  sect = find_section (filedata, ".nds32_e_flags");
    #####:19150:  if (sect != NULL && sect->sh_size >= 4)
        -:19151:    {
        -:19152:      unsigned char *buf;
        -:19153:      unsigned int flag;
        -:19154:
    #####:19155:      printf ("\nNDS32 elf flags section:\n");
    #####:19156:      buf = get_data (NULL, filedata, sect->sh_offset, 1, 4,
    #####:19157:		      _("NDS32 elf flags section"));
        -:19158:
    #####:19159:      if (buf == NULL)
    #####:19160:	return false;
        -:19161:
    #####:19162:      flag = byte_get (buf, 4);
    #####:19163:      free (buf);
    #####:19164:      switch (flag & 0x3)
        -:19165:	{
    #####:19166:	case 0:
    #####:19167:	  printf ("(VEC_SIZE):\tNo entry.\n");
    #####:19168:	  break;
    #####:19169:	case 1:
    #####:19170:	  printf ("(VEC_SIZE):\t4 bytes\n");
    #####:19171:	  break;
    #####:19172:	case 2:
    #####:19173:	  printf ("(VEC_SIZE):\t16 bytes\n");
    #####:19174:	  break;
    #####:19175:	case 3:
    #####:19176:	  printf ("(VEC_SIZE):\treserved\n");
    #####:19177:	  break;
        -:19178:	}
    #####:19179:    }
        -:19180:
    #####:19181:  return true;
        -:19182:}
        -:19183:
        -:19184:static bool
     1391:19185:process_gnu_liblist (Filedata * filedata)
        -:19186:{
        -:19187:  Elf_Internal_Shdr * section;
        -:19188:  Elf_Internal_Shdr * string_sec;
        -:19189:  Elf32_External_Lib * elib;
        -:19190:  char * strtab;
        -:19191:  size_t strtab_size;
        -:19192:  size_t cnt;
        -:19193:  unsigned long num_liblist;
        -:19194:  unsigned i;
     1391:19195:  bool res = true;
        -:19196:
     1391:19197:  if (! do_arch)
     1228:19198:    return true;
        -:19199:
      163:19200:  for (i = 0, section = filedata->section_headers;
      807:19201:       i < filedata->file_header.e_shnum;
      644:19202:       i++, section++)
        -:19203:    {
      644:19204:      switch (section->sh_type)
        -:19205:	{
    #####:19206:	case SHT_GNU_LIBLIST:
    #####:19207:	  if (section->sh_link >= filedata->file_header.e_shnum)
    #####:19208:	    break;
        -:19209:
        -:19210:	  elib = (Elf32_External_Lib *)
    #####:19211:              get_data (NULL, filedata, section->sh_offset, 1, section->sh_size,
    #####:19212:                        _("liblist section data"));
        -:19213:
    #####:19214:	  if (elib == NULL)
        -:19215:	    {
    #####:19216:	      res = false;
    #####:19217:	      break;
        -:19218:	    }
        -:19219:
    #####:19220:	  string_sec = filedata->section_headers + section->sh_link;
    #####:19221:	  strtab = (char *) get_data (NULL, filedata, string_sec->sh_offset, 1,
        -:19222:                                      string_sec->sh_size,
    #####:19223:                                      _("liblist string table"));
    #####:19224:	  if (strtab == NULL
    #####:19225:	      || section->sh_entsize != sizeof (Elf32_External_Lib))
        -:19226:	    {
    #####:19227:	      free (elib);
    #####:19228:	      free (strtab);
    #####:19229:	      res = false;
    #####:19230:	      break;
        -:19231:	    }
    #####:19232:	  strtab_size = string_sec->sh_size;
        -:19233:
    #####:19234:	  num_liblist = section->sh_size / sizeof (Elf32_External_Lib);
    #####:19235:	  printf (ngettext ("\nLibrary list section '%s' contains %lu entries:\n",
        -:19236:			    "\nLibrary list section '%s' contains %lu entries:\n",
        -:19237:			    num_liblist),
        -:19238:		  printable_section_name (filedata, section),
        -:19239:		  num_liblist);
        -:19240:
    #####:19241:	  puts (_("     Library              Time Stamp          Checksum   Version Flags"));
        -:19242:
    #####:19243:	  for (cnt = 0; cnt < section->sh_size / sizeof (Elf32_External_Lib);
    #####:19244:	       ++cnt)
        -:19245:	    {
        -:19246:	      Elf32_Lib liblist;
        -:19247:	      time_t atime;
        -:19248:	      char timebuf[128];
        -:19249:	      struct tm * tmp;
        -:19250:
    #####:19251:	      liblist.l_name = BYTE_GET (elib[cnt].l_name);
    #####:19252:	      atime = BYTE_GET (elib[cnt].l_time_stamp);
    #####:19253:	      liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);
    #####:19254:	      liblist.l_version = BYTE_GET (elib[cnt].l_version);
    #####:19255:	      liblist.l_flags = BYTE_GET (elib[cnt].l_flags);
        -:19256:
    #####:19257:	      tmp = gmtime (&atime);
    #####:19258:	      snprintf (timebuf, sizeof (timebuf),
        -:19259:			"%04u-%02u-%02uT%02u:%02u:%02u",
    #####:19260:			tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
        -:19261:			tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
        -:19262:
    #####:19263:	      printf ("%3lu: ", (unsigned long) cnt);
    #####:19264:	      if (do_wide)
    #####:19265:		printf ("%-20s", liblist.l_name < strtab_size
    #####:19266:			? strtab + liblist.l_name : _("<corrupt>"));
        -:19267:	      else
    #####:19268:		printf ("%-20.20s", liblist.l_name < strtab_size
    #####:19269:			? strtab + liblist.l_name : _("<corrupt>"));
    #####:19270:	      printf (" %s %#010lx %-7ld %-7ld\n", timebuf, liblist.l_checksum,
        -:19271:		      liblist.l_version, liblist.l_flags);
        -:19272:	    }
        -:19273:
    #####:19274:	  free (elib);
    #####:19275:	  free (strtab);
        -:19276:	}
      644:19277:    }
        -:19278:
      163:19279:  return res;
        -:19280:}
        -:19281:
        -:19282:static const char *
        5:19283:get_note_type (Filedata * filedata, unsigned e_type)
        -:19284:{
        -:19285:  static char buff[64];
        -:19286:
        5:19287:  if (filedata->file_header.e_type == ET_CORE)
    #####:19288:    switch (e_type)
        -:19289:      {
    #####:19290:      case NT_AUXV:
    #####:19291:	return _("NT_AUXV (auxiliary vector)");
    #####:19292:      case NT_PRSTATUS:
    #####:19293:	return _("NT_PRSTATUS (prstatus structure)");
    #####:19294:      case NT_FPREGSET:
    #####:19295:	return _("NT_FPREGSET (floating point registers)");
    #####:19296:      case NT_PRPSINFO:
    #####:19297:	return _("NT_PRPSINFO (prpsinfo structure)");
    #####:19298:      case NT_TASKSTRUCT:
    #####:19299:	return _("NT_TASKSTRUCT (task structure)");
    #####:19300:      case NT_GDB_TDESC:
    #####:19301:        return _("NT_GDB_TDESC (GDB XML target description)");
    #####:19302:      case NT_PRXFPREG:
    #####:19303:	return _("NT_PRXFPREG (user_xfpregs structure)");
    #####:19304:      case NT_PPC_VMX:
    #####:19305:	return _("NT_PPC_VMX (ppc Altivec registers)");
    #####:19306:      case NT_PPC_VSX:
    #####:19307:	return _("NT_PPC_VSX (ppc VSX registers)");
    #####:19308:      case NT_PPC_TAR:
    #####:19309:	return _("NT_PPC_TAR (ppc TAR register)");
    #####:19310:      case NT_PPC_PPR:
    #####:19311:	return _("NT_PPC_PPR (ppc PPR register)");
    #####:19312:      case NT_PPC_DSCR:
    #####:19313:	return _("NT_PPC_DSCR (ppc DSCR register)");
    #####:19314:      case NT_PPC_EBB:
    #####:19315:	return _("NT_PPC_EBB (ppc EBB registers)");
    #####:19316:      case NT_PPC_PMU:
    #####:19317:	return _("NT_PPC_PMU (ppc PMU registers)");
    #####:19318:      case NT_PPC_TM_CGPR:
    #####:19319:	return _("NT_PPC_TM_CGPR (ppc checkpointed GPR registers)");
    #####:19320:      case NT_PPC_TM_CFPR:
    #####:19321:	return _("NT_PPC_TM_CFPR (ppc checkpointed floating point registers)");
    #####:19322:      case NT_PPC_TM_CVMX:
    #####:19323:	return _("NT_PPC_TM_CVMX (ppc checkpointed Altivec registers)");
    #####:19324:      case NT_PPC_TM_CVSX:
    #####:19325:	return _("NT_PPC_TM_CVSX (ppc checkpointed VSX registers)");
    #####:19326:      case NT_PPC_TM_SPR:
    #####:19327:	return _("NT_PPC_TM_SPR (ppc TM special purpose registers)");
    #####:19328:      case NT_PPC_TM_CTAR:
    #####:19329:	return _("NT_PPC_TM_CTAR (ppc checkpointed TAR register)");
    #####:19330:      case NT_PPC_TM_CPPR:
    #####:19331:	return _("NT_PPC_TM_CPPR (ppc checkpointed PPR register)");
    #####:19332:      case NT_PPC_TM_CDSCR:
    #####:19333:	return _("NT_PPC_TM_CDSCR (ppc checkpointed DSCR register)");
    #####:19334:      case NT_386_TLS:
    #####:19335:	return _("NT_386_TLS (x86 TLS information)");
    #####:19336:      case NT_386_IOPERM:
    #####:19337:	return _("NT_386_IOPERM (x86 I/O permissions)");
    #####:19338:      case NT_X86_XSTATE:
    #####:19339:	return _("NT_X86_XSTATE (x86 XSAVE extended state)");
    #####:19340:      case NT_X86_CET:
    #####:19341:	return _("NT_X86_CET (x86 CET state)");
    #####:19342:      case NT_S390_HIGH_GPRS:
    #####:19343:	return _("NT_S390_HIGH_GPRS (s390 upper register halves)");
    #####:19344:      case NT_S390_TIMER:
    #####:19345:	return _("NT_S390_TIMER (s390 timer register)");
    #####:19346:      case NT_S390_TODCMP:
    #####:19347:	return _("NT_S390_TODCMP (s390 TOD comparator register)");
    #####:19348:      case NT_S390_TODPREG:
    #####:19349:	return _("NT_S390_TODPREG (s390 TOD programmable register)");
    #####:19350:      case NT_S390_CTRS:
    #####:19351:	return _("NT_S390_CTRS (s390 control registers)");
    #####:19352:      case NT_S390_PREFIX:
    #####:19353:	return _("NT_S390_PREFIX (s390 prefix register)");
    #####:19354:      case NT_S390_LAST_BREAK:
    #####:19355:	return _("NT_S390_LAST_BREAK (s390 last breaking event address)");
    #####:19356:      case NT_S390_SYSTEM_CALL:
    #####:19357:	return _("NT_S390_SYSTEM_CALL (s390 system call restart data)");
    #####:19358:      case NT_S390_TDB:
    #####:19359:	return _("NT_S390_TDB (s390 transaction diagnostic block)");
    #####:19360:      case NT_S390_VXRS_LOW:
    #####:19361:	return _("NT_S390_VXRS_LOW (s390 vector registers 0-15 upper half)");
    #####:19362:      case NT_S390_VXRS_HIGH:
    #####:19363:	return _("NT_S390_VXRS_HIGH (s390 vector registers 16-31)");
    #####:19364:      case NT_S390_GS_CB:
    #####:19365:	return _("NT_S390_GS_CB (s390 guarded-storage registers)");
    #####:19366:      case NT_S390_GS_BC:
    #####:19367:	return _("NT_S390_GS_BC (s390 guarded-storage broadcast control)");
    #####:19368:      case NT_ARM_VFP:
    #####:19369:	return _("NT_ARM_VFP (arm VFP registers)");
    #####:19370:      case NT_ARM_TLS:
    #####:19371:	return _("NT_ARM_TLS (AArch TLS registers)");
    #####:19372:      case NT_ARM_HW_BREAK:
    #####:19373:	return _("NT_ARM_HW_BREAK (AArch hardware breakpoint registers)");
    #####:19374:      case NT_ARM_HW_WATCH:
    #####:19375:	return _("NT_ARM_HW_WATCH (AArch hardware watchpoint registers)");
    #####:19376:      case NT_ARM_SYSTEM_CALL:
    #####:19377:	return _("NT_ARM_SYSTEM_CALL (AArch system call number)");
    #####:19378:      case NT_ARM_SVE:
    #####:19379:	return _("NT_ARM_SVE (AArch SVE registers)");
    #####:19380:      case NT_ARM_PAC_MASK:
    #####:19381:	return _("NT_ARM_PAC_MASK (AArch pointer authentication code masks)");
    #####:19382:      case NT_ARM_PACA_KEYS:
    #####:19383:	return _("NT_ARM_PACA_KEYS (ARM pointer authentication address keys)");
    #####:19384:      case NT_ARM_PACG_KEYS:
    #####:19385:	return _("NT_ARM_PACG_KEYS (ARM pointer authentication generic keys)");
    #####:19386:      case NT_ARM_TAGGED_ADDR_CTRL:
    #####:19387:	return _("NT_ARM_TAGGED_ADDR_CTRL (AArch tagged address control)");
    #####:19388:      case NT_ARM_PAC_ENABLED_KEYS:
    #####:19389:	return _("NT_ARM_PAC_ENABLED_KEYS (AArch64 pointer authentication enabled keys)");
    #####:19390:      case NT_ARC_V2:
    #####:19391:	return _("NT_ARC_V2 (ARC HS accumulator/extra registers)");
    #####:19392:      case NT_RISCV_CSR:
    #####:19393:	return _("NT_RISCV_CSR (RISC-V control and status registers)");
    #####:19394:      case NT_PSTATUS:
    #####:19395:	return _("NT_PSTATUS (pstatus structure)");
    #####:19396:      case NT_FPREGS:
    #####:19397:	return _("NT_FPREGS (floating point registers)");
    #####:19398:      case NT_PSINFO:
    #####:19399:	return _("NT_PSINFO (psinfo structure)");
    #####:19400:      case NT_LWPSTATUS:
    #####:19401:	return _("NT_LWPSTATUS (lwpstatus_t structure)");
    #####:19402:      case NT_LWPSINFO:
    #####:19403:	return _("NT_LWPSINFO (lwpsinfo_t structure)");
    #####:19404:      case NT_WIN32PSTATUS:
    #####:19405:	return _("NT_WIN32PSTATUS (win32_pstatus structure)");
    #####:19406:      case NT_SIGINFO:
    #####:19407:	return _("NT_SIGINFO (siginfo_t data)");
    #####:19408:      case NT_FILE:
    #####:19409:	return _("NT_FILE (mapped files)");
    #####:19410:      default:
    #####:19411:	break;
        -:19412:      }
        -:19413:  else
        5:19414:    switch (e_type)
        -:19415:      {
    #####:19416:      case NT_VERSION:
    #####:19417:	return _("NT_VERSION (version)");
    #####:19418:      case NT_ARCH:
    #####:19419:	return _("NT_ARCH (architecture)");
    #####:19420:      case NT_GNU_BUILD_ATTRIBUTE_OPEN:
    #####:19421:	return _("OPEN");
    #####:19422:      case NT_GNU_BUILD_ATTRIBUTE_FUNC:
    #####:19423:	return _("func");
    #####:19424:      case NT_GO_BUILDID:
    #####:19425:	return _("GO BUILDID");
    #####:19426:      case FDO_PACKAGING_METADATA:
    #####:19427:	return _("FDO_PACKAGING_METADATA");
        5:19428:      default:
        5:19429:	break;
        -:19430:      }
        -:19431:
        5:19432:  snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
        5:19433:  return buff;
        -:19434:}
        -:19435:
        -:19436:static bool
    #####:19437:print_core_note (Elf_Internal_Note *pnote)
        -:19438:{
    #####:19439:  unsigned int addr_size = is_32bit_elf ? 4 : 8;
        -:19440:  bfd_vma count, page_size;
        -:19441:  unsigned char *descdata, *filenames, *descend;
        -:19442:
    #####:19443:  if (pnote->type != NT_FILE)
        -:19444:    {
    #####:19445:      if (do_wide)
    #####:19446:	printf ("\n");
    #####:19447:      return true;
        -:19448:    }
        -:19449:
        -:19450:#ifndef BFD64
        -:19451:  if (!is_32bit_elf)
        -:19452:    {
        -:19453:      printf (_("    Cannot decode 64-bit note in 32-bit build\n"));
        -:19454:      /* Still "successful".  */
        -:19455:      return true;
        -:19456:    }
        -:19457:#endif
        -:19458:
    #####:19459:  if (pnote->descsz < 2 * addr_size)
        -:19460:    {
    #####:19461:      error (_("    Malformed note - too short for header\n"));
    #####:19462:      return false;
        -:19463:    }
        -:19464:
    #####:19465:  descdata = (unsigned char *) pnote->descdata;
    #####:19466:  descend = descdata + pnote->descsz;
        -:19467:
    #####:19468:  if (descdata[pnote->descsz - 1] != '\0')
        -:19469:    {
    #####:19470:      error (_("    Malformed note - does not end with \\0\n"));
    #####:19471:      return false;
        -:19472:    }
        -:19473:
    #####:19474:  count = byte_get (descdata, addr_size);
    #####:19475:  descdata += addr_size;
        -:19476:
    #####:19477:  page_size = byte_get (descdata, addr_size);
    #####:19478:  descdata += addr_size;
        -:19479:
    #####:19480:  if (count > ((bfd_vma) -1 - 2 * addr_size) / (3 * addr_size)
    #####:19481:      || pnote->descsz < 2 * addr_size + count * 3 * addr_size)
        -:19482:    {
    #####:19483:      error (_("    Malformed note - too short for supplied file count\n"));
    #####:19484:      return false;
        -:19485:    }
        -:19486:
    #####:19487:  printf (_("    Page size: "));
    #####:19488:  print_vma (page_size, DEC);
    #####:19489:  printf ("\n");
        -:19490:
    #####:19491:  printf (_("    %*s%*s%*s\n"),
    #####:19492:	  (int) (2 + 2 * addr_size), _("Start"),
    #####:19493:	  (int) (4 + 2 * addr_size), _("End"),
    #####:19494:	  (int) (4 + 2 * addr_size), _("Page Offset"));
    #####:19495:  filenames = descdata + count * 3 * addr_size;
    #####:19496:  while (count-- > 0)
        -:19497:    {
        -:19498:      bfd_vma start, end, file_ofs;
        -:19499:
    #####:19500:      if (filenames == descend)
        -:19501:	{
    #####:19502:	  error (_("    Malformed note - filenames end too early\n"));
    #####:19503:	  return false;
        -:19504:	}
        -:19505:
    #####:19506:      start = byte_get (descdata, addr_size);
    #####:19507:      descdata += addr_size;
    #####:19508:      end = byte_get (descdata, addr_size);
    #####:19509:      descdata += addr_size;
    #####:19510:      file_ofs = byte_get (descdata, addr_size);
    #####:19511:      descdata += addr_size;
        -:19512:
    #####:19513:      printf ("    ");
    #####:19514:      print_vma (start, FULL_HEX);
    #####:19515:      printf ("  ");
    #####:19516:      print_vma (end, FULL_HEX);
    #####:19517:      printf ("  ");
    #####:19518:      print_vma (file_ofs, FULL_HEX);
    #####:19519:      printf ("\n        %s\n", filenames);
        -:19520:
    #####:19521:      filenames += 1 + strlen ((char *) filenames);
        -:19522:    }
        -:19523:
    #####:19524:  return true;
        -:19525:}
        -:19526:
        -:19527:static const char *
    #####:19528:get_gnu_elf_note_type (unsigned e_type)
        -:19529:{
        -:19530:  /* NB/ Keep this switch statement in sync with print_gnu_note ().  */
    #####:19531:  switch (e_type)
        -:19532:    {
    #####:19533:    case NT_GNU_ABI_TAG:
    #####:19534:      return _("NT_GNU_ABI_TAG (ABI version tag)");
    #####:19535:    case NT_GNU_HWCAP:
    #####:19536:      return _("NT_GNU_HWCAP (DSO-supplied software HWCAP info)");
    #####:19537:    case NT_GNU_BUILD_ID:
    #####:19538:      return _("NT_GNU_BUILD_ID (unique build ID bitstring)");
    #####:19539:    case NT_GNU_GOLD_VERSION:
    #####:19540:      return _("NT_GNU_GOLD_VERSION (gold version)");
    #####:19541:    case NT_GNU_PROPERTY_TYPE_0:
    #####:19542:      return _("NT_GNU_PROPERTY_TYPE_0");
    #####:19543:    case NT_GNU_BUILD_ATTRIBUTE_OPEN:
    #####:19544:      return _("NT_GNU_BUILD_ATTRIBUTE_OPEN");
    #####:19545:    case NT_GNU_BUILD_ATTRIBUTE_FUNC:
    #####:19546:      return _("NT_GNU_BUILD_ATTRIBUTE_FUNC");
    #####:19547:    default:
        -:19548:      {
        -:19549:	static char buff[64];
        -:19550:
    #####:19551:	snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
    #####:19552:	return buff;
        -:19553:      }
        -:19554:    }
        -:19555:}
        -:19556:
        -:19557:static void
    #####:19558:decode_x86_compat_isa (unsigned int bitmask)
        -:19559:{
    #####:19560:  while (bitmask)
        -:19561:    {
    #####:19562:      unsigned int bit = bitmask & (- bitmask);
        -:19563:
    #####:19564:      bitmask &= ~ bit;
    #####:19565:      switch (bit)
        -:19566:	{
    #####:19567:	case GNU_PROPERTY_X86_COMPAT_ISA_1_486:
    #####:19568:	  printf ("i486");
    #####:19569:	  break;
    #####:19570:	case GNU_PROPERTY_X86_COMPAT_ISA_1_586:
    #####:19571:	  printf ("586");
    #####:19572:	  break;
    #####:19573:	case GNU_PROPERTY_X86_COMPAT_ISA_1_686:
    #####:19574:	  printf ("686");
    #####:19575:	  break;
    #####:19576:	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSE:
    #####:19577:	  printf ("SSE");
    #####:19578:	  break;
    #####:19579:	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSE2:
    #####:19580:	  printf ("SSE2");
    #####:19581:	  break;
    #####:19582:	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSE3:
    #####:19583:	  printf ("SSE3");
    #####:19584:	  break;
    #####:19585:	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSSE3:
    #####:19586:	  printf ("SSSE3");
    #####:19587:	  break;
    #####:19588:	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSE4_1:
    #####:19589:	  printf ("SSE4_1");
    #####:19590:	  break;
    #####:19591:	case GNU_PROPERTY_X86_COMPAT_ISA_1_SSE4_2:
    #####:19592:	  printf ("SSE4_2");
    #####:19593:	  break;
    #####:19594:	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX:
    #####:19595:	  printf ("AVX");
    #####:19596:	  break;
    #####:19597:	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX2:
    #####:19598:	  printf ("AVX2");
    #####:19599:	  break;
    #####:19600:	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512F:
    #####:19601:	  printf ("AVX512F");
    #####:19602:	  break;
    #####:19603:	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512CD:
    #####:19604:	  printf ("AVX512CD");
    #####:19605:	  break;
    #####:19606:	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512ER:
    #####:19607:	  printf ("AVX512ER");
    #####:19608:	  break;
    #####:19609:	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512PF:
    #####:19610:	  printf ("AVX512PF");
    #####:19611:	  break;
    #####:19612:	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512VL:
    #####:19613:	  printf ("AVX512VL");
    #####:19614:	  break;
    #####:19615:	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512DQ:
    #####:19616:	  printf ("AVX512DQ");
    #####:19617:	  break;
    #####:19618:	case GNU_PROPERTY_X86_COMPAT_ISA_1_AVX512BW:
    #####:19619:	  printf ("AVX512BW");
    #####:19620:	  break;
    #####:19621:	default:
    #####:19622:	  printf (_("<unknown: %x>"), bit);
    #####:19623:	  break;
        -:19624:	}
    #####:19625:      if (bitmask)
    #####:19626:	printf (", ");
        -:19627:    }
    #####:19628:}
        -:19629:
        -:19630:static void
    #####:19631:decode_x86_compat_2_isa (unsigned int bitmask)
        -:19632:{
    #####:19633:  if (!bitmask)
        -:19634:    {
    #####:19635:      printf (_("<None>"));
    #####:19636:      return;
        -:19637:    }
        -:19638:
    #####:19639:  while (bitmask)
        -:19640:    {
    #####:19641:      unsigned int bit = bitmask & (- bitmask);
        -:19642:
    #####:19643:      bitmask &= ~ bit;
    #####:19644:      switch (bit)
        -:19645:	{
    #####:19646:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_CMOV:
    #####:19647:	  printf ("CMOV");
    #####:19648:	  break;
    #####:19649:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSE:
    #####:19650:	  printf ("SSE");
    #####:19651:	  break;
    #####:19652:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSE2:
    #####:19653:	  printf ("SSE2");
    #####:19654:	  break;
    #####:19655:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSE3:
    #####:19656:	  printf ("SSE3");
    #####:19657:	  break;
    #####:19658:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSSE3:
    #####:19659:	  printf ("SSSE3");
    #####:19660:	  break;
    #####:19661:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSE4_1:
    #####:19662:	  printf ("SSE4_1");
    #####:19663:	  break;
    #####:19664:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_SSE4_2:
    #####:19665:	  printf ("SSE4_2");
    #####:19666:	  break;
    #####:19667:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX:
    #####:19668:	  printf ("AVX");
    #####:19669:	  break;
    #####:19670:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX2:
    #####:19671:	  printf ("AVX2");
    #####:19672:	  break;
    #####:19673:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_FMA:
    #####:19674:	  printf ("FMA");
    #####:19675:	  break;
    #####:19676:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512F:
    #####:19677:	  printf ("AVX512F");
    #####:19678:	  break;
    #####:19679:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512CD:
    #####:19680:	  printf ("AVX512CD");
    #####:19681:	  break;
    #####:19682:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512ER:
    #####:19683:	  printf ("AVX512ER");
    #####:19684:	  break;
    #####:19685:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512PF:
    #####:19686:	  printf ("AVX512PF");
    #####:19687:	  break;
    #####:19688:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512VL:
    #####:19689:	  printf ("AVX512VL");
    #####:19690:	  break;
    #####:19691:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512DQ:
    #####:19692:	  printf ("AVX512DQ");
    #####:19693:	  break;
    #####:19694:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512BW:
    #####:19695:	  printf ("AVX512BW");
    #####:19696:	  break;
    #####:19697:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_4FMAPS:
    #####:19698:	  printf ("AVX512_4FMAPS");
    #####:19699:	  break;
    #####:19700:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_4VNNIW:
    #####:19701:	  printf ("AVX512_4VNNIW");
    #####:19702:	  break;
    #####:19703:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_BITALG:
    #####:19704:	  printf ("AVX512_BITALG");
    #####:19705:	  break;
    #####:19706:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_IFMA:
    #####:19707:	  printf ("AVX512_IFMA");
    #####:19708:	  break;
    #####:19709:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_VBMI:
    #####:19710:	  printf ("AVX512_VBMI");
    #####:19711:	  break;
    #####:19712:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_VBMI2:
    #####:19713:	  printf ("AVX512_VBMI2");
    #####:19714:	  break;
    #####:19715:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_VNNI:
    #####:19716:	  printf ("AVX512_VNNI");
    #####:19717:	  break;
    #####:19718:	case GNU_PROPERTY_X86_COMPAT_2_ISA_1_AVX512_BF16:
    #####:19719:	  printf ("AVX512_BF16");
    #####:19720:	  break;
    #####:19721:	default:
    #####:19722:	  printf (_("<unknown: %x>"), bit);
    #####:19723:	  break;
        -:19724:	}
    #####:19725:      if (bitmask)
    #####:19726:	printf (", ");
        -:19727:    }
        -:19728:}
        -:19729:
        -:19730:static const char *
    #####:19731:get_amdgpu_elf_note_type (unsigned int e_type)
        -:19732:{
    #####:19733:  switch (e_type)
        -:19734:    {
    #####:19735:    case NT_AMDGPU_METADATA:
    #####:19736:      return _("NT_AMDGPU_METADATA (code object metadata)");
    #####:19737:    default:
        -:19738:      {
        -:19739:	static char buf[64];
    #####:19740:	snprintf (buf, sizeof (buf), _("Unknown note type: (0x%08x)"), e_type);
    #####:19741:	return buf;
        -:19742:      }
        -:19743:    }
        -:19744:}
        -:19745:
        -:19746:static void
    #####:19747:decode_x86_isa (unsigned int bitmask)
        -:19748:{
    #####:19749:  while (bitmask)
        -:19750:    {
    #####:19751:      unsigned int bit = bitmask & (- bitmask);
        -:19752:
    #####:19753:      bitmask &= ~ bit;
    #####:19754:      switch (bit)
        -:19755:	{
    #####:19756:	case GNU_PROPERTY_X86_ISA_1_BASELINE:
    #####:19757:	  printf ("x86-64-baseline");
    #####:19758:	  break;
    #####:19759:	case GNU_PROPERTY_X86_ISA_1_V2:
    #####:19760:	  printf ("x86-64-v2");
    #####:19761:	  break;
    #####:19762:	case GNU_PROPERTY_X86_ISA_1_V3:
    #####:19763:	  printf ("x86-64-v3");
    #####:19764:	  break;
    #####:19765:	case GNU_PROPERTY_X86_ISA_1_V4:
    #####:19766:	  printf ("x86-64-v4");
    #####:19767:	  break;
    #####:19768:	default:
    #####:19769:	  printf (_("<unknown: %x>"), bit);
    #####:19770:	  break;
        -:19771:	}
    #####:19772:      if (bitmask)
    #####:19773:	printf (", ");
        -:19774:    }
    #####:19775:}
        -:19776:
        -:19777:static void
    #####:19778:decode_x86_feature_1 (unsigned int bitmask)
        -:19779:{
    #####:19780:  if (!bitmask)
        -:19781:    {
    #####:19782:      printf (_("<None>"));
    #####:19783:      return;
        -:19784:    }
        -:19785:
    #####:19786:  while (bitmask)
        -:19787:    {
    #####:19788:      unsigned int bit = bitmask & (- bitmask);
        -:19789:
    #####:19790:      bitmask &= ~ bit;
    #####:19791:      switch (bit)
        -:19792:	{
    #####:19793:	case GNU_PROPERTY_X86_FEATURE_1_IBT:
    #####:19794:	  printf ("IBT");
    #####:19795:	  break;
    #####:19796:	case GNU_PROPERTY_X86_FEATURE_1_SHSTK:
    #####:19797:	  printf ("SHSTK");
    #####:19798:	  break;
    #####:19799:	case GNU_PROPERTY_X86_FEATURE_1_LAM_U48:
    #####:19800:	  printf ("LAM_U48");
    #####:19801:	  break;
    #####:19802:	case GNU_PROPERTY_X86_FEATURE_1_LAM_U57:
    #####:19803:	  printf ("LAM_U57");
    #####:19804:	  break;
    #####:19805:	default:
    #####:19806:	  printf (_("<unknown: %x>"), bit);
    #####:19807:	  break;
        -:19808:	}
    #####:19809:      if (bitmask)
    #####:19810:	printf (", ");
        -:19811:    }
        -:19812:}
        -:19813:
        -:19814:static void
    #####:19815:decode_x86_feature_2 (unsigned int bitmask)
        -:19816:{
    #####:19817:  if (!bitmask)
        -:19818:    {
    #####:19819:      printf (_("<None>"));
    #####:19820:      return;
        -:19821:    }
        -:19822:
    #####:19823:  while (bitmask)
        -:19824:    {
    #####:19825:      unsigned int bit = bitmask & (- bitmask);
        -:19826:
    #####:19827:      bitmask &= ~ bit;
    #####:19828:      switch (bit)
        -:19829:	{
    #####:19830:	case GNU_PROPERTY_X86_FEATURE_2_X86:
    #####:19831:	  printf ("x86");
    #####:19832:	  break;
    #####:19833:	case GNU_PROPERTY_X86_FEATURE_2_X87:
    #####:19834:	  printf ("x87");
    #####:19835:	  break;
    #####:19836:	case GNU_PROPERTY_X86_FEATURE_2_MMX:
    #####:19837:	  printf ("MMX");
    #####:19838:	  break;
    #####:19839:	case GNU_PROPERTY_X86_FEATURE_2_XMM:
    #####:19840:	  printf ("XMM");
    #####:19841:	  break;
    #####:19842:	case GNU_PROPERTY_X86_FEATURE_2_YMM:
    #####:19843:	  printf ("YMM");
    #####:19844:	  break;
    #####:19845:	case GNU_PROPERTY_X86_FEATURE_2_ZMM:
    #####:19846:	  printf ("ZMM");
    #####:19847:	  break;
    #####:19848:	case GNU_PROPERTY_X86_FEATURE_2_TMM:
    #####:19849:	  printf ("TMM");
    #####:19850:	  break;
    #####:19851:	case GNU_PROPERTY_X86_FEATURE_2_MASK:
    #####:19852:	  printf ("MASK");
    #####:19853:	  break;
    #####:19854:	case GNU_PROPERTY_X86_FEATURE_2_FXSR:
    #####:19855:	  printf ("FXSR");
    #####:19856:	  break;
    #####:19857:	case GNU_PROPERTY_X86_FEATURE_2_XSAVE:
    #####:19858:	  printf ("XSAVE");
    #####:19859:	  break;
    #####:19860:	case GNU_PROPERTY_X86_FEATURE_2_XSAVEOPT:
    #####:19861:	  printf ("XSAVEOPT");
    #####:19862:	  break;
    #####:19863:	case GNU_PROPERTY_X86_FEATURE_2_XSAVEC:
    #####:19864:	  printf ("XSAVEC");
    #####:19865:	  break;
    #####:19866:	default:
    #####:19867:	  printf (_("<unknown: %x>"), bit);
    #####:19868:	  break;
        -:19869:	}
    #####:19870:      if (bitmask)
    #####:19871:	printf (", ");
        -:19872:    }
        -:19873:}
        -:19874:
        -:19875:static void
    #####:19876:decode_aarch64_feature_1_and (unsigned int bitmask)
        -:19877:{
    #####:19878:  while (bitmask)
        -:19879:    {
    #####:19880:      unsigned int bit = bitmask & (- bitmask);
        -:19881:
    #####:19882:      bitmask &= ~ bit;
    #####:19883:      switch (bit)
        -:19884:	{
    #####:19885:	case GNU_PROPERTY_AARCH64_FEATURE_1_BTI:
    #####:19886:	  printf ("BTI");
    #####:19887:	  break;
        -:19888:
    #####:19889:	case GNU_PROPERTY_AARCH64_FEATURE_1_PAC:
    #####:19890:	  printf ("PAC");
    #####:19891:	  break;
        -:19892:
    #####:19893:	default:
    #####:19894:	  printf (_("<unknown: %x>"), bit);
    #####:19895:	  break;
        -:19896:	}
    #####:19897:      if (bitmask)
    #####:19898:	printf (", ");
        -:19899:    }
    #####:19900:}
        -:19901:
        -:19902:static void
    #####:19903:decode_1_needed (unsigned int bitmask)
        -:19904:{
    #####:19905:  while (bitmask)
        -:19906:    {
    #####:19907:      unsigned int bit = bitmask & (- bitmask);
        -:19908:
    #####:19909:      bitmask &= ~ bit;
    #####:19910:      switch (bit)
        -:19911:	{
    #####:19912:	case GNU_PROPERTY_1_NEEDED_INDIRECT_EXTERN_ACCESS:
    #####:19913:	  printf ("indirect external access");
    #####:19914:	  break;
    #####:19915:	default:
    #####:19916:	  printf (_("<unknown: %x>"), bit);
    #####:19917:	  break;
        -:19918:	}
    #####:19919:      if (bitmask)
    #####:19920:	printf (", ");
        -:19921:    }
    #####:19922:}
        -:19923:
        -:19924:static void
    #####:19925:print_gnu_property_note (Filedata * filedata, Elf_Internal_Note * pnote)
        -:19926:{
    #####:19927:  unsigned char * ptr = (unsigned char *) pnote->descdata;
    #####:19928:  unsigned char * ptr_end = ptr + pnote->descsz;
    #####:19929:  unsigned int    size = is_32bit_elf ? 4 : 8;
        -:19930:
    #####:19931:  printf (_("      Properties: "));
        -:19932:
    #####:19933:  if (pnote->descsz < 8 || (pnote->descsz % size) != 0)
        -:19934:    {
    #####:19935:      printf (_("<corrupt GNU_PROPERTY_TYPE, size = %#lx>\n"), pnote->descsz);
    #####:19936:      return;
        -:19937:    }
        -:19938:
    #####:19939:  while (ptr < ptr_end)
        -:19940:    {
        -:19941:      unsigned int j;
        -:19942:      unsigned int type;
        -:19943:      unsigned int datasz;
        -:19944:
    #####:19945:      if ((size_t) (ptr_end - ptr) < 8)
        -:19946:	{
    #####:19947:	  printf (_("<corrupt descsz: %#lx>\n"), pnote->descsz);
    #####:19948:	  break;
        -:19949:	}
        -:19950:
    #####:19951:      type = byte_get (ptr, 4);
    #####:19952:      datasz = byte_get (ptr + 4, 4);
        -:19953:
    #####:19954:      ptr += 8;
        -:19955:
    #####:19956:      if (datasz > (size_t) (ptr_end - ptr))
        -:19957:	{
    #####:19958:	  printf (_("<corrupt type (%#x) datasz: %#x>\n"),
        -:19959:		  type, datasz);
    #####:19960:	  break;
        -:19961:	}
        -:19962:
    #####:19963:      if (type >= GNU_PROPERTY_LOPROC && type <= GNU_PROPERTY_HIPROC)
        -:19964:	{
    #####:19965:	  if (filedata->file_header.e_machine == EM_X86_64
    #####:19966:	      || filedata->file_header.e_machine == EM_IAMCU
    #####:19967:	      || filedata->file_header.e_machine == EM_386)
    #####:19968:	    {
        -:19969:	      unsigned int bitmask;
        -:19970:
    #####:19971:	      if (datasz == 4)
    #####:19972:		bitmask = byte_get (ptr, 4);
        -:19973:	      else
    #####:19974:		bitmask = 0;
        -:19975:
    #####:19976:	      switch (type)
        -:19977:		{
    #####:19978:		case GNU_PROPERTY_X86_ISA_1_USED:
    #####:19979:		  if (datasz != 4)
    #####:19980:		    printf (_("x86 ISA used: <corrupt length: %#x> "),
        -:19981:			    datasz);
        -:19982:		  else
        -:19983:		    {
    #####:19984:		      printf ("x86 ISA used: ");
    #####:19985:		      decode_x86_isa (bitmask);
        -:19986:		    }
    #####:19987:		  goto next;
        -:19988:
    #####:19989:		case GNU_PROPERTY_X86_ISA_1_NEEDED:
    #####:19990:		  if (datasz != 4)
    #####:19991:		    printf (_("x86 ISA needed: <corrupt length: %#x> "),
        -:19992:			    datasz);
        -:19993:		  else
        -:19994:		    {
    #####:19995:		      printf ("x86 ISA needed: ");
    #####:19996:		      decode_x86_isa (bitmask);
        -:19997:		    }
    #####:19998:		  goto next;
        -:19999:
    #####:20000:		case GNU_PROPERTY_X86_FEATURE_1_AND:
    #####:20001:		  if (datasz != 4)
    #####:20002:		    printf (_("x86 feature: <corrupt length: %#x> "),
        -:20003:			    datasz);
        -:20004:		  else
        -:20005:		    {
    #####:20006:		      printf ("x86 feature: ");
    #####:20007:		      decode_x86_feature_1 (bitmask);
        -:20008:		    }
    #####:20009:		  goto next;
        -:20010:
    #####:20011:		case GNU_PROPERTY_X86_FEATURE_2_USED:
    #####:20012:		  if (datasz != 4)
    #####:20013:		    printf (_("x86 feature used: <corrupt length: %#x> "),
        -:20014:			    datasz);
        -:20015:		  else
        -:20016:		    {
    #####:20017:		      printf ("x86 feature used: ");
    #####:20018:		      decode_x86_feature_2 (bitmask);
        -:20019:		    }
    #####:20020:		  goto next;
        -:20021:
    #####:20022:		case GNU_PROPERTY_X86_FEATURE_2_NEEDED:
    #####:20023:		  if (datasz != 4)
    #####:20024:		    printf (_("x86 feature needed: <corrupt length: %#x> "), datasz);
        -:20025:		  else
        -:20026:		    {
    #####:20027:		      printf ("x86 feature needed: ");
    #####:20028:		      decode_x86_feature_2 (bitmask);
        -:20029:		    }
    #####:20030:		  goto next;
        -:20031:
    #####:20032:		case GNU_PROPERTY_X86_COMPAT_ISA_1_USED:
    #####:20033:		  if (datasz != 4)
    #####:20034:		    printf (_("x86 ISA used: <corrupt length: %#x> "),
        -:20035:			    datasz);
        -:20036:		  else
        -:20037:		    {
    #####:20038:		      printf ("x86 ISA used: ");
    #####:20039:		      decode_x86_compat_isa (bitmask);
        -:20040:		    }
    #####:20041:		  goto next;
        -:20042:
    #####:20043:		case GNU_PROPERTY_X86_COMPAT_ISA_1_NEEDED:
    #####:20044:		  if (datasz != 4)
    #####:20045:		    printf (_("x86 ISA needed: <corrupt length: %#x> "),
        -:20046:			    datasz);
        -:20047:		  else
        -:20048:		    {
    #####:20049:		      printf ("x86 ISA needed: ");
    #####:20050:		      decode_x86_compat_isa (bitmask);
        -:20051:		    }
    #####:20052:		  goto next;
        -:20053:
    #####:20054:		case GNU_PROPERTY_X86_COMPAT_2_ISA_1_USED:
    #####:20055:		  if (datasz != 4)
    #####:20056:		    printf (_("x86 ISA used: <corrupt length: %#x> "),
        -:20057:			    datasz);
        -:20058:		  else
        -:20059:		    {
    #####:20060:		      printf ("x86 ISA used: ");
    #####:20061:		      decode_x86_compat_2_isa (bitmask);
        -:20062:		    }
    #####:20063:		  goto next;
        -:20064:
    #####:20065:		case GNU_PROPERTY_X86_COMPAT_2_ISA_1_NEEDED:
    #####:20066:		  if (datasz != 4)
    #####:20067:		    printf (_("x86 ISA needed: <corrupt length: %#x> "),
        -:20068:			    datasz);
        -:20069:		  else
        -:20070:		    {
    #####:20071:		      printf ("x86 ISA needed: ");
    #####:20072:		      decode_x86_compat_2_isa (bitmask);
        -:20073:		    }
    #####:20074:		  goto next;
        -:20075:
    #####:20076:		default:
    #####:20077:		  break;
        -:20078:		}
        -:20079:	    }
    #####:20080:	  else if (filedata->file_header.e_machine == EM_AARCH64)
        -:20081:	    {
    #####:20082:	      if (type == GNU_PROPERTY_AARCH64_FEATURE_1_AND)
        -:20083:		{
    #####:20084:		  printf ("AArch64 feature: ");
    #####:20085:		  if (datasz != 4)
    #####:20086:		    printf (_("<corrupt length: %#x> "), datasz);
        -:20087:		  else
    #####:20088:		    decode_aarch64_feature_1_and (byte_get (ptr, 4));
    #####:20089:		  goto next;
        -:20090:		}
        -:20091:	    }
        -:20092:	}
        -:20093:      else
        -:20094:	{
    #####:20095:	  switch (type)
        -:20096:	    {
    #####:20097:	    case GNU_PROPERTY_STACK_SIZE:
    #####:20098:	      printf (_("stack size: "));
    #####:20099:	      if (datasz != size)
    #####:20100:		printf (_("<corrupt length: %#x> "), datasz);
        -:20101:	      else
    #####:20102:		printf ("%#lx", (unsigned long) byte_get (ptr, size));
    #####:20103:	      goto next;
        -:20104:
    #####:20105:	    case GNU_PROPERTY_NO_COPY_ON_PROTECTED:
    #####:20106:	      printf ("no copy on protected ");
    #####:20107:	      if (datasz)
    #####:20108:		printf (_("<corrupt length: %#x> "), datasz);
    #####:20109:	      goto next;
        -:20110:
    #####:20111:	    default:
    #####:20112:	      if ((type >= GNU_PROPERTY_UINT32_AND_LO
    #####:20113:		   && type <= GNU_PROPERTY_UINT32_AND_HI)
    #####:20114:		  || (type >= GNU_PROPERTY_UINT32_OR_LO
    #####:20115:		      && type <= GNU_PROPERTY_UINT32_OR_HI))
        -:20116:		{
        -:20117:		  switch (type)
        -:20118:		    {
    #####:20119:		    case GNU_PROPERTY_1_NEEDED:
    #####:20120:		      if (datasz != 4)
    #####:20121:			printf (_("1_needed: <corrupt length: %#x> "),
        -:20122:				datasz);
        -:20123:		      else
        -:20124:			{
    #####:20125:			  unsigned int bitmask = byte_get (ptr, 4);
    #####:20126:			  printf ("1_needed: ");
    #####:20127:			  decode_1_needed (bitmask);
        -:20128:			}
    #####:20129:		      goto next;
        -:20130:
    #####:20131:		    default:
    #####:20132:		      break;
        -:20133:		    }
    #####:20134:		  if (type <= GNU_PROPERTY_UINT32_AND_HI)
    #####:20135:		    printf (_("UINT32_AND (%#x): "), type);
        -:20136:		  else
    #####:20137:		    printf (_("UINT32_OR (%#x): "), type);
    #####:20138:		  if (datasz != 4)
    #####:20139:		    printf (_("<corrupt length: %#x> "), datasz);
        -:20140:		  else
    #####:20141:		    printf ("%#x", (unsigned int) byte_get (ptr, 4));
    #####:20142:		  goto next;
        -:20143:		}
    #####:20144:	      break;
        -:20145:	    }
        -:20146:	}
        -:20147:
    #####:20148:      if (type < GNU_PROPERTY_LOPROC)
    #####:20149:	printf (_("<unknown type %#x data: "), type);
    #####:20150:      else if (type < GNU_PROPERTY_LOUSER)
    #####:20151:	printf (_("<processor-specific type %#x data: "), type);
        -:20152:      else
    #####:20153:	printf (_("<application-specific type %#x data: "), type);
    #####:20154:      for (j = 0; j < datasz; ++j)
    #####:20155:	printf ("%02x ", ptr[j] & 0xff);
    #####:20156:      printf (">");
        -:20157:
    #####:20158:    next:
    #####:20159:      ptr += ((datasz + (size - 1)) & ~ (size - 1));
    #####:20160:      if (ptr == ptr_end)
    #####:20161:	break;
        -:20162:
    #####:20163:      if (do_wide)
    #####:20164:	printf (", ");
        -:20165:      else
    #####:20166:	printf ("\n\t");
        -:20167:    }
        -:20168:
    #####:20169:  printf ("\n");
        -:20170:}
        -:20171:
        -:20172:static bool
    #####:20173:print_gnu_note (Filedata * filedata, Elf_Internal_Note *pnote)
        -:20174:{
        -:20175:  /* NB/ Keep this switch statement in sync with get_gnu_elf_note_type ().  */
    #####:20176:  switch (pnote->type)
        -:20177:    {
    #####:20178:    case NT_GNU_BUILD_ID:
        -:20179:      {
        -:20180:	unsigned long i;
        -:20181:
    #####:20182:	printf (_("    Build ID: "));
    #####:20183:	for (i = 0; i < pnote->descsz; ++i)
    #####:20184:	  printf ("%02x", pnote->descdata[i] & 0xff);
    #####:20185:	printf ("\n");
        -:20186:      }
    #####:20187:      break;
        -:20188:
    #####:20189:    case NT_GNU_ABI_TAG:
        -:20190:      {
        -:20191:	unsigned long os, major, minor, subminor;
        -:20192:	const char *osname;
        -:20193:
        -:20194:	/* PR 17531: file: 030-599401-0.004.  */
    #####:20195:	if (pnote->descsz < 16)
        -:20196:	  {
    #####:20197:	    printf (_("    <corrupt GNU_ABI_TAG>\n"));
    #####:20198:	    break;
        -:20199:	  }
        -:20200:
    #####:20201:	os = byte_get ((unsigned char *) pnote->descdata, 4);
    #####:20202:	major = byte_get ((unsigned char *) pnote->descdata + 4, 4);
    #####:20203:	minor = byte_get ((unsigned char *) pnote->descdata + 8, 4);
    #####:20204:	subminor = byte_get ((unsigned char *) pnote->descdata + 12, 4);
        -:20205:
        -:20206:	switch (os)
        -:20207:	  {
    #####:20208:	  case GNU_ABI_TAG_LINUX:
    #####:20209:	    osname = "Linux";
    #####:20210:	    break;
    #####:20211:	  case GNU_ABI_TAG_HURD:
    #####:20212:	    osname = "Hurd";
    #####:20213:	    break;
    #####:20214:	  case GNU_ABI_TAG_SOLARIS:
    #####:20215:	    osname = "Solaris";
    #####:20216:	    break;
    #####:20217:	  case GNU_ABI_TAG_FREEBSD:
    #####:20218:	    osname = "FreeBSD";
    #####:20219:	    break;
    #####:20220:	  case GNU_ABI_TAG_NETBSD:
    #####:20221:	    osname = "NetBSD";
    #####:20222:	    break;
    #####:20223:	  case GNU_ABI_TAG_SYLLABLE:
    #####:20224:	    osname = "Syllable";
    #####:20225:	    break;
    #####:20226:	  case GNU_ABI_TAG_NACL:
    #####:20227:	    osname = "NaCl";
    #####:20228:	    break;
    #####:20229:	  default:
    #####:20230:	    osname = "Unknown";
    #####:20231:	    break;
        -:20232:	  }
        -:20233:
    #####:20234:	printf (_("    OS: %s, ABI: %ld.%ld.%ld\n"), osname,
        -:20235:		major, minor, subminor);
        -:20236:      }
    #####:20237:      break;
        -:20238:
    #####:20239:    case NT_GNU_GOLD_VERSION:
        -:20240:      {
        -:20241:	unsigned long i;
        -:20242:
    #####:20243:	printf (_("    Version: "));
    #####:20244:	for (i = 0; i < pnote->descsz && pnote->descdata[i] != '\0'; ++i)
    #####:20245:	  printf ("%c", pnote->descdata[i]);
    #####:20246:	printf ("\n");
        -:20247:      }
    #####:20248:      break;
        -:20249:
    #####:20250:    case NT_GNU_HWCAP:
        -:20251:      {
        -:20252:	unsigned long num_entries, mask;
        -:20253:
        -:20254:	/* Hardware capabilities information.  Word 0 is the number of entries.
        -:20255:	   Word 1 is a bitmask of enabled entries.  The rest of the descriptor
        -:20256:	   is a series of entries, where each entry is a single byte followed
        -:20257:	   by a nul terminated string.  The byte gives the bit number to test
        -:20258:	   if enabled in the bitmask.  */
    #####:20259:	printf (_("      Hardware Capabilities: "));
    #####:20260:	if (pnote->descsz < 8)
        -:20261:	  {
    #####:20262:	    error (_("<corrupt GNU_HWCAP>\n"));
    #####:20263:	    return false;
        -:20264:	  }
    #####:20265:	num_entries = byte_get ((unsigned char *) pnote->descdata, 4);
    #####:20266:	mask = byte_get ((unsigned char *) pnote->descdata + 4, 4);
    #####:20267:	printf (_("num entries: %ld, enabled mask: %lx\n"), num_entries, mask);
        -:20268:	/* FIXME: Add code to display the entries... */
        -:20269:      }
    #####:20270:      break;
        -:20271:
    #####:20272:    case NT_GNU_PROPERTY_TYPE_0:
    #####:20273:      print_gnu_property_note (filedata, pnote);
    #####:20274:      break;
        -:20275:
    #####:20276:    default:
        -:20277:      /* Handle unrecognised types.  An error message should have already been
        -:20278:	 created by get_gnu_elf_note_type(), so all that we need to do is to
        -:20279:	 display the data.  */
        -:20280:      {
        -:20281:	unsigned long i;
        -:20282:
    #####:20283:	printf (_("    Description data: "));
    #####:20284:	for (i = 0; i < pnote->descsz; ++i)
    #####:20285:	  printf ("%02x ", pnote->descdata[i] & 0xff);
    #####:20286:	printf ("\n");
        -:20287:      }
    #####:20288:      break;
        -:20289:    }
        -:20290:
    #####:20291:  return true;
        -:20292:}
        -:20293:
        -:20294:static const char *
    #####:20295:get_v850_elf_note_type (enum v850_notes n_type)
        -:20296:{
        -:20297:  static char buff[64];
        -:20298:
    #####:20299:  switch (n_type)
        -:20300:    {
    #####:20301:    case V850_NOTE_ALIGNMENT:  return _("Alignment of 8-byte objects");
    #####:20302:    case V850_NOTE_DATA_SIZE:  return _("Sizeof double and long double");
    #####:20303:    case V850_NOTE_FPU_INFO:   return _("Type of FPU support needed");
    #####:20304:    case V850_NOTE_SIMD_INFO:  return _("Use of SIMD instructions");
    #####:20305:    case V850_NOTE_CACHE_INFO: return _("Use of cache");
    #####:20306:    case V850_NOTE_MMU_INFO:   return _("Use of MMU");
    #####:20307:    default:
    #####:20308:      snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), n_type);
    #####:20309:      return buff;
        -:20310:    }
        -:20311:}
        -:20312:
        -:20313:static bool
    #####:20314:print_v850_note (Elf_Internal_Note * pnote)
        -:20315:{
        -:20316:  unsigned int val;
        -:20317:
    #####:20318:  if (pnote->descsz != 4)
    #####:20319:    return false;
        -:20320:
    #####:20321:  val = byte_get ((unsigned char *) pnote->descdata, pnote->descsz);
        -:20322:
    #####:20323:  if (val == 0)
        -:20324:    {
    #####:20325:      printf (_("not set\n"));
    #####:20326:      return true;
        -:20327:    }
        -:20328:
    #####:20329:  switch (pnote->type)
        -:20330:    {
    #####:20331:    case V850_NOTE_ALIGNMENT:
        -:20332:      switch (val)
        -:20333:	{
    #####:20334:	case EF_RH850_DATA_ALIGN4: printf (_("4-byte\n")); return true;
    #####:20335:	case EF_RH850_DATA_ALIGN8: printf (_("8-byte\n")); return true;
        -:20336:	}
    #####:20337:      break;
        -:20338:
    #####:20339:    case V850_NOTE_DATA_SIZE:
        -:20340:      switch (val)
        -:20341:	{
    #####:20342:	case EF_RH850_DOUBLE32: printf (_("4-bytes\n")); return true;
    #####:20343:	case EF_RH850_DOUBLE64: printf (_("8-bytes\n")); return true;
        -:20344:	}
    #####:20345:      break;
        -:20346:
    #####:20347:    case V850_NOTE_FPU_INFO:
        -:20348:      switch (val)
        -:20349:	{
    #####:20350:	case EF_RH850_FPU20: printf (_("FPU-2.0\n")); return true;
    #####:20351:	case EF_RH850_FPU30: printf (_("FPU-3.0\n")); return true;
        -:20352:	}
    #####:20353:      break;
        -:20354:
    #####:20355:    case V850_NOTE_MMU_INFO:
        -:20356:    case V850_NOTE_CACHE_INFO:
        -:20357:    case V850_NOTE_SIMD_INFO:
    #####:20358:      if (val == EF_RH850_SIMD)
        -:20359:	{
    #####:20360:	  printf (_("yes\n"));
    #####:20361:	  return true;
        -:20362:	}
    #####:20363:      break;
        -:20364:
    #####:20365:    default:
        -:20366:      /* An 'unknown note type' message will already have been displayed.  */
    #####:20367:      break;
        -:20368:    }
        -:20369:
    #####:20370:  printf (_("unknown value: %x\n"), val);
    #####:20371:  return false;
        -:20372:}
        -:20373:
        -:20374:static bool
    #####:20375:process_netbsd_elf_note (Elf_Internal_Note * pnote)
        -:20376:{
        -:20377:  unsigned int version;
        -:20378:
    #####:20379:  switch (pnote->type)
        -:20380:    {
    #####:20381:    case NT_NETBSD_IDENT:
    #####:20382:      if (pnote->descsz < 1)
    #####:20383:	break;
    #####:20384:      version = byte_get ((unsigned char *) pnote->descdata, sizeof (version));
    #####:20385:      if ((version / 10000) % 100)
    #####:20386:	printf ("  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u%s%c)\n", pnote->descsz,
    #####:20387:		version, version / 100000000, (version / 1000000) % 100,
    #####:20388:		(version / 10000) % 100 > 26 ? "Z" : "",
    #####:20389:		'A' + (version / 10000) % 26);
        -:20390:      else
    #####:20391:	printf ("  NetBSD\t\t0x%08lx\tIDENT %u (%u.%u.%u)\n", pnote->descsz,
    #####:20392:		version, version / 100000000, (version / 1000000) % 100,
    #####:20393:		(version / 100) % 100);
    #####:20394:      return true;
        -:20395:
    #####:20396:    case NT_NETBSD_MARCH:
    #####:20397:      printf ("  NetBSD\t\t0x%08lx\tMARCH <%s>\n", pnote->descsz,
        -:20398:	      pnote->descdata);
    #####:20399:      return true;
        -:20400:
    #####:20401:    case NT_NETBSD_PAX:
    #####:20402:      if (pnote->descsz < 1)
    #####:20403:	break;
    #####:20404:      version = byte_get ((unsigned char *) pnote->descdata, sizeof (version));
    #####:20405:      printf ("  NetBSD\t\t0x%08lx\tPaX <%s%s%s%s%s%s>\n", pnote->descsz,
    #####:20406:	      ((version & NT_NETBSD_PAX_MPROTECT) ? "+mprotect" : ""),
    #####:20407:	      ((version & NT_NETBSD_PAX_NOMPROTECT) ? "-mprotect" : ""),
    #####:20408:	      ((version & NT_NETBSD_PAX_GUARD) ? "+guard" : ""),
    #####:20409:	      ((version & NT_NETBSD_PAX_NOGUARD) ? "-guard" : ""),
    #####:20410:	      ((version & NT_NETBSD_PAX_ASLR) ? "+ASLR" : ""),
    #####:20411:	      ((version & NT_NETBSD_PAX_NOASLR) ? "-ASLR" : ""));
    #####:20412:      return true;
        -:20413:    }
        -:20414:
    #####:20415:  printf ("  NetBSD\t0x%08lx\tUnknown note type: (0x%08lx)\n",
        -:20416:	  pnote->descsz, pnote->type);
    #####:20417:  return false;
        -:20418:}
        -:20419:
        -:20420:static const char *
    #####:20421:get_freebsd_elfcore_note_type (Filedata * filedata, unsigned e_type)
        -:20422:{
    #####:20423:  switch (e_type)
        -:20424:    {
    #####:20425:    case NT_FREEBSD_THRMISC:
    #####:20426:      return _("NT_THRMISC (thrmisc structure)");
    #####:20427:    case NT_FREEBSD_PROCSTAT_PROC:
    #####:20428:      return _("NT_PROCSTAT_PROC (proc data)");
    #####:20429:    case NT_FREEBSD_PROCSTAT_FILES:
    #####:20430:      return _("NT_PROCSTAT_FILES (files data)");
    #####:20431:    case NT_FREEBSD_PROCSTAT_VMMAP:
    #####:20432:      return _("NT_PROCSTAT_VMMAP (vmmap data)");
    #####:20433:    case NT_FREEBSD_PROCSTAT_GROUPS:
    #####:20434:      return _("NT_PROCSTAT_GROUPS (groups data)");
    #####:20435:    case NT_FREEBSD_PROCSTAT_UMASK:
    #####:20436:      return _("NT_PROCSTAT_UMASK (umask data)");
    #####:20437:    case NT_FREEBSD_PROCSTAT_RLIMIT:
    #####:20438:      return _("NT_PROCSTAT_RLIMIT (rlimit data)");
    #####:20439:    case NT_FREEBSD_PROCSTAT_OSREL:
    #####:20440:      return _("NT_PROCSTAT_OSREL (osreldate data)");
    #####:20441:    case NT_FREEBSD_PROCSTAT_PSSTRINGS:
    #####:20442:      return _("NT_PROCSTAT_PSSTRINGS (ps_strings data)");
    #####:20443:    case NT_FREEBSD_PROCSTAT_AUXV:
    #####:20444:      return _("NT_PROCSTAT_AUXV (auxv data)");
    #####:20445:    case NT_FREEBSD_PTLWPINFO:
    #####:20446:      return _("NT_PTLWPINFO (ptrace_lwpinfo structure)");
    #####:20447:    case NT_FREEBSD_X86_SEGBASES:
    #####:20448:      return _("NT_X86_SEGBASES (x86 segment base registers)");
        -:20449:    }
    #####:20450:  return get_note_type (filedata, e_type);
        -:20451:}
        -:20452:
        -:20453:static const char *
    #####:20454:get_netbsd_elfcore_note_type (Filedata * filedata, unsigned e_type)
        -:20455:{
        -:20456:  static char buff[64];
        -:20457:
    #####:20458:  switch (e_type)
        -:20459:    {
    #####:20460:    case NT_NETBSDCORE_PROCINFO:
        -:20461:      /* NetBSD core "procinfo" structure.  */
    #####:20462:      return _("NetBSD procinfo structure");
        -:20463:
    #####:20464:    case NT_NETBSDCORE_AUXV:
    #####:20465:      return _("NetBSD ELF auxiliary vector data");
        -:20466:
    #####:20467:    case NT_NETBSDCORE_LWPSTATUS:
    #####:20468:      return _("PT_LWPSTATUS (ptrace_lwpstatus structure)");
        -:20469:
    #####:20470:    default:
        -:20471:      /* As of Jan 2020 there are no other machine-independent notes
        -:20472:	 defined for NetBSD core files.  If the note type is less
        -:20473:	 than the start of the machine-dependent note types, we don't
        -:20474:	 understand it.  */
        -:20475:
    #####:20476:      if (e_type < NT_NETBSDCORE_FIRSTMACH)
        -:20477:	{
    #####:20478:	  snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
    #####:20479:	  return buff;
        -:20480:	}
    #####:20481:      break;
        -:20482:    }
        -:20483:
    #####:20484:  switch (filedata->file_header.e_machine)
        -:20485:    {
        -:20486:    /* On the Alpha, SPARC (32-bit and 64-bit), PT_GETREGS == mach+0
        -:20487:       and PT_GETFPREGS == mach+2.  */
        -:20488:
    #####:20489:    case EM_OLD_ALPHA:
        -:20490:    case EM_ALPHA:
        -:20491:    case EM_SPARC:
        -:20492:    case EM_SPARC32PLUS:
        -:20493:    case EM_SPARCV9:
        -:20494:      switch (e_type)
        -:20495:	{
    #####:20496:	case NT_NETBSDCORE_FIRSTMACH + 0:
    #####:20497:	  return _("PT_GETREGS (reg structure)");
    #####:20498:	case NT_NETBSDCORE_FIRSTMACH + 2:
    #####:20499:	  return _("PT_GETFPREGS (fpreg structure)");
    #####:20500:	default:
    #####:20501:	  break;
        -:20502:	}
    #####:20503:      break;
        -:20504:
        -:20505:    /* On SuperH, PT_GETREGS == mach+3 and PT_GETFPREGS == mach+5.
        -:20506:       There's also old PT___GETREGS40 == mach + 1 for old reg
        -:20507:       structure which lacks GBR.  */
    #####:20508:    case EM_SH:
        -:20509:      switch (e_type)
        -:20510:	{
    #####:20511:	case NT_NETBSDCORE_FIRSTMACH + 1:
    #####:20512:	  return _("PT___GETREGS40 (old reg structure)");
    #####:20513:	case NT_NETBSDCORE_FIRSTMACH + 3:
    #####:20514:	  return _("PT_GETREGS (reg structure)");
    #####:20515:	case NT_NETBSDCORE_FIRSTMACH + 5:
    #####:20516:	  return _("PT_GETFPREGS (fpreg structure)");
    #####:20517:	default:
    #####:20518:	  break;
        -:20519:	}
    #####:20520:      break;
        -:20521:
        -:20522:    /* On all other arch's, PT_GETREGS == mach+1 and
        -:20523:       PT_GETFPREGS == mach+3.  */
    #####:20524:    default:
        -:20525:      switch (e_type)
        -:20526:	{
    #####:20527:	case NT_NETBSDCORE_FIRSTMACH + 1:
    #####:20528:	  return _("PT_GETREGS (reg structure)");
    #####:20529:	case NT_NETBSDCORE_FIRSTMACH + 3:
    #####:20530:	  return _("PT_GETFPREGS (fpreg structure)");
    #####:20531:	default:
    #####:20532:	  break;
        -:20533:	}
        -:20534:    }
        -:20535:
    #####:20536:  snprintf (buff, sizeof (buff), "PT_FIRSTMACH+%d",
        -:20537:	    e_type - NT_NETBSDCORE_FIRSTMACH);
    #####:20538:  return buff;
        -:20539:}
        -:20540:
        -:20541:static const char *
    #####:20542:get_openbsd_elfcore_note_type (Filedata * filedata, unsigned e_type)
        -:20543:{
    #####:20544:  switch (e_type)
        -:20545:    {
    #####:20546:    case NT_OPENBSD_PROCINFO:
    #####:20547:      return _("OpenBSD procinfo structure");
    #####:20548:    case NT_OPENBSD_AUXV:
    #####:20549:      return _("OpenBSD ELF auxiliary vector data");
    #####:20550:    case NT_OPENBSD_REGS:
    #####:20551:      return _("OpenBSD regular registers");
    #####:20552:    case NT_OPENBSD_FPREGS:
    #####:20553:      return _("OpenBSD floating point registers");
    #####:20554:    case NT_OPENBSD_WCOOKIE:
    #####:20555:      return _("OpenBSD window cookie");
        -:20556:    }
        -:20557:
    #####:20558:  return get_note_type (filedata, e_type);
        -:20559:}
        -:20560:
        -:20561:static const char *
    #####:20562:get_stapsdt_note_type (unsigned e_type)
        -:20563:{
        -:20564:  static char buff[64];
        -:20565:
    #####:20566:  switch (e_type)
        -:20567:    {
    #####:20568:    case NT_STAPSDT:
    #####:20569:      return _("NT_STAPSDT (SystemTap probe descriptors)");
        -:20570:
    #####:20571:    default:
    #####:20572:      break;
        -:20573:    }
        -:20574:
    #####:20575:  snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
    #####:20576:  return buff;
        -:20577:}
        -:20578:
        -:20579:static bool
    #####:20580:print_stapsdt_note (Elf_Internal_Note *pnote)
        -:20581:{
        -:20582:  size_t len, maxlen;
    #####:20583:  unsigned long addr_size = is_32bit_elf ? 4 : 8;
    #####:20584:  char *data = pnote->descdata;
    #####:20585:  char *data_end = pnote->descdata + pnote->descsz;
        -:20586:  bfd_vma pc, base_addr, semaphore;
        -:20587:  char *provider, *probe, *arg_fmt;
        -:20588:
    #####:20589:  if (pnote->descsz < (addr_size * 3))
    #####:20590:    goto stapdt_note_too_small;
        -:20591:
    #####:20592:  pc = byte_get ((unsigned char *) data, addr_size);
    #####:20593:  data += addr_size;
        -:20594:
    #####:20595:  base_addr = byte_get ((unsigned char *) data, addr_size);
    #####:20596:  data += addr_size;
        -:20597:
    #####:20598:  semaphore = byte_get ((unsigned char *) data, addr_size);
    #####:20599:  data += addr_size;
        -:20600:
    #####:20601:  if (data >= data_end)
    #####:20602:    goto stapdt_note_too_small;
    #####:20603:  maxlen = data_end - data;
    #####:20604:  len = strnlen (data, maxlen);
    #####:20605:  if (len < maxlen)
        -:20606:    {
    #####:20607:      provider = data;
    #####:20608:      data += len + 1;
        -:20609:    }
        -:20610:  else
    #####:20611:    goto stapdt_note_too_small;
        -:20612:
    #####:20613:  if (data >= data_end)
    #####:20614:    goto stapdt_note_too_small;
    #####:20615:  maxlen = data_end - data;
    #####:20616:  len = strnlen (data, maxlen);
    #####:20617:  if (len < maxlen)
        -:20618:    {
    #####:20619:      probe = data;
    #####:20620:      data += len + 1;
        -:20621:    }
        -:20622:  else
    #####:20623:    goto stapdt_note_too_small;
        -:20624:
    #####:20625:  if (data >= data_end)
    #####:20626:    goto stapdt_note_too_small;
    #####:20627:  maxlen = data_end - data;
    #####:20628:  len = strnlen (data, maxlen);
    #####:20629:  if (len < maxlen)
        -:20630:    {
    #####:20631:      arg_fmt = data;
    #####:20632:      data += len + 1;
        -:20633:    }
        -:20634:  else
    #####:20635:    goto stapdt_note_too_small;
        -:20636:
    #####:20637:  printf (_("    Provider: %s\n"), provider);
    #####:20638:  printf (_("    Name: %s\n"), probe);
    #####:20639:  printf (_("    Location: "));
    #####:20640:  print_vma (pc, FULL_HEX);
    #####:20641:  printf (_(", Base: "));
    #####:20642:  print_vma (base_addr, FULL_HEX);
    #####:20643:  printf (_(", Semaphore: "));
    #####:20644:  print_vma (semaphore, FULL_HEX);
    #####:20645:  printf ("\n");
    #####:20646:  printf (_("    Arguments: %s\n"), arg_fmt);
        -:20647:
    #####:20648:  return data == data_end;
        -:20649:
    #####:20650: stapdt_note_too_small:
    #####:20651:  printf (_("  <corrupt - note is too small>\n"));
    #####:20652:  error (_("corrupt stapdt note - the data size is too small\n"));
    #####:20653:  return false;
        -:20654:}
        -:20655:
        -:20656:static bool
    #####:20657:print_fdo_note (Elf_Internal_Note * pnote)
        -:20658:{
    #####:20659:  if (pnote->descsz > 0 && pnote->type == FDO_PACKAGING_METADATA)
        -:20660:    {
    #####:20661:      printf (_("    Packaging Metadata: %.*s\n"), (int) pnote->descsz, pnote->descdata);
    #####:20662:      return true;
        -:20663:    }
    #####:20664:  return false;
        -:20665:}
        -:20666:
        -:20667:static const char *
    #####:20668:get_ia64_vms_note_type (unsigned e_type)
        -:20669:{
        -:20670:  static char buff[64];
        -:20671:
    #####:20672:  switch (e_type)
        -:20673:    {
    #####:20674:    case NT_VMS_MHD:
    #####:20675:      return _("NT_VMS_MHD (module header)");
    #####:20676:    case NT_VMS_LNM:
    #####:20677:      return _("NT_VMS_LNM (language name)");
    #####:20678:    case NT_VMS_SRC:
    #####:20679:      return _("NT_VMS_SRC (source files)");
    #####:20680:    case NT_VMS_TITLE:
    #####:20681:      return "NT_VMS_TITLE";
    #####:20682:    case NT_VMS_EIDC:
    #####:20683:      return _("NT_VMS_EIDC (consistency check)");
    #####:20684:    case NT_VMS_FPMODE:
    #####:20685:      return _("NT_VMS_FPMODE (FP mode)");
    #####:20686:    case NT_VMS_LINKTIME:
    #####:20687:      return "NT_VMS_LINKTIME";
    #####:20688:    case NT_VMS_IMGNAM:
    #####:20689:      return _("NT_VMS_IMGNAM (image name)");
    #####:20690:    case NT_VMS_IMGID:
    #####:20691:      return _("NT_VMS_IMGID (image id)");
    #####:20692:    case NT_VMS_LINKID:
    #####:20693:      return _("NT_VMS_LINKID (link id)");
    #####:20694:    case NT_VMS_IMGBID:
    #####:20695:      return _("NT_VMS_IMGBID (build id)");
    #####:20696:    case NT_VMS_GSTNAM:
    #####:20697:      return _("NT_VMS_GSTNAM (sym table name)");
    #####:20698:    case NT_VMS_ORIG_DYN:
    #####:20699:      return "NT_VMS_ORIG_DYN";
    #####:20700:    case NT_VMS_PATCHTIME:
    #####:20701:      return "NT_VMS_PATCHTIME";
    #####:20702:    default:
    #####:20703:      snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
    #####:20704:      return buff;
        -:20705:    }
        -:20706:}
        -:20707:
        -:20708:static bool
    #####:20709:print_ia64_vms_note (Elf_Internal_Note * pnote)
        -:20710:{
    #####:20711:  int maxlen = pnote->descsz;
        -:20712:
    #####:20713:  if (maxlen < 2 || (unsigned long) maxlen != pnote->descsz)
    #####:20714:    goto desc_size_fail;
        -:20715:
    #####:20716:  switch (pnote->type)
        -:20717:    {
    #####:20718:    case NT_VMS_MHD:
    #####:20719:      if (maxlen <= 36)
    #####:20720:	goto desc_size_fail;
        -:20721:
    #####:20722:      int l = (int) strnlen (pnote->descdata + 34, maxlen - 34);
        -:20723:
    #####:20724:      printf (_("    Creation date  : %.17s\n"), pnote->descdata);
    #####:20725:      printf (_("    Last patch date: %.17s\n"), pnote->descdata + 17);
    #####:20726:      if (l + 34 < maxlen)
        -:20727:	{
    #####:20728:	  printf (_("    Module name    : %s\n"), pnote->descdata + 34);
    #####:20729:	  if (l + 35 < maxlen)
    #####:20730:	    printf (_("    Module version : %s\n"), pnote->descdata + 34 + l + 1);
        -:20731:	  else
    #####:20732:	    printf (_("    Module version : <missing>\n"));
        -:20733:	}
        -:20734:      else
        -:20735:	{
    #####:20736:	  printf (_("    Module name    : <missing>\n"));
    #####:20737:	  printf (_("    Module version : <missing>\n"));
        -:20738:	}
    #####:20739:      break;
        -:20740:
    #####:20741:    case NT_VMS_LNM:
    #####:20742:      printf (_("   Language: %.*s\n"), maxlen, pnote->descdata);
    #####:20743:      break;
        -:20744:
        -:20745:#ifdef BFD64
    #####:20746:    case NT_VMS_FPMODE:
    #####:20747:      printf (_("   Floating Point mode: "));
    #####:20748:      if (maxlen < 8)
    #####:20749:	goto desc_size_fail;
        -:20750:      /* FIXME: Generate an error if descsz > 8 ?  */
        -:20751:
    #####:20752:      printf ("0x%016" BFD_VMA_FMT "x\n",
    #####:20753:	      (bfd_vma) byte_get ((unsigned char *) pnote->descdata, 8));
    #####:20754:      break;
        -:20755:
    #####:20756:    case NT_VMS_LINKTIME:
    #####:20757:      printf (_("   Link time: "));
    #####:20758:      if (maxlen < 8)
    #####:20759:	goto desc_size_fail;
        -:20760:      /* FIXME: Generate an error if descsz > 8 ?  */
        -:20761:
    #####:20762:      print_vms_time (byte_get ((unsigned char *) pnote->descdata, 8));
    #####:20763:      printf ("\n");
    #####:20764:      break;
        -:20765:
    #####:20766:    case NT_VMS_PATCHTIME:
    #####:20767:      printf (_("   Patch time: "));
    #####:20768:      if (maxlen < 8)
    #####:20769:	goto desc_size_fail;
        -:20770:      /* FIXME: Generate an error if descsz > 8 ?  */
        -:20771:
    #####:20772:      print_vms_time (byte_get ((unsigned char *) pnote->descdata, 8));
    #####:20773:      printf ("\n");
    #####:20774:      break;
        -:20775:
    #####:20776:    case NT_VMS_ORIG_DYN:
    #####:20777:      if (maxlen < 34)
    #####:20778:	goto desc_size_fail;
        -:20779:
    #####:20780:      printf (_("   Major id: %u,  minor id: %u\n"),
    #####:20781:	      (unsigned) byte_get ((unsigned char *) pnote->descdata, 4),
    #####:20782:	      (unsigned) byte_get ((unsigned char *) pnote->descdata + 4, 4));
    #####:20783:      printf (_("   Last modified  : "));
    #####:20784:      print_vms_time (byte_get ((unsigned char *) pnote->descdata + 8, 8));
    #####:20785:      printf (_("\n   Link flags  : "));
    #####:20786:      printf ("0x%016" BFD_VMA_FMT "x\n",
    #####:20787:	      (bfd_vma) byte_get ((unsigned char *) pnote->descdata + 16, 8));
    #####:20788:      printf (_("   Header flags: 0x%08x\n"),
    #####:20789:	      (unsigned) byte_get ((unsigned char *) pnote->descdata + 24, 4));
    #####:20790:      printf (_("   Image id    : %.*s\n"), maxlen - 32, pnote->descdata + 32);
    #####:20791:      break;
        -:20792:#endif
        -:20793:
    #####:20794:    case NT_VMS_IMGNAM:
    #####:20795:      printf (_("    Image name: %.*s\n"), maxlen, pnote->descdata);
    #####:20796:      break;
        -:20797:
    #####:20798:    case NT_VMS_GSTNAM:
    #####:20799:      printf (_("    Global symbol table name: %.*s\n"), maxlen, pnote->descdata);
    #####:20800:      break;
        -:20801:
    #####:20802:    case NT_VMS_IMGID:
    #####:20803:      printf (_("    Image id: %.*s\n"), maxlen, pnote->descdata);
    #####:20804:      break;
        -:20805:
    #####:20806:    case NT_VMS_LINKID:
    #####:20807:      printf (_("    Linker id: %.*s\n"), maxlen, pnote->descdata);
    #####:20808:      break;
        -:20809:
    #####:20810:    default:
    #####:20811:      return false;
        -:20812:    }
        -:20813:
    #####:20814:  return true;
        -:20815:
    #####:20816: desc_size_fail:
    #####:20817:  printf (_("  <corrupt - data size is too small>\n"));
    #####:20818:  error (_("corrupt IA64 note: data size is too small\n"));
    #####:20819:  return false;
        -:20820:}
        -:20821:
        -:20822:struct build_attr_cache {
        -:20823:  Filedata *filedata;
        -:20824:  char *strtab;
        -:20825:  unsigned long strtablen;
        -:20826:  Elf_Internal_Sym *symtab;
        -:20827:  unsigned long nsyms;
        -:20828:} ba_cache;
        -:20829:
        -:20830:/* Find the symbol associated with a build attribute that is attached
        -:20831:   to address OFFSET.  If PNAME is non-NULL then store the name of
        -:20832:   the symbol (if found) in the provided pointer,  Returns NULL if a
        -:20833:   symbol could not be found.  */
        -:20834:
        -:20835:static Elf_Internal_Sym *
    #####:20836:get_symbol_for_build_attribute (Filedata *filedata,
        -:20837:				unsigned long offset,
        -:20838:				bool is_open_attr,
        -:20839:				const char **pname)
        -:20840:{
    #####:20841:  Elf_Internal_Sym *saved_sym = NULL;
        -:20842:  Elf_Internal_Sym *sym;
        -:20843:
    #####:20844:  if (filedata->section_headers != NULL
    #####:20845:      && (ba_cache.filedata == NULL || filedata != ba_cache.filedata))
        -:20846:    {
        -:20847:      Elf_Internal_Shdr * symsec;
        -:20848:
    #####:20849:      free (ba_cache.strtab);
    #####:20850:      ba_cache.strtab = NULL;
    #####:20851:      free (ba_cache.symtab);
    #####:20852:      ba_cache.symtab = NULL;
        -:20853:
        -:20854:      /* Load the symbol and string sections.  */
    #####:20855:      for (symsec = filedata->section_headers;
    #####:20856:	   symsec < filedata->section_headers + filedata->file_header.e_shnum;
    #####:20857:	   symsec ++)
        -:20858:	{
    #####:20859:	  if (symsec->sh_type == SHT_SYMTAB
    #####:20860:	      && get_symtab (filedata, symsec,
        -:20861:			     &ba_cache.symtab, &ba_cache.nsyms,
        -:20862:			     &ba_cache.strtab, &ba_cache.strtablen))
    #####:20863:	    break;
        -:20864:	}
    #####:20865:      ba_cache.filedata = filedata;
        -:20866:    }
        -:20867:
    #####:20868:  if (ba_cache.symtab == NULL)
    #####:20869:    return NULL;
        -:20870:
        -:20871:  /* Find a symbol whose value matches offset.  */
    #####:20872:  for (sym = ba_cache.symtab; sym < ba_cache.symtab + ba_cache.nsyms; sym ++)
    #####:20873:    if (sym->st_value == offset)
        -:20874:      {
    #####:20875:	if (sym->st_name >= ba_cache.strtablen)
        -:20876:	  /* Huh ?  This should not happen.  */
    #####:20877:	  continue;
        -:20878:
    #####:20879:	if (ba_cache.strtab[sym->st_name] == 0)
    #####:20880:	  continue;
        -:20881:
        -:20882:	/* The AArch64, ARM and RISC-V architectures define mapping symbols
        -:20883:	   (eg $d, $x, $t) which we want to ignore.  */
    #####:20884:	if (ba_cache.strtab[sym->st_name] == '$'
    #####:20885:	    && ba_cache.strtab[sym->st_name + 1] != 0
    #####:20886:	    && ba_cache.strtab[sym->st_name + 2] == 0)
    #####:20887:	  continue;
        -:20888:
    #####:20889:	if (is_open_attr)
        -:20890:	  {
        -:20891:	    /* For OPEN attributes we prefer GLOBAL over LOCAL symbols
        -:20892:	       and FILE or OBJECT symbols over NOTYPE symbols.  We skip
        -:20893:	       FUNC symbols entirely.  */
    #####:20894:	    switch (ELF_ST_TYPE (sym->st_info))
        -:20895:	      {
    #####:20896:	      case STT_OBJECT:
        -:20897:	      case STT_FILE:
    #####:20898:		saved_sym = sym;
    #####:20899:		if (sym->st_size)
        -:20900:		  {
        -:20901:		    /* If the symbol has a size associated
        -:20902:		       with it then we can stop searching.  */
    #####:20903:		    sym = ba_cache.symtab + ba_cache.nsyms;
        -:20904:		  }
    #####:20905:		continue;
        -:20906:
    #####:20907:	      case STT_FUNC:
        -:20908:		/* Ignore function symbols.  */
    #####:20909:		continue;
        -:20910:
    #####:20911:	      default:
    #####:20912:		break;
        -:20913:	      }
        -:20914:
    #####:20915:	    switch (ELF_ST_BIND (sym->st_info))
        -:20916:	      {
    #####:20917:	      case STB_GLOBAL:
    #####:20918:		if (saved_sym == NULL
    #####:20919:		    || ELF_ST_TYPE (saved_sym->st_info) != STT_OBJECT)
    #####:20920:		  saved_sym = sym;
    #####:20921:		break;
        -:20922:
    #####:20923:	      case STB_LOCAL:
    #####:20924:		if (saved_sym == NULL)
    #####:20925:		  saved_sym = sym;
    #####:20926:		break;
        -:20927:
    #####:20928:	      default:
    #####:20929:		break;
        -:20930:	      }
        -:20931:	  }
        -:20932:	else
        -:20933:	  {
    #####:20934:	    if (ELF_ST_TYPE (sym->st_info) != STT_FUNC)
    #####:20935:	      continue;
        -:20936:
    #####:20937:	    saved_sym = sym;
    #####:20938:	    break;
        -:20939:	  }
        -:20940:      }
        -:20941:
    #####:20942:  if (saved_sym && pname)
    #####:20943:    * pname = ba_cache.strtab + saved_sym->st_name;
        -:20944:
    #####:20945:  return saved_sym;
        -:20946:}
        -:20947:
        -:20948:/* Returns true iff addr1 and addr2 are in the same section.  */
        -:20949:
        -:20950:static bool
    #####:20951:same_section (Filedata * filedata, unsigned long addr1, unsigned long addr2)
        -:20952:{
        -:20953:  Elf_Internal_Shdr * a1;
        -:20954:  Elf_Internal_Shdr * a2;
        -:20955:
    #####:20956:  a1 = find_section_by_address (filedata, addr1);
    #####:20957:  a2 = find_section_by_address (filedata, addr2);
        -:20958:
    #####:20959:  return a1 == a2 && a1 != NULL;
        -:20960:}
        -:20961:
        -:20962:static bool
    #####:20963:print_gnu_build_attribute_description (Elf_Internal_Note *  pnote,
        -:20964:				       Filedata *           filedata)
        -:20965:{
        -:20966:  static unsigned long global_offset = 0;
        -:20967:  static unsigned long global_end = 0;
        -:20968:  static unsigned long func_offset = 0;
        -:20969:  static unsigned long func_end = 0;
        -:20970:
        -:20971:  Elf_Internal_Sym *sym;
        -:20972:  const char *name;
        -:20973:  unsigned long start;
        -:20974:  unsigned long end;
    #####:20975:  bool is_open_attr = pnote->type == NT_GNU_BUILD_ATTRIBUTE_OPEN;
        -:20976:
    #####:20977:  switch (pnote->descsz)
        -:20978:    {
    #####:20979:    case 0:
        -:20980:      /* A zero-length description means that the range of
        -:20981:	 the previous note of the same type should be used.  */
    #####:20982:      if (is_open_attr)
        -:20983:	{
    #####:20984:	  if (global_end > global_offset)
    #####:20985:	    printf (_("    Applies to region from %#lx to %#lx\n"),
        -:20986:		    global_offset, global_end);
        -:20987:	  else
    #####:20988:	    printf (_("    Applies to region from %#lx\n"), global_offset);
        -:20989:	}
        -:20990:      else
        -:20991:	{
    #####:20992:	  if (func_end > func_offset)
    #####:20993:	    printf (_("    Applies to region from %#lx to %#lx\n"), func_offset, func_end);
        -:20994:	  else
    #####:20995:	    printf (_("    Applies to region from %#lx\n"), func_offset);
        -:20996:	}
    #####:20997:      return true;
        -:20998:
    #####:20999:    case 4:
    #####:21000:      start = byte_get ((unsigned char *) pnote->descdata, 4);
    #####:21001:      end = 0;
    #####:21002:      break;
        -:21003:
    #####:21004:    case 8:
    #####:21005:      start = byte_get ((unsigned char *) pnote->descdata, 4);
    #####:21006:      end = byte_get ((unsigned char *) pnote->descdata + 4, 4);
    #####:21007:      break;
        -:21008:
    #####:21009:    case 16:
    #####:21010:      start = byte_get ((unsigned char *) pnote->descdata, 8);
    #####:21011:      end = byte_get ((unsigned char *) pnote->descdata + 8, 8);
    #####:21012:      break;
        -:21013:
    #####:21014:    default:
    #####:21015:      error (_("    <invalid description size: %lx>\n"), pnote->descsz);
    #####:21016:      printf (_("    <invalid descsz>"));
    #####:21017:      return false;
        -:21018:    }
        -:21019:
    #####:21020:  name = NULL;
    #####:21021:  sym = get_symbol_for_build_attribute (filedata, start, is_open_attr, & name);
        -:21022:  /* As of version 5 of the annobin plugin, filename symbols are biased by 2
        -:21023:     in order to avoid them being confused with the start address of the
        -:21024:     first function in the file...  */
    #####:21025:  if (sym == NULL && is_open_attr)
    #####:21026:    sym = get_symbol_for_build_attribute (filedata, start + 2, is_open_attr,
        -:21027:					  & name);
        -:21028:
    #####:21029:  if (end == 0 && sym != NULL && sym->st_size > 0)
    #####:21030:    end = start + sym->st_size;
        -:21031:
    #####:21032:  if (is_open_attr)
        -:21033:    {
        -:21034:      /* FIXME: Need to properly allow for section alignment.
        -:21035:	 16 is just the alignment used on x86_64.  */
    #####:21036:      if (global_end > 0
    #####:21037:	  && start > BFD_ALIGN (global_end, 16)
        -:21038:	  /* Build notes are not guaranteed to be organised in order of
        -:21039:	     increasing address, but we should find the all of the notes
        -:21040:	     for one section in the same place.  */
    #####:21041:	  && same_section (filedata, start, global_end))
    #####:21042:	warn (_("Gap in build notes detected from %#lx to %#lx\n"),
        -:21043:	      global_end + 1, start - 1);
        -:21044:
    #####:21045:      printf (_("    Applies to region from %#lx"), start);
    #####:21046:      global_offset = start;
        -:21047:
    #####:21048:      if (end)
        -:21049:	{
    #####:21050:	  printf (_(" to %#lx"), end);
    #####:21051:	  global_end = end;
        -:21052:	}
        -:21053:    }
        -:21054:  else
        -:21055:    {
    #####:21056:      printf (_("    Applies to region from %#lx"), start);
    #####:21057:      func_offset = start;
        -:21058:
    #####:21059:      if (end)
        -:21060:	{
    #####:21061:	  printf (_(" to %#lx"), end);
    #####:21062:	  func_end = end;
        -:21063:	}
        -:21064:    }
        -:21065:
    #####:21066:  if (sym && name)
    #####:21067:    printf (_(" (%s)"), name);
        -:21068:
    #####:21069:  printf ("\n");
    #####:21070:  return true;
        -:21071:}
        -:21072:
        -:21073:static bool
    #####:21074:print_gnu_build_attribute_name (Elf_Internal_Note * pnote)
        -:21075:{
        -:21076:  static const char string_expected [2] = { GNU_BUILD_ATTRIBUTE_TYPE_STRING, 0 };
        -:21077:  static const char number_expected [2] = { GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC, 0 };
        -:21078:  static const char bool_expected [3] = { GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE, GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE, 0 };
        -:21079:  char         name_type;
        -:21080:  char         name_attribute;
        -:21081:  const char * expected_types;
    #####:21082:  const char * name = pnote->namedata;
        -:21083:  const char * text;
        -:21084:  signed int   left;
        -:21085:
    #####:21086:  if (name == NULL || pnote->namesz < 2)
        -:21087:    {
    #####:21088:      error (_("corrupt name field in GNU build attribute note: size = %ld\n"), pnote->namesz);
    #####:21089:      print_symbol (-20, _("  <corrupt name>"));
    #####:21090:      return false;
        -:21091:    }
        -:21092:
    #####:21093:  if (do_wide)
    #####:21094:    left = 28;
        -:21095:  else
    #####:21096:    left = 20;
        -:21097:
        -:21098:  /* Version 2 of the spec adds a "GA" prefix to the name field.  */
    #####:21099:  if (name[0] == 'G' && name[1] == 'A')
        -:21100:    {
    #####:21101:      if (pnote->namesz < 4)
        -:21102:	{
    #####:21103:	  error (_("corrupt name field in GNU build attribute note: size = %ld\n"), pnote->namesz);
    #####:21104:	  print_symbol (-20, _("  <corrupt name>"));
    #####:21105:	  return false;
        -:21106:	}
        -:21107:
    #####:21108:      printf ("GA");
    #####:21109:      name += 2;
    #####:21110:      left -= 2;
        -:21111:    }
        -:21112:
    #####:21113:  switch ((name_type = * name))
        -:21114:    {
    #####:21115:    case GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC:
        -:21116:    case GNU_BUILD_ATTRIBUTE_TYPE_STRING:
        -:21117:    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE:
        -:21118:    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE:
    #####:21119:      printf ("%c", * name);
    #####:21120:      left --;
    #####:21121:      break;
    #####:21122:    default:
    #####:21123:      error (_("unrecognised attribute type in name field: %d\n"), name_type);
    #####:21124:      print_symbol (-20, _("<unknown name type>"));
    #####:21125:      return false;
        -:21126:    }
        -:21127:
    #####:21128:  ++ name;
    #####:21129:  text = NULL;
        -:21130:
    #####:21131:  switch ((name_attribute = * name))
        -:21132:    {
    #####:21133:    case GNU_BUILD_ATTRIBUTE_VERSION:
    #####:21134:      text = _("<version>");
    #####:21135:      expected_types = string_expected;
    #####:21136:      ++ name;
    #####:21137:      break;
    #####:21138:    case GNU_BUILD_ATTRIBUTE_STACK_PROT:
    #####:21139:      text = _("<stack prot>");
    #####:21140:      expected_types = "!+*";
    #####:21141:      ++ name;
    #####:21142:      break;
    #####:21143:    case GNU_BUILD_ATTRIBUTE_RELRO:
    #####:21144:      text = _("<relro>");
    #####:21145:      expected_types = bool_expected;
    #####:21146:      ++ name;
    #####:21147:      break;
    #####:21148:    case GNU_BUILD_ATTRIBUTE_STACK_SIZE:
    #####:21149:      text = _("<stack size>");
    #####:21150:      expected_types = number_expected;
    #####:21151:      ++ name;
    #####:21152:      break;
    #####:21153:    case GNU_BUILD_ATTRIBUTE_TOOL:
    #####:21154:      text = _("<tool>");
    #####:21155:      expected_types = string_expected;
    #####:21156:      ++ name;
    #####:21157:      break;
    #####:21158:    case GNU_BUILD_ATTRIBUTE_ABI:
    #####:21159:      text = _("<ABI>");
    #####:21160:      expected_types = "$*";
    #####:21161:      ++ name;
    #####:21162:      break;
    #####:21163:    case GNU_BUILD_ATTRIBUTE_PIC:
    #####:21164:      text = _("<PIC>");
    #####:21165:      expected_types = number_expected;
    #####:21166:      ++ name;
    #####:21167:      break;
    #####:21168:    case GNU_BUILD_ATTRIBUTE_SHORT_ENUM:
    #####:21169:      text = _("<short enum>");
    #####:21170:      expected_types = bool_expected;
    #####:21171:      ++ name;
    #####:21172:      break;
    #####:21173:    default:
    #####:21174:      if (ISPRINT (* name))
        -:21175:	{
    #####:21176:	  int len = strnlen (name, pnote->namesz - (name - pnote->namedata)) + 1;
        -:21177:
    #####:21178:	  if (len > left && ! do_wide)
    #####:21179:	    len = left;
    #####:21180:	  printf ("%.*s:", len, name);
    #####:21181:	  left -= len;
    #####:21182:	  name += len;
        -:21183:	}
        -:21184:      else
        -:21185:	{
        -:21186:	  static char tmpbuf [128];
        -:21187:
    #####:21188:	  error (_("unrecognised byte in name field: %d\n"), * name);
    #####:21189:	  sprintf (tmpbuf, _("<unknown:_%d>"), * name);
    #####:21190:	  text = tmpbuf;
    #####:21191:	  name ++;
        -:21192:	}
    #####:21193:      expected_types = "*$!+";
    #####:21194:      break;
        -:21195:    }
        -:21196:
    #####:21197:  if (text)
    #####:21198:    left -= printf ("%s", text);
        -:21199:
    #####:21200:  if (strchr (expected_types, name_type) == NULL)
    #####:21201:    warn (_("attribute does not have an expected type (%c)\n"), name_type);
        -:21202:
    #####:21203:  if ((unsigned long)(name - pnote->namedata) > pnote->namesz)
        -:21204:    {
    #####:21205:      error (_("corrupt name field: namesz: %lu but parsing gets to %ld\n"),
        -:21206:	     (unsigned long) pnote->namesz,
    #####:21207:	     (long) (name - pnote->namedata));
    #####:21208:      return false;
        -:21209:    }
        -:21210:
    #####:21211:  if (left < 1 && ! do_wide)
    #####:21212:    return true;
        -:21213:
    #####:21214:  switch (name_type)
        -:21215:    {
    #####:21216:    case GNU_BUILD_ATTRIBUTE_TYPE_NUMERIC:
        -:21217:      {
        -:21218:	unsigned int        bytes;
    #####:21219:	unsigned long long  val = 0;
    #####:21220:	unsigned int        shift = 0;
    #####:21221:	char *              decoded = NULL;
        -:21222:
    #####:21223:	bytes = pnote->namesz - (name - pnote->namedata);
    #####:21224:	if (bytes > 0)
        -:21225:	  /* The -1 is because the name field is always 0 terminated, and we
        -:21226:	     want to be able to ensure that the shift in the while loop below
        -:21227:	     will not overflow.  */
    #####:21228:	  -- bytes;
        -:21229:
    #####:21230:	if (bytes > sizeof (val))
        -:21231:	  {
    #####:21232:	    error (_("corrupt numeric name field: too many bytes in the value: %x\n"),
        -:21233:		   bytes);
    #####:21234:	    bytes = sizeof (val);
        -:21235:	  }
        -:21236:	/* We do not bother to warn if bytes == 0 as this can
        -:21237:	   happen with some early versions of the gcc plugin.  */
        -:21238:
    #####:21239:	while (bytes --)
        -:21240:	  {
    #####:21241:	    unsigned long long byte = *name++ & 0xff;
        -:21242:
    #####:21243:	    val |= byte << shift;
    #####:21244:	    shift += 8;
        -:21245:	  }
        -:21246:
    #####:21247:	switch (name_attribute)
        -:21248:	  {
    #####:21249:	  case GNU_BUILD_ATTRIBUTE_PIC:
        -:21250:	    switch (val)
        -:21251:	      {
    #####:21252:	      case 0: decoded = "static"; break;
    #####:21253:	      case 1: decoded = "pic"; break;
    #####:21254:	      case 2: decoded = "PIC"; break;
    #####:21255:	      case 3: decoded = "pie"; break;
    #####:21256:	      case 4: decoded = "PIE"; break;
    #####:21257:	      default: break;
        -:21258:	      }
    #####:21259:	    break;
    #####:21260:	  case GNU_BUILD_ATTRIBUTE_STACK_PROT:
        -:21261:	    switch (val)
        -:21262:	      {
        -:21263:		/* Based upon the SPCT_FLAG_xxx enum values in gcc/cfgexpand.c.  */
    #####:21264:	      case 0: decoded = "off"; break;
    #####:21265:	      case 1: decoded = "on"; break;
    #####:21266:	      case 2: decoded = "all"; break;
    #####:21267:	      case 3: decoded = "strong"; break;
    #####:21268:	      case 4: decoded = "explicit"; break;
    #####:21269:	      default: break;
        -:21270:	      }
    #####:21271:	    break;
    #####:21272:	  default:
    #####:21273:	    break;
        -:21274:	  }
        -:21275:
    #####:21276:	if (decoded != NULL)
        -:21277:	  {
    #####:21278:	    print_symbol (-left, decoded);
    #####:21279:	    left = 0;
        -:21280:	  }
    #####:21281:	else if (val == 0)
        -:21282:	  {
    #####:21283:	    printf ("0x0");
    #####:21284:	    left -= 3;
        -:21285:	  }
        -:21286:	else
        -:21287:	  {
    #####:21288:	    if (do_wide)
    #####:21289:	      left -= printf ("0x%llx", val);
        -:21290:	    else
    #####:21291:	      left -= printf ("0x%-.*llx", left, val);
        -:21292:	  }
        -:21293:      }
    #####:21294:      break;
    #####:21295:    case GNU_BUILD_ATTRIBUTE_TYPE_STRING:
    #####:21296:      left -= print_symbol (- left, name);
    #####:21297:      break;
    #####:21298:    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_TRUE:
    #####:21299:      left -= print_symbol (- left, "true");
    #####:21300:      break;
    #####:21301:    case GNU_BUILD_ATTRIBUTE_TYPE_BOOL_FALSE:
    #####:21302:      left -= print_symbol (- left, "false");
    #####:21303:      break;
        -:21304:    }
        -:21305:
    #####:21306:  if (do_wide && left > 0)
    #####:21307:    printf ("%-*s", left, " ");
        -:21308:
    #####:21309:  return true;
        -:21310:}
        -:21311:
        -:21312:/* Print the contents of PNOTE as hex.  */
        -:21313:
        -:21314:static void
        5:21315:print_note_contents_hex (Elf_Internal_Note *pnote)
        -:21316:{
        5:21317:  if (pnote->descsz)
        -:21318:    {
        -:21319:      unsigned long i;
        -:21320:
        1:21321:      printf (_("   description data: "));
        5:21322:      for (i = 0; i < pnote->descsz; i++)
        4:21323:	printf ("%02x ", pnote->descdata[i] & 0xff);
        1:21324:      if (!do_wide)
        1:21325:	printf ("\n");
        -:21326:    }
        -:21327:
        5:21328:  if (do_wide)
    #####:21329:    printf ("\n");
        5:21330:}
        -:21331:
        -:21332:#if defined HAVE_MSGPACK
        -:21333:
        -:21334:static void
        -:21335:print_indents (int n)
        -:21336:{
        -:21337:  printf ("    ");
        -:21338:
        -:21339:  for (int i = 0; i < n; i++)
        -:21340:    printf ("  ");
        -:21341:}
        -:21342:
        -:21343:/* Print OBJ in human-readable form.  */
        -:21344:
        -:21345:static void
        -:21346:dump_msgpack_obj (const msgpack_object *obj, int indent)
        -:21347:{
        -:21348:  switch (obj->type)
        -:21349:    {
        -:21350:    case MSGPACK_OBJECT_NIL:
        -:21351:      printf ("(nil)");
        -:21352:      break;
        -:21353:
        -:21354:    case MSGPACK_OBJECT_BOOLEAN:
        -:21355:      printf ("%s", obj->via.boolean ? "true" : "false");
        -:21356:      break;
        -:21357:
        -:21358:    case MSGPACK_OBJECT_POSITIVE_INTEGER:
        -:21359:      printf ("%" PRIu64, obj->via.u64);
        -:21360:      break;
        -:21361:
        -:21362:    case MSGPACK_OBJECT_NEGATIVE_INTEGER:
        -:21363:      printf ("%" PRIi64, obj->via.i64);
        -:21364:      break;
        -:21365:
        -:21366:    case MSGPACK_OBJECT_FLOAT32:
        -:21367:    case MSGPACK_OBJECT_FLOAT64:
        -:21368:      printf ("%f", obj->via.f64);
        -:21369:      break;
        -:21370:
        -:21371:    case MSGPACK_OBJECT_STR:
        -:21372:      printf ("\"%.*s\"", obj->via.str.size, obj->via.str.ptr);
        -:21373:      break;
        -:21374:
        -:21375:    case MSGPACK_OBJECT_ARRAY:
        -:21376:      {
        -:21377:	const msgpack_object_array *array = &obj->via.array;
        -:21378:
        -:21379:	printf ("[\n");
        -:21380:	++indent;
        -:21381:
        -:21382:	for (uint32_t i = 0; i < array->size; ++i)
        -:21383:	  {
        -:21384:	    const msgpack_object *item = &array->ptr[i];
        -:21385:
        -:21386:	    print_indents (indent);
        -:21387:	    dump_msgpack_obj (item, indent);
        -:21388:	    printf (",\n");
        -:21389:	  }
        -:21390:
        -:21391:	--indent;
        -:21392:	print_indents (indent);
        -:21393:	printf ("]");
        -:21394:	break;
        -:21395:      }
        -:21396:      break;
        -:21397:
        -:21398:    case MSGPACK_OBJECT_MAP:
        -:21399:      {
        -:21400:	const msgpack_object_map *map = &obj->via.map;
        -:21401:
        -:21402:	printf ("{\n");
        -:21403:	++indent;
        -:21404:
        -:21405:	for (uint32_t i = 0; i < map->size; ++i)
        -:21406:	  {
        -:21407:	    const msgpack_object_kv *kv = &map->ptr[i];
        -:21408:	    const msgpack_object *key = &kv->key;
        -:21409:	    const msgpack_object *val = &kv->val;
        -:21410:
        -:21411:	    print_indents (indent);
        -:21412:	    dump_msgpack_obj (key, indent);
        -:21413:	    printf (": ");
        -:21414:	    dump_msgpack_obj (val, indent);
        -:21415:
        -:21416:	    printf (",\n");
        -:21417:	  }
        -:21418:
        -:21419:	--indent;
        -:21420:	print_indents (indent);
        -:21421:	printf ("}");
        -:21422:
        -:21423:	break;
        -:21424:      }
        -:21425:
        -:21426:    case MSGPACK_OBJECT_BIN:
        -:21427:      printf ("(bin)");
        -:21428:      break;
        -:21429:
        -:21430:    case MSGPACK_OBJECT_EXT:
        -:21431:      printf ("(ext)");
        -:21432:      break;
        -:21433:    }
        -:21434:}
        -:21435:
        -:21436:static void
        -:21437:dump_msgpack (const msgpack_unpacked *msg)
        -:21438:{
        -:21439:  print_indents (0);
        -:21440:  dump_msgpack_obj (&msg->data, 0);
        -:21441:  printf ("\n");
        -:21442:}
        -:21443:
        -:21444:#endif /* defined HAVE_MSGPACK */
        -:21445:
        -:21446:static bool
    #####:21447:print_amdgpu_note (Elf_Internal_Note *pnote)
        -:21448:{
        -:21449:#if defined HAVE_MSGPACK
        -:21450:  /* If msgpack is available, decode and dump the note's content.  */
        -:21451:  bool ret;
        -:21452:  msgpack_unpacked msg;
        -:21453:  msgpack_unpack_return msgpack_ret;
        -:21454:
        -:21455:  assert (pnote->type == NT_AMDGPU_METADATA);
        -:21456:
        -:21457:  msgpack_unpacked_init (&msg);
        -:21458:  msgpack_ret = msgpack_unpack_next (&msg, pnote->descdata, pnote->descsz,
        -:21459:				     NULL);
        -:21460:
        -:21461:  switch (msgpack_ret)
        -:21462:    {
        -:21463:    case MSGPACK_UNPACK_SUCCESS:
        -:21464:      dump_msgpack (&msg);
        -:21465:      ret = true;
        -:21466:      break;
        -:21467:
        -:21468:    default:
        -:21469:      error (_("failed to unpack msgpack contents in NT_AMDGPU_METADATA note"));
        -:21470:      ret = false;
        -:21471:      break;
        -:21472:    }
        -:21473:
        -:21474:  msgpack_unpacked_destroy (&msg);
        -:21475:  return ret;
        -:21476:#else
        -:21477:  /* msgpack is not available, dump contents as hex.  */
    #####:21478:  print_note_contents_hex (pnote);
    #####:21479:  return true;
        -:21480:#endif
        -:21481:}
        -:21482:
        -:21483:/* Note that by the ELF standard, the name field is already null byte
        -:21484:   terminated, and namesz includes the terminating null byte.
        -:21485:   I.E. the value of namesz for the name "FSF" is 4.
        -:21486:
        -:21487:   If the value of namesz is zero, there is no name present.  */
        -:21488:
        -:21489:static bool
        5:21490:process_note (Elf_Internal_Note *  pnote,
        -:21491:	      Filedata *           filedata)
        -:21492:{
        5:21493:  const char * name = pnote->namesz ? pnote->namedata : "(NONE)";
        -:21494:  const char * nt;
        -:21495:
        5:21496:  if (pnote->namesz == 0)
        -:21497:    /* If there is no note name, then use the default set of
        -:21498:       note type strings.  */
        4:21499:    nt = get_note_type (filedata, pnote->type);
        -:21500:
        1:21501:  else if (startswith (pnote->namedata, "GNU"))
        -:21502:    /* GNU-specific object file notes.  */
    #####:21503:    nt = get_gnu_elf_note_type (pnote->type);
        -:21504:
        1:21505:  else if (startswith (pnote->namedata, "AMDGPU"))
        -:21506:    /* AMDGPU-specific object file notes.  */
    #####:21507:    nt = get_amdgpu_elf_note_type (pnote->type);
        -:21508:
        1:21509:  else if (startswith (pnote->namedata, "FreeBSD"))
        -:21510:    /* FreeBSD-specific core file notes.  */
    #####:21511:    nt = get_freebsd_elfcore_note_type (filedata, pnote->type);
        -:21512:
        1:21513:  else if (startswith (pnote->namedata, "NetBSD-CORE"))
        -:21514:    /* NetBSD-specific core file notes.  */
    #####:21515:    nt = get_netbsd_elfcore_note_type (filedata, pnote->type);
        -:21516:
        1:21517:  else if (startswith (pnote->namedata, "NetBSD"))
        -:21518:    /* NetBSD-specific core file notes.  */
    #####:21519:    return process_netbsd_elf_note (pnote);
        -:21520:
        1:21521:  else if (startswith (pnote->namedata, "PaX"))
        -:21522:    /* NetBSD-specific core file notes.  */
    #####:21523:    return process_netbsd_elf_note (pnote);
        -:21524:
        1:21525:  else if (startswith (pnote->namedata, "OpenBSD"))
        -:21526:    /* OpenBSD-specific core file notes.  */
    #####:21527:    nt = get_openbsd_elfcore_note_type (filedata, pnote->type);
        -:21528:
        1:21529:  else if (startswith (pnote->namedata, "SPU/"))
        -:21530:    {
        -:21531:      /* SPU-specific core file notes.  */
    #####:21532:      nt = pnote->namedata + 4;
    #####:21533:      name = "SPU";
        -:21534:    }
        -:21535:
        1:21536:  else if (startswith (pnote->namedata, "IPF/VMS"))
        -:21537:    /* VMS/ia64-specific file notes.  */
    #####:21538:    nt = get_ia64_vms_note_type (pnote->type);
        -:21539:
        1:21540:  else if (startswith (pnote->namedata, "stapsdt"))
    #####:21541:    nt = get_stapsdt_note_type (pnote->type);
        -:21542:
        -:21543:  else
        -:21544:    /* Don't recognize this note name; just use the default set of
        -:21545:       note type strings.  */
        1:21546:    nt = get_note_type (filedata, pnote->type);
        -:21547:
        5:21548:  printf ("  ");
        -:21549:
        5:21550:  if (((startswith (pnote->namedata, "GA")
    #####:21551:	&& strchr ("*$!+", pnote->namedata[2]) != NULL)
        5:21552:       || strchr ("*$!+", pnote->namedata[0]) != NULL)
        2:21553:      && (pnote->type == NT_GNU_BUILD_ATTRIBUTE_OPEN
        2:21554:	  || pnote->type == NT_GNU_BUILD_ATTRIBUTE_FUNC))
    #####:21555:    print_gnu_build_attribute_name (pnote);
        -:21556:  else
        5:21557:    print_symbol (-20, name);
        -:21558:
        5:21559:  if (do_wide)
    #####:21560:    printf (" 0x%08lx\t%s\t", pnote->descsz, nt);
        -:21561:  else
        5:21562:    printf (" 0x%08lx\t%s\n", pnote->descsz, nt);
        -:21563:
        5:21564:  if (startswith (pnote->namedata, "IPF/VMS"))
    #####:21565:    return print_ia64_vms_note (pnote);
        5:21566:  else if (startswith (pnote->namedata, "GNU"))
    #####:21567:    return print_gnu_note (filedata, pnote);
        5:21568:  else if (startswith (pnote->namedata, "stapsdt"))
    #####:21569:    return print_stapsdt_note (pnote);
        5:21570:  else if (startswith (pnote->namedata, "CORE"))
    #####:21571:    return print_core_note (pnote);
        5:21572:  else if (startswith (pnote->namedata, "FDO"))
    #####:21573:    return print_fdo_note (pnote);
        5:21574:  else if (((startswith (pnote->namedata, "GA")
    #####:21575:	     && strchr ("*$!+", pnote->namedata[2]) != NULL)
        5:21576:	    || strchr ("*$!+", pnote->namedata[0]) != NULL)
        2:21577:	   && (pnote->type == NT_GNU_BUILD_ATTRIBUTE_OPEN
        2:21578:	       || pnote->type == NT_GNU_BUILD_ATTRIBUTE_FUNC))
    #####:21579:    return print_gnu_build_attribute_description (pnote, filedata);
        5:21580:  else if (startswith (pnote->namedata, "AMDGPU")
    #####:21581:	   && pnote->type == NT_AMDGPU_METADATA)
    #####:21582:    return print_amdgpu_note (pnote);
        -:21583:
        5:21584:  print_note_contents_hex (pnote);
        5:21585:  return true;
        -:21586:}
        -:21587:
        -:21588:static bool
       35:21589:process_notes_at (Filedata *           filedata,
        -:21590:		  Elf_Internal_Shdr *  section,
        -:21591:		  bfd_vma              offset,
        -:21592:		  bfd_vma              length,
        -:21593:		  bfd_vma              align)
        -:21594:{
        -:21595:  Elf_External_Note *pnotes;
        -:21596:  Elf_External_Note *external;
        -:21597:  char *end;
       35:21598:  bool res = true;
        -:21599:
       35:21600:  if (length <= 0)
        8:21601:    return false;
        -:21602:
       27:21603:  if (section)
        -:21604:    {
       17:21605:      pnotes = (Elf_External_Note *) get_section_contents (section, filedata);
       17:21606:      if (pnotes)
        -:21607:	{
       16:21608:	  if (! apply_relocations (filedata, section, (unsigned char *) pnotes, length, NULL, NULL))
        -:21609:	    {
    #####:21610:	      free (pnotes);
    #####:21611:	      return false;
        -:21612:	    }
        -:21613:	}
        -:21614:    }
        -:21615:  else
       10:21616:    pnotes = (Elf_External_Note *) get_data (NULL, filedata, offset, 1, length,
       10:21617:					     _("notes"));
        -:21618:
       27:21619:  if (pnotes == NULL)
        6:21620:    return false;
        -:21621:
       21:21622:  external = pnotes;
        -:21623:
       21:21624:  if (filedata->is_separate)
    #####:21625:    printf (_("In linked file '%s': "), filedata->file_name);
        -:21626:  else
       21:21627:    printf ("\n");
       21:21628:  if (section)
       16:21629:    printf (_("Displaying notes found in: %s\n"), printable_section_name (filedata, section));
        -:21630:  else
        5:21631:    printf (_("Displaying notes found at file offset 0x%08lx with length 0x%08lx:\n"),
        -:21632:	    (unsigned long) offset, (unsigned long) length);
        -:21633:
        -:21634:  /* NB: Some note sections may have alignment value of 0 or 1.  gABI
        -:21635:     specifies that notes should be aligned to 4 bytes in 32-bit
        -:21636:     objects and to 8 bytes in 64-bit objects.  As a Linux extension,
        -:21637:     we also support 4 byte alignment in 64-bit objects.  If section
        -:21638:     alignment is less than 4, we treate alignment as 4 bytes.   */
       21:21639:  if (align < 4)
       14:21640:    align = 4;
        7:21641:  else if (align != 4 && align != 8)
        -:21642:    {
        2:21643:      warn (_("Corrupt note: alignment %ld, expecting 4 or 8\n"),
        -:21644:	    (long) align);
        2:21645:      free (pnotes);
        2:21646:      return false;
        -:21647:    }
        -:21648:
       19:21649:  printf (_("  %-20s %-10s\tDescription\n"), _("Owner"), _("Data size"));
        -:21650:
       19:21651:  end = (char *) pnotes + length;
       24:21652:  while ((char *) external < end)
        -:21653:    {
        -:21654:      Elf_Internal_Note inote;
        -:21655:      size_t min_notesz;
        -:21656:      char * next;
       23:21657:      char * temp = NULL;
       23:21658:      size_t data_remaining = end - (char *) external;
        -:21659:
       23:21660:      if (!is_ia64_vms (filedata))
        -:21661:	{
        -:21662:	  /* PR binutils/15191
        -:21663:	     Make sure that there is enough data to read.  */
       23:21664:	  min_notesz = offsetof (Elf_External_Note, name);
       23:21665:	  if (data_remaining < min_notesz)
        -:21666:	    {
        5:21667:	      warn (ngettext ("Corrupt note: only %ld byte remains, "
        -:21668:			      "not enough for a full note\n",
        -:21669:			      "Corrupt note: only %ld bytes remain, "
        -:21670:			      "not enough for a full note\n",
        -:21671:			      data_remaining),
        -:21672:		    (long) data_remaining);
       18:21673:	      break;
        -:21674:	    }
       18:21675:	  data_remaining -= min_notesz;
        -:21676:
       18:21677:	  inote.type     = BYTE_GET (external->type);
       18:21678:	  inote.namesz   = BYTE_GET (external->namesz);
       18:21679:	  inote.namedata = external->name;
       18:21680:	  inote.descsz   = BYTE_GET (external->descsz);
       18:21681:	  inote.descdata = ((char *) external
       18:21682:			    + ELF_NOTE_DESC_OFFSET (inote.namesz, align));
       18:21683:	  inote.descpos  = offset + (inote.descdata - (char *) pnotes);
       18:21684:	  next = ((char *) external
       18:21685:		  + ELF_NOTE_NEXT_OFFSET (inote.namesz, inote.descsz, align));
        -:21686:	}
        -:21687:      else
        -:21688:	{
        -:21689:	  Elf64_External_VMS_Note *vms_external;
        -:21690:
        -:21691:	  /* PR binutils/15191
        -:21692:	     Make sure that there is enough data to read.  */
    #####:21693:	  min_notesz = offsetof (Elf64_External_VMS_Note, name);
    #####:21694:	  if (data_remaining < min_notesz)
        -:21695:	    {
    #####:21696:	      warn (ngettext ("Corrupt note: only %ld byte remains, "
        -:21697:			      "not enough for a full note\n",
        -:21698:			      "Corrupt note: only %ld bytes remain, "
        -:21699:			      "not enough for a full note\n",
        -:21700:			      data_remaining),
        -:21701:		    (long) data_remaining);
    #####:21702:	      break;
        -:21703:	    }
    #####:21704:	  data_remaining -= min_notesz;
        -:21705:
    #####:21706:	  vms_external = (Elf64_External_VMS_Note *) external;
    #####:21707:	  inote.type     = BYTE_GET (vms_external->type);
    #####:21708:	  inote.namesz   = BYTE_GET (vms_external->namesz);
    #####:21709:	  inote.namedata = vms_external->name;
    #####:21710:	  inote.descsz   = BYTE_GET (vms_external->descsz);
    #####:21711:	  inote.descdata = inote.namedata + align_power (inote.namesz, 3);
    #####:21712:	  inote.descpos  = offset + (inote.descdata - (char *) pnotes);
    #####:21713:	  next = inote.descdata + align_power (inote.descsz, 3);
        -:21714:	}
        -:21715:
        -:21716:      /* PR 17531: file: 3443835e.  */
        -:21717:      /* PR 17531: file: id:000000,sig:11,src:006986,op:havoc,rep:4.  */
       18:21718:      if ((size_t) (inote.descdata - inote.namedata) < inote.namesz
       18:21719:	  || (size_t) (inote.descdata - inote.namedata) > data_remaining
        6:21720:	  || (size_t) (next - inote.descdata) < inote.descsz
        6:21721:	  || ((size_t) (next - inote.descdata)
        6:21722:	      > data_remaining - (size_t) (inote.descdata - inote.namedata)))
        -:21723:	{
       13:21724:	  warn (_("note with invalid namesz and/or descsz found at offset 0x%lx\n"),
       13:21725:		(unsigned long) ((char *) external - (char *) pnotes));
       13:21726:	  warn (_(" type: 0x%lx, namesize: 0x%08lx, descsize: 0x%08lx, alignment: %u\n"),
        -:21727:		inote.type, inote.namesz, inote.descsz, (int) align);
       13:21728:	  break;
        -:21729:	}
        -:21730:
        5:21731:      external = (Elf_External_Note *) next;
        -:21732:
        -:21733:      /* Verify that name is null terminated.  It appears that at least
        -:21734:	 one version of Linux (RedHat 6.0) generates corefiles that don't
        -:21735:	 comply with the ELF spec by failing to include the null byte in
        -:21736:	 namesz.  */
        5:21737:      if (inote.namesz > 0 && inote.namedata[inote.namesz - 1] != '\0')
        -:21738:	{
    #####:21739:	  if ((size_t) (inote.descdata - inote.namedata) == inote.namesz)
        -:21740:	    {
    #####:21741:	      temp = (char *) malloc (inote.namesz + 1);
    #####:21742:	      if (temp == NULL)
        -:21743:		{
    #####:21744:		  error (_("Out of memory allocating space for inote name\n"));
    #####:21745:		  res = false;
    #####:21746:		  break;
        -:21747:		}
        -:21748:
    #####:21749:	      memcpy (temp, inote.namedata, inote.namesz);
    #####:21750:	      inote.namedata = temp;
        -:21751:	    }
    #####:21752:	  inote.namedata[inote.namesz] = 0;
        -:21753:	}
        -:21754:
        5:21755:      if (! process_note (& inote, filedata))
    #####:21756:	res = false;
        -:21757:
        5:21758:      free (temp);
        5:21759:      temp = NULL;
        -:21760:    }
        -:21761:
       19:21762:  free (pnotes);
        -:21763:
       19:21764:  return res;
        -:21765:}
        -:21766:
        -:21767:static bool
     1373:21768:process_corefile_note_segments (Filedata * filedata)
        -:21769:{
        -:21770:  Elf_Internal_Phdr *segment;
        -:21771:  unsigned int i;
     1373:21772:  bool res = true;
        -:21773:
     1373:21774:  if (! get_program_headers (filedata))
      483:21775:    return true;
        -:21776:
      890:21777:  for (i = 0, segment = filedata->program_headers;
     2991:21778:       i < filedata->file_header.e_phnum;
     2101:21779:       i++, segment++)
        -:21780:    {
     2101:21781:      if (segment->p_type == PT_NOTE)
       16:21782:	if (! process_notes_at (filedata, NULL,
       16:21783:				(bfd_vma) segment->p_offset,
       16:21784:				(bfd_vma) segment->p_filesz,
       16:21785:				(bfd_vma) segment->p_align))
       13:21786:	  res = false;
        -:21787:    }
        -:21788:
      890:21789:  return res;
        -:21790:}
        -:21791:
        -:21792:static bool
    #####:21793:process_v850_notes (Filedata * filedata, bfd_vma offset, bfd_vma length)
        -:21794:{
        -:21795:  Elf_External_Note * pnotes;
        -:21796:  Elf_External_Note * external;
        -:21797:  char * end;
    #####:21798:  bool res = true;
        -:21799:
    #####:21800:  if (length <= 0)
    #####:21801:    return false;
        -:21802:
    #####:21803:  pnotes = (Elf_External_Note *) get_data (NULL, filedata, offset, 1, length,
    #####:21804:                                           _("v850 notes"));
    #####:21805:  if (pnotes == NULL)
    #####:21806:    return false;
        -:21807:
    #####:21808:  external = pnotes;
    #####:21809:  end = (char*) pnotes + length;
        -:21810:
    #####:21811:  printf (_("\nDisplaying contents of Renesas V850 notes section at offset 0x%lx with length 0x%lx:\n"),
        -:21812:	  (unsigned long) offset, (unsigned long) length);
        -:21813:
    #####:21814:  while ((char *) external + sizeof (Elf_External_Note) < end)
        -:21815:    {
        -:21816:      Elf_External_Note * next;
        -:21817:      Elf_Internal_Note inote;
        -:21818:
    #####:21819:      inote.type     = BYTE_GET (external->type);
    #####:21820:      inote.namesz   = BYTE_GET (external->namesz);
    #####:21821:      inote.namedata = external->name;
    #####:21822:      inote.descsz   = BYTE_GET (external->descsz);
    #####:21823:      inote.descdata = inote.namedata + align_power (inote.namesz, 2);
    #####:21824:      inote.descpos  = offset + (inote.descdata - (char *) pnotes);
        -:21825:
    #####:21826:      if (inote.descdata < (char *) pnotes || inote.descdata >= end)
        -:21827:	{
    #####:21828:	  warn (_("Corrupt note: name size is too big: %lx\n"), inote.namesz);
    #####:21829:	  inote.descdata = inote.namedata;
    #####:21830:	  inote.namesz   = 0;
        -:21831:	}
        -:21832:
    #####:21833:      next = (Elf_External_Note *) (inote.descdata + align_power (inote.descsz, 2));
        -:21834:
    #####:21835:      if (   ((char *) next > end)
    #####:21836:	  || ((char *) next <  (char *) pnotes))
        -:21837:	{
    #####:21838:	  warn (_("corrupt descsz found in note at offset 0x%lx\n"),
    #####:21839:		(unsigned long) ((char *) external - (char *) pnotes));
    #####:21840:	  warn (_(" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n"),
        -:21841:		inote.type, inote.namesz, inote.descsz);
    #####:21842:	  break;
        -:21843:	}
        -:21844:
    #####:21845:      external = next;
        -:21846:
        -:21847:      /* Prevent out-of-bounds indexing.  */
    #####:21848:      if (   inote.namedata + inote.namesz > end
    #####:21849:	  || inote.namedata + inote.namesz < inote.namedata)
        -:21850:        {
    #####:21851:          warn (_("corrupt namesz found in note at offset 0x%lx\n"),
    #####:21852:                (unsigned long) ((char *) external - (char *) pnotes));
    #####:21853:          warn (_(" type: 0x%lx, namesize: 0x%lx, descsize: 0x%lx\n"),
        -:21854:                inote.type, inote.namesz, inote.descsz);
    #####:21855:          break;
        -:21856:        }
        -:21857:
    #####:21858:      printf ("  %s: ", get_v850_elf_note_type (inote.type));
        -:21859:
    #####:21860:      if (! print_v850_note (& inote))
        -:21861:	{
    #####:21862:	  res = false;
    #####:21863:	  printf ("<corrupt sizes: namesz: %lx, descsz: %lx>\n",
        -:21864:		  inote.namesz, inote.descsz);
        -:21865:	}
        -:21866:    }
        -:21867:
    #####:21868:  free (pnotes);
        -:21869:
    #####:21870:  return res;
        -:21871:}
        -:21872:
        -:21873:static bool
     1384:21874:process_note_sections (Filedata * filedata)
        -:21875:{
        -:21876:  Elf_Internal_Shdr *section;
        -:21877:  unsigned long i;
     1384:21878:  unsigned int n = 0;
     1384:21879:  bool res = true;
        -:21880:
     1384:21881:  for (i = 0, section = filedata->section_headers;
     4879:21882:       i < filedata->file_header.e_shnum && section != NULL;
     3495:21883:       i++, section++)
        -:21884:    {
     3495:21885:      if (section->sh_type == SHT_NOTE)
        -:21886:	{
       19:21887:	  if (! process_notes_at (filedata, section,
       19:21888:				  (bfd_vma) section->sh_offset,
       19:21889:				  (bfd_vma) section->sh_size,
       19:21890:				  (bfd_vma) section->sh_addralign))
        3:21891:	    res = false;
       19:21892:	  n++;
        -:21893:	}
        -:21894:
     3495:21895:      if ((   filedata->file_header.e_machine == EM_V800
     3478:21896:	   || filedata->file_header.e_machine == EM_V850
     3474:21897:	   || filedata->file_header.e_machine == EM_CYGNUS_V850)
       47:21898:	  && section->sh_type == SHT_RENESAS_INFO)
        -:21899:	{
    #####:21900:	  if (! process_v850_notes (filedata,
    #####:21901:				    (bfd_vma) section->sh_offset,
    #####:21902:				    (bfd_vma) section->sh_size))
    #####:21903:	    res = false;
    #####:21904:	  n++;
        -:21905:	}
        -:21906:    }
        -:21907:
     1384:21908:  if (n == 0)
        -:21909:    /* Try processing NOTE segments instead.  */
     1367:21910:    return process_corefile_note_segments (filedata);
        -:21911:
       17:21912:  return res;
        -:21913:}
        -:21914:
        -:21915:static bool
     1391:21916:process_notes (Filedata * filedata)
        -:21917:{
        -:21918:  /* If we have not been asked to display the notes then do nothing.  */
     1391:21919:  if (! do_notes)
    #####:21920:    return true;
        -:21921:
     1391:21922:  if (filedata->file_header.e_type != ET_CORE)
     1384:21923:    return process_note_sections (filedata);
        -:21924:
        -:21925:  /* No program headers means no NOTE segment.  */
        7:21926:  if (filedata->file_header.e_phnum > 0)
        6:21927:    return process_corefile_note_segments (filedata);
        -:21928:
        1:21929:  if (filedata->is_separate)
    #####:21930:    printf (_("No notes found in linked file '%s'.\n"),
        -:21931:	    filedata->file_name);
        -:21932:  else
        1:21933:    printf (_("No notes found file.\n"));
        -:21934:
        1:21935:  return true;
        -:21936:}
        -:21937:
        -:21938:static unsigned char *
    #####:21939:display_public_gnu_attributes (unsigned char * start,
        -:21940:			       const unsigned char * const end)
        -:21941:{
    #####:21942:  printf (_("  Unknown GNU attribute: %s\n"), start);
        -:21943:
    #####:21944:  start += strnlen ((char *) start, end - start);
    #####:21945:  display_raw_attribute (start, end);
        -:21946:
    #####:21947:  return (unsigned char *) end;
        -:21948:}
        -:21949:
        -:21950:static unsigned char *
    #####:21951:display_generic_attribute (unsigned char * start,
        -:21952:			   unsigned int tag,
        -:21953:			   const unsigned char * const end)
        -:21954:{
    #####:21955:  if (tag == 0)
    #####:21956:    return (unsigned char *) end;
        -:21957:
    #####:21958:  return display_tag_value (tag, start, end);
        -:21959:}
        -:21960:
        -:21961:static bool
     1391:21962:process_arch_specific (Filedata * filedata)
        -:21963:{
     1391:21964:  if (! do_arch)
     1228:21965:    return true;
        -:21966:
      163:21967:  switch (filedata->file_header.e_machine)
        -:21968:    {
    #####:21969:    case EM_ARC:
        -:21970:    case EM_ARC_COMPACT:
        -:21971:    case EM_ARC_COMPACT2:
    #####:21972:      return process_attributes (filedata, "ARC", SHT_ARC_ATTRIBUTES,
        -:21973:				 display_arc_attribute,
        -:21974:				 display_generic_attribute);
    #####:21975:    case EM_ARM:
    #####:21976:      return process_attributes (filedata, "aeabi", SHT_ARM_ATTRIBUTES,
        -:21977:				 display_arm_attribute,
        -:21978:				 display_generic_attribute);
        -:21979:
        3:21980:    case EM_MIPS:
        -:21981:    case EM_MIPS_RS3_LE:
        3:21982:      return process_mips_specific (filedata);
        -:21983:
    #####:21984:    case EM_MSP430:
    #####:21985:     return process_attributes (filedata, "mspabi", SHT_MSP430_ATTRIBUTES,
        -:21986:				display_msp430_attribute,
        -:21987:				display_msp430_gnu_attribute);
        -:21988:
        1:21989:    case EM_RISCV:
        1:21990:     return process_attributes (filedata, "riscv", SHT_RISCV_ATTRIBUTES,
        -:21991:				display_riscv_attribute,
        -:21992:				display_generic_attribute);
        -:21993:
    #####:21994:    case EM_NDS32:
    #####:21995:      return process_nds32_specific (filedata);
        -:21996:
        2:21997:    case EM_68K:
        2:21998:      return process_attributes (filedata, NULL, SHT_GNU_ATTRIBUTES, NULL,
        -:21999:				 display_m68k_gnu_attribute);
        -:22000:
    #####:22001:    case EM_PPC:
        -:22002:    case EM_PPC64:
    #####:22003:      return process_attributes (filedata, NULL, SHT_GNU_ATTRIBUTES, NULL,
        -:22004:				 display_power_gnu_attribute);
        -:22005:
        3:22006:    case EM_S390:
        -:22007:    case EM_S390_OLD:
        3:22008:      return process_attributes (filedata, NULL, SHT_GNU_ATTRIBUTES, NULL,
        -:22009:				 display_s390_gnu_attribute);
        -:22010:
        4:22011:    case EM_SPARC:
        -:22012:    case EM_SPARC32PLUS:
        -:22013:    case EM_SPARCV9:
        4:22014:      return process_attributes (filedata, NULL, SHT_GNU_ATTRIBUTES, NULL,
        -:22015:				 display_sparc_gnu_attribute);
        -:22016:
    #####:22017:    case EM_TI_C6000:
    #####:22018:      return process_attributes (filedata, "c6xabi", SHT_C6000_ATTRIBUTES,
        -:22019:				 display_tic6x_attribute,
        -:22020:				 display_generic_attribute);
        -:22021:
    #####:22022:    case EM_CSKY:
    #####:22023:      return process_attributes (filedata, "csky", SHT_CSKY_ATTRIBUTES,
        -:22024:				 display_csky_attribute, NULL);
        -:22025:
      150:22026:    default:
      150:22027:      return process_attributes (filedata, "gnu", SHT_GNU_ATTRIBUTES,
        -:22028:				 display_public_gnu_attributes,
        -:22029:				 display_generic_attribute);
        -:22030:    }
        -:22031:}
        -:22032:
        -:22033:static bool
     1400:22034:get_file_header (Filedata * filedata)
        -:22035:{
        -:22036:  /* Read in the identity array.  */
     1400:22037:  if (fread (filedata->file_header.e_ident, EI_NIDENT, 1, filedata->handle) != 1)
        1:22038:    return false;
        -:22039:
        -:22040:  /* Determine how to read the rest of the header.  */
     1399:22041:  switch (filedata->file_header.e_ident[EI_DATA])
        -:22042:    {
     1396:22043:    default:
        -:22044:    case ELFDATANONE:
        -:22045:    case ELFDATA2LSB:
     1396:22046:      byte_get = byte_get_little_endian;
     1396:22047:      byte_put = byte_put_little_endian;
     1396:22048:      break;
        3:22049:    case ELFDATA2MSB:
        3:22050:      byte_get = byte_get_big_endian;
        3:22051:      byte_put = byte_put_big_endian;
        3:22052:      break;
        -:22053:    }
        -:22054:
        -:22055:  /* For now we only support 32 bit and 64 bit ELF files.  */
     1399:22056:  is_32bit_elf = (filedata->file_header.e_ident[EI_CLASS] != ELFCLASS64);
        -:22057:
        -:22058:  /* Read in the rest of the header.  */
     1399:22059:  if (is_32bit_elf)
        -:22060:    {
        -:22061:      Elf32_External_Ehdr ehdr32;
        -:22062:
     1386:22063:      if (fread (ehdr32.e_type, sizeof (ehdr32) - EI_NIDENT, 1, filedata->handle) != 1)
        1:22064:	return false;
        -:22065:
     1385:22066:      filedata->file_header.e_type      = BYTE_GET (ehdr32.e_type);
     1385:22067:      filedata->file_header.e_machine   = BYTE_GET (ehdr32.e_machine);
     1385:22068:      filedata->file_header.e_version   = BYTE_GET (ehdr32.e_version);
     1385:22069:      filedata->file_header.e_entry     = BYTE_GET (ehdr32.e_entry);
     1385:22070:      filedata->file_header.e_phoff     = BYTE_GET (ehdr32.e_phoff);
     1385:22071:      filedata->file_header.e_shoff     = BYTE_GET (ehdr32.e_shoff);
     1385:22072:      filedata->file_header.e_flags     = BYTE_GET (ehdr32.e_flags);
     1385:22073:      filedata->file_header.e_ehsize    = BYTE_GET (ehdr32.e_ehsize);
     1385:22074:      filedata->file_header.e_phentsize = BYTE_GET (ehdr32.e_phentsize);
     1385:22075:      filedata->file_header.e_phnum     = BYTE_GET (ehdr32.e_phnum);
     1385:22076:      filedata->file_header.e_shentsize = BYTE_GET (ehdr32.e_shentsize);
     1385:22077:      filedata->file_header.e_shnum     = BYTE_GET (ehdr32.e_shnum);
     1385:22078:      filedata->file_header.e_shstrndx  = BYTE_GET (ehdr32.e_shstrndx);
        -:22079:    }
        -:22080:  else
        -:22081:    {
        -:22082:      Elf64_External_Ehdr ehdr64;
        -:22083:
        -:22084:      /* If we have been compiled with sizeof (bfd_vma) == 4, then
        -:22085:	 we will not be able to cope with the 64bit data found in
        -:22086:	 64 ELF files.  Detect this now and abort before we start
        -:22087:	 overwriting things.  */
        -:22088:      if (sizeof (bfd_vma) < 8)
        -:22089:	{
        -:22090:	  error (_("This instance of readelf has been built without support for a\n\
        -:22091:64 bit data type and so it cannot read 64 bit ELF files.\n"));
        1:22092:	  return false;
        -:22093:	}
        -:22094:
       13:22095:      if (fread (ehdr64.e_type, sizeof (ehdr64) - EI_NIDENT, 1, filedata->handle) != 1)
        1:22096:	return false;
        -:22097:
       12:22098:      filedata->file_header.e_type      = BYTE_GET (ehdr64.e_type);
       12:22099:      filedata->file_header.e_machine   = BYTE_GET (ehdr64.e_machine);
       12:22100:      filedata->file_header.e_version   = BYTE_GET (ehdr64.e_version);
       12:22101:      filedata->file_header.e_entry     = BYTE_GET (ehdr64.e_entry);
       12:22102:      filedata->file_header.e_phoff     = BYTE_GET (ehdr64.e_phoff);
       12:22103:      filedata->file_header.e_shoff     = BYTE_GET (ehdr64.e_shoff);
       12:22104:      filedata->file_header.e_flags     = BYTE_GET (ehdr64.e_flags);
       12:22105:      filedata->file_header.e_ehsize    = BYTE_GET (ehdr64.e_ehsize);
       12:22106:      filedata->file_header.e_phentsize = BYTE_GET (ehdr64.e_phentsize);
       12:22107:      filedata->file_header.e_phnum     = BYTE_GET (ehdr64.e_phnum);
       12:22108:      filedata->file_header.e_shentsize = BYTE_GET (ehdr64.e_shentsize);
       12:22109:      filedata->file_header.e_shnum     = BYTE_GET (ehdr64.e_shnum);
       12:22110:      filedata->file_header.e_shstrndx  = BYTE_GET (ehdr64.e_shstrndx);
        -:22111:    }
        -:22112:
     1397:22113:  return true;
        -:22114:}
        -:22115:
        -:22116:static void
     1397:22117:free_filedata (Filedata *filedata)
        -:22118:{
     1397:22119:  free (filedata->program_interpreter);
     1397:22120:  free (filedata->program_headers);
     1397:22121:  free (filedata->section_headers);
     1397:22122:  free (filedata->string_table);
     1397:22123:  free (filedata->dump.dump_sects);
     1397:22124:  free (filedata->dynamic_strings);
     1397:22125:  free (filedata->dynamic_symbols);
     1397:22126:  free (filedata->dynamic_syminfo);
     1397:22127:  free (filedata->dynamic_section);
        -:22128:
     1398:22129:  while (filedata->symtab_shndx_list != NULL)
        -:22130:    {
        1:22131:      elf_section_list *next = filedata->symtab_shndx_list->next;
        1:22132:      free (filedata->symtab_shndx_list);
        1:22133:      filedata->symtab_shndx_list = next;
        -:22134:    }
        -:22135:
     1397:22136:  free (filedata->section_headers_groups);
        -:22137:
     1397:22138:  if (filedata->section_groups)
        -:22139:    {
        -:22140:      size_t i;
        -:22141:      struct group_list * g;
        -:22142:      struct group_list * next;
        -:22143:
      112:22144:      for (i = 0; i < filedata->group_count; i++)
        -:22145:	{
      57*:22146:	  for (g = filedata->section_groups [i].root; g != NULL; g = next)
        -:22147:	    {
    #####:22148:	      next = g->next;
    #####:22149:	      free (g);
        -:22150:	    }
        -:22151:	}
        -:22152:
       55:22153:      free (filedata->section_groups);
        -:22154:    }
     1397:22155:  memset (&filedata->section_headers, 0,
        -:22156:	  sizeof (Filedata) - offsetof (Filedata, section_headers));
     1397:22157:}
        -:22158:
        -:22159:static void
    #####:22160:close_file (Filedata * filedata)
        -:22161:{
    #####:22162:  if (filedata)
        -:22163:    {
    #####:22164:      if (filedata->handle)
    #####:22165:	fclose (filedata->handle);
    #####:22166:      free (filedata);
        -:22167:    }
    #####:22168:}
        -:22169:
        -:22170:void
    #####:22171:close_debug_file (void * data)
        -:22172:{
    #####:22173:  free_filedata ((Filedata *) data);
    #####:22174:  close_file ((Filedata *) data);
    #####:22175:}
        -:22176:
        -:22177:static Filedata *
    #####:22178:open_file (const char * pathname, bool is_separate)
        -:22179:{
        -:22180:  struct stat  statbuf;
    #####:22181:  Filedata *   filedata = NULL;
        -:22182:
    #####:22183:  if (stat (pathname, & statbuf) < 0
    #####:22184:      || ! S_ISREG (statbuf.st_mode))
    #####:22185:    goto fail;
        -:22186:
    #####:22187:  filedata = calloc (1, sizeof * filedata);
    #####:22188:  if (filedata == NULL)
    #####:22189:    goto fail;
        -:22190:
    #####:22191:  filedata->handle = fopen (pathname, "rb");
    #####:22192:  if (filedata->handle == NULL)
    #####:22193:    goto fail;
        -:22194:
    #####:22195:  filedata->file_size = (bfd_size_type) statbuf.st_size;
    #####:22196:  filedata->file_name = pathname;
    #####:22197:  filedata->is_separate = is_separate;
        -:22198:
    #####:22199:  if (! get_file_header (filedata))
    #####:22200:    goto fail;
        -:22201:
    #####:22202:  if (!get_section_headers (filedata, false))
    #####:22203:    goto fail;
        -:22204:
    #####:22205:  return filedata;
        -:22206:
    #####:22207: fail:
    #####:22208:  if (filedata)
        -:22209:    {
    #####:22210:      if (filedata->handle)
    #####:22211:        fclose (filedata->handle);
    #####:22212:      free (filedata);
        -:22213:    }
    #####:22214:  return NULL;
        -:22215:}
        -:22216:
        -:22217:void *
    #####:22218:open_debug_file (const char * pathname)
        -:22219:{
    #####:22220:  return open_file (pathname, true);
        -:22221:}
        -:22222:
        -:22223:static void
     1397:22224:initialise_dump_sects (Filedata * filedata)
        -:22225:{
        -:22226:  /* Initialise the dump_sects array from the cmdline_dump_sects array.
        -:22227:     Note we do this even if cmdline_dump_sects is empty because we
        -:22228:     must make sure that the dump_sets array is zeroed out before each
        -:22229:     object file is processed.  */
     1397:22230:  if (filedata->dump.num_dump_sects > cmdline.num_dump_sects)
    #####:22231:    memset (filedata->dump.dump_sects, 0,
    #####:22232:	    filedata->dump.num_dump_sects * sizeof (*filedata->dump.dump_sects));
        -:22233:
     1397:22234:  if (cmdline.num_dump_sects > 0)
        -:22235:    {
    #####:22236:      if (filedata->dump.num_dump_sects == 0)
        -:22237:	/* A sneaky way of allocating the dump_sects array.  */
    #####:22238:	request_dump_bynumber (&filedata->dump, cmdline.num_dump_sects, 0);
        -:22239:
    #####:22240:      assert (filedata->dump.num_dump_sects >= cmdline.num_dump_sects);
    #####:22241:      memcpy (filedata->dump.dump_sects, cmdline.dump_sects,
    #####:22242:	      cmdline.num_dump_sects * sizeof (*filedata->dump.dump_sects));
        -:22243:    }
     1397:22244:}
        -:22245:
        -:22246:static bool
     1391:22247:might_need_separate_debug_info (Filedata * filedata)
        -:22248:{
        -:22249:  /* Debuginfo files do not need further separate file loading.  */
     1391:22250:  if (filedata->file_header.e_shstrndx == SHN_UNDEF)
      355:22251:    return false;
        -:22252:
        -:22253:  /* Since do_follow_links might be enabled by default, only treat it as an
        -:22254:     indication that separate files should be loaded if setting it was a
        -:22255:     deliberate user action.  */
        -:22256:  if (DEFAULT_FOR_FOLLOW_LINKS == 0 && do_follow_links)
        -:22257:    return true;
        -:22258:  
     1036:22259:  if (process_links || do_syms || do_unwind 
      876:22260:      || dump_any_debugging || do_dump || do_debugging)
      160:22261:    return true;
        -:22262:
      876:22263:  return false;
        -:22264:}
        -:22265:
        -:22266:/* Process one ELF object file according to the command line options.
        -:22267:   This file may actually be stored in an archive.  The file is
        -:22268:   positioned at the start of the ELF object.  Returns TRUE if no
        -:22269:   problems were encountered, FALSE otherwise.  */
        -:22270:
        -:22271:static bool
     1400:22272:process_object (Filedata * filedata)
        -:22273:{
        -:22274:  bool have_separate_files;
        -:22275:  unsigned int i;
        -:22276:  bool res;
        -:22277:
     1400:22278:  if (! get_file_header (filedata))
        -:22279:    {
        3:22280:      error (_("%s: Failed to read file header\n"), filedata->file_name);
        3:22281:      return false;
        -:22282:    }
        -:22283:
        -:22284:  /* Initialise per file variables.  */
    23749:22285:  for (i = ARRAY_SIZE (filedata->version_info); i--;)
    22352:22286:    filedata->version_info[i] = 0;
        -:22287:
    54483:22288:  for (i = ARRAY_SIZE (filedata->dynamic_info); i--;)
    53086:22289:    filedata->dynamic_info[i] = 0;
     1397:22290:  filedata->dynamic_info_DT_GNU_HASH = 0;
     1397:22291:  filedata->dynamic_info_DT_MIPS_XHASH = 0;
        -:22292:
        -:22293:  /* Process the file.  */
     1397:22294:  if (show_name)
     1394:22295:    printf (_("\nFile: %s\n"), filedata->file_name);
        -:22296:
     1397:22297:  initialise_dump_sects (filedata);
        -:22298:
        -:22299:  /* There may be some extensions in the first section header.  Don't
        -:22300:     bomb if we can't read it.  */
     1397:22301:  get_section_headers (filedata, true);
        -:22302:
     1397:22303:  if (! process_file_header (filedata))
        -:22304:    {
        6:22305:      res = false;
        6:22306:      goto out;
        -:22307:    }
        -:22308:
        -:22309:  /* Throw away the single section header read above, so that we
        -:22310:     re-read the entire set.  */
     1391:22311:  free (filedata->section_headers);
     1391:22312:  filedata->section_headers = NULL;
        -:22313:
     1391:22314:  if (! process_section_headers (filedata))
        -:22315:    {
        -:22316:      /* Without loaded section headers we cannot process lots of things.  */
      490:22317:      do_unwind = do_version = do_dump = do_arch = false;
        -:22318:
      490:22319:      if (! do_using_dynamic)
      490:22320:	do_syms = do_dyn_syms = do_reloc = false;
        -:22321:    }
        -:22322:
     1391:22323:  if (! process_section_groups (filedata))
        -:22324:    /* Without loaded section groups we cannot process unwind.  */
      388:22325:    do_unwind = false;
        -:22326:
     1391:22327:  process_program_headers (filedata);
        -:22328:
     1391:22329:  res = process_dynamic_section (filedata);
        -:22330:
     1391:22331:  if (! process_relocs (filedata))
    #####:22332:    res = false;
        -:22333:
     1391:22334:  if (! process_unwind (filedata))
        4:22335:    res = false;
        -:22336:
     1391:22337:  if (! process_symbol_table (filedata))
    #####:22338:    res = false;
        -:22339:
     1391:22340:  if (! process_lto_symbol_tables (filedata))
    #####:22341:    res = false;
        -:22342:
     1391:22343:  if (! process_syminfo (filedata))
    #####:22344:    res = false;
        -:22345:
     1391:22346:  if (! process_version_sections (filedata))
    #####:22347:    res = false;
        -:22348:
     1391:22349:  if (might_need_separate_debug_info (filedata))
      160:22350:    have_separate_files = load_separate_debug_files (filedata, filedata->file_name);
        -:22351:  else
     1231:22352:    have_separate_files = false;
        -:22353:
     1391:22354:  if (! process_section_contents (filedata))
    #####:22355:    res = false;
        -:22356:
     1391:22357:  if (have_separate_files)
        -:22358:    {
        -:22359:      separate_info * d;
        -:22360:
    #####:22361:      for (d = first_separate_info; d != NULL; d = d->next)
        -:22362:	{
    #####:22363:	  initialise_dump_sects (d->handle);
        -:22364:
    #####:22365:	  if (process_links && ! process_file_header (d->handle))
    #####:22366:	    res = false;
    #####:22367:	  else if (! process_section_headers (d->handle))
    #####:22368:	    res = false;
    #####:22369:	  else if (! process_section_contents (d->handle))
    #####:22370:	    res = false;
    #####:22371:	  else if (process_links)
        -:22372:	    {
    #####:22373:	      if (! process_section_groups (d->handle))
    #####:22374:		res = false;
    #####:22375:	      process_program_headers (d->handle);
    #####:22376:	      if (! process_dynamic_section (d->handle))
    #####:22377:		res = false;
    #####:22378:	      if (! process_relocs (d->handle))
    #####:22379:		res = false;
    #####:22380:	      if (! process_unwind (d->handle))
    #####:22381:		res = false;
    #####:22382:	      if (! process_symbol_table (d->handle))
    #####:22383:		res = false;
    #####:22384:	      if (! process_lto_symbol_tables (d->handle))
    #####:22385:		res = false;
    #####:22386:	      if (! process_syminfo (d->handle))
    #####:22387:		res = false;
    #####:22388:	      if (! process_version_sections (d->handle))
    #####:22389:		res = false;
    #####:22390:	      if (! process_notes (d->handle))
    #####:22391:		res = false;
        -:22392:	    }
        -:22393:	}
        -:22394:
        -:22395:      /* The file handles are closed by the call to free_debug_memory() below.  */
        -:22396:    }
        -:22397:
     1391:22398:  if (! process_notes (filedata))
       15:22399:    res = false;
        -:22400:
     1391:22401:  if (! process_gnu_liblist (filedata))
    #####:22402:    res = false;
        -:22403:
     1391:22404:  if (! process_arch_specific (filedata))
    #####:22405:    res = false;
        -:22406:
     1391:22407: out:
     1397:22408:  free_filedata (filedata);
        -:22409:
     1397:22410:  free_debug_memory ();
        -:22411:
     1397:22412:  return res;
        -:22413:}
        -:22414:
        -:22415:/* Process an ELF archive.
        -:22416:   On entry the file is positioned just after the ARMAG string.
        -:22417:   Returns TRUE upon success, FALSE otherwise.  */
        -:22418:
        -:22419:static bool
    #####:22420:process_archive (Filedata * filedata, bool is_thin_archive)
        -:22421:{
        -:22422:  struct archive_info arch;
        -:22423:  struct archive_info nested_arch;
        -:22424:  size_t got;
    #####:22425:  bool ret = true;
        -:22426:
    #####:22427:  show_name = true;
        -:22428:
        -:22429:  /* The ARCH structure is used to hold information about this archive.  */
    #####:22430:  arch.file_name = NULL;
    #####:22431:  arch.file = NULL;
    #####:22432:  arch.index_array = NULL;
    #####:22433:  arch.sym_table = NULL;
    #####:22434:  arch.longnames = NULL;
        -:22435:
        -:22436:  /* The NESTED_ARCH structure is used as a single-item cache of information
        -:22437:     about a nested archive (when members of a thin archive reside within
        -:22438:     another regular archive file).  */
    #####:22439:  nested_arch.file_name = NULL;
    #####:22440:  nested_arch.file = NULL;
    #####:22441:  nested_arch.index_array = NULL;
    #####:22442:  nested_arch.sym_table = NULL;
    #####:22443:  nested_arch.longnames = NULL;
        -:22444:
    #####:22445:  if (setup_archive (&arch, filedata->file_name, filedata->handle,
    #####:22446:		     filedata->file_size, is_thin_archive,
        -:22447:		     do_archive_index) != 0)
        -:22448:    {
    #####:22449:      ret = false;
    #####:22450:      goto out;
        -:22451:    }
        -:22452:
    #####:22453:  if (do_archive_index)
        -:22454:    {
    #####:22455:      if (arch.sym_table == NULL)
    #####:22456:	error (_("%s: unable to dump the index as none was found\n"),
        -:22457:	       filedata->file_name);
        -:22458:      else
        -:22459:	{
        -:22460:	  unsigned long i, l;
        -:22461:	  unsigned long current_pos;
        -:22462:
    #####:22463:	  printf (_("Index of archive %s: (%lu entries, 0x%lx bytes "
        -:22464:		    "in the symbol table)\n"),
    #####:22465:		  filedata->file_name, (unsigned long) arch.index_num,
        -:22466:		  arch.sym_size);
        -:22467:
    #####:22468:	  current_pos = ftell (filedata->handle);
        -:22469:
    #####:22470:	  for (i = l = 0; i < arch.index_num; i++)
        -:22471:	    {
    #####:22472:	      if (i == 0
    #####:22473:		  || (i > 0 && arch.index_array[i] != arch.index_array[i - 1]))
        -:22474:		{
        -:22475:		  char * member_name
    #####:22476:		    = get_archive_member_name_at (&arch, arch.index_array[i],
        -:22477:						  &nested_arch);
        -:22478:
    #####:22479:		  if (member_name != NULL)
        -:22480:		    {
        -:22481:		      char * qualified_name
    #####:22482:			= make_qualified_name (&arch, &nested_arch,
        -:22483:					       member_name);
        -:22484:
    #####:22485:		      if (qualified_name != NULL)
        -:22486:			{
    #####:22487:			  printf (_("Contents of binary %s at offset "),
        -:22488:				  qualified_name);
    #####:22489:			  (void) print_vma (arch.index_array[i], PREFIX_HEX);
    #####:22490:			  putchar ('\n');
    #####:22491:			  free (qualified_name);
        -:22492:			}
    #####:22493:		      free (member_name);
        -:22494:		    }
        -:22495:		}
        -:22496:
    #####:22497:	      if (l >= arch.sym_size)
        -:22498:		{
    #####:22499:		  error (_("%s: end of the symbol table reached "
        -:22500:			   "before the end of the index\n"),
        -:22501:			 filedata->file_name);
    #####:22502:		  ret = false;
    #####:22503:		  break;
        -:22504:		}
        -:22505:	      /* PR 17531: file: 0b6630b2.  */
    #####:22506:	      printf ("\t%.*s\n",
    #####:22507:		      (int) (arch.sym_size - l), arch.sym_table + l);
    #####:22508:	      l += strnlen (arch.sym_table + l, arch.sym_size - l) + 1;
        -:22509:	    }
        -:22510:
    #####:22511:	  if (arch.uses_64bit_indices)
    #####:22512:	    l = (l + 7) & ~ 7;
        -:22513:	  else
    #####:22514:	    l += l & 1;
        -:22515:
    #####:22516:	  if (l < arch.sym_size)
        -:22517:	    {
    #####:22518:	      error (ngettext ("%s: %ld byte remains in the symbol table, "
        -:22519:			       "but without corresponding entries in "
        -:22520:			       "the index table\n",
        -:22521:			       "%s: %ld bytes remain in the symbol table, "
        -:22522:			       "but without corresponding entries in "
        -:22523:			       "the index table\n",
    #####:22524:			       arch.sym_size - l),
    #####:22525:		     filedata->file_name, arch.sym_size - l);
    #####:22526:	      ret = false;
        -:22527:	    }
        -:22528:
    #####:22529:	  if (fseek (filedata->handle, current_pos, SEEK_SET) != 0)
        -:22530:	    {
    #####:22531:	      error (_("%s: failed to seek back to start of object files "
        -:22532:		       "in the archive\n"),
        -:22533:		     filedata->file_name);
    #####:22534:	      ret = false;
    #####:22535:	      goto out;
        -:22536:	    }
        -:22537:	}
        -:22538:
    #####:22539:      if (!do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
    #####:22540:	  && !do_segments && !do_header && !do_dump && !do_version
    #####:22541:	  && !do_histogram && !do_debugging && !do_arch && !do_notes
    #####:22542:	  && !do_section_groups && !do_dyn_syms)
        -:22543:	{
    #####:22544:	  ret = true; /* Archive index only.  */
    #####:22545:	  goto out;
        -:22546:	}
        -:22547:    }
        -:22548:
        -:22549:  while (1)
    #####:22550:    {
        -:22551:      char * name;
        -:22552:      size_t namelen;
        -:22553:      char * qualified_name;
        -:22554:
        -:22555:      /* Read the next archive header.  */
    #####:22556:      if (fseek (filedata->handle, arch.next_arhdr_offset, SEEK_SET) != 0)
        -:22557:	{
    #####:22558:	  error (_("%s: failed to seek to next archive header\n"),
        -:22559:		 arch.file_name);
    #####:22560:	  ret = false;
    #####:22561:	  break;
        -:22562:	}
    #####:22563:      got = fread (&arch.arhdr, 1, sizeof arch.arhdr, filedata->handle);
    #####:22564:      if (got != sizeof arch.arhdr)
        -:22565:	{
    #####:22566:	  if (got == 0)
    #####:22567:	    break;
        -:22568:	  /* PR 24049 - we cannot use filedata->file_name as this will
        -:22569:	     have already been freed.  */
    #####:22570:	  error (_("%s: failed to read archive header\n"), arch.file_name);
        -:22571:
    #####:22572:	  ret = false;
    #####:22573:	  break;
        -:22574:	}
    #####:22575:      if (memcmp (arch.arhdr.ar_fmag, ARFMAG, 2) != 0)
        -:22576:	{
    #####:22577:	  error (_("%s: did not find a valid archive header\n"),
        -:22578:		 arch.file_name);
    #####:22579:	  ret = false;
    #####:22580:	  break;
        -:22581:	}
        -:22582:
    #####:22583:      arch.next_arhdr_offset += sizeof arch.arhdr;
        -:22584:
    #####:22585:      filedata->archive_file_size = strtoul (arch.arhdr.ar_size, NULL, 10);
        -:22586:
    #####:22587:      name = get_archive_member_name (&arch, &nested_arch);
    #####:22588:      if (name == NULL)
        -:22589:	{
    #####:22590:	  error (_("%s: bad archive file name\n"), arch.file_name);
    #####:22591:	  ret = false;
    #####:22592:	  break;
        -:22593:	}
    #####:22594:      namelen = strlen (name);
        -:22595:
    #####:22596:      qualified_name = make_qualified_name (&arch, &nested_arch, name);
    #####:22597:      if (qualified_name == NULL)
        -:22598:	{
    #####:22599:	  error (_("%s: bad archive file name\n"), arch.file_name);
    #####:22600:	  free (name);
    #####:22601:	  ret = false;
    #####:22602:	  break;
        -:22603:	}
        -:22604:
    #####:22605:      if (is_thin_archive && arch.nested_member_origin == 0)
    #####:22606:	{
        -:22607:	  /* This is a proxy for an external member of a thin archive.  */
        -:22608:	  Filedata * member_filedata;
    #####:22609:	  char * member_file_name = adjust_relative_path
        -:22610:	    (filedata->file_name, name, namelen);
        -:22611:
    #####:22612:	  free (name);
    #####:22613:	  if (member_file_name == NULL)
        -:22614:	    {
    #####:22615:	      free (qualified_name);
    #####:22616:	      ret = false;
    #####:22617:	      break;
        -:22618:	    }
        -:22619:
    #####:22620:	  member_filedata = open_file (member_file_name, false);
    #####:22621:	  if (member_filedata == NULL)
        -:22622:	    {
    #####:22623:	      error (_("Input file '%s' is not readable.\n"), member_file_name);
    #####:22624:	      free (member_file_name);
    #####:22625:	      free (qualified_name);
    #####:22626:	      ret = false;
    #####:22627:	      break;
        -:22628:	    }
        -:22629:
    #####:22630:	  filedata->archive_file_offset = arch.nested_member_origin;
    #####:22631:	  member_filedata->file_name = qualified_name;
        -:22632:
        -:22633:	  /* The call to process_object() expects the file to be at the beginning.  */
    #####:22634:	  rewind (member_filedata->handle);
        -:22635:
    #####:22636:	  if (! process_object (member_filedata))
    #####:22637:	    ret = false;
        -:22638:
    #####:22639:	  close_file (member_filedata);
    #####:22640:	  free (member_file_name);
        -:22641:	}
    #####:22642:      else if (is_thin_archive)
        -:22643:	{
        -:22644:	  Filedata thin_filedata;
        -:22645:
    #####:22646:	  memset (&thin_filedata, 0, sizeof (thin_filedata));
        -:22647:
        -:22648:	  /* PR 15140: Allow for corrupt thin archives.  */
    #####:22649:	  if (nested_arch.file == NULL)
        -:22650:	    {
    #####:22651:	      error (_("%s: contains corrupt thin archive: %s\n"),
        -:22652:		     qualified_name, name);
    #####:22653:	      free (qualified_name);
    #####:22654:	      free (name);
    #####:22655:	      ret = false;
    #####:22656:	      break;
        -:22657:	    }
    #####:22658:	  free (name);
        -:22659:
        -:22660:	  /* This is a proxy for a member of a nested archive.  */
        -:22661:	  filedata->archive_file_offset
    #####:22662:	    = arch.nested_member_origin + sizeof arch.arhdr;
        -:22663:
        -:22664:	  /* The nested archive file will have been opened and setup by
        -:22665:	     get_archive_member_name.  */
    #####:22666:	  if (fseek (nested_arch.file, filedata->archive_file_offset,
        -:22667:		     SEEK_SET) != 0)
        -:22668:	    {
    #####:22669:	      error (_("%s: failed to seek to archive member.\n"),
        -:22670:		     nested_arch.file_name);
    #####:22671:	      free (qualified_name);
    #####:22672:	      ret = false;
    #####:22673:	      break;
        -:22674:	    }
        -:22675:
    #####:22676:	  thin_filedata.handle = nested_arch.file;
    #####:22677:	  thin_filedata.file_name = qualified_name;
        -:22678:
    #####:22679:	  if (! process_object (& thin_filedata))
    #####:22680:	    ret = false;
        -:22681:	}
        -:22682:      else
        -:22683:	{
    #####:22684:	  free (name);
    #####:22685:	  filedata->archive_file_offset = arch.next_arhdr_offset;
    #####:22686:	  filedata->file_name = qualified_name;
    #####:22687:	  if (! process_object (filedata))
    #####:22688:	    ret = false;
    #####:22689:	  arch.next_arhdr_offset += (filedata->archive_file_size + 1) & -2;
        -:22690:	  /* Stop looping with "negative" archive_file_size.  */
    #####:22691:	  if (arch.next_arhdr_offset < filedata->archive_file_size)
    #####:22692:	    arch.next_arhdr_offset = -1ul;
        -:22693:	}
        -:22694:
    #####:22695:      free (qualified_name);
        -:22696:    }
        -:22697:
    #####:22698: out:
    #####:22699:  if (nested_arch.file != NULL)
    #####:22700:    fclose (nested_arch.file);
    #####:22701:  release_archive (&nested_arch);
    #####:22702:  release_archive (&arch);
        -:22703:
    #####:22704:  return ret;
        -:22705:}
        -:22706:
        -:22707:static bool
     1401:22708:process_file (char * file_name)
        -:22709:{
     1401:22710:  Filedata * filedata = NULL;
        -:22711:  struct stat statbuf;
        -:22712:  char armag[SARMAG];
     1401:22713:  bool ret = true;
        -:22714:
     1401:22715:  if (stat (file_name, &statbuf) < 0)
        -:22716:    {
    #####:22717:      if (errno == ENOENT)
    #####:22718:	error (_("'%s': No such file\n"), file_name);
        -:22719:      else
    #####:22720:	error (_("Could not locate '%s'.  System error message: %s\n"),
    #####:22721:	       file_name, strerror (errno));
    #####:22722:      return false;
        -:22723:    }
        -:22724:
     1401:22725:  if (! S_ISREG (statbuf.st_mode))
        -:22726:    {
    #####:22727:      error (_("'%s' is not an ordinary file\n"), file_name);
    #####:22728:      return false;
        -:22729:    }
        -:22730:
     1401:22731:  filedata = calloc (1, sizeof * filedata);
     1401:22732:  if (filedata == NULL)
        -:22733:    {
    #####:22734:      error (_("Out of memory allocating file data structure\n"));
    #####:22735:      return false;
        -:22736:    }
        -:22737:
     1401:22738:  filedata->file_name = file_name;
     1401:22739:  filedata->handle = fopen (file_name, "rb");
     1401:22740:  if (filedata->handle == NULL)
        -:22741:    {
    #####:22742:      error (_("Input file '%s' is not readable.\n"), file_name);
    #####:22743:      free (filedata);
    #####:22744:      return false;
        -:22745:    }
        -:22746:
     1401:22747:  if (fread (armag, SARMAG, 1, filedata->handle) != 1)
        -:22748:    {
        1:22749:      error (_("%s: Failed to read file's magic number\n"), file_name);
        1:22750:      fclose (filedata->handle);
        1:22751:      free (filedata);
        1:22752:      return false;
        -:22753:    }
        -:22754:
     1400:22755:  filedata->file_size = (bfd_size_type) statbuf.st_size;
     1400:22756:  filedata->is_separate = false;
        -:22757:
     1400:22758:  if (memcmp (armag, ARMAG, SARMAG) == 0)
        -:22759:    {
    #####:22760:      if (! process_archive (filedata, false))
    #####:22761:	ret = false;
        -:22762:    }
     1400:22763:  else if (memcmp (armag, ARMAGT, SARMAG) == 0)
        -:22764:    {
    #####:22765:      if ( ! process_archive (filedata, true))
    #####:22766:	ret = false;
        -:22767:    }
        -:22768:  else
        -:22769:    {
    1400*:22770:      if (do_archive_index && !check_all)
    #####:22771:	error (_("File %s is not an archive so its index cannot be displayed.\n"),
        -:22772:	       file_name);
        -:22773:
     1400:22774:      rewind (filedata->handle);
     1400:22775:      filedata->archive_file_size = filedata->archive_file_offset = 0;
        -:22776:
     1400:22777:      if (! process_object (filedata))
       29:22778:	ret = false;
        -:22779:    }
        -:22780:
     1400:22781:  fclose (filedata->handle);
     1400:22782:  free (filedata->section_headers);
     1400:22783:  free (filedata->program_headers);
     1400:22784:  free (filedata->string_table);
     1400:22785:  free (filedata->dump.dump_sects);
     1400:22786:  free (filedata);
        -:22787:
     1400:22788:  free (ba_cache.strtab);
     1400:22789:  ba_cache.strtab = NULL;
     1400:22790:  free (ba_cache.symtab);
     1400:22791:  ba_cache.symtab = NULL;
     1400:22792:  ba_cache.filedata = NULL;
        -:22793:
     1400:22794:  return ret;
        -:22795:}
        -:22796:
        -:22797:#ifdef SUPPORT_DISASSEMBLY
        -:22798:/* Needed by the i386 disassembler.  For extra credit, someone could
        -:22799:   fix this so that we insert symbolic addresses here, esp for GOT/PLT
        -:22800:   symbols.  */
        -:22801:
        -:22802:void
        -:22803:print_address (unsigned int addr, FILE * outfile)
        -:22804:{
        -:22805:  fprintf (outfile,"0x%8.8x", addr);
        -:22806:}
        -:22807:
        -:22808:/* Needed by the i386 disassembler.  */
        -:22809:
        -:22810:void
        -:22811:db_task_printsym (unsigned int addr)
        -:22812:{
        -:22813:  print_address (addr, stderr);
        -:22814:}
        -:22815:#endif
        -:22816:
        -:22817:int
       39:22818:main (int argc, char ** argv)
        -:22819:{
        -:22820:  int err;
        -:22821:
        -:22822:#ifdef HAVE_LC_MESSAGES
       39:22823:  setlocale (LC_MESSAGES, "");
        -:22824:#endif
       39:22825:  setlocale (LC_CTYPE, "");
       39:22826:  bindtextdomain (PACKAGE, LOCALEDIR);
       39:22827:  textdomain (PACKAGE);
        -:22828:
       39:22829:  expandargv (&argc, &argv);
        -:22830:
       39:22831:  parse_args (& cmdline, argc, argv);
        -:22832:
       39:22833:  if (optind < (argc - 1))
        -:22834:    /* When displaying information for more than one file,
        -:22835:       prefix the information with the file name.  */
       36:22836:    show_name = true;
        3:22837:  else if (optind >= argc)
        -:22838:    {
        -:22839:      /* Ensure that the warning is always displayed.  */
    #####:22840:      do_checks = true;
        -:22841:
    #####:22842:      warn (_("Nothing to do.\n"));
    #####:22843:      usage (stderr);
        -:22844:    }
        -:22845:
       39:22846:  err = false;
     1440:22847:  while (optind < argc)
     1401:22848:    if (! process_file (argv[optind++]))
       30:22849:      err = true;
        -:22850:
       39:22851:  free (cmdline.dump_sects);
        -:22852:
       39:22853:  free (dump_ctf_symtab_name);
       39:22854:  free (dump_ctf_strtab_name);
       39:22855:  free (dump_ctf_parent_name);
        -:22856:
       39:22857:  return err ? EXIT_FAILURE : EXIT_SUCCESS;
        -:22858:}
